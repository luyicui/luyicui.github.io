<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>希腊字母表</title>
      <link href="/2024/01/27/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/"/>
      <url>/2024/01/27/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202401271612976.png" alt="GreekAlphabet"></p><p>:gift_heart:读音：<a href="https://www.bilibili.com/video/BV11b411t7Fn/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=783e918d3ef4b11b94236a4cd8a51f23">50秒完全学会希腊字母读法~高中理科生的福音_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2024/01/06/Linux%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/06/Linux%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="windows与linux的区分"><a href="#windows与linux的区分" class="headerlink" title="windows与linux的区分"></a>windows与linux的区分</h2><ol><li>linux下<strong>文件名区分大小写</strong>，而windows下<strong>文件名不区分大小写</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">ABC</span><br><span class="line">aBc</span><br></pre></td></tr></table></figure><ol start="2"><li>linux下<strong>路径分隔符</strong>为<code>/</code>，而windows下<strong>路径分隔符</strong>为<code>\</code></li></ol><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309122142813.png" alt="20221027214128_clear_compress"></p><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>&#x2F;home&#x2F;itheima&#x2F;a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><blockquote><p>&#x2F;：     根目录，操作系统的启示路径跟路径</p><p>&#x2F;bin：  可执行二进制文件的目录</p><p>&#x2F;etc：   系统配置文件存放的目录</p><p>&#x2F;home：普通用户的家目录</p><p>&#x2F;root：  管理员家目录</p><p>&#x2F;dev：  device设备 设备文件存放目录</p><p>&#x2F;boot： 引导 主引导目录 独立的分区 启动菜单 内核</p><p>&#x2F;media：光驱的挂载目录</p><p>&#x2F;mnt：  临时设备挂载目录</p><p>&#x2F;proc： 里面的数据都在内存中，进程的所有目录</p><p>&#x2F;tmp：  临时文件存放目录</p><p>&#x2F;usr：  软件的安装目录</p><p>&#x2F;var：  常变文件存放目录，如日志文件，邮件文件</p></blockquote><h2 id="lsb-release命令"><a href="#lsb-release命令" class="headerlink" title="lsb_release命令"></a>lsb_release命令</h2><p>功能：查看linux的发行版本信息</p><p>语法：<code> lsb_release -a</code></p><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小</li><li>-a，显示隐藏文件</li></ul><blockquote><p><strong>隐藏文件&#x2F;文件夹</strong></p><ul><li><p>在Linux中以<code>.</code>开头的，均是隐藏的文件&#x2F;文件夹</p></li><li><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p></li></ul></blockquote><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h2><ul><li><p>相对路径，&#x3D;&#x3D;非&#x3D;&#x3D;<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D;<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h2><ul><li><code>.</code>，表示当前，比如.&#x2F;a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径</li><li>选项：-p，可选，表示创建前置路径</li></ul><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li></ul></li></ul><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test&#x2F;，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>功能：查看命令的程序本体文件路径</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符*， 比如：<code>*</code>test表示搜索任意以test结尾的文件</li></ul><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容</li></ul><h2 id="反引号"><a href="#反引号" class="headerlink" title="&#96;反引号"></a>&#96;反引号</h2><p>功能：<strong>被两个反引号包围的内容，会作为命令执行</strong></p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f -n] 参数</code></p><ul><li>参数：被查看的文件路径</li><li>选项：-f，持续跟踪文件修改</li><li>选项：-n，表示查看尾部多少行，不填默认10行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 100 filename</span><br></pre></td></tr></table></figure><h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p><ul><li><code>&gt;</code>，表示覆盖输出</li><li><code>&gt;&gt;</code>，表示追加输出</li></ul><h2 id="nano编辑器"><a href="#nano编辑器" class="headerlink" title="nano编辑器"></a>nano编辑器</h2><p><a href="https://blog.csdn.net/fuzhang_android/article/details/87873661?spm=1001.2014.3001.5506">nano简单使用介绍_nano的用法_fuzhang_android的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/WalterBrien/article/details/125836576?spm=1001.2014.3001.5506">nano编辑器的使用_SudekiMing的博客-CSDN博客</a></p><h2 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h2><h3 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215841.png" alt="image-20221027215841573"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215846.png" alt="image-20221027215846581"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215849.png" alt="image-20221027215849668"></p><h3 id="底线命令快捷键"><a href="#底线命令快捷键" class="headerlink" title="底线命令快捷键"></a>底线命令快捷键</h3><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215858.png" alt="image-20221027215858967"></p><h2 id="命令的选项"><a href="#命令的选项" class="headerlink" title="命令的选项"></a>命令的选项</h2><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p><p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。</p><p>课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</p><p>课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。</p><h3 id="查看命令的帮助"><a href="#查看命令的帮助" class="headerlink" title="查看命令的帮助"></a>查看命令的帮助</h3><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220005.png" alt="image-20221027220005610"></p><h3 id="查看命令的详细手册"><a href="#查看命令的详细手册" class="headerlink" title="查看命令的详细手册"></a>查看命令的详细手册</h3><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220010.png" alt="image-20221027220009949"></p><h1 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y   年%y   年份后两位数字 (00..99)</li><li>%m   月份 (01..12)</li><li>%d   日 (01..31)</li><li>%H   小时 (00..23)</li><li>%M   分钟 (00..59)</li><li>%S   秒 (00..60)</li><li>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220514.png" alt="image-20221027220514640"></p></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220525.png" alt="image-20221027220525625"></p></li><li><p>-d选项日期计算</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220429.png" alt="image-20221027220429831"></p><ul><li><p>支持的时间标记为：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220449.png" alt="image-20221027220449312"></p></li></ul></li></ul><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>修改时区为中国时区</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220554.png" alt="image-20221027220554654"></p><h2 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h2><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h2 id="配置VMware固定IP"><a href="#配置VMware固定IP" class="headerlink" title="配置VMware固定IP"></a>配置VMware固定IP</h2><ol><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;# 改为static，固定IP</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=&quot;192.168.88.131&quot;# IP地址，自己设置，要匹配网络范围</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;# 子网掩码，固定写法255.255.255.0</span><br><span class="line">GATEWAY=&quot;192.168.88.2&quot;# 网关，要和VMware中配置的一致</span><br><span class="line">DNS1=&quot;192.168.88.2&quot;# DNS1服务器，和网关一致即可</span><br></pre></td></tr></table></figure></li></ol><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><p><strong>举例</strong>：在Linux上，我想查看：用户为ycxie，执行命令为python3的所有进程信息，应使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;ycxie.*python3&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221303.png" alt="image-20221027221303037"></p><h2 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221241.png" alt="image-20221027221241123"></p><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221129.png" alt="image-20221027221129782"></p><h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221149.png" alt="image-20221027221148964"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309122143891.png" alt="image-20230830233213202"></p><h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221201.png" alt="image-20221027221201079"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221210.png" alt="image-20221027221210518"></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221340.png" alt="image-20221027221340729"></p><p>交互式模式中，可用快捷键：</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221354.png" alt="image-20221027221354137"></p><h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p>查看磁盘占用</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221413.png" alt="image-20221027221413787"></p><h2 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h2><p>查看CPU、磁盘的相关信息</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221440.png" alt="image-20221027221439990"></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221514.png" alt="image-20221027221514237"></p><h2 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h2><p>查看网络统计</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221545.png" alt="image-20221027221545822"></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>临时设置：export 变量名&#x3D;变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h3 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h3><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h2><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221906.png" alt="image-20221027221906247"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027221939.png" alt="image-20221027221939899"></p><h2 id="BGP-dump"><a href="#BGP-dump" class="headerlink" title="BGP-dump"></a>BGP-dump</h2><ul><li><p>打开任意终端，输入bgpdump，可查看参数。</p></li><li><p>MRT格式的RIB可从route view project官网下载：<a href="http://archive.routeviews.org/">route view project archive</a>。</p></li><li><p>常用指令：bgpdump -m xxx.bz2 &gt; output.txt</p></li></ul><h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222021.png" alt="image-20221027222021619"></p><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222035.png" alt="image-20221027222035337"></p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itheima ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>修改文件、文件夹权限</p><p>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222157.png" alt="image-20221027222157276"></p></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222326.png" alt="image-20221027222326192"></p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222354.png" alt="image-20221027222354498"></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222407.png" alt="image-20221027222407618"></p><h2 id="genenv命令"><a href="#genenv命令" class="headerlink" title="genenv命令"></a>genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222446.png" alt="image-20221027222446514"></p></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><p><img src="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027222512.png" alt="image-20221027222512274"></p></li></ul><h2 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p><h2 id="python3命令"><a href="#python3命令" class="headerlink" title="python3命令"></a>python3命令</h2><h2 id="nano命令"><a href="#nano命令" class="headerlink" title="nano命令"></a>nano命令</h2><p><a href="https://blog.csdn.net/WalterBrien/article/details/125836576?ops_request_misc=%7B%22request_id%22:%22169508811116777224443235%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169508811116777224443235&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125836576-null-null.142%5Ev94%5EchatsearchT3_1&utm_term=nano&spm=1018.2226.3001.4187">nano编辑器的使用_SudekiMing的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/carefree2005/article/details/129042788?ops_request_misc=%7B%22request_id%22:%22169508802416800182147582%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=169508802416800182147582&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-129042788-null-null.142%5Ev94%5EchatsearchT3_1&utm_term=nano%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">Linux命令之nano命令_恒悦sunsite的博客-CSDN博客</a></p><h2 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a>nohup命令</h2><p><code>nohup python3 -u test.py &gt; nohup.out 2&gt;&amp;1 &amp;</code></p><p><a href="https://blog.csdn.net/jiangyu1013/article/details/81476184?ops_request_misc=%7B%22request_id%22:%22169018276616800184180892%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=169018276616800184180892&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-81476184-null-null.142%5Ev90%5Econtrol_2,239%5Ev3%5Einsert_chatgpt&utm_term=nohup%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">(139条消息) linux 中的 nohup 命令（设置后台进程）： nohup: ignoring input and appending output to ‘nohup.out’_nohup: ignoring input and appending output to ‘noh_微风–轻许–的博客-CSDN博客</a></p><h2 id="ping命令-1"><a href="#ping命令-1" class="headerlink" title="ping命令"></a>ping命令</h2><h2 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h2><ul><li>traceroute的用法为: <code>Traceroute [options] [data size]</code></li><li><code>[options]</code>的内容有:</li></ul><p><code>[-n]</code>：显示的地址是用数字表示而不是符号<br><code>[-v]</code>：长输出<br><code>[-p]</code>：UDP端口设置（缺省为33434）<br><code>[-q]</code>：设置TTL测试数目（缺省为3）<br><code>[-t]</code>：设置测包的服务类型<br><code>[data size]</code>：每次测试包的数据字节长度（缺省为38）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2023/11/26/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/11/26/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><span id="more"></span><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><strong>&#x3D;&#x3D;参考视频：<a href="https://www.bilibili.com/video/BV1hG411p7fX/?spm_id_from=333.337.search-card.all.click&vd_source=783e918d3ef4b11b94236a4cd8a51f23">Markdown语法讲解</a>&#x3D;&#x3D;</strong></p><h2 id="😂-简要介绍"><a href="#😂-简要介绍" class="headerlink" title="😂 简要介绍"></a>😂 简要介绍</h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以 <code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 $\LaTeX$, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势. </p><p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 <strong>Markdown</strong> 语法. 如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).</p><h2 id="📐-实际应用"><a href="#📐-实际应用" class="headerlink" title="📐 实际应用"></a>📐 实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p><p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰, 层次分明.</p><p>像我大一的时候就用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告, 代码的 <code>README.md</code> … 包括本教程文档.</p><h2 id="🍴-工具"><a href="#🍴-工具" class="headerlink" title="🍴 工具"></a>🍴 工具</h2><p>Markdown 只是一种语法. 那么用来写 Markdown 的文本编辑器呢? 我推荐的是 <strong>Typora</strong> 或者 <strong>VS Code</strong></p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown 语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将 <code>.md</code> 导出成多种文件, 如 <code>.pdf</code>, <code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p><p>但是现在 Typora 已经发布正式版并且变为收费软件. 中文官网在此 <a href="https://typoraio.cn/">Typora 官方中文站 </a>. </p><p>我当然是推荐大家都用正版啦. 不过价格是永久版￥89, 好在可以用在3台设备上. 如果和你的两位同学&#x2F;舍友均摊一下, 每人就只要￥30, 和一张游戏月卡差不多. </p><p>至于盗版以及破解方法<a href="https://www.only4.work/blog/?id=379">在此随便找一种改注册表时间方法的</a><del>不介绍(还挺多的其实)</del>.</p><p><del>还有一种免费白嫖的方法就是安装测试版&#x2F;Beta版. 官网有历史版本的下载链接 <a href="https://typoraio.cn/windows/dev_release.html">Typora 历史版本下载页</a></del></p><p>白嫖Beta版已经寄了, 要么支持正版要么去学习一下破解方法吧 (还是忍不住啦, 看上面的链接👆)</p><h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VS Code 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All in One</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载 Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>大部分IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法, 在此不多赘述.</p><p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora 所包含的扩展语法.</p><h2 id="🍭-基础教程"><a href="#🍭-基础教程" class="headerlink" title="🍭 基础教程"></a>🍭 基础教程</h2><p>当有多种标记方法时我会倾向其中一种. </p><p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code <strong>本地生效</strong>, 在大多数平台上<strong>并不认可</strong>.</p><h3 id="写-Markdown-的第零步"><a href="#写-Markdown-的第零步" class="headerlink" title="写 Markdown 的第零步"></a>写 Markdown 的第零步</h3><p>我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 <code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的, 也是无法转义的. </p><p>我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如 <code>,.?!()[]:;&quot;&quot;</code>. 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.</p><p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> + <code>.(这是个句号)</code>, 切换标点的全角与半角. 这样即可中文输入+半角标点.</p><h3 id="标题-数个-“-”-空格-前置"><a href="#标题-数个-“-”-空格-前置" class="headerlink" title="标题 [数个 “#” + 空格 前置]"></a>标题 [数个 “#” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>标题会在目录与大纲分级显示, 可以跳转. </p><p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为 <code>#标题</code>, 应为 <code># 标题</code>. </p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容. </p><h3 id="强调-用-“-”-或-“-”-包围"><a href="#强调-用-“-”-或-“-”-包围" class="headerlink" title="强调 [用 “**” 或 “__” 包围]"></a>强调 [用 “**” 或 “__” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**欢迎报考南京大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考南京大学!__</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>. </p><p>E.G. </p><p><strong>欢迎报考南京大学!</strong></p><h3 id="斜体-用-“-”-或-“-”-包围"><a href="#斜体-用-“-”-或-“-”-包围" class="headerlink" title="斜体 [用 “*” 或 “_” 包围]"></a>斜体 [用 “*” 或 “_” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*欢迎大佬来浇浇我各种知识* (我喜欢用这种)</span><br><span class="line">_欢迎大佬来浇浇我各种知识_</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>. </p><p>E.G. </p><p><em>欢迎大佬来浇浇我各种知识</em></p><p>(P.S. <em><strong>斜体并强调</strong></em> [用 “***” 或 “___” 包围])</p><h3 id="删除线-用-“-”-包围"><a href="#删除线-用-“-”-包围" class="headerlink" title="删除线 [用 “~~” 包围]"></a>删除线 [用 “~~” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我宣布个事儿, 我是Sabiyary!~~</span><br></pre></td></tr></table></figure><p>E.G. </p><p><del>我宣布个事儿, 我是Sabiyary!</del></p><h3 id="高亮-用-“-”-包围"><a href="#高亮-用-“-”-包围" class="headerlink" title="*高亮 [用 “&#x3D;&#x3D;” 包围]"></a>*高亮 [用 “&#x3D;&#x3D;” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==我喜欢黄色, 也喜欢绿色==</span><br></pre></td></tr></table></figure><p>E.G. </p><p>&#x3D;&#x3D;我喜欢黄色, 也喜欢绿色&#x3D;&#x3D;</p><h3 id="代码-用-“-”-包围"><a href="#代码-用-“-”-包围" class="headerlink" title="代码 [用 “&#96;” 包围]"></a>代码 [用 “&#96;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo rm -rf /*`</span><br></pre></td></tr></table></figure><p>E.G. </p><p><code>sudo rm -rf /*</code> (没事别乱敲这个! )</p><p><del>“请输入管理员密码: (闪烁的光标)”</del></p><h3 id="代码块-按三个-“-”-并敲回车"><a href="#代码块-按三个-“-”-并敲回车" class="headerlink" title="代码块 [按三个 “&#96;” 并敲回车]"></a>代码块 [按三个 “&#96;” 并敲回车]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment">// 这里就可以开始输入你要的代码了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    print（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    retrun O;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">``` // (这三个&quot;</span>`<span class="string">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></span><br></pre></td></tr></table></figure><p>(我之前都是用这个来展示各种语法的, 应该不用举例了吧)</p><p>要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项. </p><p>代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后, <code>```</code> 会变为 <code>````</code> + <code>对应语言</code>.</p><h3 id="引用-“-”-空格-前置"><a href="#引用-“-”-空格-前置" class="headerlink" title="引用 [“&gt;” + 空格 前置]"></a>引用 [“&gt;” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 24岁, 是学生.</span><br><span class="line">&gt; &gt; 学生特有的无处不在(恼)</span><br></pre></td></tr></table></figure><p>引用是可以嵌套的!</p><p>E.G. </p><blockquote><p>24岁, 是学生.</p><blockquote><p>学生特有的无处不在(恼)</p></blockquote></blockquote><h3 id="无序列表-“-“-或-“-”-空格-前置"><a href="#无序列表-“-“-或-“-”-空格-前置" class="headerlink" title="无序列表 [“-“ 或  “+” + 空格 前置]"></a>无序列表 [“-“ 或  “+” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一颗是枣树 (我喜欢用这种)</span><br><span class="line">+ 另一颗还是枣树</span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure><p>三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 <code>Tab</code> 会缩进一级. </p><p>E.G. </p><ul><li>一颗是枣树</li><li>另一颗还是枣树</li></ul><h3 id="有序列表-数字-“-”-空格-前置"><a href="#有序列表-数字-“-”-空格-前置" class="headerlink" title="有序列表 [数字 + “.” + 空格 前置]"></a>有序列表 [数字 + “.” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我来这里就为了三件事:</span><br><span class="line">1. 公平</span><br><span class="line">2. 公平</span><br><span class="line">3. 还是tm的公平!</span><br></pre></td></tr></table></figure><p>敲回车会自动补全, 敲回车后按下 <code>Tab</code> 会缩进一级. </p><p>E.G. </p><p>我来这里就为了三件事:</p><ol><li><p>公平</p></li><li><p>公平</p></li><li><p>还是tm的公平!</p></li></ol><h3 id="上标-用-“-”-包围"><a href="#上标-用-“-”-包围" class="headerlink" title="*上标 [用 “^” 包围]"></a>*上标 [用 “^” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure><p>E.G. </p><p>C语言中 <code>int</code> 的上限是 2^31^ - 1 &#x3D; 2147483647</p><h3 id="下标-用-“-”-包围"><a href="#下标-用-“-”-包围" class="headerlink" title="*下标 [用 “~” 包围]"></a>*下标 [用 “~” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure><p>E.G. </p><p>H<del>2</del>O 是剧毒的!</p><h3 id="注释-“-”-后置"><a href="#注释-“-”-后置" class="headerlink" title="*注释 [“[^]” 后置]"></a>*注释 [“[^]” 后置]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure><p>需要在文末写上注释对应的内容</p><p>E.G. </p><blockquote><p>今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</p></blockquote><p>[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</p><h3 id="链接-常用-“-”-“-”-分别包围文本与链接"><a href="#链接-常用-“-”-“-”-分别包围文本与链接" class="headerlink" title="链接 [常用 “[ ]” + “( )” 分别包围文本与链接]"></a>链接 [常用 “[ ]” + “( )” 分别包围文本与链接]</h3><p><strong>(注意: 文内跳转为扩展用法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)</span><br><span class="line">[基础教程: 12. 下标](#12. 下标 [用 &quot;~&quot; 包围])</span><br></pre></td></tr></table></figure><p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并 <code>单击鼠标左键</code> 即可跳转.</p><p>E.G. </p><p><a href="https://github.com/Sakiyary">来看看我贫瘠的仓库罢</a></p><p>[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])</p><h3 id="任务列表-“-”-空格-前置"><a href="#任务列表-“-”-空格-前置" class="headerlink" title="任务列表 [“- [ ]” + 空格 前置]"></a>任务列表 [“- [ ]” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TodoList:</span><br><span class="line">- [ ] 刷B站</span><br><span class="line">- [ ] 写代码</span><br><span class="line">- [x] 起床</span><br></pre></td></tr></table></figure><p>用 <code>x</code> 代替 <code>[ ]</code> 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.</p><p>E.G. TodoList:</p><ul><li><input disabled="" type="checkbox"> 刷B站</li><li><input disabled="" type="checkbox"> 写代码</li><li><input checked="" disabled="" type="checkbox"> 起床</li></ul><h3 id="表格-用-“-”-绘制表格边框"><a href="#表格-用-“-”-绘制表格边框" class="headerlink" title="表格 [用 “|” 绘制表格边框]"></a>表格 [用 “|” 绘制表格边框]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 学号 | 姓名  | 年龄 |</span><br><span class="line">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class="line">|114514|田所|24|</span><br><span class="line">|1919810|浩三|25|</span><br></pre></td></tr></table></figure><p>第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据</p><p>E.G. </p><table><thead><tr><th align="left">学号</th><th align="center">姓名</th><th align="right">年龄</th></tr></thead><tbody><tr><td align="left">114514</td><td align="center">田所</td><td align="right">24</td></tr><tr><td align="left">1919810</td><td align="center">浩三</td><td align="right">25</td></tr></tbody></table><h3 id="图片-直接拖进来或者复制粘贴"><a href="#图片-直接拖进来或者复制粘贴" class="headerlink" title="图片 [直接拖进来或者复制粘贴]"></a>图片 [直接拖进来或者复制粘贴]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片](图片的位置)</span><br></pre></td></tr></table></figure><p>我还是会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式. </p><h3 id="分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">--- (我喜欢用这种)</span><br><span class="line">___</span><br><span class="line">// (其实按三个及以上都可以)</span><br></pre></td></tr></table></figure><p>由于 <code>*</code> 与 <code>_</code> 均会自动补全, 所以我觉得 <code>-</code> 最为方便.</p><p>E.G. </p><hr><hr><hr><h3 id="Emoji表情-“-”-前置"><a href="#Emoji表情-“-”-前置" class="headerlink" title="Emoji表情 [“:” 前置]"></a>Emoji表情 [“:” 前置]</h3><p><strong>(注意: 英文输入为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sweat_smile: </span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br></pre></td></tr></table></figure><p>这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji 的英文名. </p><p>E.G. </p><p>:sweat_smile:<br>:drooling_face:<br>:clown_face:</p><p>对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来, 这是直接<strong>硬编码</strong>的 (<del>刻进DNA里</del>)</p><p>E.G. </p><p>😅🤤🤡</p><p>用好这个功能可以让你的文本非常的可爱! <del>太抽象了</del></p><p>这里分享一个可以复制<a href="https://emojipedia.org/apple/">全Emoji的网站</a>, 非常好用! 我之前的C语言大作业也是从这里下载的资源! </p><h2 id="🔥-进阶教程"><a href="#🔥-进阶教程" class="headerlink" title="🔥 进阶教程"></a>🔥 进阶教程</h2><h3 id="目录-自动生成"><a href="#目录-自动生成" class="headerlink" title="目录 [自动生成]"></a>目录 [自动生成]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure><p>若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code 的<code>命令面板</code> (即 <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">VS Code Command Palette</a>) 输入 <code>Create Table of Contents</code> 自动生成目录, 且可在扩展设置中细调目录参数.</p><h3 id="内联-HTML-代码-用-“-”-包围"><a href="#内联-HTML-代码-用-“-”-包围" class="headerlink" title="内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]"></a>内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">  &lt;font style=&quot;color:red&quot;&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>只要你会写, 你完全可以把 Markdown 当作 <strong>HTML</strong> 来写.</p><p>同时, <code>.md</code> 文件可以直接导出成一个网页.</p><p>下划线可以选中想要下划的文字按下 <code>Ctrl</code> + <code>U</code>. </p><p>E.G. </p><div style="text-align:center">  <font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font></div><center>简单的文字居中也可以这样</center><p><u>我差点忘了还有下划线这东西…</u></p><h3 id="内联-LaTeX-公式-用-“-”-包围"><a href="#内联-LaTeX-公式-用-“-”-包围" class="headerlink" title="内联 $\LaTeX$ 公式 [用 “$” 包围]"></a>内联 $\LaTeX$ 公式 [用 “$” 包围]</h3><p><strong>(注意: 部分编译器会不识别部分符号)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class="line"></span><br><span class="line">$a^n+b^n=c^n$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">%\usepackage&#123;unicode-math&#125;</span><br><span class="line">\displaystyle \ointctrclockwise\mathcal&#123;D&#125;[x(t)]</span><br><span class="line">\sqrt&#123;\frac&#123;\displaystyle3\uppi^2-\sum_&#123;q=0&#125;^&#123;\infty&#125;(z+\hat L)^&#123;q&#125;</span><br><span class="line">\exp(\symrm&#123;i&#125;q^2 \hbar x)&#125;&#123;\displaystyle (\symsfup&#123;Tr&#125;\symbfcal&#123;A&#125;)</span><br><span class="line">\left(\symbf\Lambda_&#123;j_1j_2&#125;^&#123;i_1i_2&#125;\Gamma_&#123;i_1i_2&#125;^&#123;j_1j_2&#125;</span><br><span class="line">\hookrightarrow\vec D\cdot \symbf P \right)&#125;&#125;</span><br><span class="line">=\underbrace&#123;\widetilde&#123;\left\langle \frac&#123;\notin \emptyset&#125;</span><br><span class="line">&#123;\varpi\alpha_&#123;k\uparrow&#125;&#125;\middle\vert</span><br><span class="line">\frac&#123;\partial_\mu T_&#123;\mu\nu&#125;&#125;&#123;2&#125;\right\rangle&#125;&#125;_&#123;\mathrm&#123;K&#125;_3</span><br><span class="line">\mathrm&#123;Fe&#125;(\mathrm&#123;CN&#125;)_6&#125; ,\forall z \in \mathbb&#123;R&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>用 <code>$</code> 包围为单条公式, 按下两个 <code>$</code> 并敲回车即生成公式块.</p><p>E.G. </p><p>$\LaTeX$ 是最好用的论文排版语言! 不信你看!</p><p>$a^n+b^n&#x3D;c^n$</p><p>$$<br>%\usepackage{unicode-math}<br>\displaystyle \ointctrclockwise\mathcal{D}[x(t)]<br>\sqrt{\frac{\displaystyle3\uppi^2-\sum_{q&#x3D;0}^{\infty}(z+\hat L)^{q}<br>\exp(\symrm{i}q^2 \hbar x)}{\displaystyle (\symsfup{Tr}\symbfcal{A})<br>\left(\symbf\Lambda_{j_1j_2}^{i_1i_2}\Gamma_{i_1i_2}^{j_1j_2}<br>\hookrightarrow\vec D\cdot \symbf P \right)}}<br>&#x3D;\underbrace{\widetilde{\left\langle \frac{\notin \emptyset}<br>{\varpi\alpha_{k\uparrow}}\middle\vert<br>\frac{\partial_\mu T_{\mu\nu}}{2}\right\rangle}}_{\mathrm{K}_3<br>\mathrm{Fe}(\mathrm{CN})_6} ,\forall z \in \mathbb{R}<br>$$</p><h3 id="网络图床"><a href="#网络图床" class="headerlink" title="*网络图床"></a>*网络图床</h3><p>(这是学长给我的网络图床教程, 我并未实践过…)</p><p>分享一个 Typora 搭配腾讯云COS&#x2F;阿里云OSS图床的<a href="https://blog.csdn.net/guo_ridgepole/article/details/108257277">例子</a>. 新用户免费试用6个月, 另外还可选择七牛云或者路过图床.</p><h3 id="Typora-的常用快捷键"><a href="#Typora-的常用快捷键" class="headerlink" title="*Typora 的常用快捷键"></a>*Typora 的常用快捷键</h3><table><thead><tr><th align="center">按键</th><th align="center">效果</th><th align="center">按键</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>Ctrl</code> + <code>D</code></td><td align="center">选中当前词</td><td align="center"><code>Ctrl</code> + <code>L</code></td><td align="center">选中当前句&#x2F;行</td></tr><tr><td align="center"><code>Ctrl</code> + <code>E</code></td><td align="center">选中当前区块</td><td align="center"><code>Ctrl</code> + <code>F</code></td><td align="center">搜索当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>B</code></td><td align="center">加粗当前选中</td><td align="center"><code>Ctrl</code> + <code>H</code></td><td align="center">替换当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>I</code></td><td align="center">倾斜当前选中</td><td align="center"><code>Ctrl</code> + <code>U</code></td><td align="center">下划当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>K</code></td><td align="center">将当前选中生成链接</td><td align="center"><code>Ctrl</code> + <code>J</code></td><td align="center">滚动屏幕将选中滚至顶部</td></tr><tr><td align="center"><code>Ctrl</code> + <code>W</code></td><td align="center">关闭当前窗口</td><td align="center"><code>Ctrl</code> + <code>N</code></td><td align="center">打开新窗口</td></tr><tr><td align="center"><code>Ctrl</code> + <code>O</code></td><td align="center">打开文件</td><td align="center"><code>Ctrl</code> + <code>P</code></td><td align="center">搜索文件并打开</td></tr><tr><td align="center"><code>Ctrl</code> + <code>回车</code></td><td align="center">表格下方插入行</td><td align="center"><code>Ctrl</code> + <code>,</code></td><td align="center">打开偏好设置</td></tr><tr><td align="center"><code>Ctrl</code> + <code>.</code></td><td align="center">切换全角&#x2F;半角标点</td><td align="center"><code>Ctrl</code> + <code>/</code></td><td align="center">切换正常&#x2F;源代码视图</td></tr><tr><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td><td align="center">缩小视图缩放</td><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td><td align="center">放大视图缩放</td></tr></tbody></table><p>还有一些不常用的&#x2F;三键的快捷键不在此列出.</p><h3 id="Typora-的主题样式与检查元素"><a href="#Typora-的主题样式与检查元素" class="headerlink" title="*Typora 的主题样式与检查元素"></a>*Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故Typora的主题样式本质就是 CSS 文件.</p><p>可以下载各种好看的主题给 Typora换上, 同时也可以自己调整对应的 CSS 文件, 或者自己手搓. </p><p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开 <code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML 来编辑.</p><h2 id="💯-总结"><a href="#💯-总结" class="headerlink" title="💯 总结"></a>💯 总结</h2><p>至此, <strong>Markdown + Typora &#x2F; VSCode</strong> 的手册教程也告一段落. </p><p>不知你看完这么长的教程&#x2F;手册, 是否能体会到 Markdown 的精妙简洁之处呢? </p><p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown 之后对于理解 HTML 也有帮助, 对于用 $\LaTeX$ 来写论文也有帮助. 标记语言正是为了摆脱 Word 那种虽然”所见即所得”, 但又过于花哨浮华, 很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的”所写即所得”时, 你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex公式</title>
      <link href="/2023/11/26/LaTeX%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/11/26/LaTeX%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>$$<br>\delta,\lambda\<br>\Delta,\Lambda\<br>\Alpha\Beta\<br>\phi,\varphi\<br>\epsilon,\varepsilon\<br>π<br>$$</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>$$<br>a^2,a_1\<br>x^{y+z},p_{ij},p_ij\<br>x_i,x_{\text i}\<br>\text{A B},\rm{A B}\<br>\text A B,\rm A B\<br>{\rm A} B\<br>\text{e},\text{i}<br>$$</p><span id="more"></span><h2 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h2><p>$$<br>\frac{1}{2},\frac 1 2,\<br>\frac 1 {x+y}\<br>\frac {\dfrac 1 x + 1}{y + 1}<br>$$</p><p>$$<br>\sqrt 2,\sqrt{x+y},\sqrt[3]x<br>$$</p><h2 id="普通运算符"><a href="#普通运算符" class="headerlink" title="普通运算符"></a>普通运算符</h2><p>$$<br>+-\<br>\times,\cdot,\div\<br>\pm,\mp\</p><blockquote><p>&lt;,\ge,\le,\gg,\ll,\ne,\approx,\equiv\<br>\cap,\cup,\in,\notin,\subseteq,\subsetneqq,\varnothing\<br>\forall,\exists,\nexists\<br>\because,\therefore\<br>\mathbb R,\R,\Q,\N,\Z_+\<br>\mathcal F,\mathscr F<br>$$</p></blockquote><p>$$<br>\cdots,\vdots,\ddots<br>$$</p><p>$$<br>\infty,\partial,∂,\nabla,\propto,\degree<br>$$</p><p>$$<br>\sin x,\sec x,\cosh x\<br>\log_2 x, \ln x,\lg x\<br>\lim\limits_{x \to 0} \frac { x}{\sin x}\<br>\max x<br>$$</p><p>$$<br>\text{MSE}(x)<br>$$</p><h2 id="大型运算符"><a href="#大型运算符" class="headerlink" title="大型运算符"></a>大型运算符</h2><p>$$<br>\sum,\prod\<br>\sum_i,\sum_{i&#x3D;0}^N\<br>\frac{\sum\limits_{i&#x3D;1}^n x_i}{\prod\limits_{i&#x3D;1}^n x_i}<br>$$</p><p>$$<br>\int,\iint,\iiint,\oint,\oiint\<br>\int_{-\infty}^0 f(x),\text d x<br>$$</p><p>$$<br>a, a\<br>a\ a\<br>a\quad a\<br>a\qquad a<br>$$</p><h2 id="标注符号"><a href="#标注符号" class="headerlink" title="标注符号"></a>标注符号</h2><p>$$<br>\vec x,\overrightarrow {AB}\<br>\bar x,\overline{AB}<br>$$</p><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><p>$$<br>\leftarrow,\Rightarrow,\Leftrightarrow,\longleftarrow<br>$$</p><h2 id="括号与定界符"><a href="#括号与定界符" class="headerlink" title="括号与定界符"></a>括号与定界符</h2><p>$$<br>([]){ }\<br>\lceil,\rceil,\lfloor,\rfloor,||\<br>\left(0,\frac 1 a\right]\<br>\left.\frac {∂f}{∂x}\right|_{x&#x3D;0}<br>$$</p><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><p>$$<br>\begin{align}</p><p>a&amp;&#x3D;b+c+d\<br>&amp;&#x3D;e+f</p><p>\end{align}<br>$$</p><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p>$$<br>f(x)&#x3D;</p><p>\begin{cases}</p><p>\sin x, &amp; -π\le x \le π\<br>0,&amp; \text{其他}</p><p>\end{cases}<br>$$</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>$$<br>\begin{matrix}</p><p>a &amp; b &amp; \cdots &amp; c \<br>\vdots&amp; \vdots &amp; \ddots &amp; \vdots \<br>e &amp; f&amp; \cdots &amp; g</p><p>\end{matrix}<br>$$</p><p>$$<br>\begin{bmatrix}</p><p>a &amp; b &amp; \cdots &amp; c \<br>\vdots&amp; \vdots &amp; \ddots &amp; \vdots \<br>e &amp; f&amp; \cdots &amp; g</p><p>\end{bmatrix}</p><p>\begin{pmatrix}</p><p>a &amp; b &amp; \cdots &amp; c \<br>\vdots&amp; \vdots &amp; \ddots &amp; \vdots \<br>e &amp; f&amp; \cdots &amp; g</p><p>\end{pmatrix}</p><p>\begin{vmatrix}</p><p>a &amp; b &amp; \cdots &amp; c \<br>\vdots&amp; \vdots &amp; \ddots &amp; \vdots \<br>e &amp; f&amp; \cdots &amp; g</p><p>\end{vmatrix}<br>$$</p><p>$$<br>\bf A,\bf B^{\rm T}<br>$$</p><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><p>$$<br>f(x) &#x3D; \frac 1 {\sqrt{2\pi} \sigma} {\rm e} ^ {-\frac {(x-\mu)^2}{2\sigma ^ 2}}\<br>f(x) &#x3D; \frac 1 {\sqrt{2\pi} \sigma} \exp \left[ {-\frac {(x-\mu)^2}{2\sigma ^ 2}}\right]<br>$$</p><p>$$<br>\lim\limits_{N\to \infty} P \left{ \left| \frac {I\left( \alpha_i \right)}{N} - H(s) \right| &lt; \varepsilon  \right} &#x3D; 1<br>$$</p><p>$$<br>x(n) &#x3D; \frac 1 {2\pi} \int _{-π} ^ π X\left( {\rm e} ^ </p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码表</title>
      <link href="/2023/11/11/ASCII%E7%A0%81%E8%A1%A8/"/>
      <url>/2023/11/11/ASCII%E7%A0%81%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a><strong>ASCII码表</strong></h2><table><thead><tr><th align="center"><strong>ASCII值</strong></th><th align="center"><strong>控制字符</strong></th><th align="center"><strong>ASCII值</strong></th><th align="center"><strong>控制字符</strong></th><th align="center"><strong>ASCII值</strong></th><th align="center"><strong>控制字符</strong></th><th align="center"><strong>ASCII值</strong></th><th align="center"><strong>控制字符</strong></th></tr></thead><tbody><tr><td align="center">0</td><td align="center">NUL</td><td align="center">32</td><td align="center">(space)</td><td align="center">64</td><td align="center">@</td><td align="center">96</td><td align="center">、</td></tr><tr><td align="center">1</td><td align="center">SOH</td><td align="center">33</td><td align="center">！</td><td align="center">65</td><td align="center">A</td><td align="center">97</td><td align="center">a</td></tr><tr><td align="center">2</td><td align="center">STX</td><td align="center">34</td><td align="center">”</td><td align="center">66</td><td align="center">B</td><td align="center">98</td><td align="center">b</td></tr><tr><td align="center">3</td><td align="center">ETX</td><td align="center">35</td><td align="center">#</td><td align="center">67</td><td align="center">C</td><td align="center">99</td><td align="center">c</td></tr><tr><td align="center">4</td><td align="center">EOT</td><td align="center">36</td><td align="center">$</td><td align="center">68</td><td align="center">D</td><td align="center">100</td><td align="center">d</td></tr><tr><td align="center">5</td><td align="center">ENQ</td><td align="center">37</td><td align="center">%</td><td align="center">69</td><td align="center">E</td><td align="center">101</td><td align="center">e</td></tr><tr><td align="center">6</td><td align="center">ACK</td><td align="center">38</td><td align="center">&amp;</td><td align="center">70</td><td align="center">F</td><td align="center">102</td><td align="center">f</td></tr><tr><td align="center">7</td><td align="center">BEL</td><td align="center">39</td><td align="center">‘</td><td align="center">71</td><td align="center">G</td><td align="center">103</td><td align="center">g</td></tr><tr><td align="center">8</td><td align="center">BS</td><td align="center">40</td><td align="center">(</td><td align="center">72</td><td align="center">H</td><td align="center">104</td><td align="center">h</td></tr><tr><td align="center">9</td><td align="center">HT</td><td align="center">41</td><td align="center">)</td><td align="center">73</td><td align="center">I</td><td align="center">105</td><td align="center">i</td></tr><tr><td align="center">10</td><td align="center">LF</td><td align="center">42</td><td align="center">*</td><td align="center">74</td><td align="center">J</td><td align="center">106</td><td align="center">j</td></tr><tr><td align="center">11</td><td align="center">VT</td><td align="center">43</td><td align="center">+</td><td align="center">75</td><td align="center">K</td><td align="center">107</td><td align="center">k</td></tr><tr><td align="center">12</td><td align="center">FF</td><td align="center">44</td><td align="center">,</td><td align="center">76</td><td align="center">L</td><td align="center">108</td><td align="center">l</td></tr><tr><td align="center">13</td><td align="center">CR</td><td align="center">45</td><td align="center">-</td><td align="center">77</td><td align="center">M</td><td align="center">109</td><td align="center">m</td></tr><tr><td align="center">14</td><td align="center">SO</td><td align="center">46</td><td align="center">.</td><td align="center">78</td><td align="center">N</td><td align="center">110</td><td align="center">n</td></tr><tr><td align="center">15</td><td align="center">SI</td><td align="center">47</td><td align="center">&#x2F;</td><td align="center">79</td><td align="center">O</td><td align="center">111</td><td align="center">o</td></tr><tr><td align="center">16</td><td align="center">DLE</td><td align="center">48</td><td align="center">0</td><td align="center">80</td><td align="center">P</td><td align="center">112</td><td align="center">p</td></tr><tr><td align="center">17</td><td align="center">DCI</td><td align="center">49</td><td align="center">1</td><td align="center">81</td><td align="center">Q</td><td align="center">113</td><td align="center">q</td></tr><tr><td align="center">18</td><td align="center">DC2</td><td align="center">50</td><td align="center">2</td><td align="center">82</td><td align="center">R</td><td align="center">114</td><td align="center">r</td></tr><tr><td align="center">19</td><td align="center">DC3</td><td align="center">51</td><td align="center">3</td><td align="center">83</td><td align="center">X</td><td align="center">115</td><td align="center">s</td></tr><tr><td align="center">20</td><td align="center">DC4</td><td align="center">52</td><td align="center">4</td><td align="center">84</td><td align="center">T</td><td align="center">116</td><td align="center">t</td></tr><tr><td align="center">21</td><td align="center">NAK</td><td align="center">53</td><td align="center">5</td><td align="center">85</td><td align="center">U</td><td align="center">117</td><td align="center">u</td></tr><tr><td align="center">22</td><td align="center">SYN</td><td align="center">54</td><td align="center">6</td><td align="center">86</td><td align="center">V</td><td align="center">118</td><td align="center">v</td></tr><tr><td align="center">23</td><td align="center">TB</td><td align="center">55</td><td align="center">7</td><td align="center">87</td><td align="center">W</td><td align="center">119</td><td align="center">w</td></tr><tr><td align="center">24</td><td align="center">CAN</td><td align="center">56</td><td align="center">8</td><td align="center">88</td><td align="center">X</td><td align="center">120</td><td align="center">x</td></tr><tr><td align="center">25</td><td align="center">EM</td><td align="center">57</td><td align="center">9</td><td align="center">89</td><td align="center">Y</td><td align="center">121</td><td align="center">y</td></tr><tr><td align="center">26</td><td align="center">SUB</td><td align="center">58</td><td align="center">:</td><td align="center">90</td><td align="center">Z</td><td align="center">122</td><td align="center">z</td></tr><tr><td align="center">27</td><td align="center">ESC</td><td align="center">59</td><td align="center">;</td><td align="center">91</td><td align="center">[</td><td align="center">123</td><td align="center">{</td></tr><tr><td align="center">28</td><td align="center">FS</td><td align="center">60</td><td align="center">&lt;</td><td align="center">92</td><td align="center">\</td><td align="center">124</td><td align="center">|</td></tr><tr><td align="center">29</td><td align="center">GS</td><td align="center">61</td><td align="center">&#x3D;</td><td align="center">93</td><td align="center">]</td><td align="center">125</td><td align="center">}</td></tr><tr><td align="center">30</td><td align="center">RS</td><td align="center">62</td><td align="center">&gt;</td><td align="center">94</td><td align="center">^</td><td align="center">126</td><td align="center">~</td></tr><tr><td align="center">31</td><td align="center">US</td><td align="center">63</td><td align="center">?</td><td align="center">95</td><td align="center">—</td><td align="center">127</td><td align="center">DEL</td></tr></tbody></table><span id="more"></span><p><strong>注意</strong></p><blockquote><ol><li><strong>ASCII中的<code>0</code>~<code>31</code>为控制字符；<code>32</code>~&#96;126<code>为打印字符；</code>127&#96;为Delete(删除)命令</strong>，下表为控制字符释义</li></ol><table><thead><tr><th align="center"><strong>十进制</strong></th><th align="center"><strong>十六进制</strong></th><th align="center"><strong>字符</strong></th><th align="center"><strong>十进制</strong></th><th align="center"><strong>十六进制</strong></th><th align="center"><strong>字符</strong></th></tr></thead><tbody><tr><td align="center">0</td><td align="center">00</td><td align="center">空</td><td align="center">16</td><td align="center">10</td><td align="center">数据链路转意</td></tr><tr><td align="center">1</td><td align="center">01</td><td align="center">头标开始</td><td align="center">17</td><td align="center">11</td><td align="center">设备控制 1</td></tr><tr><td align="center">2</td><td align="center">02</td><td align="center">正文开始</td><td align="center">18</td><td align="center">12</td><td align="center">设备控制 2</td></tr><tr><td align="center">3</td><td align="center">03</td><td align="center">正文结束</td><td align="center">19</td><td align="center">13</td><td align="center">设备控制 3</td></tr><tr><td align="center">4</td><td align="center">04</td><td align="center">传输结束</td><td align="center">20</td><td align="center">14</td><td align="center">设备控制 4</td></tr><tr><td align="center">5</td><td align="center">05</td><td align="center">查询</td><td align="center">21</td><td align="center">15</td><td align="center">反确认</td></tr><tr><td align="center">6</td><td align="center">06</td><td align="center">确认</td><td align="center">22</td><td align="center">16</td><td align="center">同步空闲</td></tr><tr><td align="center">7</td><td align="center">07</td><td align="center">震铃</td><td align="center">23</td><td align="center">17</td><td align="center">传输块结束</td></tr><tr><td align="center">8</td><td align="center">08</td><td align="center">backspace</td><td align="center">24</td><td align="center">18</td><td align="center">取消</td></tr><tr><td align="center">9</td><td align="center">09</td><td align="center">水平制表符</td><td align="center">25</td><td align="center">19</td><td align="center">媒体结束</td></tr><tr><td align="center">10</td><td align="center">0A</td><td align="center">换行&#x2F;新行</td><td align="center">26</td><td align="center">1A</td><td align="center">替换</td></tr><tr><td align="center">11</td><td align="center">0B</td><td align="center">竖直制表符</td><td align="center">27</td><td align="center">1B</td><td align="center">转意</td></tr><tr><td align="center">12</td><td align="center">0C</td><td align="center">换页&#x2F;新页</td><td align="center">28</td><td align="center">1C</td><td align="center">文件分隔符</td></tr><tr><td align="center">13</td><td align="center">0D</td><td align="center">回车</td><td align="center">29</td><td align="center">1D</td><td align="center">组分隔符</td></tr><tr><td align="center">14</td><td align="center">0E</td><td align="center">移出</td><td align="center">30</td><td align="center">1E</td><td align="center">记录分隔符</td></tr><tr><td align="center">15</td><td align="center">0F</td><td align="center">移入</td><td align="center">31</td><td align="center">1F</td><td align="center">单元分隔符</td></tr></tbody></table></blockquote><h2 id="ASCII扩展字符"><a href="#ASCII扩展字符" class="headerlink" title="ASCII扩展字符"></a>ASCII扩展字符</h2><p>​<strong>ASCII扩展字符——（为了适应更多字符）<code>128</code>~<code>255</code>&#x2F;<code>-128</code>~&#96;-1<code>，其中，</code>-128<code>对应</code>128&#96;，依次递增对应</strong></p><table><thead><tr><th align="center"><strong>十进制</strong></th><th align="center"><strong>十六进制</strong></th><th align="center"><strong>字符</strong></th><th align="center"><strong>十进制</strong></th><th align="center"><strong>十六进制</strong></th><th align="center"><strong>字符</strong></th></tr></thead><tbody><tr><td align="center">128</td><td align="center">80</td><td align="center">Ç</td><td align="center">192</td><td align="center">C0</td><td align="center">└</td></tr><tr><td align="center">129</td><td align="center">81</td><td align="center">ü</td><td align="center">193</td><td align="center">C1</td><td align="center">┴</td></tr><tr><td align="center">130</td><td align="center">82</td><td align="center">é</td><td align="center">194</td><td align="center">C2</td><td align="center">┬</td></tr><tr><td align="center">131</td><td align="center">83</td><td align="center">â</td><td align="center">195</td><td align="center">C3</td><td align="center">├</td></tr><tr><td align="center">132</td><td align="center">84</td><td align="center">ä</td><td align="center">196</td><td align="center">C4</td><td align="center">─</td></tr><tr><td align="center">133</td><td align="center">85</td><td align="center">à</td><td align="center">197</td><td align="center">C5</td><td align="center">┼</td></tr><tr><td align="center">134</td><td align="center">86</td><td align="center">å</td><td align="center">198</td><td align="center">C6</td><td align="center">╞</td></tr><tr><td align="center">135</td><td align="center">87</td><td align="center">ç</td><td align="center">199</td><td align="center">C7</td><td align="center">╟</td></tr><tr><td align="center">136</td><td align="center">88</td><td align="center">ê</td><td align="center">200</td><td align="center">C8</td><td align="center">╚</td></tr><tr><td align="center">137</td><td align="center">89</td><td align="center">ë</td><td align="center">201</td><td align="center">C9</td><td align="center">╔</td></tr><tr><td align="center">138</td><td align="center">8A</td><td align="center">è</td><td align="center">202</td><td align="center">CA</td><td align="center">╩</td></tr><tr><td align="center">139</td><td align="center">8B</td><td align="center">ï</td><td align="center">203</td><td align="center">CB</td><td align="center">╦</td></tr><tr><td align="center">140</td><td align="center">8C</td><td align="center">î</td><td align="center">204</td><td align="center">CC</td><td align="center">╠</td></tr><tr><td align="center">141</td><td align="center">8D</td><td align="center">ì</td><td align="center">205</td><td align="center">CD</td><td align="center">═</td></tr><tr><td align="center">142</td><td align="center">8E</td><td align="center">Ä</td><td align="center">206</td><td align="center">CE</td><td align="center">╬</td></tr><tr><td align="center">143</td><td align="center">8F</td><td align="center">Å</td><td align="center">207</td><td align="center">CF</td><td align="center">╧</td></tr><tr><td align="center">144</td><td align="center">90</td><td align="center">É</td><td align="center">208</td><td align="center">D0</td><td align="center">╨</td></tr><tr><td align="center">145</td><td align="center">91</td><td align="center">æ</td><td align="center">209</td><td align="center">D1</td><td align="center">╤</td></tr><tr><td align="center">146</td><td align="center">92</td><td align="center">Æ</td><td align="center">210</td><td align="center">D2</td><td align="center">╥</td></tr><tr><td align="center">147</td><td align="center">93</td><td align="center">ô</td><td align="center">211</td><td align="center">D3</td><td align="center">╙</td></tr><tr><td align="center">148</td><td align="center">94</td><td align="center">ö</td><td align="center">212</td><td align="center">D4</td><td align="center">Ô</td></tr><tr><td align="center">149</td><td align="center">95</td><td align="center">ò</td><td align="center">213</td><td align="center">D5</td><td align="center">╒</td></tr><tr><td align="center">150</td><td align="center">96</td><td align="center">û</td><td align="center">214</td><td align="center">D6</td><td align="center">╓</td></tr><tr><td align="center">151</td><td align="center">97</td><td align="center">ù</td><td align="center">215</td><td align="center">D7</td><td align="center">╫</td></tr><tr><td align="center">152</td><td align="center">98</td><td align="center">ÿ</td><td align="center">216</td><td align="center">D8</td><td align="center">╪</td></tr><tr><td align="center">153</td><td align="center">99</td><td align="center">Ö</td><td align="center">217</td><td align="center">D9</td><td align="center">┘</td></tr><tr><td align="center">154</td><td align="center">9A</td><td align="center">Ü</td><td align="center">218</td><td align="center">DA</td><td align="center">┌</td></tr><tr><td align="center">155</td><td align="center">9B</td><td align="center">¢</td><td align="center">219</td><td align="center">DB</td><td align="center">█</td></tr><tr><td align="center">156</td><td align="center">9C</td><td align="center">£</td><td align="center">220</td><td align="center">DC</td><td align="center">▄</td></tr><tr><td align="center">157</td><td align="center">9D</td><td align="center">¥</td><td align="center">221</td><td align="center">DD</td><td align="center">▌</td></tr><tr><td align="center">158</td><td align="center">9E</td><td align="center">?</td><td align="center">222</td><td align="center">DE</td><td align="center">?</td></tr><tr><td align="center">159</td><td align="center">9F</td><td align="center">ƒ</td><td align="center">223</td><td align="center">DF</td><td align="center">?</td></tr><tr><td align="center">160</td><td align="center">A0</td><td align="center">á</td><td align="center">224</td><td align="center">E0</td><td align="center">α</td></tr><tr><td align="center">161</td><td align="center">A1</td><td align="center">í</td><td align="center">225</td><td align="center">E1</td><td align="center">ß</td></tr><tr><td align="center">162</td><td align="center">A2</td><td align="center">ó</td><td align="center">226</td><td align="center">E2</td><td align="center">Γ</td></tr><tr><td align="center">163</td><td align="center">A3</td><td align="center">ú</td><td align="center">227</td><td align="center">E3</td><td align="center">π</td></tr><tr><td align="center">164</td><td align="center">A4</td><td align="center">ñ</td><td align="center">228</td><td align="center">E4</td><td align="center">Σ</td></tr><tr><td align="center">165</td><td align="center">A5</td><td align="center">Ñ</td><td align="center">229</td><td align="center">E5</td><td align="center">σ</td></tr><tr><td align="center">166</td><td align="center">A6</td><td align="center">ª</td><td align="center">230</td><td align="center">E6</td><td align="center">µ</td></tr><tr><td align="center">167</td><td align="center">A7</td><td align="center">º</td><td align="center">231</td><td align="center">E7</td><td align="center">τ</td></tr><tr><td align="center">168</td><td align="center">A8</td><td align="center">¿</td><td align="center">232</td><td align="center">E8</td><td align="center">Φ</td></tr><tr><td align="center">169</td><td align="center">A9</td><td align="center">?</td><td align="center">233</td><td align="center">E9</td><td align="center">Θ</td></tr><tr><td align="center">170</td><td align="center">AA</td><td align="center">¬</td><td align="center">234</td><td align="center">EA</td><td align="center">Ω</td></tr><tr><td align="center">171</td><td align="center">AB</td><td align="center">½</td><td align="center">235</td><td align="center">EB</td><td align="center">δ</td></tr><tr><td align="center">172</td><td align="center">AC</td><td align="center">¼</td><td align="center">236</td><td align="center">EC</td><td align="center">∞</td></tr><tr><td align="center">173</td><td align="center">AD</td><td align="center">¡</td><td align="center">237</td><td align="center">ED</td><td align="center">φ</td></tr><tr><td align="center">174</td><td align="center">AE</td><td align="center">«</td><td align="center">238</td><td align="center">EE</td><td align="center">ε</td></tr><tr><td align="center">175</td><td align="center">AF</td><td align="center">»</td><td align="center">239</td><td align="center">EF</td><td align="center">∩</td></tr><tr><td align="center">176</td><td align="center">B0</td><td align="center">?</td><td align="center">240</td><td align="center">F0</td><td align="center">≡</td></tr><tr><td align="center">177</td><td align="center">B1</td><td align="center">?</td><td align="center">241</td><td align="center">F1</td><td align="center">±</td></tr><tr><td align="center">178</td><td align="center">B2</td><td align="center">▓</td><td align="center">242</td><td align="center">F2</td><td align="center">≥</td></tr><tr><td align="center">179</td><td align="center">B3</td><td align="center">│</td><td align="center">243</td><td align="center">F3</td><td align="center">≤</td></tr><tr><td align="center">180</td><td align="center">B4</td><td align="center">┤</td><td align="center">244</td><td align="center">F4</td><td align="center">?</td></tr><tr><td align="center">181</td><td align="center">B5</td><td align="center">╡</td><td align="center">245</td><td align="center">F5</td><td align="center">?</td></tr><tr><td align="center">182</td><td align="center">B6</td><td align="center">╢</td><td align="center">246</td><td align="center">F6</td><td align="center">÷</td></tr><tr><td align="center">183</td><td align="center">B7</td><td align="center">╖</td><td align="center">247</td><td align="center">F7</td><td align="center">≈</td></tr><tr><td align="center">184</td><td align="center">B8</td><td align="center">╕</td><td align="center">248</td><td align="center">F8</td><td align="center">≈</td></tr><tr><td align="center">185</td><td align="center">B9</td><td align="center">╣</td><td align="center">249</td><td align="center">F9</td><td align="center">?</td></tr><tr><td align="center">186</td><td align="center">BA</td><td align="center">║</td><td align="center">250</td><td align="center">FA</td><td align="center">·</td></tr><tr><td align="center">187</td><td align="center">BB</td><td align="center">╗</td><td align="center">251</td><td align="center">FB</td><td align="center">√</td></tr><tr><td align="center">188</td><td align="center">BC</td><td align="center">╝</td><td align="center">252</td><td align="center">FC</td><td align="center">?</td></tr><tr><td align="center">189</td><td align="center">BD</td><td align="center">╜</td><td align="center">253</td><td align="center">FD</td><td align="center">²</td></tr><tr><td align="center">190</td><td align="center">BE</td><td align="center">╛</td><td align="center">FE</td><td align="center">■</td><td align="center"></td></tr><tr><td align="center">191</td><td align="center">BF</td><td align="center">┐</td><td align="center">255</td><td align="center">FF</td><td align="center">ÿ</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>int main(int argc,char *argv [])</title>
      <link href="/2023/11/03/argc,argv/"/>
      <url>/2023/11/03/argc,argv/</url>
      
        <content type="html"><![CDATA[<h2 id="int-main-int-argc-char-argv"><a href="#int-main-int-argc-char-argv" class="headerlink" title="int main(int argc,char *argv [])"></a>int main(int argc,char *argv [])</h2><p><code>int argc</code> 和 <code>char *argv[]</code> 是通常在 C 和 C++ 中用于处理命令行参数的两个参数，它们用于从命令行获取程序启动时传递给程序的参数信息。</p><ol><li><code>int argc</code>（Argument Count）：表示命令行参数的数量，即在程序启动时传递给程序的参数的个数。参数至少包括了程序名称本身，因此至少为 1。</li><li><code>char *argv[]</code>（Argument Vector）：是一个指向字符指针数组的指针，用于存储命令行参数的字符串。每个字符串表示一个命令行参数。**<code>argv[0]</code> 通常存储程序的名称**，而 <code>argv[1]</code>、<code>argv[2]</code> 等存储传递给程序的其他参数。</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong><code>a.cpp</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// argc 表示参数的数量，包括程序名称本身</span></span><br><span class="line">    <span class="comment">// argv 是一个指向参数字符串的数组</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;argc = &quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印每个命令行参数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;argv[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-用户不提供参数"><a href="#1-用户不提供参数" class="headerlink" title="1. 用户不提供参数"></a>1. 用户不提供参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\a.exe</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311032300431.png" alt="image-20231103230027354"></p><h3 id="2-用户提供参数"><a href="#2-用户提供参数" class="headerlink" title="2. 用户提供参数"></a>2. 用户提供参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\a.exe 0 1 2</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311032301519.png" alt="image-20231103230121475"></p><blockquote><ul><li><strong><code>argv[0]</code> 由OS自动赋值，存储程序的名称</strong></li><li><strong><code> argc≥1</code></strong></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型的精度及范围</title>
      <link href="/2023/10/20/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E5%BA%A6%E5%8F%8A%E8%8C%83%E5%9B%B4/"/>
      <url>/2023/10/20/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E5%BA%A6%E5%8F%8A%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310200836229.png" alt="img"></p><span id="more"></span><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><table><thead><tr><th align="center">数据类型</th><th align="center">字节数</th><th align="center">取值范围1</th><th align="center">取值范围2</th></tr></thead><tbody><tr><td align="center"><code>char</code></td><td align="center">1</td><td align="center">$$-2^{7}$$   ~   $$2^{7}-1$$</td><td align="center">-128 ~ 127</td></tr><tr><td align="center"><code>unsigned char</code></td><td align="center">1</td><td align="center">0   ~   $$2^{8}-1$$</td><td align="center">0 ~ 255</td></tr><tr><td align="center"><code>short</code></td><td align="center">2</td><td align="center">$$-2^{15}$$   ~   $$2^{15}-1$$</td><td align="center">$$-3.2\times 10^{4}$$ ~ $$3.2\times 10^{4}$$</td></tr><tr><td align="center"><code>unsigned short</code></td><td align="center">2</td><td align="center">0   ~   $$2^{16}-1$$</td><td align="center">0 ~ $$6.5\times 10^{4}$$</td></tr><tr><td align="center"><code>int</code>&#x2F;<code>long</code></td><td align="center">4</td><td align="center">$$-2^{31}$$   ~   $$2^{31}-1$$</td><td align="center">$$-2.1\times 10^{9}$$ ~ $$2.1\times 10^{9}$$</td></tr><tr><td align="center"><code>unsigned int</code>&#x2F;<code>unsigned long</code></td><td align="center">4</td><td align="center">0   ~   $$2^{32}-1$$</td><td align="center">0 ~ $$4.2\times 10^{9}$$</td></tr><tr><td align="center"><code>long long</code></td><td align="center">8</td><td align="center">$$-2^{63}$$   ~   $$2^{63}-1$$</td><td align="center">$$-9.2\times 10^{18}$$ ~ $$9.2\times 10^{18}$$</td></tr><tr><td align="center"><code>unsigned long long</code></td><td align="center">8</td><td align="center">0   ~   $$2^{64}-1$$</td><td align="center">0 ~ $$1.8\times 10^{19}$$</td></tr></tbody></table><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table><thead><tr><th align="center">数据类型</th><th align="center">字节数</th><th align="center">取值范围（绝对值）</th></tr></thead><tbody><tr><td align="center"><code>float</code></td><td align="center">4</td><td align="center">$$1.17549\times 10^{-38}$$   ~   $$3.40282\times 10^{38}$$</td></tr><tr><td align="center"><code>double</code></td><td align="center">8</td><td align="center">$$2.22507\times 10^{-308}$$   ~   $$1.79769\times 10^{308}$$</td></tr><tr><td align="center"><code>long double</code></td><td align="center">12</td><td align="center">$$2.22507\times 10^{-308}$$   ~   $$1.79769\times 10^{308}$$</td></tr></tbody></table><blockquote><p>  <a href="https://blog.csdn.net/qq_52911954/article/details/125528446">C语言——数据类型、基本数据类型的取值范围_c语言数据类型取值范围_Lydialyy的博客-CSDN博客</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INT_MAX，INT_MIN</title>
      <link href="/2023/10/15/INT_MAX%EF%BC%8CINT_MIN/"/>
      <url>/2023/10/15/INT_MAX%EF%BC%8CINT_MIN/</url>
      
        <content type="html"><![CDATA[<h1 id="INT-MAX，INT-MIN"><a href="#INT-MAX，INT-MIN" class="headerlink" title="INT_MAX，INT_MIN"></a>INT_MAX，INT_MIN</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C中<strong>常量</strong><code>INT_MAX</code>和<code>INT_MIN</code>分别表示int类型的最大值和最小值</p><blockquote><ol><li><code>INT_MAX</code> &#x3D; 2^31-1 &#x3D; 2147483647<code>INT_MIN</code> &#x3D; -2^31 &#x3D; -2147483648</li><li>所有超过该限值的int类型变量，都会出现溢出，出现warning，但是并不会出现error。</li><li>如果想表示的整数超过了该限值，可以使用长整型long long （占8字节64位）表示。</li></ol></blockquote><span id="more"></span><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对INT_MAX和INT_MIN的运算应当格外注意，在出现溢出的时候，不遵循数学规则。</p><ul><li><p><code>INT_MAX + 1 = INT_MIN</code></p></li><li><p><code>INT_MIN - 1 = INT_MAX</code></p></li><li><p><code>abs(INT_MIN) = INT_MIN</code></p></li></ul><p>比较有趣的是，<code>INT_MAX + 1 &lt; INT_MAX</code>， <code>INT_MIN - 1 &gt; INT_MIN</code>， <code>abs(INT_MIN) &lt; 0</code></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=MAX_INT;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a); </span><br><span class="line"><span class="type">int</span> b=INT_MIN;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121414941.png" alt="image-20221003094125792" style="zoom: 67%;" />]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2023/10/15/%E6%8C%87%E9%92%88/"/>
      <url>/2023/10/15/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法一：</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> *p; <span class="comment">// p是空指针，没有分配内存单元</span></span><br><span class="line"><span class="comment">//*p=4错误</span></span><br><span class="line">p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二：</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// p分配了内存单元，存有内存单元的地址</span></span><br><span class="line">*p = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR</title>
      <link href="/2023/10/12/ERROR/"/>
      <url>/2023/10/12/ERROR/</url>
      
        <content type="html"><![CDATA[<h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><h2 id="reference-to-left-right-is-ambiguous"><a href="#reference-to-left-right-is-ambiguous" class="headerlink" title="reference to &#39;left&#39;/&#39;right&#39; is ambiguous"></a><code>reference to &#39;left&#39;/&#39;right&#39; is ambiguous</code></h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><blockquote><p><strong>自定义的left 变量和right变量 与库中重名</strong></p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>​<strong>修改一下变量名left和right</strong></p><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能头文件</title>
      <link href="/2023/10/12/%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2023/10/12/%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>万能头文件**<code>#include &lt;bits/stdc++.h&gt;</code>**&#x3D;&#x3D;<strong>包含了目前c++所包含的所有头文件！！！！</strong>&#x3D;&#x3D;</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看我们开挂以后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><ol><li>使用场景：当我们&#x3D;&#x3D;<strong>忘记</strong>&#x3D;&#x3D;<strong>某函数的头文件</strong>或者<strong>头文件较多</strong>时，可以用**<code>#include&lt;bits/stdc++.h&gt;</code>**代替。</li><li>缺点：<ul><li><strong>编译时间太长</strong>。</li><li>**<code>#include &lt;bits/stdc++.h&gt;</code>**不是c++的标准头文件，部分编译器不支持。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏定义</title>
      <link href="/2023/10/12/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/10/12/%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><h2 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a><strong>宏常量</strong></h2><p>  我们最常使用到的#define的用法就是用#define来定义一个符号常量，而要修改时,只需修改#define这条语句就行了,不必每处代码都修改<br>例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR <span class="string">&quot;圆周率约等于&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %f&quot;</span>,STR,PI); <span class="comment">//预处理时会被替换为 printf(&quot;%s %f&quot;,&quot;圆周率约等于&quot;,3.14);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>运行结果:<br><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429733.png" alt="在这里插入图片描述"></p><h2 id="宏语句"><a href="#宏语句" class="headerlink" title="宏语句"></a><strong>宏语句</strong></h2><p>  我们还可以用宏定义一条或多条语句<br>例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Print printf(<span class="string">&quot;hello world!&quot;</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Print;  <span class="comment">//预处理时会被替换为 printf(&quot;hello world!&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>操作结果:<br><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429680.png" alt="在这里插入图片描述"></p><h2 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a><strong>宏函数</strong></h2><p>  我还可以用宏来定义函数,因为宏定义也可以带参数<br>例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Print(str) printf(<span class="string">&quot;%s&quot;</span>,str)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Print(<span class="string">&quot;这是一个只有一条语句的宏函数!&quot;</span>);</span><br><span class="line">    <span class="comment">//预处理时会被替换为 printf(&quot;%s&quot;,&quot;这是一个只有一条语句的宏函数!&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429685.png" alt="在这里插入图片描述"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><strong>其它</strong></h2><p><strong>1.#undef 是用来撤销宏定义的，用法如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.141592654</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI</span></span><br><span class="line"><span class="comment">//下面开始 PI 就失效了</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>2.使用ifndef防止头文件被重复包含和编译</strong></p><p>  这是宏定义的一种，它可以根据是否已经定义了一个变量来进行分支选择，一般用于调试等等.实际上确切的说这应该是预处理功能中三种（宏定义，文件包含和条件编译）中的一种—-条件编译。 C语言在对程序进行编译时，会先根据预处理命令进行“预处理”。C语言编译系统包括预处理，编译和链接等部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> x <span class="comment">//先测试x是否被宏定义过</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x <span class="comment">//如果没有宏定义下面就宏定义x并编译下面的语句</span></span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//如果已经定义了则编译#endif后面的语句</span></span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>条件指示符#ifndef检查预编译常量在前面是否已经被宏定义。如果在前面没有被宏定义,则条件指示符的值为真，于是从#ifndef到#endif之间的所有语句都被包含进来进行编译处理。相反，如果#ifndef指示符的值为假，则它与#endif指示符之间的行将被忽略。条件指示符#ifndef 的最主要目的是防止头文件的重复包含和编译。<br>　　千万不要忽略了头件的中的#ifndef，这是一个很关键的东西。比如你有两个C文件，这两个C文件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。</p><p>所以还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>&lt;标识&gt;在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDIO_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> xxx <span class="comment">//如果没有定义xxx</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xxx <span class="comment">//定义xxx</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//结束如果</span></span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>这个用法主要是在头文件中，主要是为了防止类重复的include，所以在类的头文件之前加上前面两个，用类名替代xxx，在最后加上最后一句</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转义字符</title>
      <link href="/2023/10/12/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2023/10/12/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><table><thead><tr><th align="center">转义字符</th><th align="center">字 符 值</th><th align="center">输 出 结 果</th></tr></thead><tbody><tr><td align="center"><code>\&#39;</code></td><td align="center">一个单撇号（’）</td><td align="center">输出单撇号字符’</td></tr><tr><td align="center"><code>\&quot;</code></td><td align="center">一个双撇号（”）</td><td align="center">输出双撇号字符”</td></tr><tr><td align="center"><code>\?</code></td><td align="center">一个人问号（?）</td><td align="center">输出问号字符?</td></tr><tr><td align="center"><code>\\</code></td><td align="center">一个反斜杠（\）</td><td align="center">输出反斜杠字符\</td></tr><tr><td align="center"><code>\a</code></td><td align="center">警告（alert）</td><td align="center">产生声音或视觉信号</td></tr><tr><td align="center"><code>\b</code></td><td align="center">退格（backspace）</td><td align="center">将光标当前位置后退一个字符</td></tr><tr><td align="center"><code>\f</code></td><td align="center">换页（from feed）</td><td align="center">将光标当前位置移到下一页的开头</td></tr><tr><td align="center"><code>\n</code></td><td align="center">换行</td><td align="center">将光标当前位置移到下一行的开头</td></tr><tr><td align="center"><code>\r</code></td><td align="center">回车（carriagereturn）</td><td align="center">将光标当前位置移到本行的开头</td></tr><tr><td align="center"><code>\t</code></td><td align="center">水平制表符</td><td align="center">将光标当前位置移到下一个Tab位置</td></tr><tr><td align="center"><code>\v</code></td><td align="center">垂直制表符</td><td align="center">将光标当前位置移到下一个垂直表对齐点</td></tr><tr><td align="center"><code>\o</code>、<code>\oo</code>、<code>\ooo</code></td><td align="center">与该八进制码对应的ASCII字符，其中o表示一个八进制数字</td><td align="center">与该八进制码对应的字符</td></tr><tr><td align="center"><code>\xh[h...]</code></td><td align="center">与该十六进制码对应的ASCII字符，其中h代表一个十六进制数字</td><td align="center">与该十六进制码对应的字符</td></tr></tbody></table><p><strong>详解</strong></p><blockquote><p>  <a href="https://blog.csdn.net/qq_61552595/article/details/124109830?ops_request_misc=%7B%22request_id%22:%22169709154416800192287021%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=169709154416800192287021&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-124109830-null-null.142%5Ev96%5Epc_search_result_base3&utm_term=%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&spm=1018.2226.3001.4187">详解转义字符_小蜗牛~向前冲的博客-CSDN博客</a></p></blockquote><h1 id="输出"><a href="#输出" class="headerlink" title="输出%"></a>输出<code>%</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%%&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组初始化</title>
      <link href="/2023/10/12/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/10/12/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h1><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;全局数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n局部数组：\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121413439.png" alt="在这里插入图片描述"></p><p><strong>结论</strong></p><ul><li><strong>全局数组的初始值为0</strong></li><li><strong>局部数组的初始值为随机数</strong></li></ul><span id="more"></span><h2 id="1-使用memset函数"><a href="#1-使用memset函数" class="headerlink" title="1. 使用memset函数"></a>1. 使用memset<a href="">函数</a></h2><p><a href="%5B(66%E6%9D%A1%E6%B6%88%E6%81%AF">memset函数用法</a> memset的用法详解_薛定谔的猫ovo的博客-CSDN博客_memset](<a href="https://blog.csdn.net/weixin_44162361/article/details/115790452?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_44162361/article/details/115790452?spm=1001.2014.3001.5506</a>))</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><code>void *memset(void *s, int c, int count)</code></p><ul><li>s：为指针或是数组</li><li>c：是赋给s的值</li><li>count：是s的长度</li><li>返回类型是一个指向存储区s的指针。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>memset是一个初始化函数，作用是<strong>将某一块内存空间全部设置为指定的值</strong>。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>memset可以方便的&#x3D;&#x3D;<strong>清空</strong>或初始化一个<strong>数组</strong>。&#x3D;&#x3D;</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ol><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><h2 id="2-赋值"><a href="#2-赋值" class="headerlink" title="2. 赋值"></a>2. 赋值</h2><ol><li>直接给每个元素赋值<br> <code>int arr[5] = &#123;1,2,3,4,5&#125;;</code></li><li>给一部分赋值，后面的全部为0<br> <code>int arr[5] = &#123;1,2&#125;;</code></li><li>由赋值参数个数决定数组的个数<br> <code>int arr[] = &#123;1,2&#125;;</code></li><li>数组元素初始化为0<br> <code>int array[4] = &#123;0&#125;;</code></li></ol><blockquote><p>注意：声明、初始化与赋值的区别</p><ul><li>声明：<code>int a;</code></li><li>初始化：<code>int a = 2;</code>（在声明的时候顺带赋值叫做初始化）</li><li>赋值：<code>a = 2;</code></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【自定义函数】</title>
      <link href="/2023/10/12/%E3%80%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E3%80%91/"/>
      <url>/2023/10/12/%E3%80%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">string <span class="title">addString</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, j = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num += b[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(num % <span class="number">10</span>);</span><br><span class="line">        carry = num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h3><p>假设 <code>i</code> 和 <code>j</code> 分别表示两个数的当前位，<code>result[i + j]</code> 存储了来自<strong>进位的累积值</strong>，而 <code>result[i + j + 1]</code> 存储了<strong>两位相乘后的最终结果</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">mulString</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len2 = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len1 + len2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mul = (a[i] - <span class="string">&#x27;0&#x27;</span>) * (b[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="type">int</span> sum = mul + res[i + j + <span class="number">1</span>];</span><br><span class="line">            res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果转换为字符串</span></span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(result.<span class="built_in">empty</span>() &amp;&amp; num == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result += <span class="built_in">to_string</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成【m，n】（m"><a href="#生成【m，n】（m" class="headerlink" title="生成【m，n】（m&lt;n）的随机数"></a>生成【m，n】（m&lt;n）的随机数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span><span class="comment">//srand(time(0));</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">random</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() % (n - m + <span class="number">1</span>) + m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//放在主函数main()内部</span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h3 id="判断是否为闰年"><a href="#判断是否为闰年" class="headerlink" title="判断是否为闰年"></a>判断是否为闰年</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>闰年：二月29天，一年366天</li><li>非闰年：二月28天，一年365天</li></ul></blockquote><h3 id="求year的天数"><a href="#求year的天数" class="headerlink" title="求year的天数"></a>求year的天数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//    return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">days</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">365</span> + <span class="built_in">leap</span>(year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求year年month月的天数"><a href="#求year年month月的天数" class="headerlink" title="求year年month月的天数"></a>求year年month月的天数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">days</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (month == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">28</span> + <span class="built_in">leap</span>(year);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">4</span> || month == <span class="number">6</span> || month == <span class="number">9</span> || month == <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求关键字k的第p位"><a href="#求关键字k的第p位" class="headerlink" title="求关键字k的第p位"></a>求关键字k的第p位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Radix</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121356542.png" alt="image-20221209092201927"></p><h3 id="判断质数"><a href="#判断质数" class="headerlink" title="判断质数"></a>判断质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)         <span class="comment">//注意是小于等于</span></span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="因数个数"><a href="#因数个数" class="headerlink" title="因数个数"></a>因数个数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisor</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i * i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            cnt += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i * i == n)</span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数个数"><a href="#分解质因数个数" class="headerlink" title="分解质因数个数"></a>分解质因数个数</h3><p>求正整数$$N(N&gt;1)$$的质因数的个数。 相同的质因数需要重复计算。如$$120&#x3D;2<em>2</em>2<em>3</em>5$$，共有$$5$$个质因数。</p><blockquote><p>  我们求质因子的时候其实没有必要去先判断一个因子是否为质数，为什么呢？</p><ul><li><p>比如说一个因子为 11，是质数，那么无论前面怎么进行除法运算，一定有这个因子，所以质数因子不可能漏掉</p></li><li><p>而对于因子 4，它肯定可以转换成质因子之积：2×2，那么在前面已经被除过了，所以已经没有非质数因子了</p></li></ul><p>  所以我们只需要从 2 开始遍历，遍历到$$\sqrt{n}$$即可，为什么是$$\sqrt{n}$$呢？</p><ul><li>因为任何一个数n至多存在一个大于$$\sqrt{n}$$且$$!&#x3D;n$$的因子，所以如果存在，加1就好了。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prime_cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在大于 sqrt(num) 的因子</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数gcd"><a href="#最大公约数gcd" class="headerlink" title="最大公约数gcd"></a>最大公约数gcd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b==<span class="number">0</span> ? a : <span class="built_in">gcd</span>(b,a%b);<span class="comment">//递归+辗转相除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小公倍数lcm"><a href="#最小公倍数lcm" class="headerlink" title="最小公倍数lcm"></a>最小公倍数lcm</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b==<span class="number">0</span> ? a : <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;<span class="comment">//有时候两数乘积会超过整数的范围,由此我们可以调整一下顺序:a/gcd(a,b)*b,   先除一下，这样就可以避免在一定程度上避免溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 最小公倍数&#x3D;两数乘积&#x2F;最大公约数，即</p><p> <strong>$$\left[ a,b \right] \cdot \left( a,b \right) &#x3D;a\cdot b$$</strong></p></blockquote><h3 id="四舍五入精确到小数点后i位"><a href="#四舍五入精确到小数点后i位" class="headerlink" title="四舍五入精确到小数点后i位"></a>四舍五入精确到小数点后i位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">rounding</span><span class="params">(<span class="type">double</span> a)</span><span class="comment">//四舍五入保留i位小数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>)<span class="keyword">return</span>  (<span class="type">int</span>)(a*<span class="built_in">pow</span>(<span class="number">10</span>,i)+<span class="number">0.5</span>)/<span class="built_in">pow</span>(<span class="number">10</span>,i);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">return</span>  (<span class="type">int</span>)(a*<span class="built_in">pow</span>(<span class="number">10</span>,i)- <span class="number">0.5</span>)/<span class="built_in">pow</span>(<span class="number">10</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为“指定字符”"><a href="#判断是否为“指定字符”" class="headerlink" title="判断是否为“指定字符”"></a>判断是否为“指定字符”</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s=<span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">find</span>(ch)!=string::npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为-闰年"><a href="#判断是否为-闰年" class="headerlink" title="判断是否为 闰年"></a>判断是否为 闰年</h3><blockquote><p>闰年：被 4 整除且不能被 100 整除 或者 可以被 400 整除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>)||n%<span class="number">400</span>==<span class="number">0</span>); <span class="comment">//Attention:最外面必须有一个（）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用sort自定义cmp函数"><a href="#使用sort自定义cmp函数" class="headerlink" title="使用sort自定义cmp函数"></a>使用sort自定义cmp函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score!=b.score)</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">return</span> a.score!=b.score ? a.score&gt;b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> node a,<span class="keyword">struct</span> node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height!=b.height ? a.height&gt;b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：类型为void类型时，可以不带return语句，系统会自动加上一个return语句</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子列和</title>
      <link href="/2023/10/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/"/>
      <url>/2023/10/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子列和"><a href="#最大子列和" class="headerlink" title="最大子列和"></a>最大子列和</h1><h2 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310231458556.png" alt="image-20231023145758457"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];        <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum)   <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)        <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;        <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型二"><a href="#类型二" class="headerlink" title="类型二"></a>类型二</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310231513494.png" alt="image-20231023151341432"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = -MAX_INT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];        <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum)   <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)        <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;        <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  只需更改maxsum的初值即可<code>int maxsum = -MAX_INT</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符数组&amp;&amp;字符串</title>
      <link href="/2023/10/12/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84&amp;&amp;%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/10/12/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84&amp;&amp;%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符数组-字符串"><a href="#字符数组-字符串" class="headerlink" title="字符数组&amp;&amp;字符串"></a>字符数组&amp;&amp;字符串</h1><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p>​我们知道定义一个数组时需要为其指定相应的变量类型。也就是说，定义了数组的类型之后这个数组中的所有变量就都是相同的类型。现在我们就来定义一个<strong>字符数组</strong>，如下：</p><p><code>char hello[5] = &#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;</code></p><p>​这样我们就定义了一个字符型的数组，对于数组型的变量这样定义是没有问题的，但有两个方面的不足：</p><ol><li><p>定义的过程比较麻烦，在数组变量初始化时需要逐个写出每一个字符，并在这每一个字符的两端加上一对单引号。</p></li><li><p>在显示字符数组时，我们通常希望能够让其一次性的显示出来，而不是通过循环数组的方式逐个显示这些字符。</p></li></ol><p>​例如上面定义的数组我们想要用printf将其显示出来我们则需要通过循环的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">5</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, hello[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>​其实，在C语言中支持直接定义<strong>字符串</strong>的方式，定义字符数组，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, hello);</span><br></pre></td></tr></table></figure><p>​注意，我们在定义这个数组时，指定数组的大小为6，也就是说需要申请6个字节的存储空间，而在等号右侧的双引号中我们却只书写了5个字符。这并不是笔误，C语言规定当使用**<font color='red'>双引号定义字符串</font><strong>时以&#x3D;&#x3D;</strong><code>&#39;\0&#39;</code><strong>&#x3D;&#x3D;作为这个字符串的</strong><font color='blue'>结束标志符</font>**，也就是说这个字符串一共有6个字符，分别是<code>&#39;H&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;l&#39;</code>、<code>&#39;l&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;\0&#39;</code></p><blockquote><p> 关于<code>&#39;\0&#39;</code>读者只需要知道这是一个特殊的字符即可，它表示字符串的结束，它的值为0。</p></blockquote><p>​这样我们就可以通过printf函数将这个字符串直接打印出来。需要注意的是，<strong>当使用<code>printf(“%s”,  )</code>来显示字符串时，我们要确保这个<font color='red'>字符串变量中最后一个结束字符为\0</font>，如果结束字符不是\0则printf在显示这个字符串时，就不知道显示到何处结束，</strong>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">Hello#@($<span class="number">0948</span>#.<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>​也就是说，我们虽然定义了一个字符串，但只定义了5个字符的长度，而使用双引号为其初始化时，这个字符串的<strong>实际大小应该是6</strong>，因为要<strong>追加一个<code>\0</code><strong>，但我们在定义数组大小时只指定其大小是5，所以这个数组中的中只有5个元素是<code>&#39;H&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;l&#39;</code>、<code>&#39;l&#39;</code>、<code>&#39;o&#39;</code>。而在’o’之后并没有<code>&#39;\0&#39;</code>，所以在<code>printf</code>显示这个字符串时，显示 Hello之后，并不知道何时结束，所以就会继续显示，直到遇到一个<code>&#39;\0&#39;</code>为止，于是我们程序就出现了非预期的结果。这样的程序并不是我们提倡的，</strong>我们在定义字符串时一定要为其<font color='red'>多分配一个字符的长度</font>，以便存放<font color='blue'>字符串结束符<code>&#39;\0&#39;</code></font>。</strong>当然，使用双引号定义的字符串可以像使用普通数组一样使用其数组元素，例如ABC运行结果可以看到直接显示字符串和循环显示字符数组中的元素的效果是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(str); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>​在这里我们使用了另一个重要函数sizeof()，它的作用是可以计算出某一个变量或类型的大小，就是占用的内存字节数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d\n&quot;</span>, </span><br><span class="line">        <span class="built_in">sizeof</span>(ch), </span><br><span class="line">        <span class="built_in">sizeof</span>(sh), </span><br><span class="line">        <span class="built_in">sizeof</span>(i), </span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">long</span>), </span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>​请注意，long类型的变量在不同的操作系统下占用字节数可能不同，请参数参见《变量大小》。另外在使用sizeof来计算数组大小时，计算的是数组一共占用内存的字节数，而不是数组的元素元素的个数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br></pre></td></tr></table></figure><p>​上面例子的结果是16而不是4。</p><h2 id="输入对比"><a href="#输入对比" class="headerlink" title="输入对比"></a>输入对比</h2><ol><li>字符数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">50</span>];<span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">50</span>];<span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121407458.png" alt="image-20221010181124750"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++标准库函数】</title>
      <link href="/2023/10/12/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/"/>
      <url>/2023/10/12/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="C-标准库函数"><a href="#C-标准库函数" class="headerlink" title="C++标准库函数"></a>C++标准库函数</h1><p>[TOC]</p><h2 id="max-element、min-element"><a href="#max-element、min-element" class="headerlink" title="max_element、min_element"></a>max_element、min_element</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>1. 求数组的最大值或最小值</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a, a + <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a, a + <span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//获取最大值</span></span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//获取最小值</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>2. 求数组最大值最小值对应的下标</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a, a + <span class="number">8</span>) - a; </span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a, a + <span class="number">8</span>) - a;</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); <span class="comment">//获取最大值对应的下标</span></span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();<span class="comment">//获取最小值对应的下标</span></span><br></pre></td></tr></table></figure><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><a href="https://blog.csdn.net/liu16659/article/details/87152348?ops_request_misc=%7B%22request_id%22:%22167715751316800188555444%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167715751316800188555444&biz_id=0&spm=1018.2226.3001.4187">(96条消息) C++ 中 fill() 的使用_LawsonAbs的博客-CSDN博客_c++ fill</a></p><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><h3 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a>头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><code>void *memset(void *s, int c, int count)</code></p><ul><li>s：为指针或是数组</li><li>c：是赋给s的值</li><li>count：是s的长度</li><li>返回类型是一个指向存储区s的指针。</li></ul><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>memset是一个初始化函数，作用是<strong>将某一块内存空间全部设置为指定的值</strong>。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>memset可以方便的&#x3D;&#x3D;<strong>清空</strong>或初始化一个<strong>数组</strong>。&#x3D;&#x3D;</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ol><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><blockquote><p>  <a href="https://blog.csdn.net/weixin_44162361/article/details/115790452?ops_request_misc=%7B%22request_id%22:%22169735623116800180650624%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169735623116800180650624&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115790452-null-null.142%5Ev96%5Epc_search_result_base3&utm_term=memset&spm=1018.2226.3001.4187">memset的用法详解_薛定谔的猫ovo的博客-CSDN博客</a></p></blockquote><h2 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h2><p>memcmp是比较内存区域buf1和buf2的前count个字节。该函数是按字节比较的</p><h3 id="基本原型"><a href="#基本原型" class="headerlink" title="基本原型"></a>基本原型</h3><p>int memcmp(const void *buf1, const void *buf2, unsigned int count);</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>比较内存区域buf1和buf2的前count个字节。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li><p>当buf1&lt;buf2时，返回值&lt;0</p></li><li><p>当buf1&#x3D;buf2时，返回值&#x3D;0</p></li><li><p>当buf1&gt;buf2时，返回值&gt;0</p></li></ul><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">r = <span class="built_in">memcmp</span>(&amp;s1,&amp;s2,<span class="built_in">strlen</span>(s1));</span><br><span class="line"><span class="keyword">if</span>(!r)<span class="comment">//！r 非零返回的是 1  这个是非运算，计算机是二进制的，不是零就是一了 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 and s2 are identical\n&quot;</span>);<span class="comment">/*s1等于s2*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);<span class="comment">/*s1小于s2*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);<span class="comment">/*s1大于s2*/</span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,!r); //输出是一， </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,r);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明:"></a>说明:</h3><ol><li><p>该函数是按字节比较的：当s1,s2为字符串时</p><ul><li><p><code>memcmp(s1,s2,1)</code>就是比较s1和s2的第一个字节的ascII码值；</p></li><li><p><code>memcmp(s1,s2,n)</code>就是比较s1和s2的前n个字节的ascII码值；</p></li></ul></li></ol><p>  例如:</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> *s2=<span class="string">&quot;acd&quot;</span>;</span><br><span class="line"><span class="type">int</span> r=<span class="built_in">memcmp</span>(s1,s2,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>  比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了所以$$r&#x3D;-1$$.  </p><ol start="2"><li>对于<code>memcmp()</code>，如果两个字符串相同而且<code>count</code>大于字符串长度的话，<code>memcmp</code>不会在<code>\0</code>处停下来，会继续比较<code>\0</code>后面的内存单元，直到<code>_res</code>不为零或者达到<code>count</code>次数。</li></ol><p>  例如：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[]=<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="type">char</span> a2[]=<span class="string">&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure><pre><code>对于`memcmp(a1,a2,10)`，`memcmp`在两个字符串的`\0`之后继续比较    所以，如果想使用memcmp比较字符串，要保证count不能超过最短字符串的长度，否则结果有可能是错误的。</code></pre></blockquote><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p><code>new()</code>使计算机开辟一块内存空间，并返回<strong>内存空间的首地址</strong></p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ol><li><p>使用new来分配内存</p><pre><code>     `ElementType*p=new ElementType;`</code></pre></li><li><p>使用new来分配内存并赋值</p><pre><code>     `ElementType*p=new ElementType(data);`</code></pre></li><li><p>使用new函数创建数组</p><pre><code>     `ElementType*p=new ElementType [size];`</code></pre></li><li><p><code>ElementType*p=new ElementType [size]&#123;&#125;;</code></p></li></ol><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><ol><li>new开辟的空间在堆上，而一般声明的变量存放在栈上</li><li><strong><font color='red'>通常用new函数代替malloc函数</font></strong></li><li>new不需要头文件</li></ol><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">example1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以在new后面直接赋值</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以单独赋值</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">example2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用new创建数组</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 也可以依次赋值</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        q[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *st = <span class="keyword">new</span> <span class="built_in">student</span>(&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *stlist = <span class="keyword">new</span> student[<span class="number">3</span>]&#123;&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;bac&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="string">&quot;ccd&quot;</span>, <span class="number">93</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> e1 = <span class="built_in">example1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e1: &quot;</span> &lt;&lt; e1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *e2 = <span class="built_in">example2</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; e2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st1 = <span class="built_in">example3</span>();</span><br><span class="line">    cout &lt;&lt; st1-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st1-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st2 = <span class="built_in">example4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; st2[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st2[i].score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402201656921.png" alt="image-20240220165632598"></p><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>**<code>swap(a,b);</code><strong>交换两个变量</strong><code>a,b</code>**的值</p><blockquote><p><strong><code>a,b</code><strong>可以是</strong><font color='red'>任何数据类型</font></strong></p></blockquote><h3 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h3><p><strong><code>void swap ( ElementType &amp;a, ElementType &amp;b);</code></strong></p><h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; <span class="comment">// 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121336975.png" alt="image-20221208182201962"></p><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;ABCD&quot;</span>;     string b = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121336032.png" alt="image-20221208182533843"></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="头文件-3"><a href="#头文件-3" class="headerlink" title="头文件"></a>头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p>反转在**<font color='red'> [ first,last ) </font>**范围内的顺序（包括first指向的元素，不包括last指向的元素）</p><h3 id="原型-2"><a href="#原型-2" class="headerlink" title="原型"></a>原型</h3><p><strong><code>void reverse (BidirectionalIterator first,BidirectionalIterator last);</code></strong></p><ul><li>参数first：待排区域的**<font color='blue'>起始地址</font>**</li><li>参数last：待排区域的**<font color='blue'>末尾地址</font>**</li></ul><h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><ul><li>反转<strong>向量</strong><font color='blue'><strong>vector</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//v的值为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><ul><li>反转数组**<code>ElementType A[]</code>**</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[]=&#123;<span class="number">12</span>,<span class="number">-5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(A, A+<span class="number">6</span>);<span class="comment">//数组A为19,1,7,0,-5,12</span></span><br></pre></td></tr></table></figure><ul><li>反转<strong>字符串<font color='blue'>string</font></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;www.mathor.top&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//str结果为pot.rohtam.wwww</span></span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h3 id="头文件-4"><a href="#头文件-4" class="headerlink" title="头文件"></a>头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h3><p>对&#x3D;&#x3D;<strong><font color='red'>数组排序</font></strong>&#x3D;&#x3D;</p><blockquote><ul><li>数组可以是**<code>ElementType A[]</code>**，也可以是 <strong><code>vector &lt;ElementType&gt; A</code></strong><ul><li><strong><code>ElementType A[]</code><strong>：</strong><code>A</code><strong>表示</strong><font color='blue'>数组首地址</font><strong>，</strong><code>A+n</code><strong>表示</strong><font color='blue'>数组尾部</font></strong></li><li><strong><code>vector &lt;ElementType&gt; A</code><strong>：</strong><code>A.begin()</code><strong>和</strong><code>A.end()</code><strong>表示</strong><font color='blue'>头尾</font></strong></li></ul></li></ul></blockquote><h3 id="原型-3"><a href="#原型-3" class="headerlink" title="原型"></a>原型</h3><table><thead><tr><th>默认</th><th><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last);</code></strong></th></tr></thead><tbody><tr><td><strong>自定义</strong></td><td><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last,Compare comp);</code></strong></td></tr></tbody></table><ul><li>参数first：待排数组的**<font color='blue'>起始地址</font>**</li><li>参数last：待排数组的**<font color='blue'>末尾地址</font>**</li><li>参数comp：自定义排序方法<ul><li>如果第三个参数不写，则<strong>默认的排序方法</strong>是**<font color='red'>从小到大</font>**排序。</li></ul></li></ul><h3 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// cmp函数返回的值是bool类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 从大到⼩排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 因为这里没有传入参数cmp，所以按照默认,v从小到大排列</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, cmp); <span class="comment">// arr从大到小排列，因为cmp函数排序规则设置了从大到小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见cmp函数"><a href="#常见cmp函数" class="headerlink" title="常见cmp函数"></a>常见cmp函数</h3><p>- </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br></pre></td></tr></table></figure><p>- </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score!=b.score)</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">return</span> a.score!=b.score ? a.score&gt;b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> node a,<span class="keyword">struct</span> node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height!=b.height ? a.height&gt;b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>- </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注： <strong><code>sort</code></strong> 函数的 <strong><code>cmp</code></strong> 必须按照规定来写，即必须只是 <strong><code>&gt;</code></strong> 或者 <strong><code>&lt;</code></strong> ，比如： <strong><code>return a &gt; b;</code></strong> 或者 <strong><code>return a &lt; b;</code></strong> 而不能是 <strong><code>&lt;=</code></strong> 或者 <strong><code>&gt;=</code></strong> </p></blockquote><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><pre><code>使用关键字`typedef`可以为数据类型起一个新的别名</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br><span class="line">newName a,b;</span><br></pre></td></tr></table></figure><ul><li><code>oldName</code> 是类型原来的名字，</li><li><code>newName</code> 是类型新的名字</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<code>typedef</code>去掉，<code>oldname</code>保留，<code>newname</code>换成a,b&#x3D;&#x3D;</p></blockquote><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldName a,b;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>typedef 是赋予<strong>现有类型</strong>一个<strong>新的名字</strong>，而&#x3D;&#x3D;<strong>不是创建新的类型</strong>&#x3D;&#x3D;。</li><li>为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。</li><li>&#x3D;&#x3D;<font color='red'><strong>最后的分号<code>;</code>不要忘记</strong></font>&#x3D;&#x3D;</li></ol></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>typedef给如<code>int</code>，<code>double</code>，<code>char</code>，<code>long</code>，<code>float</code> 等类型定义别名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br></pre></td></tr></table></figure><hr><ol start="2"><li><strong>typedef 给数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> array[<span class="number">20</span>];</span><br><span class="line">array a1, a2, s1, s2;</span><br></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><blockquote><p>注：数组也是有类型的。例如char a1[20];定义了一个数组 a1，它的类型就是 &#x3D;&#x3D;<strong>char [20]</strong>&#x3D;&#x3D;。</p></blockquote><hr><ol start="3"><li><strong>typedef 给结构体类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure><p><code>stu</code>  是 <code>struct node</code> 的别名，可以用 <code>stu</code> 定义结构体变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu x;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> x;</span><br></pre></td></tr></table></figure><hr><ol start="4"><li><strong>typedef 给结构数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>typedef 给指针类型定义别名</strong></li></ol><ul><li>例一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_ARR)</span>[4]</span>;</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR 是类型<code>int [4] * </code>的别名，它是一个&#x3D;&#x3D;<strong>二维数组指针</strong>&#x3D;&#x3D;类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><hr><ul><li>例二</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * PTR_TO_ARR [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR 是类型<code>int * [4]</code>的别名，它是一个&#x3D;&#x3D;<strong>元素指向整形数据的指针数组</strong>&#x3D;&#x3D;类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>typedef为函数指针类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">PTR_TO_FUNC pfunc;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*PTR_TO_ARR)</span>[30]</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">3</span>][<span class="number">30</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;百度搜索引擎&quot;</span>,</span><br><span class="line">    <span class="string">&quot;C-Language&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PTR_TO_ARR parr = str;</span><br><span class="line">    PTR_TO_FUNC pfunc = max;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max: %d\n&quot;</span>, (*pfunc)(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str[%d]: %s\n&quot;</span>, i, *(parr+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max: <span class="number">20</span></span><br><span class="line">str[<span class="number">0</span>]: http:<span class="comment">//www.baidu.com</span></span><br><span class="line">str[<span class="number">1</span>]: 百度搜索引擎</span><br><span class="line">str[<span class="number">2</span>]: C-Language</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ol><li><a href="https://blog.csdn.net/weixin_51635753/article/details/115434999?ops_request_misc=%7B%22request_id%22:%22167049370716782414992762%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=167049370716782414992762&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-21-115434999-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=C++%E8%87%AA%E5%B8%A6swap%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">(82条消息) C++ STL 常用函数_Mr.bei的博客-CSDN博客_c++stl常用函数</a></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++ STL】</title>
      <link href="/2023/10/12/%E3%80%90C++%20STL%E3%80%91/"/>
      <url>/2023/10/12/%E3%80%90C++%20STL%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a></p><h1 id="数组vector"><a href="#数组vector" class="headerlink" title="数组vector"></a>数组vector</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><strong><code>#include &lt;vector&gt;</code></strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ElementType&gt; v;</span><br></pre></td></tr></table></figure><blockquote><p>  这里的ElementType可以是<strong>任意类型</strong>，例如 int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br></pre></td></tr></table></figure><blockquote><p>  定义一个向量v，**<font color='red'>大小为0</font>** </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><blockquote><p>  先定义⼀个向量v，然后**<font color='red'>将长度resize为8</font>**，默认这8个元素都是0</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>   定义具有10个int元素的向量v，**<font color='red'>默认这10个元素值都为0</font>**</p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>  定义具有10个int元素的向量v，且**<font color='red'>这10个元素值都为</font>**1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure><blockquote><p>   先定义⼀个向量a，然后**<font color='red'>将向量b赋值给向量a</font>**（a的值完全等价于b的值）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br></pre></td></tr></table></figure><blockquote><p>  将向量b中从0-2（**<font color='blue'>共3个</font>**）的元素赋值给a，a的类型为int型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b, b + <span class="number">7</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>  从数组中获得初值</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><a href="https://blog.csdn.net/weixin_41743247/article/details/90635931?ops_request_misc=%7B%22request_id%22:%22167064353616800184186226%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167064353616800184186226&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90635931-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=vector&spm=1018.2226.3001.4187">C++_vector操作</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>   返回**<font color='red'>vector数组大小</font><strong>，类型</strong>unsigned int**</p></blockquote><p>:taco: 如果v.size()&#x3D;&#x3D;1，则v.size()-3为正数，必须int(a.size()) - 3才行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(n)</span><br></pre></td></tr></table></figure><blockquote><p>  将向量 v的 <strong><font color='red'>元素个数调整为n个</font><strong>，</strong><font color='blue'>多则删，少则补（其值为0）</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(n,x)</span><br></pre></td></tr></table></figure><blockquote><p>  将向量 v 的**<font color='red'>元素个数调整为n个</font><strong>，</strong><font color='blue'>多则删，少则补（其值为x）</font>**</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  <strong><font color='red'>清空</font><strong>向量</strong>v</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">front</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  返回v的<font color='red'><strong>第一个元素</strong></font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  返回v的<font color='red'><strong>最后一个元素</strong></font>，不检查这个数据是否存在</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  检测 vector 是否为空：&#x3D;&#x3D;<strong><font color='red'>返回 true 则空，返回 false 则非空</font></strong>&#x3D;&#x3D; 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>  将 <strong>x</strong> 添加到**<font color='red'>向量 v 最后</font>**（<code>v.size</code>会加1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><blockquote><p>  **<font color='red'>删除</font><strong>向量 v 的</strong><font color='red'>最后一个元素</font>**（<code>v.size</code>会减1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,elem)</span><br></pre></td></tr></table></figure><blockquote><p>  在pos位置插入一个elem拷贝，传回新数据位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,n,elem)</span><br></pre></td></tr></table></figure><blockquote><p>  在pos位置插入n个elem数据,无返回值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>  在pos位置插入在[beg,end)区间的数据。无返回值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(pos);</span><br></pre></td></tr></table></figure><blockquote><p>  删除pos位置的数据，传回下一个数据的位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>  删除[beg,end)区间的数据，传回下一个数据的位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>  将(beg; end)区间中的数据赋值给c</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(n,elem)</span><br></pre></td></tr></table></figure><blockquote><p>  将n个elem的拷贝赋值给c</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.at(idx)</span><br></pre></td></tr></table></figure><blockquote><p>  传回索引idx所指的数据，如果idx越界，抛出out_of_range。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.capacity()</span><br></pre></td></tr></table></figure><blockquote><p>  返回容器中数据个数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.max_size()</span><br></pre></td></tr></table></figure><blockquote><p>  返回容器中最大数据的数量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1.<span class="built_in">swap</span>(v2)</span><br></pre></td></tr></table></figure><blockquote><p>  将vector:v1中的元素和vector:v2中的元素**<font color='red'>整体交换</font>**</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除v[2]元素（即数字3）</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After erasing v[2]: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除v[2]、v[3]、v[4]元素（即数字4、5、6）</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">begin</span>() + <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After erasing range from v[2] to v[4]: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用assign函数重新赋值</span></span><br><span class="line">    v.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">100</span>); <span class="comment">// 创建一个大小为5的vector，所有元素值为100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After using assign to set 5 elements to 100: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用at函数访问元素</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idxElement = v.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; idxElement &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> out_of_range &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Out of range error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中数据的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of the vector: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中最大数据的数量（通常与size()相同）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max size of the vector: &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义另一个vector并与当前vector交换</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">swap</span>(v2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">After erasing v[2]: 1 2 4 5 6 7 8 9 10 </span><br><span class="line">After erasing range from v[2] to v[4]: 1 2 7 8 9 10</span><br><span class="line">After using assign to set 5 elements to 100: 100 100 100 100 100</span><br><span class="line">Element at index 2: 100</span><br><span class="line">Size of the vector: 5</span><br><span class="line">Max size of the vector: 4611686018427387903</span><br><span class="line">Before swap:</span><br><span class="line">v1: 100 100 100 100 100</span><br><span class="line">v2: 11 12 13 14 15</span><br><span class="line">After swap:</span><br><span class="line">v1: 11 12 13 14 15</span><br><span class="line">v2: 100 100 100 100 100</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义的时候不指定vector的大小</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">// 这个时候size是0 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        a.<span class="built_in">push_back</span>(i); <span class="comment">//在vector a的末尾添加一个元素i </span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 此时会发现a的size变成了10 </span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">15</span>)</span></span>; <span class="comment">//定义的时候指定vector的大小，默认b里面元素都是0</span></span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) </span><br><span class="line">        b[i]= <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) </span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>)</span></span>; <span class="comment">//定义的时候指定vector的大小并把所有的元素赋一个指定的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i++) </span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); it++) <span class="comment">//使用迭代器的方式访问vector </span></span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//vector相等判断与赋值    </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec2;</span><br><span class="line"><span class="keyword">if</span> (vec1 == vec2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec1与vec2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">vec2 = vec1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值后&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (vec1 == vec2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec1与vec2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">赋值后</span><br><span class="line">vec1与vec2相等</span><br></pre></td></tr></table></figure></li><li><p>vector的赋值会把<strong>一个vector的所有元素</strong>赋值到<strong>另一个vector中</strong>，并<font color='red'><strong>替代所有元素</strong></font>；</p></li><li><p>而vector的相等也是需要**逐个元素<font color='red'>依次比较</font><strong>并</strong><font color='blue'>全部相等</font>**才算相等。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  ..........</span><br><span class="line">  v.<span class="built_in">pop_back</span>();</span><br><span class="line">  ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>v.pop_back()</code>之前要<code>v.empty()</code></p></li><li><p>&#96;&#96;v.pop_back();<code>无返回值，**&lt;font color=&#39;blue&#39;&gt;仅删除&lt;/font&gt;**向量 v 的最后一个元素；要**&lt;font color=&#39;gree&#39;&gt;获得&lt;/font&gt;**&lt;font color=&#39;red&#39;&gt;**向量 v 的最后一个元素**&lt;/font&gt;需要</code>v.back()&#96;</p></li></ul><h1 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h1><h2 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;ElementType&gt; q;</span><br></pre></td></tr></table></figure><blockquote><p>  这里的ElementType可以是<strong>任意类型</strong>，例如 int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。 </p></blockquote><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  返回**<font color='red'>队列大小</font>**</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  将 x <strong><font color='red'>插入队尾</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">front</span>()</span><br><span class="line">q.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  分别返回**<font color='red'>队首元素</font>**和<font color='red'><strong>队尾元素</strong></font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  令队首元素<strong>出队</strong>，<font color='blue'><strong>删除</strong></font>队首元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  检测 queue 是否为空：&#x3D;&#x3D;<strong><font color='red'>返回 true 则空，返回 false 则非空</font></strong>&#x3D;&#x3D; </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  返回 queue 中<font color='red'><strong>元素个数</strong></font></p></blockquote><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 0</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, q.<span class="built_in">front</span>(),q.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>q.pop()</code>无返回值，仅删除队首元素。要**<font color='gree'>获得</font>**<font color='red'><strong>队首元素</strong></font><strong>还需<code>q.front()</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()==<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EMPTY! \n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NOT EMPTY! \n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EMPTY! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NOT EMPTY! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EMPTY!</span><br><span class="line">NOT EMPTY!</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li><li><p>注意： 使用 <code>q.front()</code>和 <code>q.pop()</code>函数前，必须用 <code>q.empty()</code>判断队列&#x3D;&#x3D;<strong>是否为空</strong>&#x3D;&#x3D;，否则可能因为<strong>队空</strong>而出现错误</p></li></ul><h1 id="双端队列deque"><a href="#双端队列deque" class="headerlink" title="双端队列deque"></a>双端队列deque</h1><h2 id="头文件-2"><a href="#头文件-2" class="headerlink" title="头文件"></a><strong>头文件</strong></h2><p><code>#include &lt;deque&gt;</code></p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;ElementType&gt; q;</span><br></pre></td></tr></table></figure><blockquote><p>  这里的ElementType可以是<strong>任意类型</strong>，例如 int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。 </p></blockquote><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在头部加入数据0</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">11</span>); <span class="comment">// 在尾部加入数据11</span></span><br><span class="line">a.<span class="built_in">pop_front</span>();   <span class="comment">// 在头部删除数据</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();    <span class="comment">// 在尾部删除数据</span></span><br><span class="line">a.<span class="built_in">resize</span>(num);   <span class="comment">// 重新指定队列的长度</span></span><br><span class="line">a.<span class="built_in">size</span>()         <span class="comment">// 返回容器中实际数据个数</span></span><br><span class="line">a.<span class="built_in">max_size</span>()     <span class="comment">// 返回容器中最大数据的数量</span></span><br></pre></td></tr></table></figure><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//创建一个有10个元素双端队列a,初始值都为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给deque赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出deque中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头尾加入新数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在头部加入数据0：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在尾部加入数据11：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头尾删除数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在头部删除数据: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在尾部删除数据: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回容器中实际数据个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新指定队列的长度</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回容器中最大数据的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.max_size() = &quot;</span> &lt;&lt; a.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入&amp;&amp;输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">在头部加入数据0：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">在尾部加入数据11：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">在头部删除数据:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">在尾部删除数据:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">a.size() = 10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 0</span><br><span class="line">a.empty() = 0</span><br><span class="line">a.max_size() = 4611686018427387903</span><br></pre></td></tr></table></figure><h1 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h1><h2 id="头文件-3"><a href="#头文件-3" class="headerlink" title="头文件"></a>头文件</h2><p><strong><code>#include &lt;stack&gt;</code></strong></p><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;ElementType&gt; s;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>ElementType</code>可以是<strong>任意类型</strong>，例如 int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。 </p></blockquote><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">push</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  将 x <strong><font color='red'>压入栈顶</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  返回**<font color='red'>栈顶元素</font>**</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  令**<font color='red'>栈顶元素</font>出栈**，<font color='blue'><strong>删除</strong></font>栈顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  检测 stack 是否为空：&#x3D;&#x3D;<strong><font color='red'>返回 true 则空，返回 false 则非空</font></strong>&#x3D;&#x3D;</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>  返回 stack 中的<font color='red'><strong>元素个数</strong></font></p></blockquote><h2 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 0</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, q.<span class="built_in">front</span>(),q.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sailboat:<code>s.pop()</code>无返回值，仅删除栈顶元素。要**<font color='blue'>获得</font>**<font color='red'><strong>栈顶元素</strong></font>还需<code>s.top()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;  q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.size &quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.top &quot;</span>&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;   <span class="comment">//输出栈顶元素 </span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//删除栈顶元素</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.size &quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;  </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.top &quot;</span>&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q.size 5</span><br><span class="line">q.top 5</span><br><span class="line">q.size 4</span><br><span class="line">q.top 4</span><br></pre></td></tr></table></figure></li></ul><p>:tea:使用 **<code>s.top()</code>**和 **<code>s.pop()</code>**函数前，必须用 <strong><code>s.empty()</code><strong>判断队列&#x3D;&#x3D;<strong>是否为空</strong>&#x3D;&#x3D;，否则可能因为</strong>队空</strong>而出现错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用list或vector作为栈的容器，默认是使用deque的。</span></span><br><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; a;</span><br><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.<span class="built_in">top</span>()); <span class="comment">// 取栈项数据</span></span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">3</span>);              <span class="comment">// 将3这个元素入栈a</span></span><br><span class="line">b.<span class="built_in">push</span>(<span class="number">2</span>);              <span class="comment">// 将2这个元素入栈b</span></span><br><span class="line">a.<span class="built_in">pop</span>();                <span class="comment">// 将栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//  判断栈是否为空</span></span><br></pre></td></tr></table></figure><h1 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h1><h2 id="头文件-4"><a href="#头文件-4" class="headerlink" title="头文件"></a>头文件</h2><p><strong><code>#include &lt;string&gt;</code></strong></p><blockquote><p>头文件不写也可以</p></blockquote><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br></pre></td></tr></table></figure><blockquote><p>  生成<strong>空字符串</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 法1 */</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="comment">/* 法2 */</span></span><br><span class="line">string s = str;</span><br></pre></td></tr></table></figure><blockquote><p>  将字符串str的内容复制给s；               </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, i, len)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>  将字符串str中从<strong>下标i开始</strong>、<strong>长度为len</strong>的部分作为字符串初值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, i)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>将字符串str中从<strong>下标i开始</strong>到<strong>字符串结束</strong>的部分作为字符串初值</li></ul></blockquote><blockquote><ul><li>这里的cstr是<strong>字符串变量</strong>，eg：<code>string s(str,3);</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cstr, len)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>以<strong>C_string类型</strong>cstr的<strong>前len个字符</strong>作为字符串s的初值</li><li>这里的&#x3D;&#x3D;C_string类型是<strong>字符串常量</strong>类型&#x3D;&#x3D;，eg：<code>string s(&quot;abcde&quot;,3);</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(num ,c)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>  生成<font color='red'><strong>num个 c 字符</strong></font>的字符串，c为char类型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;               <span class="comment">//生成空字符串</span></span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;  <span class="comment">//生成&quot;1234456789&quot;的复制品</span></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;0123456&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为&quot;01234&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;       <span class="comment">//结果为&quot;11111&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为&quot;3456789&quot;</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str2:&quot;</span>&lt;&lt;str2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str3:&quot;</span>&lt;&lt;str3&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str4:&quot;</span>&lt;&lt;str4&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str5:&quot;</span>&lt;&lt;str5&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str6:&quot;</span>&lt;&lt;str6&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121323094.png" alt="这里写图片描述"></p><h2 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line">s.<span class="built_in">length</span>();</span><br><span class="line">s.<span class="built_in">max_size</span>();</span><br><span class="line">s.<span class="built_in">capacity</span>();</span><br></pre></td></tr></table></figure><ul><li><p><code>s.size()</code>和<code>s.length()</code>：返回字符串s的<strong>长度</strong>。</p></li><li><p><code>s.max_size()</code>：返回string对象最多包含的字符数，超出编译器会抛出length_error异常</p></li><li><p><code>s.capacity()</code>：返回当前string类在<strong>不重新分配内存</strong>的情况下，能存多少字符（即当前内存支持多少）。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;1234567&quot;</span>)</span></span>;<span class="comment">//string s=&quot;1234567&quot;;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;length=&quot;</span> &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_size=&quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121323095.png" alt="这里写图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">compare</span>()</span><br></pre></td></tr></table></figure><ul><li>C ++字符串支持<strong>比较</strong>操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。</li></ul><blockquote><blockquote><p>  string比较的原则是从左往右，按&#x3D;&#x3D;<strong>字典序</strong>&#x3D;&#x3D;，<strong>逐个字符</strong>比较，直到不同</p></blockquote></blockquote><ul><li><p><code>s.compare()</code>支持多参数处理，支持用索引值和长度定位子串来进行比较，他返回一个整数来表示比较结果：</p><ul><li><p><strong>0：相等</strong></p></li><li><p><strong>1：大于</strong></p></li><li><p><strong>-1：小于</strong></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (A的ASCII码是65，a的ASCII码是97)</span></span><br><span class="line">    <span class="comment">// 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0</span></span><br><span class="line">    <span class="function">string <span class="title">A</span><span class="params">(<span class="string">&quot;aBcd&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">B</span><span class="params">(<span class="string">&quot;Abcd&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">C</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">D</span><span class="params">(<span class="string">&quot;123dfg&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;aBcd&quot; 和 &quot;Abcd&quot;比较------ a &gt; A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(B)：&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(B)&lt;&lt; endl;                          <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;cd&quot; 和 &quot;Abcd&quot;比较------- c &gt; A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B):&quot;</span> &lt;&lt;A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B)&lt;&lt; endl;                <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;cd&quot; 和 &quot;cd&quot;比较 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B, 2, 3):&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由结果看出来：0表示下标，3表示长度</span></span><br><span class="line">    <span class="comment">// &quot;123&quot; 和 &quot;123&quot;比较 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C.compare(0, 3, D, 0, 3)&quot;</span> &lt;&lt;C.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, D, <span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl;    <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h2><p>:sweat_drops: c语言里没有**<code>string</code><strong>型的，</strong><code>string</code><strong>在c++里面。但有时候在c++里要用</strong><code>scanf()</code>** 和 **<code>printf()</code><strong>输入输出</strong><code>string</code>**型字符串，此时可以使用 <strong>string</strong> 的成员函数 <strong><code>s.c_str()</code></strong> ，该函数返回字符串的首字符的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s[<span class="number">0</span>]); <span class="comment">//不能用&amp;s</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h1><p>​map提供了“[]”运算符，使得map可以像数组一样使用，所以map也称为“关联数组”，map就是从键（key）到值（value）的映射。例如可以用一个<code>map&lt;string, int&gt; month_name </code>来表示“月份名字到月份编号”的映射，然后用<code>month_name[“July”] = 7 </code>这样的方式来赋值</p><h2 id="头文件-5"><a href="#头文件-5" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;map&gt;</code></p><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;ElementType, ElementType&gt; m;</span><br></pre></td></tr></table></figure><blockquote><p>  这里的ElementType可以是<strong>任意类型</strong>，例如 int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等</p></blockquote><h2 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h2><p><a href="https://blog.csdn.net/sevenjoin/article/details/81943864?ops_request_misc=%7B%22request_id%22:%22169708750416800215061817%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169708750416800215061817&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81943864-null-null.142%5Ev96%5Epc_search_result_base3&utm_term=map&spm=1018.2226.3001.4187">C++ map用法总结</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">begin</span>()         <span class="comment">// 返回指向map头部的迭代器</span></span><br><span class="line">m.<span class="built_in">clear</span>()         <span class="comment">// 删除所有元素</span></span><br><span class="line">m.<span class="built_in">count</span>(elem)     <span class="comment">// 返回指定元素出现的次数</span></span><br><span class="line">m.<span class="built_in">empty</span>()         <span class="comment">// 如果map为空则返回true</span></span><br><span class="line">m.<span class="built_in">end</span>()           <span class="comment">// 返回指向map末尾的迭代器</span></span><br><span class="line">m.<span class="built_in">equal_range</span>()   <span class="comment">// 返回特殊条目的迭代器对</span></span><br><span class="line">m.<span class="built_in">erase</span>()         <span class="comment">// 删除一个元素</span></span><br><span class="line">m.<span class="built_in">find</span>()          <span class="comment">// 查找一个元素</span></span><br><span class="line">m.<span class="built_in">get_allocator</span>() <span class="comment">// 返回map的配置器</span></span><br><span class="line">m.<span class="built_in">insert</span>()        <span class="comment">// 插入元素</span></span><br><span class="line">m.<span class="built_in">key_comp</span>()      <span class="comment">// 返回比较元素key的函数</span></span><br><span class="line">m.<span class="built_in">lower_bound</span>()   <span class="comment">// 返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line">m.<span class="built_in">max_size</span>()      <span class="comment">// 返回可以容纳的最大元素个数</span></span><br><span class="line">m.<span class="built_in">rbegin</span>()        <span class="comment">// 返回一个指向map尾部的逆向迭代器</span></span><br><span class="line">m.<span class="built_in">rend</span>()          <span class="comment">// 返回一个指向map头部的逆向迭代器</span></span><br><span class="line">m.<span class="built_in">size</span>()          <span class="comment">// 返回map中元素的个数</span></span><br><span class="line">m.<span class="built_in">swap</span>()          <span class="comment">// 交换两个map</span></span><br><span class="line">m.<span class="built_in">upper_bound</span>()   <span class="comment">// 返回键值&gt;给定元素的第一个位置</span></span><br><span class="line">m.<span class="built_in">value_comp</span>()    <span class="comment">// 返回比较元素value的函数</span></span><br></pre></td></tr></table></figure><h2 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h2><ul><li><p>例题:反片语<br>输入一些单词，找出所有满足如下条件的单词:该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输入时应保留输入中的大小写，按字典序进行排列(所有大写字母在小写字母的前面)</p></li><li><p>样例输入:<br>ladder came tape soon leader acme RIDE lone Dreis peat ScAlE orb eye Rides dealer NotE derail LaCeS drled noel dire Disk mace Rob dries #</p></li><li><p>样例输出:<br>Disk<br>NotE<br>derail<br>drled<br>eye<br>ladder</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mapp;</span><br><span class="line">vector&lt;string&gt; words;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将单词s标准化</span></span><br><span class="line"><span class="function">string <span class="title">standard</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">length</span>(); i++)</span><br><span class="line">        t[i] = <span class="built_in">tolower</span>(t[i]);</span><br><span class="line">    <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        words.<span class="built_in">push_back</span>(s);</span><br><span class="line">        string r = <span class="built_in">standard</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (!mapp.<span class="built_in">count</span>(r))</span><br><span class="line">            mapp[r] = <span class="number">0</span>;</span><br><span class="line">        mapp[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapp[<span class="built_in">standard</span>(words[i])] == <span class="number">1</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h1><h2 id="头文件-6"><a href="#头文件-6" class="headerlink" title="头文件"></a>头文件</h2><p><code>#include &lt;set&gt;</code></p><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;ElementType&gt; s;</span><br></pre></td></tr></table></figure><blockquote><p>  这里的ElementType可以是<strong>任意类型</strong>，例如 int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等</p></blockquote><h2 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">begin</span>()         <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">clear</span>()         <span class="comment">// 清除所有元素</span></span><br><span class="line">s.<span class="built_in">count</span>()         <span class="comment">// 返回某个值元素的个数</span></span><br><span class="line">s.<span class="built_in">empty</span>()         <span class="comment">// 如果集合为空，返回true(真）</span></span><br><span class="line">s.<span class="built_in">end</span>()           <span class="comment">// 返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line">s.<span class="built_in">equal_range</span>()   <span class="comment">// 返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line">s.<span class="built_in">erase</span>()         <span class="comment">// 删除集合中的元素</span></span><br><span class="line">s.<span class="built_in">find</span>()          <span class="comment">// 返回一个指向被查找到元素的迭代器</span></span><br><span class="line">s.<span class="built_in">get_allocator</span>() <span class="comment">// 返回集合的分配器</span></span><br><span class="line">s.<span class="built_in">insert</span>()        <span class="comment">// 在集合中插入元素</span></span><br><span class="line">s.<span class="built_in">lower_bound</span>()   <span class="comment">// 返回指向大于（或等于）某值的第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">key_comp</span>()      <span class="comment">// 返回一个用于元素间值比较的函数</span></span><br><span class="line">s.<span class="built_in">max_size</span>()      <span class="comment">// 返回集合能容纳的元素的最大限值</span></span><br><span class="line">s.<span class="built_in">rbegin</span>()        <span class="comment">// 返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">s.<span class="built_in">rend</span>()          <span class="comment">// 返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">s.<span class="built_in">size</span>()          <span class="comment">// 集合中元素的数目</span></span><br><span class="line">s.<span class="built_in">swap</span>()          <span class="comment">// 交换两个集合变量</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>()   <span class="comment">// 返回大于某个值元素的迭代器</span></span><br><span class="line">s.<span class="built_in">value_comp</span>()    <span class="comment">// 返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure><h2 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s; <span class="comment">// 创建一个空的整数集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of set: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查集合是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is set empty? &quot;</span> &lt;&lt; (s.<span class="built_in">empty</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向最后一个元素之后的迭代器</span></span><br><span class="line">    it = s.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 注意：这里不能通过*it来访问元素，因为it现在指向的是最后一个元素之后的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;One past the last element: &quot;</span> &lt;&lt; *<span class="built_in">prev</span>(it) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    it = s.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found element 10&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element 10 not found&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查集合是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is set empty after clear? &quot;</span> &lt;&lt; (s.<span class="built_in">empty</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用insert插入多个元素</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入重复元素，set会忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count of element 10: &quot;</span> &lt;&lt; s.<span class="built_in">count</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 总是返回1，因为set中不会有重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::reverse_iterator rit = s.<span class="built_in">rbegin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Last element (reverse): &quot;</span> &lt;&lt; *rit &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">    rit = s.<span class="built_in">rend</span>();</span><br><span class="line">    <span class="comment">// 注意：这里不能通过*rit来访问元素，因为rit现在指向的是第一个元素之前的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before the first element (reverse): &quot;</span> &lt;&lt; *<span class="built_in">prev</span>(rit) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个集合变量（这里只有一个集合，所以无法演示交换）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合的上界和下界</span></span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator&gt; bounds = s.<span class="built_in">equal_range</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lower bound of 5: &quot;</span> &lt;&lt; *bounds.first &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Upper bound of 5: &quot;</span> &lt;&lt; *bounds.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合的分配器</span></span><br><span class="line">    allocator&lt;<span class="type">int</span>&gt; alloc = s.<span class="built_in">get_allocator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取比较键的函数对象</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::key_compare keyComp = s.<span class="built_in">key_comp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取比较值的函数对象</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::value_compare valueComp = s.<span class="built_in">value_comp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合能容纳的最大元素数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max size of set: &quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Size of set: 4</span><br><span class="line">Is set empty? false</span><br><span class="line">First element: 5</span><br><span class="line">One past the last element: 20</span><br><span class="line">Found element 10</span><br><span class="line">Is set empty after clear? true</span><br><span class="line">Count of element 10: 1</span><br><span class="line">Last element (reverse): 5</span><br><span class="line">Before the first element (reverse): 5</span><br><span class="line">Lower bound of 5: 5</span><br><span class="line">Upper bound of 5: 1</span><br><span class="line">Max size of set: 461168601842738790</span><br></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>遍历**<font color='blue'>容器</font><strong><code>vector</code>、<code>set</code>、<code>map</code>要使用</strong><font color='red'>迭代器&#x2F;反向迭代器</font>**访问</p><ul><li><p><strong><code>c.begin()</code><strong>是一个指针，指向容器的</strong><font color='purple'>第一个元素</font></strong></p></li><li><p><strong><code>c.end()</code><strong>是一个指针，指向容器&#x3D;&#x3D;</strong><font color='red'>最后一个元素的后一个位置</font></strong>&#x3D;&#x3D;</p></li><li><p>**<code>c.rbegin()</code>**是一个指针，指向容器的<font color='purple'><strong>最后一个元素</strong></font></p></li><li><p>**<code>c.rend()</code>**是一个指针，指向容器的&#x3D;&#x3D;<font color='red'><strong>第一个元素的前一个位置</strong></font>&#x3D;&#x3D;</p></li></ul><p>所以**<font color='blue'>迭代器指针it</font>**的for循环判断条 件是 <strong><code>it != c.end()</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); it++)  <span class="comment">// 使用迭代器的方式访问vector </span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">rbegin</span>(); it != c.<span class="built_in">rend</span>(); it--)  <span class="comment">// 使用反向迭代器的方式访问vector </span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402212219367.jpg" alt="e5b86169c82b93bbe409229eb505976"></p><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用符号&amp;</title>
      <link href="/2023/10/12/%E5%BC%95%E7%94%A8%E7%AC%A6%E5%8F%B7&amp;/"/>
      <url>/2023/10/12/%E5%BC%95%E7%94%A8%E7%AC%A6%E5%8F%B7&amp;/</url>
      
        <content type="html"><![CDATA[<h1 id="引用符号"><a href="#引用符号" class="headerlink" title="引用符号&amp;"></a>引用符号&amp;</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++里面的引用时在变量名之前加一个<code>&amp;</code>符号，比如在函数传入的参数中<code>int &amp;a</code>,那么对这个引用变量<code>a</code>做的所以操作都是直接对传入的原变量进行操作，并没有像原来<code>int a</code>一样只是拷贝一个副本（传值）</p><span id="more"></span><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//传入的是n的引用，相当于直接对n进行了操作,只不过在func函数中换了个名字叫a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(n);<span class="comment">//n由0变成了99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//传入的是0这个值，并不会改变main函数中n的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(n);<span class="comment">//并不会改变n的值，n还是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello 算法</title>
      <link href="/2023/10/03/hello%20%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/03/hello%20%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;<a href="https://www.hello-algo.com/">Hello 算法 (hello-algo.com)</a>&#x3D;&#x3D;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【318家国家5A级风景区】</title>
      <link href="/2023/10/03/5A%E6%99%AF%E5%8C%BA/"/>
      <url>/2023/10/03/5A%E6%99%AF%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939877.jpeg" alt="img"></p><span id="more"></span><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030949257.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939648.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939378.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939756.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940425.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940146.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940323.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940140.jpeg" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030950797.jpeg" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【排序】</title>
      <link href="/2023/09/29/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91/"/>
      <url>/2023/09/29/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序<img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900163.png" alt="img"></h1><span id="more"></span><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p> <code>void XSort ( ElementType A[], int N )</code></p><ul><li>为简单起见，讨论**<font color='red'>从小大的整数</font>**排序</li><li>只讨论基于比较的排序（&gt; &#x3D; &lt; 有定义）</li><li>&#x3D;&#x3D;<strong>没有一种排序是任何情况下都表现最好的</strong>&#x3D;&#x3D;</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290857254.png" alt="image-20230929085748167"></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900164.png" alt="image-20221021191151215"></p><blockquote><p>注：</p><ol><li>直接插入排序是从**<font color='red'>第二个元素</font>**开始的</li><li>直接插入排序**<code>L</code><strong>趟后，前</strong><code>L+1</code><strong>个元素是</strong><font color='blue'>有序的</font>**。</li><li>总共需要&#x3D;&#x3D;<strong><font color='blue'>n-1</font></strong>&#x3D;&#x3D;趟排序</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ElementType t = A[i];<span class="type">int</span> j=i<span class="number">-1</span>;<span class="comment">//t为待插入元素</span></span><br><span class="line"><span class="comment">//寻找待插入元素的位置，同时移动元素</span></span><br><span class="line"><span class="keyword">while</span>( A[j] &gt; t &amp;&amp; j &gt;= <span class="number">0</span> )<span class="comment">//必须是t&lt;a[j]，不能是a[i]&lt;a[j] </span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">A[j+<span class="number">1</span>] = t;<span class="comment">//j+1即为待插入的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong><code>while( a[j] &gt; t &amp;&amp; j &gt;= 0 )</code><strong>决定了该算法是</strong><font color='red'>稳定的排序算法</font></strong></li><li>移动位置时**<font color='blue'>从后往前</font>**移动</li></ol></blockquote><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900165.png" alt="image-20221021194038472" style="zoom:70%;" /><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900166.png" alt="image-20221021194054276"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900167.png" alt="image-20221021194336606"></p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900168.png" alt="image-20221021194551088"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900169.png" alt="image-20221208164824621"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(ElementType A[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == t)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; t)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModInsertSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = A[i];</span><br><span class="line">        <span class="comment">// 折半插入排序采用--折半查找</span></span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">BinarySearch</span>(A, <span class="number">0</span>, i - <span class="number">1</span>, t);</span><br><span class="line">        <span class="comment">// 从后往前移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= k; j--)</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        A[k] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：折半插入排序采用–折半查找，查找效率提高，但**<font color='blue'>元素移动次数不变</font><strong>（</strong><font color='blue'>元素比较次数减少</font><strong>），仅仅将</strong><font color='red'>分散移动</font><strong>改为</strong><font color='red'>集体移动</font>**     </p></blockquote><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="思想：缩小增量排序"><a href="#思想：缩小增量排序" class="headerlink" title="思想：缩小增量排序"></a>思想：缩小增量排序</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900170.png" alt="image-20221208165741872"></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900171.png" alt="image-20221208183557556"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=gap; i&lt;n; i++) <span class="comment">//插入排序,从第二个元素开始,对所有组进行</span></span><br><span class="line">        &#123;</span><br><span class="line">            ElementType t=A[i];<span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; t &lt; A[j]; j -= gap) <span class="comment">//从后往前移动</span></span><br><span class="line">                A[j+gap]=A[j];</span><br><span class="line">            A[j+gap]=t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>冒泡排序一趟后，<font color='red'><strong>最大元素沉底</strong></font>且<strong>位于最终位置</strong></li><li>总共需要**<font color='blue'>n-1</font>**趟</li></ul><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>冒泡法排序：（数字&#x2F;字符） </p><ol><li>相邻两个元素作比较，大的元素放在后面，</li><li>对n个数进行排序<font color='blue'><strong>需n-1次排序</strong></font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) <span class="comment">//n-1次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j=<span class="number">0</span>; j&lt;n-i; j++)</span><br><span class="line"><span class="keyword">if</span>( A[j] &gt; A[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=A[j];A[j]=A[j+<span class="number">1</span>];A[j+<span class="number">1</span>]=t;<span class="comment">// swap(A[j],A[j+1]);</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若某一趟排序中没有元素交换,则说明所有元素已经有序，不需要再排序</span></span><br><span class="line"><span class="keyword">if</span> (flag)<span class="keyword">return</span>;<span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="法一（推荐）"><a href="#法一（推荐）" class="headerlink" title="法一（推荐）"></a>法一（推荐）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Median3</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (A[left] &gt; A[mid])</span><br><span class="line">        <span class="built_in">swap</span>(A[left], A[mid]);</span><br><span class="line">    <span class="keyword">if</span> (A[left] &gt; A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[left], A[right]);</span><br><span class="line">    <span class="keyword">if</span> (A[mid] &gt; A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[mid], A[right]);</span><br><span class="line">    <span class="built_in">swap</span>(A[mid], A[left]); <span class="comment">// 把中值放在数组的首位，便于取主元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Median3</span>(A, left, right);</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//必须是先right再left</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt;= A[k])</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= A[k])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="built_in">swap</span>(A[left], A[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(A[k], A[right]); <span class="comment">// swap(A[k], A[left]);也可以</span></span><br><span class="line">    <span class="keyword">return</span> right;<span class="comment">// return left;也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(A, left, right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, left, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(A, <span class="number">0</span>, n<span class="number">-1</span>);<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Median3</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[left] &gt; A[mid])</span><br><span class="line">        <span class="built_in">swap</span>(A[left],A[mid]);</span><br><span class="line">    <span class="keyword">if</span>(A[left]&gt;A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[left],A[right]);</span><br><span class="line">    <span class="keyword">if</span>(A[mid]&gt;A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[mid],A[right]);    </span><br><span class="line">    <span class="built_in">swap</span>(A[mid],A[left]);<span class="comment">//把中值放在数组的首位，便于取主元</span></span><br><span class="line">    <span class="keyword">return</span> A[left];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">Median3</span>(A,left,right);</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; A[right]&gt;=t)</span><br><span class="line">            right--;</span><br><span class="line">        A[left]=A[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; A[left]&lt;=t)</span><br><span class="line">          left++;</span><br><span class="line">        A[right]=A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left]=t;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot=<span class="built_in">partition</span>(A,left,right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,left,pivot<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(A, <span class="number">0</span>, n<span class="number">-1</span>);<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="type">int</span> min=i;<span class="comment">//min是用来记录a[i]后面最小元素的下标</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line"><span class="keyword">if</span>(A[j]&lt;A[min])</span><br><span class="line">min=j;</span><br><span class="line"><span class="keyword">if</span>(min!=i)</span><br><span class="line"><span class="built_in">swap</span>(A[i],A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li><h3 id="以大根堆为例"><a href="#以大根堆为例" class="headerlink" title="以大根堆为例"></a>以<font color='purple'>大根堆</font>为例</h3></li></ul><blockquote><p>堆排序**<code>ElementType A[]</code>从<code>A[1]</code><font color='red'>开始存储</font><strong>，</strong><font color='blue'>A[0]充当哨兵</font>**</p><ul><li><p><strong><font color='red'>A[1]到A[n]</font><strong>存储</strong><font color='cyan'>待排元素</font></strong></p></li><li><p>此时堆满足：</p></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900172.png" alt="image-20221208224655254"></p></blockquote><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><ol><li>构造初始堆：将给定的无序序列构造成**<font color='red'>大根堆</font>**：A[1] 、A[2]……..A[n]；</li><li>将堆顶元素A[1]与末尾元素进行交换，使末尾元素最大；</li><li>然后再将A[ ]调整为最大堆，重复步骤2，反复调整、交换、调整，直到整个序列有序</li></ol><h3 id="筛选算法"><a href="#筛选算法" class="headerlink" title="筛选算法"></a>筛选算法</h3><h4 id="上滤"><a href="#上滤" class="headerlink" title="上滤"></a>上滤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s]=A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h4 id="下滤"><a href="#下滤" class="headerlink" title="下滤"></a>下滤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])<span class="comment">//i&lt;n说明A[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= A[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s]=A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><hr><hr><hr><blockquote><p>从**<font color='red'>最后一个非终端结点</font>**开始建堆；</p><ul><li>n个结点 ,最后一个非终端结点的下标是 <img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900173.png" alt="image-20221208235618668"></li><li>归并排序采用**<font color='blue'>下滤筛选</font>**算法</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调整为初始堆</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=n; i&gt;<span class="number">1</span>; i--)  <span class="comment">//i表示当前最大堆的末尾元素，也是当前堆的大小</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//堆顶元素A[1]与末尾元素A[i]交换，使最大元素沉底        </span></span><br><span class="line">        ElementType t=A[i];A[i]=A[<span class="number">1</span>];A[<span class="number">1</span>]=t;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,i<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900174.png" alt="image-20221209083227737"></p><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900175.png" alt="image-20221209083336292"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900176.jpg" alt="微信图片_20221209083037"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElementType A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType B[n]; <span class="comment">// 构造辅助数组B,n为A数组大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">        B[i] = A[i]; <span class="comment">// 复制A中元素到B中</span></span><br><span class="line">    <span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = low;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j])</span><br><span class="line">            A[k++] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有剩余元素，则一一复制到数组A中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElementType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(A, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(A, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MergeSort</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900177.png" alt="image-20221209090502894"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900178.png" alt="image-20221209090418302"></p><h3 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900179.png" alt="image-20221209091734211"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Radix</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(ElementType A[],<span class="type">int</span> figure,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;Q[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> pass=<span class="number">1</span>; pass&lt;=figure; pass++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900180.png" alt="img"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900181.jpg" alt="13315216532604079"></p><blockquote><ul><li>不稳定排序：**<font color='red'>选择排序，希尔排序，快速排序，堆排序</font>**</li></ul></blockquote><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900182.png" alt="image-20221111123448323"></p><h3 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900183.png" alt="image-20221111123540642"></p><h3 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900184.png" alt="image-20221111123621514"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(ElementType A[i],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=n, h=<span class="number">1</span>;<span class="comment">//h代表颜色</span></span><br><span class="line">    <span class="keyword">while</span>(h&lt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( i&lt;j &amp;&amp; A[i].key==h )</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>( i&lt;j &amp;&amp; A[j].key!=h )</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;ElementType t=A[i];A[i]=A[j];A[j]=t;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j=n;h++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>此题采用了———**<font color='red'>快速排序</font>**的部分思想</p></blockquote><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900185.png" alt="image-20221211154954610"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="下滤筛选"><a href="#下滤筛选" class="headerlink" title="下滤筛选"></a>下滤筛选</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])<span class="comment">//i &lt; n 说明A[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= A[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h4 id="上滤筛选"><a href="#上滤筛选" class="headerlink" title="上滤筛选"></a>上滤筛选</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆调整-1"><a href="#堆调整-1" class="headerlink" title="堆调整"></a>堆调整</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>上滤</font>：用于<font color='blue'>向堆中插入一个元素</font></strong></p></blockquote><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ul><li>&#x3D;&#x3D;<strong><font color='red'>上滤算法</font></strong>  +  <strong><font color='red'>调整算法</font></strong>&#x3D;&#x3D;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h1 id="重点参考"><a href="#重点参考" class="headerlink" title="重点参考"></a>重点参考</h1></li></ul><p><a href="https://blog.csdn.net/weixin_53011574/article/details/125964731?spm=1001.2014.3001.5506">(72条消息) 数据结构学习笔记（第八章 排序-内部排序）_低调$(生活)的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【对列】</title>
      <link href="/2023/09/28/%E3%80%90%E5%AF%B9%E5%88%97%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90%E5%AF%B9%E5%88%97%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一：循环队列"><a href="#一：循环队列" class="headerlink" title="一：循环队列"></a>一：循环队列</h1><p>循环队列的引入是为了克服&#x3D;&#x3D;<strong><font color='red'>“假上溢”现象</font></strong>&#x3D;&#x3D;。</p><h3 id="1、存储结构"><a href="#1、存储结构" class="headerlink" title="1、存储结构"></a>1、存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* base;</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>front和rear</font><strong>是头尾指针（相对于数组），front指向</strong>第一个元素</strong>，rear指向<strong>最后一个元素的&#x3D;&#x3D;<font color='blue'>下一个位置</font>&#x3D;&#x3D;</strong></p></blockquote><span id="more"></span><h3 id="2、初始化"><a href="#2、初始化" class="headerlink" title="2、初始化"></a>2、初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(Queue&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q.base = <span class="keyword">new</span> ElementType[MASQSIZE];<span class="comment">//开辟空间</span></span><br><span class="line"><span class="keyword">if</span> (!q.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">q.front = q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、入队"><a href="#3、入队" class="headerlink" title="3、入队"></a>3、入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; q, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((q.rear + <span class="number">1</span>) % MAXQSIZE == q.front)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队满</span></span><br><span class="line">q.base[q.rear] = e;</span><br><span class="line">q.rear = (q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、出队"><a href="#3、出队" class="headerlink" title="3、出队"></a>3、出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; q, ElementType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q.front == q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">e = q.base[q.front];</span><br><span class="line">q.front = (q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、队列长度"><a href="#4、队列长度" class="headerlink" title="4、队列长度"></a>4、队列长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q.rear - q.front + MAXQSIZE ) % MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、队满"><a href="#5、队满" class="headerlink" title="5、队满"></a>5、队满</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueFull</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q.rear + <span class="number">1</span> ) % MAXQSIZE == q.front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、链队列"><a href="#二、链队列" class="headerlink" title="二、链队列"></a>二、链队列</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119858.png" alt="image-20230928211711116"></p><blockquote><p><strong><font color='red'>链队</font><strong>带</strong><font color='blue'>头结点</font></strong></p></blockquote><h3 id="1、存储结构-1"><a href="#1、存储结构-1" class="headerlink" title="1、存储结构"></a>1、存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">Node* front;<span class="comment">//队头指针</span></span><br><span class="line">Node* rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h3 id="2、链队的初始化"><a href="#2、链队的初始化" class="headerlink" title="2、链队的初始化"></a>2、链队的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front = Q.rear = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、链队的入队"><a href="#3、链队的入队" class="headerlink" title="3、链队的入队"></a>3、链队的入队</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119834.png" alt="image-20230928211729867"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">p-&gt;data = x;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//头插法    </span></span><br><span class="line">Q.rear-&gt;next = p;</span><br><span class="line">Q.rear = p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、链队的出队"><a href="#4、链队的出队" class="headerlink" title="4、链队的出队"></a>4、链队的出队</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119867.png" alt="image-20230928211745037"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队列为空</span></span><br><span class="line">p = Q.front-&gt;next;<span class="comment">//p指向队头元素</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//e保存队头元素的值</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)<span class="comment">//如果最后一个元素被删，则队尾指针为空</span></span><br><span class="line">Q.rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放原队头元素的空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><pre><code>    如果队列Q中==**&lt;font color=&#39;red&#39;&gt;最后一个元素被删除&lt;/font&gt;**==了，则队列中没有元素了，- **`Q.rear`**不指向任何元素，要修改并赋值**`NULL`**- **`Q.front`**由于是**&lt;font color=&#39;red&#39;&gt;头结点&lt;/font&gt;**，所以其值始终不会改变</code></pre></blockquote><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119854.png" alt="image-20221216122834047"></p><blockquote><p>**<font color='red'>不设置头结点</font>**，就必须考虑</p><ol><li>初始时&#x3D;&#x3D;<strong><font color='blue'>链表是否为空</font></strong>&#x3D;&#x3D;</li><li>是否在**<font color='orange'>第一个结点前插入新结点</font>**</li><li>是否**<font color='red'>删除</font><strong>结点后</strong><font color='blue'>链表为空</font>**</li></ol></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119888.jpeg" alt="13315216532604079"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(node* rear,ElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p=<span class="keyword">new</span> node;</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">    <span class="keyword">if</span>(rear==<span class="literal">NULL</span>)<span class="comment">//队列为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=p;</span><br><span class="line">        rear=p;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=rear-&gt;next;</span><br><span class="line">        rear-&gt;next=p;</span><br><span class="line">        rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">DeQueue</span><span class="params">(ElementType &amp;x,node* rear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear==<span class="literal">NULL</span>)<span class="keyword">return</span> ERROR;       </span><br><span class="line">    node* p=rear-&gt;next;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(p==rear)<span class="comment">//删除后队列为空</span></span><br><span class="line">        rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rear-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ALV树画法</title>
      <link href="/2023/09/28/AVL%E6%A0%91%E7%94%BB%E6%B3%95/"/>
      <url>/2023/09/28/AVL%E6%A0%91%E7%94%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL树画法"><a href="#AVL树画法" class="headerlink" title="AVL树画法"></a>AVL树画法</h1><h2 id="基本理论："><a href="#基本理论：" class="headerlink" title="基本理论："></a><strong>基本理论：</strong></h2><h3 id="一：AVL树的前身"><a href="#一：AVL树的前身" class="headerlink" title="一：AVL树的前身"></a>一：AVL树的前身</h3><p>平衡二叉树（AVL树）的前身是<strong>二叉排序树（二叉查找树）</strong>。</p><blockquote><p>二叉排序树的一个重要性质：左子树上的所有结点都小于根结点，右子树上的所有结点都大于根节点。<strong>简而言之，左小右大。</strong></p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916761.jpeg" alt="img"></p><p>​图1</p><span id="more"></span><p>如图1。10左边的数都比它小，右边的数都比它大。对于9和15来说也是一样。<strong>所以如果要插入一个数字14，那么该如何做呢？</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916545.webp" alt="img"></p><p>​图2</p><p>如图2。14比10大，所以在10的右边。比15小，所以在15的左边。比12大，所以在12的右边。</p><h3 id="二、何来“平衡”？"><a href="#二、何来“平衡”？" class="headerlink" title="二、何来“平衡”？"></a>二、何来“平衡”？</h3><p>引入概念，<strong>平衡因子。即左子树与右子树的高度（深度）差。</strong>请为上图，标上平衡因子。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916731.webp" alt="img"></p><p>​图3</p><p>如图3所示。<strong>平衡二叉树要求平衡因子的绝对值不大于1</strong>，所以该图就是一个标准的平衡二叉树。</p><hr><h3 id="三：不平衡与旋转："><a href="#三：不平衡与旋转：" class="headerlink" title="三：不平衡与旋转："></a>三：<strong>不平衡与旋转：</strong></h3><p><strong>不平衡即出现了绝对值大于1的平衡因子。</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916119.webp" alt="img"></p><p>​图4（LL旋转）</p><p>插入3之后，9的平衡因子变为2。<strong>二叉树失去平衡，需要通过旋转来重新平衡。</strong></p><h3 id="四：旋转类型的判定："><a href="#四：旋转类型的判定：" class="headerlink" title="四：旋转类型的判定："></a>四：<strong>旋转类型的判定：</strong></h3><p><font color='red'><strong>离插入点最近的</strong></font>，平衡因子的绝对值大于1的点称为<strong>失衡点</strong>。</p><p>&#x3D;&#x3D;<font color='blue'><strong>从失衡点开始，沿树“寻找”插入点。且只记录“寻找”的前两步的路径方向。由此判定旋转类型。</strong></font>&#x3D;&#x3D;</p><p>以图4为例。插入点为3，失衡点为9。从9开始，“寻找”3。<strong>发现3在9的左子树的左子树上。</strong>将路径简记为“左左”。所以需要<strong>LL旋转</strong>。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916606.webp" alt="img"></p><p>​图5（LR旋转）</p><p>如图5。从失衡点5开始，“寻找”插入点4。将路径简记为“左右”。所以需要<strong>LR旋转</strong>。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916620.webp" alt="img"></p><p>​图6（RR旋转）</p><p>如图6。“寻找”路径简记为“右右”。所以需要<strong>RR旋转</strong>。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916869.webp" alt="img"></p><p>​图7（RL旋转）</p><p>如图7。“寻找”路径简记为“右左”。所以需要<strong>RL旋转</strong>。</p><hr><h2 id="旋转方法："><a href="#旋转方法：" class="headerlink" title="旋转方法："></a><strong>旋转方法：</strong></h2><p>方法与旋转类型无关。且一种方法就可应对四种旋转类型。</p><p><strong><font color='red'>从失衡点开始，经过两步“寻找”，则必然遇到两个结点。加上失衡点，总共三个结点。</font>假设为A、B、C，并规定A&lt;B&lt;C。将这三个结点单独拿出来。把其中的“中位数”B作为根结点，A作为B的左子树，C作为B的右子树，构建一个新的平衡二叉树。并将该新树的根B放到原来的失衡点上。其中，A和C的子树不动。【当B原来的左子树根≠A时，把它接到A的右边。当B原来的右子树根≠C时，把它接到C的左边。】</strong>（框内步骤不一定会用到，需要具体问题具体分析。）</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916234.webp" alt="img"></p><p>旋转方法图解</p><p>问：那A原来的右子树和C原来的左子树怎么办？</p><p>答：它们不存在，或者A原来的右子树根&#x3D;B or C，C原来的左子树根&#x3D;A or B。</p><p>问：B的右子树恰好是C</p><p>答：这个时候就<strong>不用将</strong>B的右子树“顺理成章”的放在新树C的左边了</p><h3 id="具体示例："><a href="#具体示例：" class="headerlink" title="具体示例："></a><strong>具体示例：</strong></h3><p><strong>1.将图4重新平衡</strong></p><p>失衡点为9。<strong>“寻找”路径上的三个点为9、4、3。取“中位数”4为树根，</strong>生成新的平衡二叉树。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916846.webp" alt="img"></p><p>把树根4替换到失衡点上。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916902.webp" alt="img"></p><p>二叉树重新获得平衡。</p><p>*<strong>2.画出以序列{25,27,30,12,11,18,14,20,15,22}构造的一棵平衡二叉树*</strong></p><p>首先，<strong>按照左小右大的原则，画二叉树。依次插入25,27,30。</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916188.webp" alt="img"></p><p>插入30后，二叉树失衡。显然，需要进行<strong>RR旋转。</strong>取“中位数”27作树根，25作左子树，30作右子树，生成新的平衡二叉树。并替换到失衡点25上。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916309.webp" alt="img"></p><p>继续插入12，11。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916724.webp" alt="img"></p><p>插入11后，二叉树又失衡了。显然，需要进行<strong>LL旋转。</strong>取“中位数”12作树根，11作左子树，25作右子树，生成新的平衡二叉树。并替换到失衡点25上。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916723.webp" alt="img"></p><p>继续插入18。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916161.webp" alt="img"></p><p>插入18后，二叉树双失衡了。插入点为18，失衡点为27。“寻找”路径记为“左右”，因此需要<strong>LR旋转</strong>。<strong>在27,12,25中</strong>，取“中位数”25作树根，12作左子树，27作右子树，生成新的平衡二叉树。<strong>且25的左子树根18“顺理成章”地放在12的右侧。</strong>（不懂请看旋转方法图解）并替换到失衡点27上。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915364.webp" alt="img"></p><p>继续插入14，20，15。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915337.webp" alt="img"></p><p>插入15后，二叉树叒失衡了。插入点为15，失衡点为12。“寻找”路径记为“右左”，因此需要<strong>RL旋转</strong>。<strong>在12,18,14中</strong>，取“中位数”14作树根，12作左子树，18作右子树，生成新的平衡二叉树。<strong>且14的右子树根15“顺利成章”地放在18的左侧。</strong>（不懂请看旋转方法图解）并替换到失衡点12上。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915412.webp" alt="img"></p><p>最后插入22。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915594.webp" alt="img"></p><p>插入22后，二叉树叕失衡了。插入点为22，失衡点为25。“寻找”路径记为“左右”，因此需要<strong>LR旋转</strong>。<strong>在25,14,18中</strong>，取“中位数”18作树根，14作左子树，25作右子树，生成新的平衡二叉树。<strong>且18的左子树根15“顺理成章”地放在14的右侧，18的右子树根20“顺利成章”地放在25的左侧。</strong>（不懂请看旋转方法图解）并替换到失衡点25上。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915415.webp" alt="img"></p><p>最终的平衡二叉树，如图。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915234.png" alt="image-20221111200549327"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915235.jpg" alt="59b2f7b53f3380a64c814219d3e04bb"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【串】</title>
      <link href="/2023/09/28/%E3%80%90%E4%B8%B2%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90%E4%B8%B2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="模式串匹配算法"><a href="#模式串匹配算法" class="headerlink" title="模式串匹配算法"></a>模式串匹配算法</h2><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282041971.png" alt="image-20221110210307366"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282041953.png" alt="image-20221110210326808"></p><span id="more"></span><h3 id="next函数算法"><a href="#next函数算法" class="headerlink" title="next函数算法"></a>next函数算法</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282041149.png" alt="image-20221110210506712"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282041095.png" alt="image-20221110210707246"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_next</span><span class="params">(string T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*计算next数组*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(T.length(), <span class="number">0</span>)</span></span>; <span class="comment">// next 数组(初值元素一个 0)</span></span><br><span class="line">    <span class="type">int</span> prefix_len = <span class="number">0</span>;              <span class="comment">// 当前共同前后缀的长度</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;                       <span class="comment">// 子串指针</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == T[prefix_len])</span><br><span class="line">        &#123;</span><br><span class="line">            next[i] = ++prefix_len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prefix_len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next[i] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prefix_len = next[prefix_len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模式串next函数**<font color='red'>从1号单元开始，0号单元存放串的长度</font>**</p></blockquote><hr><hr><hr><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string S, string T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*KMP字符串匹配算法*/</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">get_next</span>(T); <span class="comment">// 得到子串的next数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;               <span class="comment">// i是主串的指针，j是子串的指针</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) <span class="comment">// 字符匹配，指针后移</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) <span class="comment">// 字符失配，根据next跳过字串前面的若干个字符</span></span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 子串第一个字符就失配</span></span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (j == T.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>若匹配成功，返回<strong>模式串T</strong>在<strong>目标串S</strong>中**<font color='red'>首次出现的有效位移</font>**</li><li>若匹配失败，返回1</li></ol></blockquote><p><a href="https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click</a></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282041230.jpeg" alt="307d2ae478633f0ab69b5f4ea7662e1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsReverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断输入的字符串中‘&amp;’前后两部分是否为逆串，是则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;s;<span class="type">char</span> c,t;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        s.<span class="built_in">push</span>(c);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t!=c)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>判断是否为逆序通常需要使用**<code>stack</code>**</li><li>注意<strong>第9，第13行</strong>。</li></ol></blockquote><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p> <strong>1095 解码PAT准考证</strong></p><p><strong>题目</strong></p><p>PAT 准考证号由 4 部分组成：</p><ul><li>第 1 位是级别，即 <code>T</code> 代表顶级；<code>A</code> 代表甲级；<code>B</code> 代表乙级；</li><li>第 2~4 位是考场编号，范围从 101 到 999；</li><li>第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；</li><li>最后 11~13 位是考生编号，范围从 000 到 999。</li></ul><p>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。</p><p><strong>输入格式：</strong></p><p>输入首先在一行中给出两个正整数 <em>N</em>（≤104）和 <em>M</em>（≤100），分别为考生人数和统计要求的个数。</p><p>接下来 <em>N</em> 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。</p><p>考生信息之后，再给出 <em>M</em> 行，每行给出一个统计要求，格式为：<code>类型 指令</code>，其中</p><ul><li><code>类型</code> 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 <code>指令</code> 则给出代表指定级别的字母；</li><li><code>类型</code> 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 <code>指令</code> 则给出指定考场的编号；</li><li><code>类型</code> 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 <code>指令</code> 则给出指定日期，格式与准考证上日期相同。</li></ul><p><strong>输出格式：</strong></p><p>对每项统计要求，首先在一行中输出 <code>Case #: 要求</code>，其中 <code>#</code> 是该项要求的编号，从 1 开始；<code>要求</code> 即复制输入给出的要求。随后输出相应的统计结果：</p><ul><li><code>类型</code> 为 1 的指令，输出格式与输入的考生信息格式相同，即 <code>准考证号 成绩</code>。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；</li><li><code>类型</code> 为 2 的指令，按 <code>人数 总分</code> 的格式输出；</li><li><code>类型</code> 为 3 的指令，输出按人数非递增顺序，格式为 <code>考场编号 总人数</code>。若人数并列则按考场编号递增顺序输出。</li></ul><p>如果查询结果为空，则输出 <code>NA</code>。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8 4</span><br><span class="line">B123180908127 99</span><br><span class="line">B102180908003 86</span><br><span class="line">A112180318002 98</span><br><span class="line">T107150310127 62</span><br><span class="line">A107180908108 100</span><br><span class="line">T123180908010 78</span><br><span class="line">B112160918035 88</span><br><span class="line">A107180908021 98</span><br><span class="line">1 A</span><br><span class="line">2 107</span><br><span class="line">3 180908</span><br><span class="line">2 999</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1 A</span><br><span class="line">A107180908108 100</span><br><span class="line">A107180908021 98</span><br><span class="line">A112180318002 98</span><br><span class="line">Case 2: 2 107</span><br><span class="line">3 260</span><br><span class="line">Case 3: 3 180908</span><br><span class="line">107 2</span><br><span class="line">123 2</span><br><span class="line">102 1</span><br><span class="line">Case 4: 2 999</span><br><span class="line">NA</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>200 ms</p><p>内存限制</p><p>64 MB</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string t;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value != b.value ? a.value &gt; b.value : a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; v[i].t &gt;&gt; v[i].value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; num &gt;&gt; s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>, i, num, s.<span class="built_in">c_str</span>());      <span class="comment">//Attention!    s.c_str()</span></span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t[<span class="number">0</span>] == s[<span class="number">0</span>])      ans.<span class="built_in">push_back</span>(v[j]); <span class="comment">//S[0]即为字符‘A’....</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, ans[j].t.<span class="built_in">c_str</span>(), ans[j].value);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>)     <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>) == s) </span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    sum += v[j].value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt)   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, sum);</span><br><span class="line">            <span class="keyword">else</span>       <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">6</span>) == s)   m[v[j].t.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>)]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : m)   </span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;it.first, it.second&#125;);   <span class="comment">//Attention!!   &#123;it.first,it.second&#125;直接插入结构体</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, ans[j].t.<span class="built_in">c_str</span>(), ans[j].value);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>)     <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>27行：<code>string</code>类型的变量s用printf输出必须是<code>printf(“%s”,s.c_str());</code>即<strong>s.c_str()</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀、中缀、后缀表达式</title>
      <link href="/2023/09/28/%E5%89%8D%E7%BC%80%EF%BC%8C%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/09/28/%E5%89%8D%E7%BC%80%EF%BC%8C%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>前缀表达式（波兰式），中缀表达式，后缀表达式（逆波兰式）</p><ul><li>区别在于<strong>运算符</strong>相对与<strong>操作数</strong>的位置不同：<ul><li>前缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之前</strong>；</li><li>中缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之间</strong>；</li><li>后缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之后</strong>；</li></ul></li><li>举例：<br>  (3 + 4) × 5 - 6 就是中缀表达式<br>  - × + 3 4 5 6 前缀表达式<br>  3 4 + 5 × 6 - 后缀表达式</li></ul><span id="more"></span><h2 id="1、中缀表达式转后缀表达式："><a href="#1、中缀表达式转后缀表达式：" class="headerlink" title="1、中缀表达式转后缀表达式："></a>1、中缀表达式转后缀表达式：</h2><p>假定有中缀表达式A：1 + (( 2 + 3)* 4 ) – 5，请将它转化为后缀表达式。</p><h3 id="方法一：直接转换法"><a href="#方法一：直接转换法" class="headerlink" title="方法一：直接转换法"></a>方法一：直接转换法</h3><p>  （1）首先确定表达式表达式A的运算顺序，然后加括号：（（1 + (( 2 + 3)* 4 )） – 5 ）</p><p>  （2）从最里面的一层括号开始运算，转换成后缀表达式的方法为：（忽略括号）数字在前，符号在后。</p><p>​       1）( 2 + 3) &#x3D;&gt; 23+</p><p>​       2) (( 2 + 3)* 4 ) &#x3D;&gt; 23+4*</p><p>​       3) （1 + (( 2 + 3)* 4 )）&#x3D;&gt; 123+4*+   [按照运算次序，从左到右排列]</p><p>​       4）（（1 + (( 2 + 3)* 4 )） – 5 ）&#x3D;&gt; 123+4*+ 5-</p><p>​    后缀表达式为：12 3 + 4 * + 5 –</p><h3 id="方法二：利用表达式树"><a href="#方法二：利用表达式树" class="headerlink" title="方法二：利用表达式树"></a>方法二：利用表达式树</h3><p>​ 首先将中缀表达式转换为表达式树，然后<strong>后序遍历</strong>表达式树，所得结果就是后缀表达式。详细过程见<a href="C:\Users\cuiluyi\Desktop\编程随想\DAG和二叉树描述表达式.md">DAG和二叉树描述表达式</a>如上述表达式的表达式树为：</p><blockquote><p><a href="%E8%B7%AF%E5%BE%84....................................">自定义名称</a>跳转文件，详细见<a href="%5B(69%E6%9D%A1%E6%B6%88%E6%81%AF">Typora使用技巧 | 各种跳转 </a> Typora使用技巧 | 各种跳转 【必备】_想要腹肌的熊的博客-CSDN博客_typora链接跳转到其他文件](<a href="https://blog.csdn.net/qq_41907769/article/details/121722716">https://blog.csdn.net/qq_41907769/article/details/121722716</a>))</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290925432.png" alt="img"></p><h3 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290941178.png" alt="image-20230929094150044"></p><blockquote><p>任意时刻<strong>栈顶的优先级</strong>都要<strong>大于</strong>其**<font color='red'>下面一个</font>**的优先级</p></blockquote><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290942146.png" alt="image-20230929094204000"></p><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290942448.png" alt="image-20221103161920147"></p><blockquote><p><strong><font color='red'>B</font></strong></p></blockquote><h2 id="2、中缀表达式转为前缀表达式"><a href="#2、中缀表达式转为前缀表达式" class="headerlink" title="2、中缀表达式转为前缀表达式"></a>2、中缀表达式转为前缀表达式</h2><p>  假定有中缀表达式1 + (( 2 + 3)* 4 ) – 5，请将它转化为前缀表达式。</p><h3 id="方法一：直接转换法-1"><a href="#方法一：直接转换法-1" class="headerlink" title="方法一：直接转换法"></a>方法一：直接转换法</h3><p>  （1）首先确定表达式表达式A的运算顺序，然后加括号：（（1 + (( 2 + 3)* 4 )） – 5 ）</p><p>  （2）从最里面的一层括号开始运算，转换成前缀表达式的方法为：（忽略括号）符号在前，数字在后。</p><p>​       1）( 2 + 3) &#x3D;&gt; +23</p><p>​       \2) (( 2 + 3)* 4 ) &#x3D;&gt; *+234</p><p>​       \3) （1 + (( 2 + 3)* 4 )）&#x3D;&gt;  +1*+234  </p><p>​       4）（（1 + (( 2 + 3)* 4 )） – 5 ）&#x3D;&gt; -+1*+2345</p><p>​    前缀表达式为：-+1*+2345</p><h3 id="方法二：利用表达式树-1"><a href="#方法二：利用表达式树-1" class="headerlink" title="方法二：利用表达式树"></a>方法二：利用表达式树</h3><p>  首先将中缀表达式转换为表达式树，然后先序遍历表达式树，所得结果就是前缀表达式。</p><p>  将中缀表达式转化为表达式树的方法：表达式树的树叶是操作数，而其他节点为操作符，根结点为优先级最低且靠右的操作符（如上述表达式优先级最低是-和+，但-最靠右，所以根为-），圆括号不包括。</p><p>   经过前序遍历所得前缀表达式为：- + 1 * + 2 3 4 5</p><h2 id="3、后缀表达式-转-中缀表达式"><a href="#3、后缀表达式-转-中缀表达式" class="headerlink" title="3、后缀表达式 转 中缀表达式"></a>3、后缀表达式 转 中缀表达式</h2><p>  假定有后缀表达式1 2 3 + 4 * +5 – ，请将它转化为前缀表达式。</p><h3 id="方法一：利用表达式树："><a href="#方法一：利用表达式树：" class="headerlink" title="方法一：利用表达式树："></a>方法一：利用表达式树：</h3><p>​    从左到右扫面后缀表达式，一次一个符号读入表达式。如果符号是操作数，那么就建立一个单节点树并将它推入栈中。如果符号是操作符，那么就从栈中弹出两个树T1和T2（T1先弹出）并形成一颗新的树，该树的根就是操作符，它的左、右儿子分别是T2和T1。然后将指向这棵新树的指针压入栈中。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943091.png" alt="img">扫描123后</p><p>前三个符号是操作数，因此创建三颗单节点树并将指向它们的指针压入栈中。 </p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943201.png" alt="img">扫描+后</p><p> “+”被读入，因此指向最后两颗树的指针被弹出，形成一颗新树，并将指向新树的指针压入栈中。以下的流程图以相同原理执行。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943954.png" alt="img">扫描4和*后</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943074.png" alt="img">扫描+和5后</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943478.png" alt="img">扫描-后</p><p>最后再中序遍历所得的表达式树即得到我们所需的中缀表达式：1+（（2+3）*4）-5 </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="表达式转换"><a href="#表达式转换" class="headerlink" title="表达式转换"></a>表达式转换</h3><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中给出不含空格的中缀表达式，可包含<code>+</code>、<code>-</code>、<code>*</code>、<code>\</code>以及左右括号<code>()</code>，表达式不超过20个字符。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2+3*(7-4)+8/4</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 7 4 - * + 8 4 / +</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string c;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;p;</span><br><span class="line">p[<span class="string">&quot;+&quot;</span>]=<span class="number">1</span>;p[<span class="string">&quot;-&quot;</span>]=<span class="number">1</span>;p[<span class="string">&quot;*&quot;</span>]=<span class="number">2</span>;p[<span class="string">&quot;/&quot;</span>]=<span class="number">2</span>;p[<span class="string">&quot;(&quot;</span>]=<span class="number">3</span>;p[<span class="string">&quot;)&quot;</span>]=<span class="number">3</span>;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    vector&lt;string&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(c[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c[i]&lt;=<span class="string">&#x27;9&#x27;</span>||i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;(c[j]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c[j]&lt;=<span class="string">&#x27;9&#x27;</span>||c[j]==<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">j++;</span><br><span class="line">            l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i,j-i));    </span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;c[i+<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;c[j]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">j++;</span><br><span class="line">    l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i+<span class="number">2</span>,j-i<span class="number">-2</span>));</span><br><span class="line">    i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;c[i+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;c[j]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">j++;</span><br><span class="line">    l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i+<span class="number">1</span>,j-i<span class="number">-1</span>));</span><br><span class="line">    i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">stack&lt;string&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l[i]==<span class="string">&quot;+&quot;</span>||l[i]==<span class="string">&quot;-&quot;</span>||l[i]==<span class="string">&quot;*&quot;</span>||l[i]==<span class="string">&quot;/&quot;</span>||l[i]==<span class="string">&quot;(&quot;</span>||l[i]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||(p[l[i]]&gt;p[s.<span class="built_in">top</span>()]&amp;&amp;l[i]!=<span class="string">&quot;)&quot;</span>)||s.<span class="built_in">top</span>()==<span class="string">&quot;(&quot;</span>)</span><br><span class="line">s.<span class="built_in">push</span>(l[i]);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l[i]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">top</span>()!=<span class="string">&quot;(&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;p[l[i]]&lt;=p[s.<span class="built_in">top</span>()]&amp;&amp;s.<span class="built_in">top</span>()!=<span class="string">&quot;(&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">push</span>(l[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;cout&lt;&lt;(flag==<span class="number">0</span>?<span class="string">&quot;&quot;</span>:<span class="string">&quot; &quot;</span>)&lt;&lt;l[i];flag=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2023/09/28/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2023/09/28/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="时间空间复杂度"><a href="#时间空间复杂度" class="headerlink" title="时间空间复杂度"></a>时间空间复杂度</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>设 <em>n</em> 是描述问题规模的非负整数，下列程序段的时间复杂度是：**<font color='red'>C</font>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( n &gt;= (x+<span class="number">1</span>)*(x+<span class="number">1</span>) )</span><br><span class="line">    x = x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>A. <em>O</em>(<em>n</em>2)</p><p>B. <em>O</em>(<em>n</em>)</p><p>C. <em>O</em>(n^1&#x2F;2^)</p><p>D. <em>O</em>(logn)<img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914207.png" alt="image-20221019111453276"></p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914217.png" alt="image-20221019111930977" style="zoom:80%;" /><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914238.png" alt="image-20221019111828861"></p><h2 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h2><p>设n nn是描述问题规模的非负整数，下面程序片段的时间复杂度是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">2</span>；</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">x=<span class="number">2</span>*x;</span><br></pre></td></tr></table></figure><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914208.png" alt="image-20221104182829170" style="zoom: 50%;" /><h2 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h2><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914201.png" alt="image-20221104182958557" style="zoom:150%;" /><h2 id="例六"><a href="#例六" class="headerlink" title="例六"></a>例六</h2><p>下列函数的时间复杂度是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span> <span class="params">( <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sum&lt; n) sum += ++ i;</span><br><span class="line"><span class="keyword">return</span> i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914190.png" alt="image-20221104183451111"></p><p><strong><code>B</code></strong></p><h1 id="存储密度"><a href="#存储密度" class="headerlink" title="存储密度"></a>存储密度</h1><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914686.png" alt="image-20221016175203394" style="zoom:150%;" /><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="数据逻辑结构"><a href="#数据逻辑结构" class="headerlink" title="数据逻辑结构"></a>数据逻辑结构</h3><p>1.<strong>集合结构</strong>:数据元素之间没有任何关系.</p><p>2.<strong>线性结构</strong>:数据元素之间定义了线性关系.1对1</p><p>3.<strong>树形结构</strong>:数据元素之间定义了层次关系 1对多.</p><p>4.<strong>图状结构</strong>:数据元素之间定义了网状关系 多对多.</p><h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><ol><li><p><strong>顺序存储结构</strong>:借助数据元素之间的相对位置来表示元素之间的逻辑结构.（vector动态数组、 deque双端队列、stack栈容器、queue队列容器）</p></li><li><p><strong>链式存储结构</strong>:借助数据元素之间的元素的指针表示数组元素的逻辑结构.</p></li><li><p><strong>散列存储结构</strong>:顺序存储+算列.</p></li><li><p><strong>索引存储结构</strong>:顺序存储+索引.</p></li></ol><blockquote><p><strong>数据逻辑结构在计算机存储器中的表示称为数据的<a href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a><strong>（或存储表示），也称为</strong>物理结构</strong>。</p></blockquote><h3 id="存储密度-1"><a href="#存储密度-1" class="headerlink" title="存储密度"></a>存储密度</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><pre><code>存储密度 = &lt;u&gt;结点&lt;/u&gt;**数据**本身所占存储量 / &lt;u&gt;结点&lt;/u&gt;**结构**所占的存储量</code></pre><ul><li>结构数据本身所占存储量 &#x3D; 数据域所占存储量</li><li>结点结构所占的存储总量 &#x3D; （数据域+结点域）所占存储量</li><li>注：指针存储量与机器位数有关，如32位机指针大小为32bit，4Byte</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol><li><p>&#x3D;&#x3D;<strong>顺序表</strong>&#x3D;&#x3D;的存储密度等于1</p></li><li><p>假设单链表的结点的<strong>数据域</strong>占的存储量为N，结点的<strong>指针域</strong>所占的存储量为M，则存储密度 &#x3D; N &#x2F; (N+M)，所以<strong>单链表的密度是小于1</strong>的。</p></li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">chainList</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chainList</span> *next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>该链表的</p><ul><li><p>结构数据本身所占存储量 &#x3D; sizeof(int) &#x3D; 2</p></li><li><p>结点结构所占的存储总量 &#x3D; 8(64位机)+2</p></li><li><p>存储密度 &#x3D; 20%</p></li></ul><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>对某个带权连通图构造最小生成树，以下说法中正确的是（ ）。</p><p>Ⅰ.该图的所有最小生成树的总代价一定是唯一的</p><p>Ⅱ.其**<font color='red'>所有</font><strong>权值</strong><font color='red'>最小的</font>**边一定会出现在所有的最小生成树中</p><p>Ⅲ.用普里姆（Prim）算法从不同顶点开始构造的所有最小生成树**<font color='red'>一定相同</font>**</p><p>Ⅳ.使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树<font color='red'><strong>总不相同</strong></font></p><p>A.  仅Ⅰ、Ⅲ</p><p>&#x3D;&#x3D;<strong>B.  仅Ⅰ</strong>&#x3D;&#x3D;</p><p>C.  仅Ⅱ</p><p>D.  仅Ⅱ、Ⅳ</p><blockquote><p>A：由一个<strong>带权连通图</strong>构造的最小生成树可能有多棵，但其代价一定是唯一的；</p><p>B：**<font color='red'>权值最小的边可能不止一条</font><strong>，这些不唯一的最小权值边</strong><font color='blue'>不一定都会</font><strong>出现在所有的最小生成树中，但至少会有一条权值最小的边出现在MBT中（根据Kruskal算法至少会有一条，多条可能导致</strong>内部联通**）</p><p>C：当存在**<font color='blue'>多条权值相同的边</font>**时，用普里姆（Prim）算法从不同顶点开始得到的最小生成树不一定相同（不唯一）；</p><p>D：使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树不一定总不相同</p><ul><li>若图中**<font color='red'>最小生成树唯一时</font>，&#x3D;&#x3D;无论用哪种算法&#x3D;&#x3D;，得到的最小生成树都是相同的**。</li><li>若图中**<font color='red'>最小生成树不唯一时</font>，prim和Kruskal算法得到的最小生成树并不总是相同**。</li></ul></blockquote><h1 id="数据基本概念"><a href="#数据基本概念" class="headerlink" title="数据基本概念"></a>数据基本概念</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914908.png" alt="image-20221104184520267"></p><blockquote><p>数据元素是数据的&#x3D;&#x3D;<strong><font color='red'>基本（最小）单位</font></strong>&#x3D;&#x3D;</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914913.png" alt="在这里插入图片描述"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914895.png" alt="image-20221109214634474"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914037.png" alt="image-20221109214836979"></p><blockquote><p>DFS&#x2F;BFS：邻接矩阵O（n^2^）邻接表O（n+e）</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914968.png" alt="image-20221110140604533"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树结点的计算问题</title>
      <link href="/2023/09/28/%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/"/>
      <url>/2023/09/28/%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="树结点的计算问题"><a href="#树结点的计算问题" class="headerlink" title="树结点的计算问题"></a>树结点的计算问题</h1><h2 id="树的种数"><a href="#树的种数" class="headerlink" title="树的种数"></a>树的种数</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291052715.png" alt="image-20230929105248559"></p><span id="more"></span><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291053249.png" alt="image-20230929105310153"></p><h1 id="一：完全二叉树中结点问题"><a href="#一：完全二叉树中结点问题" class="headerlink" title="一：完全二叉树中结点问题"></a>一：完全二叉树中结点问题</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919576.png" alt="image-20221105154910530"></p><blockquote><h1 id="完全二叉树，n1-0或1"><a href="#完全二叉树，n1-0或1" class="headerlink" title="完全二叉树，n1&#x3D;0或1"></a><font color='red'>完全二叉树，n<del>1</del>&#x3D;0或1</font></h1></blockquote><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>设叶子节点个数为n0,度为1的节点个数为n1,度为2的节点个数为n2</p><p>则 </p><p>n0+n1+n2&#x3D;n                (1)</p><p>n0&#x3D;n2+1                       (2)</p><p>由(1)(2) &#x3D;&#x3D;&gt;&#x3D;&#x3D;<strong>n0&#x3D;(n+1-n1)&#x2F;2</strong>&#x3D;&#x3D;              </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>由**<u>完全二叉树的性质可知：n1&#x3D;0 或 1</u>**</p><ol><li><p>当<strong>n1&#x3D;0</strong>或<strong>n为奇数</strong>时，n0&#x3D; (n+1)&#x2F;2;</p></li><li><p>当<strong>n1&#x3D;1</strong>或<strong>n为偶数</strong>时，n0&#x3D; n&#x2F;2;</p></li></ol><blockquote><p>综合1，2可得：</p><p>一个具有n个节点的<strong>完全二叉树</strong>，其<strong>叶子节点的个数n0</strong>为： &#x3D;&#x3D;<strong>n&#x2F;2 向上取整，或者(n+1)&#x2F;2 向下取整</strong>&#x3D;&#x3D;</p></blockquote><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h4><p>设一棵完全二叉树共有699个节点，则在该二叉树中的叶节点数为？ </p><p>——350</p><hr><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>一棵完全二叉树<u>第六层有</u>8个叶结点（根为第一层），则结点个数<u>最多有</u>（）个。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ol><li><p><strong>二叉树第k层最多有 2^(k-1) 个节点</strong></p><p> 第一层最多有1个节点</p></li></ol><p>​第二层最多有2个节点</p><p>​第三层最多有4个节点 </p><p>​第四层最多有8个节点</p><p>​第五层最多有16个节点</p><p>​第六层最多有32个节点</p><ol start="2"><li><p><strong>完全二叉树的叶节点只可能出现在后两层</strong>，<strong>除最后一层可能不满，其余层均满</strong></p><p> 第六层有8（&lt;2^6-1^&#x3D;32）个结点，说明<strong>第六层</strong>是完全二叉树的<strong>最后两层</strong>之一</p></li></ol><ul><li><p>&#x3D;&#x3D;<strong>如果完全二叉树有6层</strong>&#x3D;&#x3D;，则前5层是满二叉树，总节点数n&#x3D;（2^5^-1）+8&#x3D;39</p></li><li><p>如果完全二叉树有7层，则</p><ul><li><p>前6层是满二叉树，前六层总节点数目为2^6^-1&#x3D;63</p></li><li><p>第六层有8个叶子节点，则有32-8&#x3D;24个非叶子节点</p></li><li><p>  $$<br>  第七层最多有24*2&#x3D;48个叶子节点<br>  $$</p></li></ul><p>  故总节点数目为63+24*2&#x3D;111</p><p>  <img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919577.jpg" alt="10579c757472bc18bd16578d42dcb1d"></p></li></ul><h1 id="二：树的结点问题"><a href="#二：树的结点问题" class="headerlink" title="二：树的结点问题"></a>二：树的结点问题</h1><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>已知在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶子结点的个数为？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919578.jpg" alt="daf0765aa213be23c7bff6d820e6c92"></p><blockquote><p>注：&#x3D;&#x3D;<strong>若树的节点数为n，则边数为n-1</strong>&#x3D;&#x3D;</p></blockquote><h2 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h2><p>一棵度为3的树中，有3度的结点100个，有2度的结点200个，有叶子结点多少个？</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290921109.png" alt="image-20221002222557971" style="zoom: 18%;" /><h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919580.jpg" alt="6eb138545a60b02c6aace0b7aa36ab2"></p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919581.jpg" alt="a07999b6a7af0f1122d73a179281c15"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919582.jpg" alt="3f1a63bfca3d22b868487ba223510bc"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符优先级</title>
      <link href="/2023/09/28/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2023/09/28/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310031506806.png" alt="202310031501616"></p><span id="more"></span><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310031505067.png" alt="202310031501616"></p><p><strong>说明</strong>：</p><ol><li><strong>一优先级的运算符，运算次序由结合方向所决定</strong></li><li><strong>简单记就是：！ &gt;</strong> <strong>算术运算符</strong> <strong>&gt;</strong> <strong>关系运算符</strong> <strong>&gt; &amp;&amp; &gt; || &gt;</strong> <strong>赋值运算符</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法与MST</title>
      <link href="/2023/09/28/Dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2023/09/28/Dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>$$Dijkstra$$最短路径算法构造的生成树是否一定为最小生成树？<br>问题描述：一连通无向图,边为非负权值，问用$$Dijkstra$$最短路径算法能否给出一棵生成树，这树是否一定为最小生成树？说明理由。</p><span id="more"></span><blockquote><p>  ​解答:$$Dijkstra$$最短路径算法能够给出一棵生成树,但该树不一定为最小生成树。虽然$$Dijkstra$$算法和$$Prim$$算法的思路与步骤较为相似，但两者的更新算法不一致，而其余部分完全一致。</p></blockquote><ol><li>$$Dijkstra$$算法对应的$$Min$$更新算法为:</li></ol><p>$$<br>if(Min[j] &gt; Min[k] + G[k][j])\<br>Min[j] &#x3D; Min[k] + G[k][j];<br>$$</p><ol start="2"><li>而$$Prim$$算法对应的$$Min$$更新算法为:</li></ol><p>$$<br>if(Min[j] &gt; G[k][j])<br>\Min[j] &#x3D; G[k][j]<br>$$</p><ol start="3"><li>为此，可考虑以下的反例：对于以下的带权连通无向图</li></ol><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849744.png" alt="在这里插入图片描述"></p><ul><li>用$$Prim$$算法构造的一棵最小生成树为:</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849802.png" alt="在这里插入图片描述"></p><ul><li>而用$$Dijkstra$$算法构造的一棵生成树为:</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849648.png" alt="在这里插入图片描述"></p><p>​其中，$$Dijkstra$$算法的执行过程中，从$$v1$$到$$v3$$的最短路径选择的是$$v1-&gt;v3$$，而不是$$v1-&gt;v4-&gt;v3$$，原因是$$Min[3]&#x3D;Min[4]+G[4][3]$$，即$$v1$$到$$v3$$的初始最短距离与$$v1$$到$$v4$$的最短路径加上$$v4$$到$$v3$$的距离相等，因此在更新过程中保留$$v1-&gt;v3$$的最短路径为$$v1-&gt;v3$$而非$$v1-&gt;v4-&gt;v3$$，所以最后，构造的生成树的边权值之和为$$1+4+6&#x3D;11$$，远大于用$$Prim$$算法构造的最小生成树边权值之和$$1+2+4&#x3D;7$$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DAG、BT描述表达式</title>
      <link href="/2023/09/28/DAG%E3%80%81BT%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/09/28/DAG%E3%80%81BT%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式二叉树"><a href="#表达式二叉树" class="headerlink" title="表达式二叉树"></a>表达式二叉树</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>用二叉树来表示一个简单算术表达式，树的每一个结点包括一个运算符或运算数。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong><font color='red'>把操作数作为叶结点，操作符作为非叶节点</font></strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847728.png" alt="image-20221101205736696"></p><blockquote><p>表达式二叉树</p><ul><li>&#x3D;&#x3D;<strong><font color='orange'>叶结点的个数</font><strong>即为</strong><font color='red'>操作数的个数<font color='cyan'>（可以重复）</font></strong>&#x3D;&#x3D;</li><li><strong><font color='red'>操作符均位于非叶子节点</font></strong></li><li><strong><font color='green'>结点个数 &#x3D; 操作数的个数 + 操作符的个数</font></strong></li></ul></blockquote><span id="more"></span><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847729.png" alt="image-20221101210106099"></p><blockquote><ol><li>表达式二叉树的**<font color='red'>前序遍历</font><strong>序列和</strong><font color='red'>后序遍历</font><strong>序列即为相应的</strong><font color='blue'>前缀表达式</font><strong>和</strong><font color='blue'>后缀表达式</font>**</li><li>表达式二叉树的**<font color='red'>中序遍历</font>** 序列与中缀表达式有可能不符合</li></ol></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847730.jpg" alt="821ba35825723c1d45f5ee6ca406d33"></p><ul><li><h2 id="解答-B"><a href="#解答-B" class="headerlink" title="解答  B"></a>解答  <font color='red'>B</font></h2></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847732.jpg" alt="13312021776171515"></p><h1 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a><font color='purple'>有向</font>无环图描述表达式</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ol><li>把各个**操作数<font color='red'>不重复地</font>**排成一排</li><li>标出各个运算符的**<font color='blue'>生效顺序</font>**（先算左边括号或者先算右边括号均可以）</li><li>&#x3D;&#x3D;<strong>按运算先后顺序加入运算符</strong>&#x3D;&#x3D;，不同的运算级别层次不同，过程中如果已经存在某部分，则直接用</li><li>最后生成的图就是有向无环图</li></ol><blockquote><ol><li><strong>用有向无环图表示表达式的目的就是<font color='red'>去掉相同的部分</font>，压缩存储，节省空间</strong></li><li>DAG中&#x3D;&#x3D;<strong>顶点的个数</strong>即为**<font color='gree'>运算符号个数（无重复）</font><strong>和</strong><font color='cyan'>运算数个数（无重复）</font>**之和&#x3D;&#x3D;</li></ol></blockquote><h2 id="例题8"><a href="#例题8" class="headerlink" title="例题8"></a>例题8</h2><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847733.png" alt="image-20221101203825317"></p><blockquote><p>注意：**<code>( x + y )( ( x + y ) / x )</code> <font color='red'>省略了一个<code>*</code></font>**</p></blockquote><p> <img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160848334.png" alt="在这里插入图片描述"></p><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847734.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map应用</title>
      <link href="/2023/09/28/map%E5%BA%94%E7%94%A8/"/>
      <url>/2023/09/28/map%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1065-单身狗"><a href="#1065-单身狗" class="headerlink" title="1065 单身狗"></a><strong>1065 单身狗</strong></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻&#x2F;伴侣的对数；随后 N 行，每行给出一对夫妻&#x2F;伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p><span id="more"></span><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">11111 22222</span><br><span class="line">33333 44444</span><br><span class="line">55555 66666</span><br><span class="line">7</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10000 23333 44444 55555 88888</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//find函数 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,t1,t2;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">p[t1]=t2;p[t2]=t1;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans,<span class="built_in">t</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">cin&gt;&gt;t[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">find</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),p[t[i]]);</span><br><span class="line"><span class="keyword">if</span>(it==t.<span class="built_in">end</span>())</span><br><span class="line">ans.<span class="built_in">push_back</span>(t[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%05d&quot;</span>,i==<span class="number">0</span>?<span class="string">&quot;&quot;</span>:<span class="string">&quot; &quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第22-23行代码不能写成<del><code>if(find(t.begin(),t.end(),p[t[i]]==t.end())</code></del></p></blockquote><h1 id="1090-危险品装箱"><a href="#1090-危险品装箱" class="headerlink" title="1090 危险品装箱"></a><strong>1090 危险品装箱</strong></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。</p><p>本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。</p><h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数：<em>N</em> (≤104) 是成对的不相容物品的对数；<em>M</em> (≤100) 是集装箱货品清单的单数。</p><p>随后数据分两大块给出。第一块有 <em>N</em> 行，每行给出一对不相容的物品。第二块有 <em>M</em> 行，每行给出一箱货物的清单，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K G[1] G[2] ... G[K]</span><br></pre></td></tr></table></figure><p>其中 <code>K</code> (≤1000) 是物品件数，<code>G[i]</code> 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。</p><h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 <code>Yes</code>，否则输出 <code>No</code>。</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">20001 20002</span><br><span class="line">20003 20004</span><br><span class="line">20005 20006</span><br><span class="line">20003 20001</span><br><span class="line">20005 20004</span><br><span class="line">20004 20006</span><br><span class="line">4 00001 20004 00002 20003</span><br><span class="line">5 98823 20002 20003 20006 10010</span><br><span class="line">3 12345 67890 23333</span><br></pre></td></tr></table></figure><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;map&gt;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     int n, k, t1, t2;</span></span><br><span class="line"><span class="comment">//     map&lt;int,vector&lt;int&gt;&gt; m;</span></span><br><span class="line"><span class="comment">//     scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; n; i++) </span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         scanf(&quot;%d%d&quot;, &amp;t1, &amp;t2);</span></span><br><span class="line"><span class="comment">//         m[t1].push_back(t2);//m[t]是vector&lt;int&gt;(动态数组),表示与编号为t的所有不相容货物的编号 </span></span><br><span class="line"><span class="comment">//         m[t2].push_back(t1);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     while (k--) </span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//         int cnt, flag = 0, a[100000] = &#123;0&#125;;//a[]用于记录相关编号是否出现 </span></span><br><span class="line"><span class="comment">//         scanf(&quot;%d&quot;, &amp;cnt);//cnt表示每箱的物品件数； </span></span><br><span class="line"><span class="comment">//         vector&lt;int&gt; v(cnt);//初始化动态数组v，长度为cnt，自动初始化全为0；用于记录一箱内所有物品编号（因为要成对比较） </span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; cnt; i++) </span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//             scanf(&quot;%d&quot;, &amp;v[i]);</span></span><br><span class="line"><span class="comment">//             a[v[i]] = 1;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; v.size(); i++)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//    for (int j = 0; j &lt; m[v[i]].size(); j++)//两个集合之间是否存在交集，存在flag=1；否则flag=0； </span></span><br><span class="line"><span class="comment">//             if (a[m[v[i]][j]] == 1) flag = 1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//         printf(&quot;%s\n&quot;,flag ? &quot;No&quot; :&quot;Yes&quot;);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//find函数 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,t1,t2;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;p;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;        <span class="comment">//m[t]是vector&lt;int&gt;(动态数组),表示与编号为t的所有不相容货物的编号 </span></span><br><span class="line">p[t1].<span class="built_in">push_back</span>(t2);p[t1].<span class="built_in">push_back</span>(t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(t1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t1;j++)</span><br><span class="line">cin&gt;&gt;a[j];</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t1;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;p[a[j]].<span class="built_in">size</span>();k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),p[a[j]][k]);</span><br><span class="line"><span class="keyword">if</span>(it!=a.<span class="built_in">end</span>())</span><br><span class="line">&#123;flag=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Heap】</title>
      <link href="/2023/09/28/%E3%80%90Heap%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90Heap%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&#x3D;&#x3D;采用**<font color='blue'>数组存储</font><strong>的</strong><font color='red'>完全二叉树</font>**&#x3D;&#x3D;</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011962.png" alt="image-20230916123313335"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011898.png" alt="image-20221019101952011"></p><blockquote><p>注意：<code>data[0]</code>用来存放&#x3D;&#x3D;<strong>哨兵</strong>&#x3D;&#x3D;</p></blockquote><span id="more"></span><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><blockquote><p><code>最小堆</code>（MinHeap）：任一结点的<code>data</code>小于其所有子树结点的data</p></blockquote><blockquote><p><code>最大堆</code>（MinHeap）：任一结点的<code>data</code>大于其所有子树结点的dat</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011027.png" alt="image-20230916123453824"></p><h2 id="操作（以MaxHeap为例）"><a href="#操作（以MaxHeap为例）" class="headerlink" title="操作（以MaxHeap为例）"></a>操作（以MaxHeap为例）</h2><h3 id="对象集"><a href="#对象集" class="headerlink" title="对象集"></a>对象集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">ElementType data[Maxsize];</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MaxHeap;</span><br></pre></td></tr></table></figure><h3 id="下滤筛选"><a href="#下滤筛选" class="headerlink" title="下滤筛选"></a>下滤筛选</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(MaxHeap H,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = H-&gt;data[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; H-&gt;size &amp;&amp; H-&gt;data[i] &lt; H-&gt;data[i+<span class="number">1</span>])<span class="comment">//i &lt; H-&gt;size说明H-&gt;data[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= H-&gt;data[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;H-&gt;data[s]=H-&gt;data[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h3 id="上滤筛选"><a href="#上滤筛选" class="headerlink" title="上滤筛选"></a>上滤筛选</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(MaxHeap H,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = H-&gt;data[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;data[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;H-&gt;data[s]=H-&gt;data[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>上滤</font>：用于<font color='blue'>向堆中插入一个元素</font></strong></p></blockquote><h3 id="最大堆的初始化创建"><a href="#最大堆的初始化创建" class="headerlink" title="最大堆的初始化创建"></a>最大堆的初始化创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">CreatHeap</span><span class="params">(<span class="type">int</span> Max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆的插入"><a href="#最大堆的插入" class="headerlink" title="最大堆的插入"></a>最大堆的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size&gt;=Maxsize)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t&gt;H-&gt;data[i/<span class="number">2</span>];i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>H-&gt;data[0]</code>是哨兵，它不会小于堆中的最大元素，其作用：控制循环结束。</p></blockquote><h3 id="最大堆的删除"><a href="#最大堆的删除" class="headerlink" title="最大堆的删除"></a>最大堆的删除</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011907.png" alt="这里写图片描述"></p><blockquote><p>删除并且返回根节点（最大值）</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(MaxHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ElementType max=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点最大值，最后return</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    ElementType t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最大的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>((child!=H-&gt;size)&amp;&amp;H-&gt;data[child] &lt; H-&gt;data[child+<span class="number">1</span>])<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=H-&gt;data[child])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第10行<del>parent*&#x3D;2</del>错误，必须是<code>parent=child</code>,作用是parent索引变成儿子索引，向下交换</li><li>第8行<del><code>data[H-&gt;size]</code></del>错误，必须是<code>data[H-&gt;size--]</code></li></ul></blockquote><h3 id="最大堆的建立"><a href="#最大堆的建立" class="headerlink" title="最大堆的建立"></a>最大堆的建立</h3><h4 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h4><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><h6 id="（1）调用Insert函数，将N个元素一个个相继插入到一个初始为空的堆Heap中去。"><a href="#（1）调用Insert函数，将N个元素一个个相继插入到一个初始为空的堆Heap中去。" class="headerlink" title="（1）调用Insert函数，将N个元素一个个相继插入到一个初始为空的堆Heap中去。"></a>（1）调用Insert函数，将N个元素一个个相继插入到一个初始为空的堆Heap中去。</h6><h6 id="（2）其时间复杂度为O-N-logN-。"><a href="#（2）其时间复杂度为O-N-logN-。" class="headerlink" title="（2）其时间复杂度为O(N logN)。"></a>（2）其时间复杂度为O(N logN)。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">BuildHeap</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    ElementType t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h4><h5 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h5><h6 id="（1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性"><a href="#（1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性" class="headerlink" title="（1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性"></a>（1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性</h6><h6 id="（2）调整各结点位置，以满足最大堆的有序特性。"><a href="#（2）调整各结点位置，以满足最大堆的有序特性。" class="headerlink" title="（2）调整各结点位置，以满足最大堆的有序特性。"></a>（2）调整各结点位置，以满足最大堆的有序特性。</h6><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">BuildHeap</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ElementType t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;H-&gt;data[i];</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HuffmanTree】</title>
      <link href="/2023/09/28/%E3%80%90HuffmanTree%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90HuffmanTree%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>通过&#x3D;&#x3D;最小堆（最小堆存放树的根结点）&#x3D;&#x3D;来实现，每次拿出两个权值&#x3D;&#x3D;最小的二叉树&#x3D;&#x3D;进行合并，合并后的新树插入最小堆</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>哈夫曼<strong>树</strong> 属于 &#x3D;&#x3D;树&#x3D;&#x3D;，也是链式存储</li><li><strong>构建<code>HuffmanTree</code>之前必须先构建<code>MinHeap</code></strong></li></ol><span id="more"></span><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012075.png" alt="image-20230916123759336"></p><blockquote><ol><li>&#x3D;&#x3D;<strong><font color='red'>权值的个数即为叶子节点的个数</font></strong>&#x3D;&#x3D;</li><li>HuffmanTree编码的**<font color='gree'>码字</font><strong>均在</strong><font color='purple'>叶结点</font>**上</li></ol></blockquote><p>哈夫曼树是一种带权路径长度最短的树，在一个度为m的哈夫曼树中，其叶结点个数为n，则非叶结点的个数为<u><strong><font color='red'>（n-1) &#x2F; （m-1）</font></strong></u>。<br>        答：叶结点即度为0的结点有n个；假设度为m的结点个数为x,则x+n&#x3D;mx+1;也就是x&#x3D;n-1&#x2F;m-1;<br>        若n-1不能被整除，即所给数据不能直接构造最优m叉树，这时需要加一些不影响建树的数据，可以添0；添加的个数为(m-1)-（(n-1)%(m-1)）。所以最终x应该为⌈n-1&#x2F;m-1⌉ ，即向上取整；</p><blockquote><p>联想：信息论进行m元Huffman编码进行压缩，每m个压缩一次后减少了m-1个，最后一次压缩可能需要补零。q+t&#x3D;k(m-1)+m</p></blockquote><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* left,right;</span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree data[Maxsize];<span class="comment">//Attention!!</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MinHeap;</span><br><span class="line"></span><br><span class="line">HuffmanTree T=<span class="built_in">CreateHuffman</span>();</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树的创建-初始化"><a href="#哈夫曼树的创建-初始化" class="headerlink" title="哈夫曼树的创建(初始化)"></a>哈夫曼树的创建(初始化)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Huffman T=(Huffman)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;weight=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树的建立"><a href="#哈夫曼树的建立" class="headerlink" title="哈夫曼树的建立"></a>哈夫曼树的建立</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">BuildHuffman</span><span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;H-&gt;size;i++)<span class="comment">/*做H-&gt;Size-1次合并*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));<span class="comment">/*建立新结点*/</span></span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(H);<span class="comment">/*从最小堆中删除一个结点，作为新T的左子结点*/</span></span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(H);<span class="comment">/*再从最小堆中删除一个结点，作为新T的右子结点*/</span></span><br><span class="line">        T-&gt;weight=T-&gt;left-&gt;weight+T-&gt;right-&gt;weight;<span class="comment">/*计算新权值*/</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T);<span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="built_in">Delete</span>(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要调用的MinHeap函数"><a href="#需要调用的MinHeap函数" class="headerlink" title="需要调用的MinHeap函数"></a>需要调用的MinHeap函数</h4><h6 id="最小堆CreatHeap"><a href="#最小堆CreatHeap" class="headerlink" title="最小堆CreatHeap"></a>最小堆CreatHeap</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinHeap H=(MinHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HeapNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]=(Huffman)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;left=H-&gt;data[<span class="number">0</span>]-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;weight=<span class="number">-1</span>;<span class="comment">//哨兵H-&gt;data[0]的值最小</span></span><br><span class="line">H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h6 id="最小堆BuildHeap函数"><a href="#最小堆BuildHeap函数" class="headerlink" title="最小堆BuildHeap函数"></a>最小堆BuildHeap函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuidHeap</span> <span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    HuffmanTree t=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">    t-&gt;left=t-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t-&gt;weight;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="最小堆Delete函数"><a href="#最小堆Delete函数" class="headerlink" title="最小堆Delete函数"></a>最小堆Delete函数</h6><blockquote><ol><li>需要把<code>ElementType</code>改变成<code>HuffmanTree</code></li><li>将<code>H-&gt;data[child]</code> 改为<code>H-&gt;data[child]-&gt;weight</code> </li><li>将<code>t</code>改为<code>t-&gt;weight</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span><span class="comment">//Attention!!!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//可有可无</span></span><br><span class="line"><span class="comment">//    if(H-&gt;size==0)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line">    </span><br><span class="line">    HuffmanTree min=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点最小值，最后return</span></span><br><span class="line">   <span class="comment">/* 用最小堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    HuffmanTree t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最小的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;size&amp;&amp;H-&gt;data[child]-&gt;weight &gt; H-&gt;data[child+<span class="number">1</span>]-&gt;weight)<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;weight &lt;= H-&gt;data[child]-&gt;weight)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>将H-&gt;Elements[]按&#x3D;&#x3D;权值&#x3D;&#x3D;<code>H-&gt;Elements[]-&gt;weight</code>调整为最小堆</li><li>第11行<del>parent*&#x3D;2</del>错误，必须是<code>parent=child</code>,作用是parent索引变成儿子索引，向下交换</li><li>第9行<del><code>data[H-&gt;size]</code></del>错误，必须是<code>data[H-&gt;size--]</code></li></ol></blockquote><hr><h6 id="最小堆Insert函数"><a href="#最小堆Insert函数" class="headerlink" title="最小堆Insert函数"></a>最小堆Insert函数</h6><blockquote><ol><li>需要把<code>ElementType</code>改变成<code>HuffmanTree</code></li><li>将<code>H-&gt;data[i/2]</code> 改为<code>H-&gt;data[i/2]-&gt;weight</code> </li><li>将<code>t</code>改为<code>t-&gt;weight</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size&gt;=Maxsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t-&gt;weight &lt; H-&gt;data[i/<span class="number">2</span>]-&gt;weight;i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="WPL的计算"><a href="#WPL的计算" class="headerlink" title="WPL的计算"></a>WPL的计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意：哈夫曼树没有度为1的节点 </span></span><br><span class="line"><span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)<span class="comment">//左右子树都为空</span></span><br><span class="line"><span class="keyword">return</span> depth*T-&gt;weight;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//递归去左右子树求权重，而且深度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">WPL</span>(T-&gt;left,depth+<span class="number">1</span>)+<span class="built_in">WPL</span>(T-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>初次调用WPL时：<code>int sum=WPL(T,0);</code>使depth的初始值为&#x3D;&#x3D;0&#x3D;&#x3D;；（因为&#x3D;&#x3D;根节点的深度为0&#x3D;&#x3D;）。这里的深度<code>depth</code>实际是码字长度</li><li>递归出口为根节点<code>T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL</code></li><li>递归关系为<code>WPL(T-&gt;left,depth+1)+WPL(T-&gt;right,depth+1);</code></li><li>哈夫曼树没有度为1的节点</li></ol></blockquote><hr><h1 id="例题-05-树9-Huffman-Codes"><a href="#例题-05-树9-Huffman-Codes" class="headerlink" title="例题 05-树9 Huffman Codes"></a>例题 <strong>05-树9 Huffman Codes</strong></h1><p>In 1953, David A. Huffman published his paper “A Method for the Construction of Minimum-Redundancy Codes”, and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string “aaaxuaxz”, we can observe that the frequencies of the characters ‘a’, ‘x’, ‘u’ and ‘z’ are 4, 2, 1 and 1, respectively. We may either encode the symbols as {‘a’&#x3D;0, ‘x’&#x3D;10, ‘u’&#x3D;110, ‘z’&#x3D;111}, or in another way as {‘a’&#x3D;1, ‘x’&#x3D;01, ‘u’&#x3D;001, ‘z’&#x3D;000}, both compress the string into 14 bits. Another set of code can be given as {‘a’&#x3D;0, ‘x’&#x3D;11, ‘u’&#x3D;100, ‘z’&#x3D;101}, but {‘a’&#x3D;0, ‘x’&#x3D;01, ‘u’&#x3D;011, ‘z’&#x3D;001} is NOT correct since “aaaxuaxz” and “aazuaxax” can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives an integer <em>N</em> (2≤<em>N</em>≤63), then followed by a line that contains all the <em>N</em> distinct characters and their frequencies in the following format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[1] f[1] c[2] f[2] ... c[N] f[N]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is a character chosen from {‘0’ - ‘9’, ‘a’ - ‘z’, ‘A’ - ‘Z’, ‘_’}, and <code>f[i]</code> is the frequency of <code>c[i]</code> and is an integer no more than 1000. The next line gives a positive integer <em>M</em> (≤1000), then followed by <em>M</em> student submissions. Each student submission consists of <em>N</em> lines, each in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i] code[i]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is the <code>i</code>-th character and <code>code[i]</code> is an non-empty string of no more than 63 ‘0’s and ‘1’s.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in each line either “Yes” if the student’s submission is correct, or “No” if not.</p><p>Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">A 1 B 1 C 1 D 3 E 3 F 6 G 6</span><br><span class="line">4</span><br><span class="line">A 00000</span><br><span class="line">B 00001</span><br><span class="line">C 0001</span><br><span class="line">D 001</span><br><span class="line">E 01</span><br><span class="line">F 10</span><br><span class="line">G 11</span><br><span class="line">A 01010</span><br><span class="line">B 01011</span><br><span class="line">C 0100</span><br><span class="line">D 011</span><br><span class="line">E 10</span><br><span class="line">F 11</span><br><span class="line">G 00</span><br><span class="line">A 000</span><br><span class="line">B 001</span><br><span class="line">C 010</span><br><span class="line">D 011</span><br><span class="line">E 100</span><br><span class="line">F 101</span><br><span class="line">G 110</span><br><span class="line">A 00000</span><br><span class="line">B 00001</span><br><span class="line">C 0001</span><br><span class="line">D 001</span><br><span class="line">E 00</span><br><span class="line">F 10</span><br><span class="line">G 11</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>400 ms</p><p>内存限制</p><p>64 MB</p><p><a href="%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC(%E6%85%95%E8%AF%BE">解题思路</a> (icourse163.org)](<a href="https://www.icourse163.org/learn/ZJU-93001?tid=1468077441#/learn/content?type=detail&id=1249683129&cid=1277237407">https://www.icourse163.org/learn/ZJU-93001?tid=1468077441#/learn/content?type=detail&amp;id=1249683129&amp;cid=1277237407</a>))</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012036.png" alt="image-20220923151214229"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012970.png" alt="image-20220923151404979"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012024.png" alt="image-20220923151427266"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 64</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建MinHeap和HeapNode结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* left, *right;</span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree data[Maxsize];<span class="comment">//Attention!!</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MinHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line"><span class="type">int</span> n,m,min_length;<span class="type">char</span> c; </span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span>;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//建立最小堆 </span></span><br><span class="line">MinHeap H=<span class="built_in">CreatHeap</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    HuffmanTree t=<span class="built_in">CreateHuffman</span>(); </span><br><span class="line">        cin&gt;&gt;c&gt;&gt;t-&gt;weight;</span><br><span class="line">        cnt[c]=t-&gt;weight;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  建立哈夫曼树 </span></span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="type">int</span> n=H-&gt;size; </span><br><span class="line"><span class="comment">//  for(int i=1;i&lt;H-&gt;size;i++) 错误，H-&gt;size的值会在循环中改变 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">/*做n-1次合并*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(H);</span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(H);</span><br><span class="line">        T-&gt;weight=T-&gt;left-&gt;weight+T-&gt;right-&gt;weight;<span class="comment">/*计算新权值*/</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T);<span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="built_in">Delete</span>(H);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  计算最短长度 </span></span><br><span class="line">min_length=<span class="built_in">WPL</span>(T,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//判断 </span></span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">judge</span>())<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinHeap H=(MinHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HeapNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;left=H-&gt;data[<span class="number">0</span>]-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;weight=<span class="number">-1</span>;<span class="comment">//哨兵H-&gt;data[0]的值最小</span></span><br><span class="line">H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HuffmanTree T=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;weight=<span class="number">0</span>;<span class="comment">//Attention！！</span></span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    可有可无 </span></span><br><span class="line"><span class="comment">//    if(H-&gt;size&gt;=Maxsize)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t-&gt;weight &lt; H-&gt;data[i/<span class="number">2</span>]-&gt;weight;i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    HuffmanTree min=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点（weight最小），最后return</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 用最小堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    HuffmanTree t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最小的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;size&amp;&amp;H-&gt;data[child]-&gt;weight &gt; H-&gt;data[child+<span class="number">1</span>]-&gt;weight)<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;weight&lt;=H-&gt;data[child]-&gt;weight)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意：哈夫曼树没有度为1的节点 </span></span><br><span class="line"><span class="keyword">if</span>((T-&gt;left==<span class="literal">NULL</span>)&amp;&amp;(T-&gt;right==<span class="literal">NULL</span>))<span class="comment">//左右子树都为空</span></span><br><span class="line"><span class="keyword">return</span> depth*T-&gt;weight;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//递归去左右子树求权重，而且深度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">WPL</span>(T-&gt;left,depth+<span class="number">1</span>)+<span class="built_in">WPL</span>(T-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">string codes; </span><br><span class="line">HuffmanTree T=<span class="built_in">CreateHuffman</span>();      <span class="comment">//模拟建树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c&gt;&gt;codes;</span><br><span class="line"><span class="keyword">if</span>(codes.<span class="built_in">length</span>()&gt;=n)<span class="comment">//也可以没有这个判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree p = T;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;codes.<span class="built_in">length</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(codes[j]==<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">p-&gt;left = <span class="built_in">CreateHuffman</span>();</span><br><span class="line">p = p-&gt;left;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(codes[j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">p-&gt;right = <span class="built_in">CreateHuffman</span>();</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;weight) <span class="comment">//说明已经被访问过了 </span></span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//不能直接打印，要把后面的读完 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;left || p-&gt;right )<span class="comment">//说明该结点不是叶子节点 </span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p-&gt;weight = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">len += codes.<span class="built_in">length</span>()*cnt[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(len!=min_length)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><blockquote><p>judge函数模拟建树过程中</p><ol><li>左右移动过程中不能遇到<strong>已经访问的节点</strong></li><li>最后赋值的节点必须是<strong>叶节点</strong></li><li>节点weight起到标记flag的作用</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【栈】</title>
      <link href="/2023/09/28/%E3%80%90%E6%A0%88%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90%E6%A0%88%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一：顺序栈"><a href="#一：顺序栈" class="headerlink" title="一：顺序栈"></a>一：顺序栈</h1><h3 id="1、表示"><a href="#1、表示" class="headerlink" title="1、表示"></a>1、表示</h3><ul><li><p>因为栈底位置是固定不变的，所以可以将栈底位置设置在数组的任何一个端点；</p></li><li><p>栈顶位置是随着进栈和退栈操作而变化的，故需要一个变量top来指示当前栈顶的位置，通常称top为**<font color='red'>栈顶指针</font>**。</p></li></ul><blockquote><p><strong><font color='red'>栈顶指针top</font><strong>指向</strong><font color='blue'>栈顶元素的下一个位置</font></strong></p></blockquote><span id="more"></span><h3 id="2、顺序栈的定义"><a href="#2、顺序栈的定义" class="headerlink" title="2、顺序栈的定义"></a>2、顺序栈的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* base;<span class="comment">//栈底指针</span></span><br><span class="line">ElementType* top;<span class="comment">//栈顶指针</span></span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//可使用的最大容量</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">Stack S;<span class="comment">//定义顺序栈</span></span><br><span class="line">S.stacksize = s;<span class="comment">//栈的大小</span></span><br><span class="line">S.base == S.top;<span class="comment">//空栈</span></span><br><span class="line">S.top - S.base == stacksize;<span class="comment">//满栈</span></span><br></pre></td></tr></table></figure><h3 id="2、顺序栈初始化"><a href="#2、顺序栈初始化" class="headerlink" title="2、顺序栈初始化"></a>2、顺序栈初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.base = <span class="keyword">new</span> SElemType[MAXSIZE];<span class="comment">//分配空间</span></span><br><span class="line"><span class="keyword">if</span> (!S.base) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//分配失败，返回错误</span></span><br><span class="line">S.top = S.base;<span class="comment">//栈顶指针初始化为栈底指针</span></span><br><span class="line">S.stacksize = MAXSIZE;<span class="comment">//初始化栈的最大容量</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>**<font color='red'>exit是c++程序的退出函数</font>**，声明为<code>void exit(int value)</code>，其功能是退出当前的程序，并将参数value返回主调进程</li><li>**<font color='red'>OVERFLOW为math.h的一个宏定义</font>**，其值为3。含义为运算过程中出现了上溢，运算结果超出了运算变量所能存储的范围。</li><li>所以，<code>exit(OVERFLOW)</code>的含义就是，退出程序，并返回OVERFLOW的值给主调进程。其标准的使用范围为，当程序运算出现上溢时，退出程序并报错给主调进程。</li></ul></blockquote><h3 id="3、顺序栈入栈"><a href="#3、顺序栈入栈" class="headerlink" title="3、顺序栈入栈"></a>3、顺序栈入栈</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855471.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Stack&amp; S, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top - S.base == S.stacksize)<span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*S.top++ = e;<span class="comment">//新元素e压入栈顶，同时将栈顶指针+1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、顺序栈出栈"><a href="#4、顺序栈出栈" class="headerlink" title="4、顺序栈出栈"></a>4、顺序栈出栈</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855473.png" alt="在这里插入图片描述"></p><blockquote><p>算法思想<br>1、判断是否栈空，若空则出错<br>2、栈顶指针-1<br>3、获取栈顶元素e（**<font color='red'>引用&amp;返回</font>**）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack&amp; S, ElementType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//栈空报错</span></span><br><span class="line">e = *--S.top;<span class="comment">//获取栈顶元素e，同时将栈顶指针-1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、取顺序栈栈顶元素"><a href="#5、取顺序栈栈顶元素" class="headerlink" title="5、取顺序栈栈顶元素"></a>5、取顺序栈栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">GetTop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top != S.base)<span class="comment">//栈非空</span></span><br><span class="line"><span class="keyword">return</span> *(S.top - <span class="number">1</span>);<span class="comment">//返回栈顶元素的值</span></span><br><span class="line">                        <span class="comment">//栈顶指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、输出栈内容"><a href="#6、输出栈内容" class="headerlink" title="6、输出栈内容"></a>6、输出栈内容</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut_SqS</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == S.base)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空栈！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (ElementType* p = S.top - <span class="number">1</span> ; p &gt;= S.base ; p--)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二：链栈"><a href="#二：链栈" class="headerlink" title="二：链栈"></a>二：链栈</h1><blockquote><p>1、链式存储方式表示的栈称链栈<br>2、运算受限的单链表<br>3、**<font color='red'>链表的头结点就是栈顶</font>**<br>4、**<font color='blue'>插入与删除仅在栈顶执行</font>**</p></blockquote><h3 id="1、链栈的存储结构"><a href="#1、链栈的存储结构" class="headerlink" title="1、链栈的存储结构"></a>1、链栈的存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*Stack;</span><br><span class="line"></span><br><span class="line">Stack S;</span><br></pre></td></tr></table></figure><h3 id="2、链栈的初始化"><a href="#2、链栈的初始化" class="headerlink" title="2、链栈的初始化"></a>2、链栈的初始化</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855474.png" alt="image-20221110233126960"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!S)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、链栈的入栈"><a href="#3、链栈的入栈" class="headerlink" title="3、链栈的入栈"></a>3、链栈的入栈</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855475.png" alt="image-20221110235147314"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(Stack&amp; S, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> Node;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="comment">//头插法    </span></span><br><span class="line">p-&gt;next = S-&gt;next;</span><br><span class="line">S-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、链栈的出栈"><a href="#4、链栈的出栈" class="headerlink" title="4、链栈的出栈"></a>4、链栈的出栈</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855476.png" alt="image-20221110235341367"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack&amp; S, ElementType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> ERROR;<span class="comment">//栈空</span></span><br><span class="line">    p = S-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">    </span><br><span class="line">S-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、取链栈栈顶元素"><a href="#5、取链栈栈顶元素" class="headerlink" title="5、取链栈栈顶元素"></a>5、取链栈栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">GetTop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = S-&gt;next;</span><br><span class="line"><span class="keyword">if</span> ( p != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、输出链栈的内容"><a href="#6、输出链栈的内容" class="headerlink" title="6、输出链栈的内容"></a>6、输出链栈的内容</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* p = S-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空栈！&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290854572.png" alt="image-20230929085414412"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsReverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断输入的字符串中‘&amp;’前后两部分是否为逆串，是则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;s;<span class="type">char</span> c,t;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        s.<span class="built_in">push</span>(c);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t!=c)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>判断是否为逆序通常需要使用**<code>stack</code>**</li><li>注意<strong>第9，第13行</strong>。</li></ol></blockquote><h3 id="例二：数制转换"><a href="#例二：数制转换" class="headerlink" title="例二：数制转换"></a>例二：数制转换</h3><p>基于栈设计一个算法，将一个十进制整数d转化为相应的r进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=d%r;</span><br><span class="line">        s.<span class="built_in">push</span>(t);</span><br><span class="line">        d/=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例三：回文数的判断"><a href="#例三：回文数的判断" class="headerlink" title="例三：回文数的判断"></a>例三：回文数的判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;    stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        t=n%<span class="number">10</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(t);</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">       t=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855477.png" alt="image-20221110223733088"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855478.png" alt="image-20221111125540175"></p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType v[m];</span><br><span class="line">    <span class="type">int</span> top[<span class="number">2</span>];<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure><h4 id="建栈"><a href="#建栈" class="headerlink" title="建栈"></a>建栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(Stack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.top[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    S.top[<span class="number">1</span>]=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Stack &amp;S,ElementType x,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top[<span class="number">1</span>]-S.top[<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:S.v[++S.top[<span class="number">0</span>]]=x;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: S.v[--S.top[<span class="number">1</span>]]=x;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack &amp;S, ElementType &amp;x, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(S.top[<span class="number">0</span>]==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x=S.v[S.top[<span class="number">0</span>]--];</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(S.top[<span class="number">1</span>]==m)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            x=S.v[S.top[<span class="number">1</span>]++];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例五：表达式求值"><a href="#例五：表达式求值" class="headerlink" title="例五：表达式求值"></a>例五：表达式求值</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855479.png" alt="image-20221111000921743"></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><hr><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855480.png" alt="image-20221111125043545"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855481.png" alt="image-20221111125349605"></p><h3 id="例五：括号匹配"><a href="#例五：括号匹配" class="headerlink" title="例五：括号匹配"></a>例五：括号匹配</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855482.png" alt="image-20221111110712016"></p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855483.png" alt="image-20221111110734311"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855484.png" alt="image-20221111110748683"></p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;stack&lt;<span class="type">char</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;(&#x27;</span> || ch==<span class="string">&#x27;[&#x27;</span> || ch==<span class="string">&#x27;&#123;&#x27;</span> ):</span><br><span class="line">                s.<span class="built_in">push</span>(ch);<span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;)&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(t!=<span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;[&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(t!=<span class="string">&#x27;]&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;&#123;&#x27;</span> ):</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">if</span>(t!=<span class="string">&#x27;&#125;&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例六：迷宫求解"><a href="#例六：迷宫求解" class="headerlink" title="例六：迷宫求解"></a>例六：迷宫求解</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855485.png" alt="image-20221211163004047"></p><p>[栈和队列](D:\Document\已结课资料\数据结构\老师课件\第3章 栈和队列22.pdf)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【查找】</title>
      <link href="/2023/09/28/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290957892.png" alt="image-20230929095705501"></p><span id="more"></span><h1 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h1><p><font color='red'><strong>Static Search Table</strong></font>：不涉及**<font color='blue'>插入和删除</font>**操作</p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素类型的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">keyType key;<span class="comment">//关键字域</span></span><br><span class="line">InfoType otherInfo;<span class="comment">//其他域</span></span><br><span class="line">&#125;ElementType;</span><br><span class="line"><span class="comment">//静态查找表的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElememtType* R;<span class="comment">//数据元素存储空间基地址，建表时按实际长度分配，0号单元留空</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//表长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line">SSTable ST;<span class="comment">//定义顺序表ST</span></span><br><span class="line"><span class="comment">//设元素从ST.R[1]开始向后顺序存放，ST.R[0]不用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, keyType key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ST.length;i &gt;= <span class="number">1</span>;--i)</span><br><span class="line"><span class="keyword">if</span> (ST.R[i].key == key)</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//从后往前找</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>ElememtType* R;</code></strong></p><p>数据元素存储空间<strong>基地址</strong>，建表时按<strong>实际长度（length）</strong>malloc分配，**<font color='red'>0号单元留空</font>**</p></blockquote><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>&#x3D;&#x3D;改进&#x3D;&#x3D;：把待查<strong>关键字key</strong>存入**<font color='red'>表头(0号单元)</font><strong>，充当</strong><font color='blue'>“哨兵“</font><strong>，从后向前逐个比较时，可</strong>免去**查找过程中每一步都要检测是否查找完毕.<img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949384.png" alt="在这里插入图片描述">加快速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, keyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//若成功返回其位置信息，否找返回0</span></span><br><span class="line">ST.R[<span class="number">0</span>].key = key;<span class="comment">//哨兵</span></span><br><span class="line"><span class="keyword">for</span> (i = ST.length;ST.R[i].key != key;--i)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="comment">//不用for (int i = ST.length;i &gt;= 1;--i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引查找"><a href="#索引查找" class="headerlink" title="索引查找"></a>索引查找</h2><h3 id="存储要求"><a href="#存储要求" class="headerlink" title="存储要求"></a>存储要求</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949385.png" alt="image-20221025123336315"></p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><blockquote><p><strong>折半查找</strong>又称<strong>二分查找</strong>，前提条件是**<font color='red'>顺序存储且数组元素有序</font>**</p></blockquote><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>设表长为<code>n</code>，<code>low</code>，<code>high</code>，<code>mid</code>分别指向待查元素所在区间的上界、下界和中点，key为要查找的值。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949386.png" alt="在这里插入图片描述"></p><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素类型的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">keyType key;<span class="comment">//关键字域</span></span><br><span class="line">InfoType otherInfo;<span class="comment">//其他域</span></span><br><span class="line">&#125;ElementType;</span><br><span class="line"><span class="comment">//顺序表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* R;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若找到，则函数值为该元素在表中的位置，否则为0</span></span><br><span class="line">low = <span class="number">1</span>;high = ST.length;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (key == ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key)</span><br><span class="line">high = mid - <span class="number">1</span>;<span class="comment">//前一子表查找</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;<span class="comment">//后一子表查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表中不存在待查元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>18行注意是&#x3D;&#x3D;low**<code>&lt;=</code>**high&#x3D;&#x3D;</p></blockquote><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType* R;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin_re</span><span class="params">(SSTable ST, KeyType key,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若找到，则函数值为该元素在表中的位置，否则为0</span></span><br><span class="line"><span class="keyword">if</span> (low &gt; high)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表中不存在待查元素</span></span><br><span class="line"><span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (key == ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Search_Bin_re</span>(ST, key, low, mid - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Search_Bin_re</span>(ST, key, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="折半查找判定树的画法"><a href="#折半查找判定树的画法" class="headerlink" title="折半查找判定树的画法"></a>折半查找判定树的画法</h2><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>​在计算mid值时，使用的时mid&#x3D;（low+high）&#x2F;2  。这里由于mid为int类型，自动默认为向下取整，因此对于一个长度为n序列进行划分之后的序列为 **<code>（0，1，2，……，mid-1）mid（mid+1，mid+2，……n-1）</code>**，此时出现两种情况：</p><ul><li><p>左子序列长&#x3D;&#x3D;右子序列长      （n&#x3D;2k+1    k&#x3D;0，1，2，……）</p></li><li><p>左子序列长&#x3D;&#x3D;右子序列长-1   （n&#x3D;2k        k&#x3D;1，2，3，……）</p></li></ul><p>因此可以得知，**<font color='purple'>折半查找</font><strong>的二叉判定树对于所有结点，</strong><font color='red'>右子树结点个数 &gt;&#x3D; 左子树结点个数。</font>**即：</p><ul><li>若某序列总长n为奇数，左右子树结点个数相等；</li><li>若某序列总长n为偶数，左字数结点个数&#x3D;右子树结点个数-1.</li></ul><blockquote><p>换句话说，对判定树中所有结点都有：<br>（右子树结点数 - 左子树结点数 &#x3D;&#x3D; 1）||（右子树结点数 — 左子树结点数 &#x3D;&#x3D; 0）</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><strong>由此给定某个序列，构建折半查找判定树方法如下三步：</strong></p><ol><li>按照结点总数先画出**<font color='blue'>最大的满二叉树</font>**结构，并计算剩余几个结点。</li><li>将剩余结点按照上述的规律依次填入最底层即为二叉判定树的树形。</li><li>将给定序列依次按照**<font color='red'>中序遍历</font>**顺序填入各个结点。</li></ol><blockquote><p><strong><font color='blue'>折半查找判定树</font><strong>也是</strong><font color='red'>二叉查找树</font><strong>，故</strong>中序遍历即为递增序列</strong></p></blockquote><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>画出（2，5，7，10，14，15，18，23，35，41，52）的折半查找判定树。</p><blockquote><p>折半查找的前提就是<strong>序列有序</strong></p></blockquote><ol><li>序列总长度为n&#x3D;11&gt;2^3-1     即二叉判定树为4层，前三层为满二叉树结构，剩余4个结点。</li></ol><p>​先画出前三层结构。</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949387.png" alt="img" style="zoom:50%;" /><ol start="2"><li></li></ol><p>1）第一个结点。a的左右子树结点个数相等，所以新的结点应加入a的右子树；再看a的右子树，c的左右子树结点个数相等，所以新结点应加入c的右子树；再看c的右子树，g的左右子树结点个数相等，所以新结点应加入g的右子树；如图</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949388.png" alt="img" style="zoom:50%;" /><p>2）第二个结点。a的左子树结点数-右子树结点数&#x3D;-1，所以新结点应加入a的左子树（若加入右子树，对于a来说左右子树结点之差&#x3D;-2，不符合规律）；再看a的左子树，b的左右子树结点个数相等，所以新结点应加入b的右子树；再看b的右子树，e的左右子树结点个数相等，所以新结点应加入e的右子树。如图</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949389.png" alt="img" style="zoom:50%;" /><p>3）同理分析，第三个结点应加在如图位置。</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949390.png" alt="img" style="zoom:50%;" /><p>4）第四个结点加在如图位置。</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949391.png" alt="img" style="zoom: 67%;" /><p>得到最终的树形如上图。（字母编号不唯一，但后面中序遍历结果会不同）</p><p>3.该二叉树的**<font color='red'>中序遍历</font>**顺序为dkbeiafjcgh，分别对应2，5，7，10，14，15，18，23，35，41，52。因此将序列一一对应填入树中，即</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949392.png" alt="img" style="zoom:67%;" /><p>该树即为此序列的二叉判定树。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>做题过程中熟练使用此方法比通过算法模拟来推断二叉判定树的速度要快许多倍。</p><p>在平时做题过程中，涉及到需要具体画出二叉判定树的题目，往往结点个数（序列长度）不超过2^4-1&#x3D;15个，即一般为高度不超过4的树，因此可以在练习时将结点个数8-14的所有树形画几遍，就可以很熟练的掌握这个方法。</p><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>一个递增有序表为R[0..11]，采用折半查找方法进行查找，在一次不成功查找中，以下（ ）是不可能的记录比较序列。</p><p>A.R[5]、R[8]、R[10]</p><p>B.R[5]、R[8]、R[6]、R[7]</p><p>C.R[5]、R[2]、R[3]</p><p>D.R[5]、R[8]、R[6]</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949393.jpg" alt="56cb394ddbe752ccadbe544a3b9f40c"></p><blockquote><p>一次失败的查找必须查找到**<font color='red'>叶结点&#x2F;只有一个儿子节点</font>**处</p></blockquote><h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949394.png" alt="image-20221111202130826"></p><p>答案：**<font color='red'>B</font>**</p><h1 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h1><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><blockquote><p>详细见—-数据结构【图】</p></blockquote><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949395.png" alt="image-20221104133158218"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949396.jpg" alt="8b2b8cf18df013cb2e84b09b02b897b"></p><p>[AVL树画法](C:\Users\cuiluyi\Desktop\编程随想\数据结构 [AVL树画法] .md)</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949397.jpg" alt="13312013948078200"></h1><h1 id="哈希查找的ASL"><a href="#哈希查找的ASL" class="headerlink" title="哈希查找的ASL"></a>哈希查找的ASL</h1><h2 id="查找成功的ASL"><a href="#查找成功的ASL" class="headerlink" title="查找成功的ASL"></a>查找成功的ASL</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002906.png" alt="在这里插入图片描述"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>题目条件通常是在**<font color='red'>等概率下</font>查找<strong>，所以</strong><code>ASL=（C0+C1+...+Cn）/n.</code>**</li><li>查找成功是针对&#x3D;&#x3D;<strong><font color='red'>关键字</font></strong>&#x3D;&#x3D;查找的，最后除以**<font color='blue'>关键字的总个数</font>**。</li></ol><h2 id="查找失败的ASL"><a href="#查找失败的ASL" class="headerlink" title="查找失败的ASL"></a>查找失败的ASL</h2><h3 id="查找失败的原因"><a href="#查找失败的原因" class="headerlink" title="查找失败的原因"></a>查找失败的原因</h3><p>如果我们要查找<strong>表中的元素</strong>，那么一定可以找到，所以讨论查找失败就没有意义。我们讨论查找失败，一定是针对**<font color='orange'>表中没有的元素</font>**在哈希表中查找，才有查找失败的意义。</p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ol><li>查找失败是针对**<font color='red'>表中没有的元素，是对位置的查找</font>**</li><li>失败查找次数就是该位置<strong>向后探测到第一个没有关键字的地址位置之间的距离</strong></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例一-1"><a href="#例一-1" class="headerlink" title="例一"></a>例一</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002983.png" alt="在这里插入图片描述"></p><pre><code>构建出来的哈希表有八个元素，针对这八个元素的比较次数，得出ASLsuccess=(1+1+1+2+1+2+1+2)/8=11/8.</code></pre><p>而查找失败时的平均查找长度，却是针对位置的查找。<br>为什么呢，因为如果我们要查找表中的元素，那么一定可以找到，所以讨论查找失败就没有意义。我们讨论查找失败，一定是针对表中没有的元素在这张表中查找，才有查找失败的意义。</p><p>所以，针对上图的哈希表，我们将待查找关键字X代入哈希函数，我们设定X与这张表中的关键字都不相同：</p><ol><li><p>当H(X)&#x3D;3X mod 11&#x3D;0时，因为散列地址为0的位置没有关键字，所以查找1次就失败了；</p></li><li><p>当H(X)&#x3D;3X mod 11&#x3D;1时，因为散列地址为1的位置有关键字4，X与4不等，所以按照线性探测法向后探测1，散列地址为2的位置没有关键字，所以查找失败，一共查找了2次；</p></li><li><p>当H(X)&#x3D;3X mod 11&#x3D;2时，同0；</p></li><li><p>当H(X)&#x3D;3X mod 11&#x3D;3时，因为散列地址为3的位置有关键字12，X与12不等，所以向后线性探测，散列地址为4的位置有关键字49，还不等，继续探测，因为X与表中的关键字都不等，所以直到散列地址为10没有关键字，才查找失败，这次一共查找了8次；<br> …以此类推</p></li></ol><blockquote><h4 id="1-失败查找次数就是-该位置向后探测到第一个没有关键字的地址位置之间的距离"><a href="#1-失败查找次数就是-该位置向后探测到第一个没有关键字的地址位置之间的距离" class="headerlink" title="1. 失败查找次数就是**该位置向后探测到第一个没有关键字的地址位置之间的距离**"></a>1. 失败查找次数就是**<font color='blue'>该位置向后探测到第一个没有关键字的地址位置之间的距离</font>**</h4><h4 id="2-而求平均数的除数，是-模的大小"><a href="#2-而求平均数的除数，是-模的大小" class="headerlink" title="2. 而求平均数的除数，是**模的大小**"></a>2. 而求平均数的除数，是**<font color='red'>模的大小</font>**</h4></blockquote><p>因为失败查找次数是针对位置查找，因为模为11，所以查找的位置(哈希函数的值)为0-10(共11个),针对这11个位置进行查找，而与表的长度无关。</p><p>理清了思路，我们来看看链地址法表示的哈希表：</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002875.png" alt="img" style="zoom:80%;" /><pre><code>    成功时的平均查找长度很好求，针对表中的每个关键字：有五个关键字找一次：4,12,49,13,32；三个关键字找两次：38,24,21.</code></pre><p>失败时的平均查找长度针对位置来查找：</p><ol><li>等于0时，只有空指针域，查找1次；</li><li>等于1时，带一个结点，所以查找2次找到空指针；<br> …</li><li>等于4时，带两个节点，所以查找3次找到空指针；<br> …</li><li>综上所述，我们可以总结：</li></ol><p>&#x3D;&#x3D;<strong>失败查找次数就是当前位置所带的结点个数+1</strong>&#x3D;&#x3D;<br>使用链地址法查找时无二次聚集现象(二次聚集：处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象)</p><p>&#x3D;&#x3D;<strong>除数也是模的大小</strong>&#x3D;&#x3D;</p><blockquote><p><strong>查找成功时，分母为哈希表元素个数；</strong></p><p><strong>查找不成功时，分母为哈希表长度。</strong></p><p><strong>计算查找不成功的次数就直接找关键字到第一个地址上关键字为空的距离即可；</strong></p></blockquote><h3 id="例二-1"><a href="#例二-1" class="headerlink" title="例二"></a>例二</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002818.png" alt="img"></p><h3 id="例三-1"><a href="#例三-1" class="headerlink" title="例三"></a>例三</h3><p>将关键字序列（7、8、30、11、18、9、14）散列存储到散列表中。散列表的存储空间是一个下标从0开始的一维数组。散列函数为： H(key) &#x3D; (keyx3) MOD T，处理冲突采用线性探测再散列法，要求装填（载）因子为0.7。<br>(1) 请画出所构造的散列表；<br>(2) 分别计算等概率情况下查找成功和查找不成功的平均查找长度。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002054.jpeg" alt="752a42495403f7b79fb9becef3eb5c8"></p><h3 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002811.jpeg" alt="54636c164030154e379275639ca60fe"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002407.png" alt="image-20221025140718996"></p><blockquote><p>d<del>i</del>为增量，**<code>i((7k)MOD10+1)</code>**省略了乘号，中间是k（关键字）</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002571.jpeg" alt="13312114798622059"></p><p>不成功**<code>30/11</code>**</p><h1 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h1><ul><li><h2 id="实验四：基于词频的文件相似度"><a href="#实验四：基于词频的文件相似度" class="headerlink" title="实验四：基于词频的文件相似度"></a>实验四：基于词频的文件相似度</h2></li></ul><p>实现一种简单原始的文件相似度计算，即以两文件的公共词汇占总词汇的比例来定义相似度。为简化问题，这里不考虑中文（因为分词太难了），只考虑长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。</p><p><strong>输入格式:</strong></p><p>输入首先给出正整数<em>N</em>（≤100），为文件总数。随后按以下格式给出每个文件的内容：首先给出文件正文，最后在一行中只给出一个字符<code>#</code>，表示文件结束。在<em>N</em>个文件内容结束之后，给出查询总数<em>M</em>（≤104），随后<em>M</em>行，每行给出一对文件编号，其间以空格分隔。这里假设文件按给出的顺序从1到<em>N</em>编号。</p><p><strong>输出格式:</strong></p><p>针对每一条查询，在一行中输出两文件的相似度，即两文件的公共词汇量占两文件总词汇量的百分比，精确到小数点后1位。注意这里的一个“单词”只包括仅由英文字母组成的、长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。单词间以任何非英文字母隔开。另外，大小写不同的同一单词被认为是相同的单词，例如“You”和“you”是同一个单词。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">Aaa Bbb Ccc</span><br><span class="line">#</span><br><span class="line">Bbb Ccc Ddd</span><br><span class="line">#</span><br><span class="line">Aaa2 ccc Eee</span><br><span class="line">is at Ddd@Fff</span><br><span class="line">#</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50.0%</span><br><span class="line">33.3%</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949398.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODk3MjYx,size_16,color_FFFFFF,t_70-1666415229140-5"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949399.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODk3MjYx,size_16,color_FFFFFF,t_70-1666415220872-3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[<span class="number">11</span>],ch;</span><br><span class="line"><span class="type">int</span> com[<span class="number">101</span>][<span class="number">101</span>],num[<span class="number">101</span>],sn;</span><br><span class="line">map&lt;string,<span class="type">bool</span>&gt; mp[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span>((ch = <span class="built_in">tolower</span>(<span class="built_in">getchar</span>())) != <span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">                <span class="keyword">if</span>(sn &lt; <span class="number">10</span>) s[sn ++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">                s[sn] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sn &gt; <span class="number">2</span>) mp[i][s] = <span class="number">1</span>;</span><br><span class="line">                sn = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;string,<span class="type">bool</span>&gt;::iterator it = mp[i].<span class="built_in">begin</span>();it != mp[i].<span class="built_in">end</span>();it ++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j ++) </span><br><span class="line">                com[i][j] = com[j][i] += mp[j][it -&gt; first];</span><br><span class="line">        com[i][i] = num[i] = mp[i].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.1f%\n&quot;</span>,com[a][b] * <span class="number">100.0</span> / (num[a] + num[b] - com[a][b]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>17-19行的**<code>&#123; &#125;</code><strong>不能省略，否则下面的</strong><code>else</code>**配对出错</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图】</title>
      <link href="/2023/09/28/%E3%80%90%E5%9B%BE%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90%E5%9B%BE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017409.png" alt="image-20221105083921772"></p><span id="more"></span><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="（一）邻接矩阵（Adjacency-Matrix"><a href="#（一）邻接矩阵（Adjacency-Matrix" class="headerlink" title="（一）邻接矩阵（Adjacency Matrix)"></a>（一）邻接矩阵（Adjacency Matrix)</h2><h3 id="1，存储结构"><a href="#1，存储结构" class="headerlink" title="1，存储结构"></a>1，存储结构</h3><blockquote><ol><li><p>图是由<strong>顶点</strong>和<strong>边&#x2F;弧</strong>两部分组成，合在一起比较困难，可以分为两个结构来存储</p></li><li><p><strong>顶点</strong>因为不区分大小，主次，所以可以用一个<font color='red'><strong>一维数组</strong>来存储顶点</font>，记录各个顶点的信息</p></li><li><p><strong>边&#x2F;弧</strong>是顶点和顶点的关系，用<strong>邻接矩阵</strong>来存储，表示各个顶点之间的邻接关系。是图的**<font color='red'>顺序存储结构</font>**</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;  <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><blockquote><p>注：<strong>VertexType</strong>和<strong>ArcType</strong>等价于<strong>ElementType</strong></p><ol><li><p>**<code>ElementType</code>**既可以是<code>int</code>，<code>char</code>，<code>double</code>，<code>float</code>等，即</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> ElementType;    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ElementType ;      </span><br></pre></td></tr></table></figure><blockquote><p>注意typedef最后面的<font color='red'><strong>分号</strong></font></p></blockquote><p> <strong><code>ElementType</code><strong>也可以是自定义的</strong>struct类型</strong>，eg：</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;ElementType;</span><br></pre></td></tr></table></figure></li><li><p><code>MVNum</code>与<code>MaxInt</code>需要通过宏定义</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><hr><h3 id="2，采用邻接矩阵创建无向网"><a href="#2，采用邻接矩阵创建无向网" class="headerlink" title="2，采用邻接矩阵创建无向网"></a>2，采用邻接矩阵创建无向网</h3><blockquote><p>【算法步骤】<br>1、输入总顶点数和边数<br>2、依次输入点的信息存入到顶点表中<br>3、初始化邻接矩阵，使每个权值初始化为极大值<br>4、构造邻接矩阵</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用邻接矩阵表示法创建无向网*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateUDN</span><span class="params">(Graph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入总顶点数和总边数</span></span><br><span class="line">cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输入顶点表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">cin &gt;&gt; G.vexs[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入邻接矩阵</span></span><br><span class="line"><span class="comment">    1. 初始化邻接矩阵，边的权值均置为极大值    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*法一：</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; G.vexnum;++i)</span></span><br><span class="line"><span class="comment">for (int j = 0;j &lt; G.vexnum;++j)</span></span><br><span class="line"><span class="comment">G.arcs[i][j] = INT_MAX;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line">    <span class="built_in">fill</span>(G.arcs[<span class="number">0</span>],G.arc[<span class="number">0</span>] + G.vexnum * G.vexnum, INT_MAX);<span class="comment">//头文件：#include &lt;algorithm&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2. 输入边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.arcnum;++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输入一条边依附的顶点和权值        </span></span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line"><span class="comment">//确定两个顶点v1和v2在G中的位置        </span></span><br><span class="line">i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line"><span class="comment">//无向网 边&lt;v1,v2&gt;和&lt;v2,v1&gt;的权值均置为w        </span></span><br><span class="line">G.arcs[i][j] = G.arcs[j][i] = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在图中查找顶点的位置LocateVex()函数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(Graph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若在图中找到这个元素，则返回它的下标i,否则返回-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line"><span class="keyword">if</span> (u == G.vexs[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>问：图的邻接矩阵，不相连的边用0还是无穷？</p><blockquote><p>——–那要看你的边权到底是拿来干嘛用的了</p><ul><li><p>若做路径搜索&#x2F;最小生成树&#x2F;最短距离，边权是路程长度，那不连通的理所应当用inf。</p></li><li><p>但若仅判断有无边，无关长度&#x2F;路径&#x2F;代价，无连接的时候自然可以用0</p></li></ul></blockquote><h4 id="1：（无向-有向）图的邻接矩阵"><a href="#1：（无向-有向）图的邻接矩阵" class="headerlink" title="1：（无向&#x2F;有向）图的邻接矩阵"></a>1：（无向&#x2F;有向）图的邻接矩阵</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017348.png" alt="image-20221101200143602"></p><blockquote><p><strong><font color='blue'>无边用0表示</font></strong></p></blockquote><p>例如：<img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017365.png" alt="image-20221101200513851"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017328.png" alt="image-20221101200537514"></p><h4 id="2：（有向-无向）网"><a href="#2：（有向-无向）网" class="headerlink" title="2：（有向&#x2F;无向）网"></a>2：（有向&#x2F;无向）网</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017324.png" alt="image-20221101200729973"></p><blockquote><p> <strong><font color='blue'>无边用∞表示</font></strong></p></blockquote><p>例如</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017330.png" alt="image-20221101200823831"></p><p>有向带权图（网）的邻接矩阵</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017882.png" alt="在这里插入图片描述"></p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>B</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>C</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>D</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>E</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>F</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id="（二）邻接表-Adjacency-List）"><a href="#（二）邻接表-Adjacency-List）" class="headerlink" title="（二）邻接表(Adjacency List）"></a>（二）邻接表(Adjacency List）</h2><ol><li>邻接表是图的**<font color='red'>链式存储结构</font>**</li><li>只存储图中<strong>存在的边</strong>的信息，对不相邻的顶点则不保留信息</li><li>对图中<strong>每个顶点v</strong>i建立一个<strong>带头结点的单链表</strong>，称为顶点表</li><li>把<strong>与vi相邻接的顶点</strong>放在这个链表中，一个单链表对应邻接矩阵中的一行，称为<strong>边链表</strong>。</li></ol><h3 id="1，存储结构-1"><a href="#1，存储结构-1" class="headerlink" title="1，存储结构"></a>1，存储结构</h3><blockquote><p><strong>分三部分：<br>1、图的结构定义<br>2、顶点的头结点结构<br>3、弧（边）的结点结构</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（即在AdjList[]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*说明*/</span></span><br><span class="line">Graph G;<span class="comment">//定义了邻接表表示的图G</span></span><br><span class="line">G.vexnum = <span class="number">5</span>;G.arcnum = <span class="number">6</span>;<span class="comment">//图G包含了5个顶点和6条边</span></span><br><span class="line">G.vexs[<span class="number">1</span>].data = <span class="string">&#x27;v2&#x27;</span>;<span class="comment">//图G中第2个顶点是v2</span></span><br><span class="line">p = G.vexs[<span class="number">1</span>].firstarc;<span class="comment">//指针p指向顶点v2的第一个边结点</span></span><br><span class="line">p-&gt;adjvex = <span class="number">4</span>;<span class="comment">//p指针所指边结点是到下标为4的结点的边</span></span><br></pre></td></tr></table></figure><h3 id="2，采用邻接表创建无向图"><a href="#2，采用邻接表创建无向图" class="headerlink" title="2，采用邻接表创建无向图"></a>2，采用邻接表创建无向图</h3><blockquote><p>【算法步骤】</p><p>1.，输入总顶点数和总边数</p><p>2， 建立顶点表</p><ul><li>依次输入点的信息存入顶点表中</li><li>使每个表头结点的指针域初始化为<code>NULL</code></li></ul><p>3、创建邻接表</p><ul><li>依次输入每条边依附的两个顶点</li><li>确定这两个顶点的序号<code>i</code>和<code>j</code></li><li>将此边结点分别插入<code>vi</code>和<code>vj</code>对应的两个边链表的头部</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用邻接表表示法创建无向图*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(Graph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入顶点数和弧数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; G.vexs[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">G.vexs[i].firstarc = <span class="literal">NULL</span>;<span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.arcnum;k++)<span class="comment">//输入各边，构造邻接表，头插法</span></span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">i = <span class="built_in">LocateVex</span>(G, v1);j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">        p1=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));<span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">p1-&gt;adjvex = j;<span class="comment">//邻结点序号为j</span></span><br><span class="line">p1-&gt;nextarc = G.vexs[i].firstarc;<span class="comment">//firstarc为空，所以nextarc也指向空，即最后的一个结点</span></span><br><span class="line">G.vexs[i].firstarc = p1;   <span class="comment">//将新结点*p1插入到顶点vi的边表头部</span></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">p2 = <span class="keyword">new</span> ArcNode;<span class="comment">//生成一个新的边结点*p2</span></span><br><span class="line">p2-&gt;adjvex = i;</span><br><span class="line">p2-&gt;nextarc = G.vexs[j].firstarc;<span class="comment">//插入弧结点到单链表</span></span><br><span class="line">G.vexs[j].firstarc = p2;<span class="comment">//将新结点*p2插入到顶点vi的边表头部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017876.png" alt="image-20221101201335057"></p><blockquote><ol><li>顶点表顺序存储，以便可以随机访问任一顶点的边链表</li><li>邻接表表示不唯一</li></ol></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017859.png" alt="image-20221104193418025"></p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a><strong>邻接矩阵</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵的存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//当前图的顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DFS遍历连通图*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从第v个顶点依次遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//访问标志符数组置为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; G.vexnum;w++)<span class="comment">//依次检查邻接矩阵v所在行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][w] != <span class="number">0</span> &amp;&amp; !visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//w是v的邻接点，如果w未被访问，则调用DFS_AM</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a><strong><font color='red'>邻接表</font></strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span>* nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"></span><br><span class="line">==========================================================================================================================================</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*采用邻接表表示图的DFS*/</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">DFS</span>(ALGraph G, <span class="type">int</span> v)</span><br><span class="line">&#123;<span class="comment">//图G为邻接表类型，从第v个结点出发DFS图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//置访问标志符为true</span></span><br><span class="line"><span class="keyword">for</span>(ArcNode* p = G.vexs[v].firstarc; p ;p = p-&gt;nextarc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> w = p-&gt;adjvex;<span class="comment">//w是p邻接点的下标</span></span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//如果w未访问，则递归调用DFS_AL</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非连通图"><a href="#非连通图" class="headerlink" title="非连通图"></a>非连通图</h3><h4 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*非连通图G的深度优先搜索遍历*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从第v个顶点依次遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//访问标志符数组置为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; G.vexnum; w++)<span class="comment">//依次检查邻接矩阵v所在行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][w] &amp;&amp; !visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//w是v的邻接点，如果w未被访问，则调用DFS_AM</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//访问标志数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line"><span class="built_in">DFS</span>(G, i);<span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v)</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(ArcNode* p=G.vexs[v].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[j])</span><br><span class="line">            <span class="built_in">DFS</span>(G,j);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//访问标志数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line"><span class="built_in">DFS</span>(G, i);<span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017851.png" alt="image-20221003205935386"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017845.png" alt="image-20221003205948486"></p><h3 id="采用邻接矩阵表示的图的BFS"><a href="#采用邻接矩阵表示的图的BFS" class="headerlink" title="采用邻接矩阵表示的图的BFS:"></a><strong>采用<font color='red'>邻接矩阵</font>表示的图的BFS:</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按广度优先非递归遍历连通图G*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">q.<span class="built_in">push</span>(v);<span class="comment">//v进队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();<span class="comment">//队头元素出队并置为u</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line"><span class="keyword">if</span> (arcs[u][w] &amp;&amp; !visited[w])<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;<span class="comment">//置访问标志数组分量为true</span></span><br><span class="line">q.<span class="built_in">push</span>(w);<span class="comment">//w进队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**<font color='red'>入栈的同时访问</font>**，出栈时不必访问</p></blockquote><h3 id="采用邻接表表示的图的BFS"><a href="#采用邻接表表示的图的BFS" class="headerlink" title="采用邻接表表示的图的BFS:"></a><strong>采用<font color='red'>邻接表</font>表示的图的BFS:</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按广度优先非递归遍历连通图G*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">q.<span class="built_in">push</span>(v);<span class="comment">//v进队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();<span class="comment">//队头元素出队并置为u</span></span><br><span class="line"><span class="keyword">for</span> (ArcNode* p=G.vexs[u].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w=p-&gt;adjvex;<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;<span class="comment">//置访问标志数组分量为true</span></span><br><span class="line">q.<span class="built_in">push</span>(w);<span class="comment">//w进队</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>DFS&#x2F;BFS的作用</p><ul><li>求图的**<font color='red'>连通分量</font>**</li><li>判断图是否连通</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="06-图1-列出连通集"><a href="#06-图1-列出连通集" class="headerlink" title="06-图1 列出连通集"></a><strong>06-图1 列出连通集</strong></h3><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arc[<span class="number">105</span>][<span class="number">105</span>];<span class="type">int</span> visit[<span class="number">10</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arc[i][j]==<span class="number">1</span>&amp;&amp;visit[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">            visit[j]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">visit[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arc[i][j]==<span class="number">1</span>&amp;&amp;visit[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line"> visit[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> t1,t2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">arc[t1][t2]=arc[t2][t1]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//memset(visit,0,sizeof(visit));</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">visit[i]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><ul><li><p>生成树：包含&#x3D;&#x3D;<strong><font color='red'>连通图</font></strong>&#x3D;&#x3D;中**<font color='blue'>所有顶点</font><strong>的</strong><font color='gree'>极小</font><font color='orange'>连通子图</font>**</p></li><li><p>最小生成树（Minimum Spanning Tree，简称MST）：带权**<font color='red'>连通图</font><strong>（网）的所有生成树中，</strong>各边权值之和最小<strong>的</strong>生成树<strong>称为</strong>最小生成树**</p></li></ul><blockquote><ol><li><p>只有**<font color='red'>连通图（无向）</font>**才存在最小生成树&#x2F;生成树</p></li><li><p>**<font color='red'>有向图不存在生成树</font>**的概念</p></li><li><p>连通图的生成树具有这样的特征，即生成树中<code>边的数量 = 顶点数 - 1</code>。</p></li></ol></blockquote><h2 id="prim算法-加点法"><a href="#prim算法-加点法" class="headerlink" title="prim算法(加点法)"></a>prim算法(加点法)</h2><h3 id="算法概要"><a href="#算法概要" class="headerlink" title="算法概要"></a>算法概要</h3><pre><code>**设G = （ V , E )是连通网，T是 G 上最小生成树中边的集合。U为G上最小生成树顶点的集合**</code></pre><p>（1）初始时，<strong>U&#x3D;{u<del>0</del>}（u<del>0</del>∈V）,T&#x3D;{ }</strong></p><p>（2）找到满足**<code>min&#123; weight(ui,vi) |ui∈U，vi∈V-U&#125;</code><strong>的边</strong><code>(ui,vi)</code><strong>，并将该边加入T，同时</strong><code>vi</code>**并入U；</p><p>（3）重复步骤（2），直到**<code>U=V</code>**时算法结束</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017920.png" alt="在这里插入图片描述"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>（1）图采用邻接矩阵来存储<br>（2）一维数组closedeg,记录从U到V-U具有最小代价的边。</strong></p><blockquote><p><strong><code>closeedge[i]</code><strong>表示顶点&#x3D;&#x3D;</strong><font color='blue'>v<del>i</del></font></strong>&#x3D;&#x3D;到集合U的**<font color='gree'>最短边</font>**，其中</p><ul><li><strong><code>closeedge[i].adjvex</code><strong>表示依附于这条最小代价边的</strong><font color='blue'>另一个顶点</font></strong></li><li>**<code>closeedge[i].lowcost</code>**表示最小边的权值<ul><li><strong><code>closeedge[i].lowcost = 0</code></strong> :表示顶点 v<del>i</del> 已经在顶点集U中</li><li><strong><code>closeedge[i].lowcost != 0</code></strong> :表示顶点 v<del>i</del> 还在顶点集V-U中</li></ul></li></ul><blockquote><p>**<code>closeedge[i];</code>**有三种功能</p><ol><li>标记顶点 v<del>i</del>是否已经再顶点集U中</li><li>记录顶点 v<del>i</del>到集合U-V的最小边（包含另一个顶点adjvex和边的权值）</li></ol></blockquote></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018349.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;  <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VerTexType adjvex;<span class="comment">//最小边的顶点</span></span><br><span class="line">ArcType lowcost;<span class="comment">//最小边的权值</span></span><br><span class="line">&#125;closedge[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//adjvex:依附于这条最小代价边的另一个顶点</span></span><br><span class="line"><span class="comment">//lowcost = 0 :表示顶点已经在顶点集U中</span></span><br><span class="line"><span class="comment">//lowcost != 0 :表示顶点i还在V-U中</span></span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="邻接矩阵-2"><a href="#邻接矩阵-2" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(Graph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//无向网G以邻接矩阵存储，从顶点u出发构造G的最小生成树T,输出T的各条边</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">LocateVex</span>(G, u);<span class="comment">//起点位置，k为顶点u的下标</span></span><br><span class="line"><span class="comment">//对V-U的每个顶点vi,初始化closedge[i]    </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            closedge[i].adjvex = u;</span><br><span class="line">closedge[i].lowcost = G.arcs[k][i];</span><br><span class="line">          <span class="comment">//closedge[i]=&#123;G.vexs[k],G.arcs[k][i]&#125;  //closedge[i]=&#123; u, G.arcs[k][i]&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            closedge[i].lowcost = <span class="number">0</span>;<span class="comment">//初始，U = &#123; u &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; G.vexnum;++i)<span class="comment">//选择其余n-1个顶点，生成n-1条边（n = G.vexnum ）</span></span><br><span class="line">&#123;</span><br><span class="line">k = <span class="built_in">Min</span>(closedge);<span class="comment">//求出T的下一个结点：closedge[k]存有当前最小边(非零最小)</span></span><br><span class="line"><span class="built_in">printf</span>( G.vexs[k], closedge[k].adjvex );</span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//新顶点并入U后修改其他顶点最小边        </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line"><span class="keyword">if</span> (G.arcs[k][j] &lt; closedge[j].lowcost)</span><br><span class="line">&#123;</span><br><span class="line">closedge[j].adjvex = G.vexs[k];</span><br><span class="line">closedge[j].lowcost = G.arcs[k][j];</span><br><span class="line">             <span class="comment">//closedge[j]=&#123;G.vexs[k],G.arcs[k][j]&#125;  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表-2"><a href="#邻接表-2" class="headerlink" title="邻接表"></a>邻接表</h4><h2 id="Kruskal算法（加边法）"><a href="#Kruskal算法（加边法）" class="headerlink" title="Kruskal算法（加边法）"></a>Kruskal算法（加边法）</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><pre><code>            **设G = （ V , E )是连通网，T是 G 上最小生成树中边的集合。**</code></pre><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018480.png" alt="image-20221101171353307"></p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><blockquote><p>Dijkstra算法不能处理带有**<font color='red'>负权值</font>**的边</p></blockquote><ul><li>反例<img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018368.webp" alt="img"></li></ul><p>按照Prim算法，d（4）为2，路径为1，3，4</p><p>但显然路径是1，2，3，4时，d（4）才是最小，为1</p><ul><li>原因：Dijkstra算法是按照**<font color='red'>路径长度递增</font><strong>的次序，逐步产生各个顶点到源点最短路径的</strong><font color='red'>贪心</font>**算法，而当存在带负权值的边时，当把一个节点选入集合S时，即意味着已经找到了从源点到这个点的最短路径，但若存在负权边，就与这个前提矛盾，可能会出现得出的距离加上负权后比已经得到S中的最短路径还短。（无法回溯）</li></ul><blockquote><p>Floyd算法允许有**<font color='red'>带负权值的边</font><strong>，但不允许图中有</strong><font color='red'>包含带负权值回路</font>**</p></blockquote><ul><li><p>这句话的意思并不是说“<strong>只要回路中存在负权值Floyd就不可以解决</strong>”。而是<strong>“组成这个回路的所有的边的权值之和如果为负，就无法解决，否则还是可以解决的”</strong></p></li><li><p>举例说明<img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018397.png" alt="img"></p></li></ul><p>这个图中右侧的三个边组成了一个回路，其中一边为负，但是三边权值之和为：<strong>2+3+(-1)&#x3D;4 &gt;0</strong>，此时Folyd算法是可以解决的</p><hr><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018382.png" alt="img"></p><p>而第二张图同样右侧的三个边组成了一个回路，其中一边为负，但是三边权值之和为：<strong>1+1+(-3)&#x3D;-2&lt;0</strong>，此时Folyd算法无法解决，因为每多走一遍回路总的路径就会 -2 如果求路径长度最小值只需要一直走下去，进入了死循环。</p><hr><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018390.png" alt="image-20221109220903123"></p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>利用Prim算法、Kruskal算法构造最小生成树</strong><br><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018791.png" alt="在这里插入图片描述"></p><p><strong>利用Prim算法、Kruskal算法构造最小生成树</strong><br><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018797.png" alt="在这里插入图片描述"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018021.jpeg" alt="13311768599213125"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018029.png" alt="在这里插入图片描述"></p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018930.png" alt="image-20221109092959403"></p><ol><li><p><strong><font color='red'>顶点活动网(AOV网</font><strong>，Activity On <strong><font color='red'>Vertex</font></strong> NetWork)：将&#x3D;&#x3D;</strong><font color='oran'>顶点表示活动，边表示活动之间的关系</font></strong>&#x3D;&#x3D;的有向网称为<strong>顶点活动网</strong>；</p></li><li><p>拓扑序列：若有向图G&#x2F;AOV网的顶点序列v1,v2,…,vn满足下列条件：若在AOV网&#x2F;有向图G中<strong>存在从vi到vj的路径</strong>，则在该<strong>（线性）序列</strong>中的**<font color='orange'>vi必定在vj之前</font>**，便称这个序列为一个拓扑序列。</p></li><li><p>求一个有向图拓扑序列的过程称为拓扑排序。</p></li></ol><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018070.png" alt="在这里插入图片描述"></p><h3 id="算法概要-1"><a href="#算法概要-1" class="headerlink" title="算法概要"></a>算法概要</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018246.png" alt="image-20221102100608149"></p><p>拓扑排序<strong>可以判断一个有向图<font color='red'>是否存在环路</font></strong></p><ol><li>若网中<strong>所有顶点</strong>都在其的拓扑排序序列中，则该AOV网中必不存在环。</li><li>如果有向图存在环，则不能进行拓扑排序；反之，如果对一个有向图不能进行拓扑排序，则必定存在环。<ul><li>&#x3D;&#x3D;<strong><font color='red'>有向图存在环路&lt; &#x3D; &#x3D; &gt;不能进行拓扑排序&lt; &#x3D; &#x3D; &gt;不存在关键路径</font></strong>&#x3D;&#x3D;</li><li>&#x3D;&#x3D;<strong><font color='red'>有向图不存在环路（即有向无环图）&lt; &#x3D; &#x3D; &gt;能进行拓扑排序&lt; &#x3D; &#x3D; &gt;存在关键路径</font></strong>&#x3D;&#x3D;</li></ul></li></ol><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="邻接矩阵-3"><a href="#邻接矩阵-3" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(Graph G,<span class="type">int</span> &amp;indegree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[i][j])</span><br><span class="line">            indegree[j]++;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G, <span class="type">int</span> topo[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图G采用邻接矩阵存储</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G,indegree);<span class="comment">//求出各顶点的入度存入数组indegree中</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;<span class="comment">//栈初始化为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line"><span class="keyword">if</span> (!indegree[i]) s.<span class="built_in">push</span>(i);<span class="comment">//入度为0者进栈</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始化为0</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())<span class="comment">//栈S非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();<span class="comment">//取栈顶顶点vi出栈</span></span><br><span class="line">topo[cnt++] = i;<span class="comment">//将vi保存在拓扑序列数组topo中    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p遍历vi的所有邻接点        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[i][j] &amp;&amp; --indegree[j]==<span class="number">0</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (cnt &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//该有向图有回路</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="邻接表-3"><a href="#邻接表-3" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（在AdjList[MVNum]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(Graph G,<span class="type">int</span> &amp;indegree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(ArcNode *p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopoSort</span><span class="params">(Graph G, <span class="type">int</span> topo[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G,indegree);<span class="comment">//求出各顶点的入度存入数组indegree中</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;<span class="comment">//栈初始化为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line"><span class="keyword">if</span> (!indegree[i]) s.<span class="built_in">push</span>(i);<span class="comment">//入度为0者进栈</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始化为0</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())<span class="comment">//栈S非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();<span class="comment">//取栈顶顶点vi出栈</span></span><br><span class="line">topo[cnt++] = i;<span class="comment">//将vi保存在拓扑序列数组topo中    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p遍历vi的所有邻接点        </span></span><br><span class="line">        <span class="keyword">for</span>(ArcNode *p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            k=p-&gt;adjvex;<span class="comment">//vk为vi的邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(--indegree[k]==<span class="number">0</span>)<span class="comment">//先把indegree[k]减1，若入度减为0，则入栈</span></span><br><span class="line">                s.<span class="built_in">push</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (cnt &lt; G.vexnum)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//该有向图有回路</span></span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018217.png" alt="image-20221109094330861"></p><h3 id="邻接表-4"><a href="#邻接表-4" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（在AdjList[MVNum]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"><span class="comment">//G为邻接表存储的有向网，输出G的各项关键活动    </span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CriticalPath</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">TopoSort</span>(G, topo)) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给每个事件的最早发生时间置初值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">ve[i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*按照拓扑次序求每个事件的最早发生时间*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//从前往后</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = topo[i];<span class="comment">//取得拓扑序列中的顶点序号j</span></span><br><span class="line"><span class="keyword">for</span>(ArcNode *p = G.vexs[j].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">&#123;    <span class="comment">//依次更新j的所有邻接顶点的最早发生时间</span></span><br><span class="line"><span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//k为邻接顶点的序号</span></span><br><span class="line"><span class="keyword">if</span> (ve[k] &lt; ve[j] + p-&gt;info)   <span class="comment">//更新顶点k的最早发生时间ve[k]</span></span><br><span class="line">ve[k] = ve[j] + p-&gt;info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给每个事件的最迟发生时间置初值为ve[n-1]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) </span><br><span class="line">vl[i] = ve[G.vexnum - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*按逆拓扑次序求每个事件的最迟发生时间*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = G.vexnum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//从后往前</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = topo[i];<span class="comment">//取得拓扑序列中的顶点序号k</span></span><br><span class="line"><span class="keyword">for</span>(p = G.vexs[j].firstarc; p ; p=p-&gt;nextarc)<span class="comment">//活动&lt;vj,vk&gt;</span></span><br><span class="line">&#123; <span class="comment">//依次更新j的所有邻接顶点的最迟发生时间</span></span><br><span class="line"><span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//k为邻接顶点的序号</span></span><br><span class="line"><span class="keyword">if</span> (vl[j] &gt; vl[k] - p-&gt;info)   <span class="comment">//更新顶点j的最迟发生时间vl[j]</span></span><br><span class="line">vl[j] = vl[k] - p-&gt;info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*判断每一活动是否为关键活动*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">&#123; <span class="comment">//每次循环针对vi为活动开始点的所有活动</span></span><br><span class="line"><span class="keyword">for</span> (p = G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = p-&gt;adjvex;<span class="comment">//j为i的邻接顶点的序号</span></span><br><span class="line"><span class="type">int</span> e = ve[i];<span class="comment">//计算活动&lt;vi,vj&gt;的最早开始时间</span></span><br><span class="line"><span class="type">int</span> l = vl[j] - p-&gt;info;<span class="comment">//计算活动&lt;vi,vj&gt;的最迟开始时间</span></span><br><span class="line"><span class="keyword">if</span> (e == l)<span class="comment">//若为关键活动，输出&lt;vi,vj&gt;</span></span><br><span class="line">cout &lt;&lt; G.vexs[i].data &lt;&lt; G.vexs[j].data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>关键活动和拓扑排序是针对**<font color='blue'>有向无环图</font>**而言的</p></li><li><p>求<strong>关键路径</strong>之前**首先要进行<font color='red'>拓朴排序</font>**，目的是</p><ul><li>判断该有向网是否存在环路；若存在环路，不存在关键路径，否则存在关键路径</li><li>给出相应的拓扑序列（工程能完成的某一个事件顺序，从最开始源点事件到汇点事件，包含所有事件的一条路径）</li></ul></li></ol></blockquote><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h4 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017920.png" alt="**1、初始化：**"></p><blockquote><p>用Dijkstra算法求有向网G的<strong>v<del>0</del>顶点</strong>到**<font color='red'>其余各个顶点</font>**的最短路径</p></blockquote><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>1,  主要存储结构：<strong>邻接矩阵</strong>G(或者邻接表) </p><p>2 ,  辅助存储结构： </p><p> （1）数组**<code>final[n]</code><strong>:记录相应顶点是否&#x3D;&#x3D;<strong>已被确定</strong>最短距离&#x3D;&#x3D;（是否在</strong>集合S**中）</p><ul><li>初值：1：已确定；0:未确定</li></ul><p>（2）数组**<code>D[n]</code><strong>:记录</strong><font color='red'>源点V<del>0</del></font>**到相应顶点 V<del>i</del> 路径的长度</p><ul><li>初值：如果V<del>0</del>到V<del>i</del><strong>有弧</strong>，则<code>D[i]</code>为弧上权值，否则为无穷</li></ul><p> （3）数组**<code>P[n]</code><strong>:记录相应顶点的</strong><font color='red'>前驱顶点</font>**</p><ul><li>初值：如果v0到vi有弧，则**<code>P[i]</code><strong>为</strong><font color='gree'>v<del>0</del></font>**，否则为&#x3D;&#x3D;<font color='blue'><strong>–1</strong></font>&#x3D;&#x3D;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ArcType ;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph G;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">final</span>[MVNum];</span><br><span class="line"><span class="type">int</span> P[MVNum];</span><br><span class="line"><span class="type">double</span> D[MVNum];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*迪杰斯特拉算法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//初始化辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123; </span><br><span class="line">D[w] = G.arcs[v][w]; <span class="comment">//将v到各个终点的最短路径长度初始化       </span></span><br><span class="line"><span class="keyword">final</span>[w] = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (D[w] &lt; MaxInt)</span><br><span class="line">P[w] = v; <span class="comment">//v与w之间有弧，将w的前驱置为v</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P[w] = <span class="number">-1</span>; <span class="comment">//如果v与w之间无弧，则将w的前驱置为-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">1</span>; <span class="comment">//将v加入final</span></span><br><span class="line">P[v]= <span class="number">-1</span>; <span class="comment">//源点v的前驱结点设为-1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*循环n-1次，将图中所有顶点加入集合S中*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//找到当前离v距离最近的顶点j（即在D[]中寻找最小值）</span></span><br><span class="line"><span class="type">int</span> min = MaxInt;<span class="comment">//min辅组找最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">final</span>[j] == <span class="number">0</span> &amp;&amp; D[j] &lt; min)<span class="comment">//w顶点在V-S中</span></span><br><span class="line">&#123;</span><br><span class="line">min = D[j];                </span><br><span class="line">v = j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">1</span>; <span class="comment">//将v加入S集</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//更新从v出发到集合V-S上所有顶点的P[]和D[]        </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; w++) </span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; D[v] + G.arcs[v][w] &lt; D[w])</span><br><span class="line">&#123;</span><br><span class="line">D[w] = D[v] + G.arcs[v][w];<span class="comment">//更新D[w]</span></span><br><span class="line">P[w] = v;<span class="comment">//更改w的前驱为v</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">=====================================================================</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出v到各个顶点的最小距离和路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(i != v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n%f:%d&quot;</span>,D[i],i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> pre=P[i]; pre!= <span class="number">-1</span>; pre=P[pre])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;-%d&quot;</span>,pre);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多源最短路径"><a href="#多源最短路径" class="headerlink" title="多源最短路径"></a>多源最短路径</h2><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><blockquote><p> 求有向网G中**<font color='red'>任意两个顶点V<del>i</del>，V<del>j</del>之间</font>** &#x2F; **<font color='red'>所有顶点之间</font>**的最短路径</p></blockquote><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018452.png" alt="image-20221012132457324"></p><h4 id="算法实例分析"><a href="#算法实例分析" class="headerlink" title="算法实例分析"></a>算法实例分析</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018694.png" alt="image-20221012132532780"></p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018686.png" alt="image-20221012132638042" style="zoom:60%;" /><blockquote><ol><li>表中**<font color='red'>最多只有三个字母</font><strong>，</strong>最左最右是固定的，中间的那个字母是动态调整的**</li><li>只有**<font color='orange'>两个字母表示直达</font>**，对角线一定是两个相同的字母00</li></ol></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018576.png" alt="image-20221012132812283"></p><h4 id="算法要点—迭代"><a href="#算法要点—迭代" class="headerlink" title="算法要点—迭代"></a>算法要点—迭代</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018828.png" alt="image-20221012132930217"></p><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>1,  主要存储结构：邻接矩阵G </p><p>2 ,  辅助存储结构： </p><p>（1）数组**<code>D[i][j]</code><strong>:记录&#x3D;&#x3D;<strong>当前</strong>&#x3D;&#x3D;</strong><font color='red'>从【顶点i 】到 【顶点j】 的最短路径长度</font>**</p><ul><li>初值：**<code>D[i][j]=G.arc[i][j];</code>**</li></ul><p> （2）数组**<code>P[i][j]</code>**:记录&#x3D;&#x3D;<strong>顶点j</strong>&#x3D;&#x3D;的（到顶点i这条路径） <strong><font color='red'>前驱顶点</font></strong></p><ul><li>初值：如果vi到vj有弧，则**<code>P[i][j]=i</code>**，否则为<font color='gree'>-1</font></li></ul><h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_Floyed</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//初始化各结点之间的已知路径及距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line">D[i][j] = G.arcs[i][j];</span><br><span class="line"><span class="keyword">if</span> (D[i][j] &lt; MaxInt)</span><br><span class="line">P[i][j] = i;<span class="comment">//i和j之间有弧，将j的前驱置为i</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P[i][j] = <span class="number">-1</span>;<span class="comment">//i和j之间无弧，则将j的前驱置为-1</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Dk依次迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.vexnum;k++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line"><span class="keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j])</span><br><span class="line">&#123; <span class="comment">// 从i经过k到j的一条路径更短</span></span><br><span class="line">D[i][j] = D[i][k] + D[k][j];<span class="comment">//更新D[i][j]</span></span><br><span class="line">P[i][j] = k;<span class="comment">//更改j的前驱为k，记录路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：&#x3D;&#x3D;<strong>不可以</strong>&#x3D;&#x3D;先循环<code>i</code>和<code>j</code>，把<code>k</code>放到最内层循环</p><ul><li>可以把k想象成一个阶段，即k为中转点时，枚举 i ，j，通过k的变动不停地松弛i、j之间的最短路。因为i、j可以重复遍历，但k不能。如果k在内层循环，程序无法进行多次的松弛操作，也就是程序出错的原因。</li></ul></blockquote><h1 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018715.png" alt="image-20221103182338937"></p><h3 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h3><p>采用邻接表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（即在AdjList[]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018073.webp" alt="img"></p><blockquote><p>有利用**<font color='red'>DFS</font>**的思想</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"><span class="comment">//出发点为i，终点为j，长度为k </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exist_path_len</span><span class="params">(Graph G,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( k&lt;<span class="number">0</span> )<span class="comment">//路径为负显然不成立</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j &amp;&amp; k==<span class="number">0</span>)<span class="comment">//递归终止条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    visited[i]=<span class="number">1</span>;</span><br><span class="line"> <span class="comment">/*寻找i的邻接点是否存在到j的长度为k-1的路径*/</span>     </span><br><span class="line">    <span class="keyword">for</span>( ArcNode* p=G.vertices[i].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[t])</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist_path_len</span>(G, t, j, k - p-&gt;info))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    visited[i]=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">/*如果沿某个方向不存在长度为length的路径,</span></span><br><span class="line"><span class="comment">  沿这个方向 经过的顶点 仍可能存在于沿其他方向的目标路径中,</span></span><br><span class="line"><span class="comment">  因此要恢复成未访问*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018102.png" alt="image-20221106125355662"></p><h3 id="存储结构-3"><a href="#存储结构-3" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;</span><br><span class="line">    InfoType info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode * firstarc;</span><br><span class="line">&#125;VNode,*AdjList[MVNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    AdjList vexs;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018153.png" alt="image-20221106133757704"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> visited[], <span class="type">int</span> &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visited[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ArcNode *p = G.vertices[i].firstarc;</span><br><span class="line"><span class="keyword">while</span>(!flag &amp;&amp; p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="type">int</span> k = p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(!visited[k])</span><br><span class="line"><span class="built_in">DFS</span>(G, k, j, visited, flag);</span><br><span class="line">p = p-&gt;nextarc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Path</span><span class="params">(ALGraph G, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> visited[MVNum];<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">1</span>; m &lt;= G.vexnum; m++)</span><br><span class="line">visited[m] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">DFS</span>(G, i, j, visited, flag);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>   从**<font color='red'>V<del>i</del></font>**开始进行DFS&#x2F;BFS。</p><ul><li><p>若在此过程中访问到V<del>j</del>，则说明存在，返回1；</p></li><li><p>若遍历结束，则说明未找到，返回0；</p></li></ul><blockquote><p>改编DFS，将**<code>visit（i）</code><strong>改为判断</strong><code>if(i==j)return 1;</code>**</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exist_path</span><span class="params">(Graph G,<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visited[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==j)<span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ArcNode*p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[k])</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist_path</span>(G,k,j))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用了DFS&#x2F;BFS可用于求**<font color='red'>连通分量</font>**（任意两个顶点间均存在路径，均可达）的作用</p><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p>在一个图中，存在这样一条路径，它经过每条边恰好一次，并在最后一个顶点时会到第一个顶点，这样的路径叫做<strong>欧拉回路</strong>。给无向图，编写程序输出是否存在欧拉回路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【线性表】</title>
      <link href="/2023/09/28/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/"/>
      <url>/2023/09/28/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一:预备知识"></a>一:预备知识</h1><h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>头指针</strong>为L，指针<code>t</code>指向待插入的新结点</p><h3 id="若单链表含有头结点"><a href="#若单链表含有头结点" class="headerlink" title="若单链表含有头结点"></a>若单链表含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = t;</span><br></pre></td></tr></table></figure><h3 id="若单链表不含有头结点"><a href="#若单链表不含有头结点" class="headerlink" title="若单链表不含有头结点"></a>若单链表不含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head;</span><br><span class="line">head = t;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>尾指针</strong>为tail，指针 <code>t</code>指向待插入的新结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail-&gt;next = t;</span><br><span class="line">tail = t;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>头插法</font><strong>会改变</strong><font color='red'>原先顺序</font><strong>，</strong><font color='blue'>尾插法</font><strong>不会改变</strong><font color='blue'>原先顺序</font></strong></p></blockquote><h2 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h2><h3 id="头结点的作用"><a href="#头结点的作用" class="headerlink" title="头结点的作用"></a>头结点的作用</h3><ol><li><strong>使插入操作和删除操作统一</strong>，在**<font color='blue'>第一个结点之前插入结点</font><strong>或</strong><font color='blue'>删除第一个结点</font>**时不必另作判断</li><li>不论链表是否为空，<strong>头指针不变，始终指向头结点</strong></li></ol><h3 id="没有头节点的链表"><a href="#没有头节点的链表" class="headerlink" title="没有头节点的链表"></a>没有头节点的链表</h3><p>对于不带头结点的链表，要考虑</p><ol><li>初始时**<font color='blue'>链表是否为空</font>**</li><li>是否在**<font color='blue'>第一个结点前插入新结点</font>**</li><li>是否**<font color='red'>删除</font><strong>结点后</strong><font color='blue'>链表为空</font>**</li></ol><h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二:链表"></a>二:链表</h1><h2 id="链表复制"><a href="#链表复制" class="headerlink" title="链表复制"></a>链表复制</h2><p>​不带头结点的单链表反转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">copyList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head-&gt;val, head-&gt;next);</span><br><span class="line">    ListNode *p = head, *q = newhead;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(&#123;p-&gt;val, p-&gt;next&#125;);</span><br><span class="line">        q-&gt;next = t;</span><br><span class="line">        q = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表逆转"><a href="#链表逆转" class="headerlink" title="链表逆转"></a>链表逆转</h2><h3 id="带头结点的-单链表反转"><a href="#带头结点的-单链表反转" class="headerlink" title="**带头结点的**单链表反转"></a>**<font color='red'>带头结点的</font>**单链表反转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>* next;</span><br><span class="line">&#125;*List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(List &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List h=L-&gt;next;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(h)</span><br><span class="line">    &#123;</span><br><span class="line">        List t=h;</span><br><span class="line">        h=h-&gt;next;</span><br><span class="line">        t-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不带头结点的单链表反转"><a href="#不带头结点的单链表反转" class="headerlink" title="不带头结点的单链表反转"></a><font color='red'>不带头结点的</font>单链表反转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>* next;</span><br><span class="line">&#125;*List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(List &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List h=L;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(h)</span><br><span class="line">    &#123;</span><br><span class="line">        List t=h;</span><br><span class="line">        h=h-&gt;next;</span><br><span class="line">        t-&gt;next=L;</span><br><span class="line">        L=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290903384.png" alt="image-20230929090330216"></p><p><strong>注释</strong></p><ol><li><code>L-&gt;Next=NULL</code>使L成为<strong>反转链表</strong>的&#x3D;&#x3D;<strong>头节点</strong>&#x3D;&#x3D;。</li><li><code>List h=L-&gt;Next;</code> 使h指向<strong>原链表的第一个结点</strong>。</li><li><code>List t=h;</code>使t指向要插入反转链表的那个结点</li><li><code>h=h-&gt;next</code>用于记录未反转链表的下一个元素。</li><li><code>t-&gt;next=L-&gt;next;</code>     <code>L-&gt;next=t;</code></li></ol><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p><strong>6-1 单链表逆转</strong></p><p>本题要求实现一个函数，将给定的单链表逆转。</p><ul><li><strong>函数接口定义：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Reverse</span><span class="params">( List L )</span></span>;</span><br></pre></td></tr></table></figure><p>​其中<code>List</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> *PtrToNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List; <span class="comment">/* 定义单链表类型 */</span></span><br></pre></td></tr></table></figure><p>​<code>L</code>是给定单链表，函数<code>Reverse</code>要返回被逆转后的链表。</p><ul><li><strong>裁判测试程序样例：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> *PtrToNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">( List L )</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Reverse</span><span class="params">( List L )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2;</span><br><span class="line">    L1 = <span class="built_in">Read</span>();</span><br><span class="line">    L2 = <span class="built_in">Reverse</span>(L1);</span><br><span class="line">    <span class="built_in">Print</span>(L1);</span><br><span class="line">    <span class="built_in">Print</span>(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 4 5 2</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2 5 4 3 1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Reverse</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List h=<span class="literal">NULL</span>;<span class="comment">//h指向反转链表的第一个结点，最开始为NULL</span></span><br><span class="line">    <span class="keyword">while</span>(L)</span><br><span class="line">    &#123;</span><br><span class="line">        List t=L;    <span class="comment">//t指向待处理的头结点</span></span><br><span class="line">        L=L-&gt;Next;      <span class="comment">//L指向下轮循环要处理的头结点</span></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">        t-&gt;Next=h;</span><br><span class="line">        h=t;      </span><br><span class="line"><span class="comment">//      L=L-&gt;Next;   错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong></li></ul><ol><li>本题单链表L是&#x3D;&#x3D;<strong>不带头结点的单链表</strong>&#x3D;&#x3D;</li><li><strong>不能</strong>将 <code>L=L-&gt;Next;</code>放在循环体的最后（即第10行）,因为在头插结点的过程中<code>L-&gt;Next</code>会改变。</li></ol><h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290904949.png" alt="image-20220929123046549"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>* next;</span><br><span class="line">&#125;ListNode, *List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(List &amp;L)</span><span class="comment">//带头结点的单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List h=L-&gt;next;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(h)</span><br><span class="line">    &#123;</span><br><span class="line">        List t=h;</span><br><span class="line">        h=h-&gt;next;</span><br><span class="line">        t-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h3><p><strong>1025 反转链表</strong></p><p>给定一个常数 <em>K</em> 以及一个单链表 <em>L</em>，请编写程序将 <em>L</em> 中每 <em>K</em> 个结点反转。例如：给定 <em>L</em> 为 1→2→3→4→5→6，<em>K</em> 为 3，则输出应该为 3→2→1→6→5→4；如果 <em>K</em> 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 <em>K</em> 个元素不反转。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em> (≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>];             <span class="comment">//地址为5位数,模拟内存存储；     </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t; </span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  注意：不一定所有的输入的结点都是有用的，把链表储存在L数组中</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">    n=L.<span class="built_in">size</span>();             <span class="comment">//符合要求的节点个数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line">res.<span class="built_in">resize</span>(n);                  <span class="comment">//必须设定大小，否则res【i】出错</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-n%k;i++)        <span class="comment">//sum-sum%k是除去了最后不能反转的</span></span><br><span class="line">res[i]=L[k<span class="number">-1</span>-i%k+i/k*k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-n%k;i&lt;n;i++)</span><br><span class="line">        res[i]=L[i];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    输出     </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)   <span class="comment">//最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line">    </span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;    </span><br><span class="line"><span class="comment">//     法二</span></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;n-n%k;i+=k)</span></span><br><span class="line"><span class="comment">//         reverse(L.begin()+i,L.begin()+i+k);    //需要头文件algorithm</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// //    输出     </span></span><br><span class="line"><span class="comment">// for(int i=1;i&lt;n;i++)            //最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d %05d\n&quot;,L[i-1],A[L[i-1]].data,L[i]);</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d -1&quot;,L.back(),A[L.back()].data);    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h3><p><strong>1075 链表元素分类</strong></p><p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K (≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [−105,105] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00100 9 10</span><br><span class="line">23333 10 27777</span><br><span class="line">00000 0 99999</span><br><span class="line">00100 18 12309</span><br><span class="line">68237 -6 23333</span><br><span class="line">33218 -4 00000</span><br><span class="line">48652 -2 -1</span><br><span class="line">99999 5 68237</span><br><span class="line">27777 11 48652</span><br><span class="line">12309 7 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">33218 -4 68237</span><br><span class="line">68237 -6 48652</span><br><span class="line">48652 -2 12309</span><br><span class="line">12309 7 00000</span><br><span class="line">00000 0 99999</span><br><span class="line">99999 5 23333</span><br><span class="line">23333 10 00100</span><br><span class="line">00100 18 27777</span><br><span class="line">27777 11 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理多余节点   </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&lt;<span class="number">0</span>)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;=<span class="number">0</span>&amp;&amp;A[L[i]].data&lt;=k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例六"><a href="#例六" class="headerlink" title="例六"></a>例六</h3><p><strong>区块反转</strong></p><p>给定一个单链表 <em>L</em>，我们将每 <em>K</em> 个结点看成一个<strong>区块</strong>（链表最后若不足 <em>K</em> 个结点，也看成一个区块），请编写程序将 <em>L</em> 中所有区块的链接反转。例如：给定 <em>L</em> 为 1→2→3→4→5→6→7→8，<em>K</em> 为 3，则输出应该为 7→8→4→5→6→1→2→3。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em> (≤<em>N</em>)，即区块的大小。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code> 是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00100 8 3</span><br><span class="line">71120 7 88666</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 71120</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">88666 8 -1</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">71120 7 88666</span><br><span class="line">88666 8 00000</span><br><span class="line">00000 4 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 00100</span><br><span class="line">00100 1 12309</span><br><span class="line">12309 2 33218</span><br><span class="line">33218 3 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100001</span>];</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;L,res,block[<span class="number">100001</span>];<span class="comment">//当n=100000，k=1时区块最多 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vector&lt;int&gt;L,res,block[100001];//放在局部变量会导致溢出，只能放在全局变量</span></span><br><span class="line"><span class="comment">//  故申请大内存时最好放在全局变量里面</span></span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">block[t].<span class="built_in">push_back</span>(L[i]);</span><br><span class="line"><span class="keyword">if</span>(cnt%k==<span class="number">0</span>&amp;&amp;t!=n<span class="number">-1</span>)        <span class="comment">//Attention！if(cnt%k==0) 也对</span></span><br><span class="line">t++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : block[i]) </span><br><span class="line">            res.<span class="built_in">push_back</span>(it);        </span><br><span class="line"><span class="comment">//等价   for(int j=0;j&lt;block[i].size();j++)</span></span><br><span class="line"><span class="comment">// res.push_back(block[i][j]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表合并"><a href="#链表合并" class="headerlink" title="链表合并"></a>链表合并</h2><h3 id="两个升序链表合并为一个升序链表"><a href="#两个升序链表合并为一个升序链表" class="headerlink" title="两个升序链表合并为一个升序链表"></a>两个升序链表合并为一个升序链表</h3><p>​利用原链表空间，将两个升序的链表（带头结点）合并成一个升序链表，时间复杂度O(N),空间复杂度O(1)</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290904950.jpeg" alt="img"></p><ul><li>用两个指针p1、p2分别遍历L1和L2，用一个尾指针永远指向新链表的最后一个节点</li><li>比较两个指针指向的节点的大小，将数据域较小的节点用&#x3D;&#x3D;<strong><font color='red'>尾插法</font></strong>&#x3D;&#x3D;接在新链表后面</li><li>尾指针后移，p1或者p2后移</li><li>当有一个为空时另一个还会有剩余节点没有加入新链表，将剩下的直接接在新链表后面</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MergeTwoLink</span><span class="params">(List L1, List L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L2;</span><br><span class="line">    <span class="keyword">if</span> (L2-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List L=new ListNode();//新建一个头结点</span></span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List tail = L;      <span class="comment">// tail为尾指针，指向新链表的最后一个节点</span></span><br><span class="line">    List p1 = L1-&gt;next; <span class="comment">// 用p1遍历L1</span></span><br><span class="line">    List p2 = L2-&gt;next; <span class="comment">// 用p2遍历L2</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;data &lt; p2-&gt;data) <span class="comment">// 如果p1指向的值小于p2,则用尾插法将p1接在链表尾部</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = p1; <span class="comment">// 让新链表的尾结点指向p1</span></span><br><span class="line">            tail = p1;</span><br><span class="line">            p1 = p1-&gt;next; <span class="comment">// 更新尾结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = p2;</span><br><span class="line">            tail = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        tail-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tail-&gt;next = p2;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个升序链表合并为一个降序链表"><a href="#两个升序链表合并为一个降序链表" class="headerlink" title="两个升序链表合并为一个降序链表"></a>两个升序链表合并为一个降序链表</h3><ul><li>用两个指针p1，p2分别遍历L1和L2，用指针s每次指向待插入的节点</li><li>将新链表的头结点的指针域置空</li><li>开始遍历并用&#x3D;&#x3D;<strong><font color='red'>头插法</font></strong>&#x3D;&#x3D;开始插入节点</li><li>退出循环后对未遍历完的节点用头插法将剩余节点插入新链表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">mergeTwoLinkdesc</span><span class="params">(List L1, List L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = L1;        <span class="comment">// 新链表的头结点用L1的头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;     <span class="comment">// 将新链表的头节点置空，这样原来的链表就变成了两段</span></span><br><span class="line">    List p1 = L1-&gt;next; <span class="comment">// 用p1遍历L1</span></span><br><span class="line">    List p2 = L2-&gt;next; <span class="comment">// 用p2遍历L2</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2)    <span class="comment">// 每次比较两个指针指向的节点的数据域，将较小的那个用头插法查到链表头部</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;data &lt; p2-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            List t = p1;       <span class="comment">// s指向待插入节点p1</span></span><br><span class="line">            t-&gt;next = L-&gt;next; <span class="comment">// 将待插入节点接在头节点后面，头插法</span></span><br><span class="line">            L-&gt;next = s;</span><br><span class="line">            p1 = p1-&gt;next; <span class="comment">// p1指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            List t = p2;</span><br><span class="line">            t-&gt;next = L-&gt;next;</span><br><span class="line">            L-&gt;next = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2; <span class="comment">// 处理有一个链表没有全部插入的情况</span></span><br><span class="line">    <span class="keyword">while</span> (p1)   <span class="comment">// 遍历该链表，用头插法将剩余节点插到新链表中</span></span><br><span class="line">    &#123;</span><br><span class="line">        List t = p1;</span><br><span class="line">        t-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = t;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例一-1"><a href="#例一-1" class="headerlink" title="例一"></a>例一</h3><p><strong>List Concatenation</strong></p><p>Concatenation of lists is an operation where the elements of one list are added at the end of another list. For example, if we have a linked list <code>L1</code>→1→2→3 and another one <code>L2</code>→4→5→6. The function <code>ListConcat</code> is to return the head pointer of the list L→4→5→6→1→2→3.</p><p><strong>The list structure is defined as the following:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br></pre></td></tr></table></figure><p><strong>Please fill in the blanks.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">ListConcat</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Tmp = L2;</span><br><span class="line">    <span class="keyword">if</span> ( !L2 ) <span class="keyword">return</span> L1;</span><br><span class="line">    <span class="keyword">while</span> ( Tmp-&gt;Next )</span><br><span class="line">________________;【<span class="number">4</span>分】</span><br><span class="line">______________;【<span class="number">4</span>分】</span><br><span class="line">    <span class="keyword">return</span> __________;【<span class="number">4</span>分】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><p>【1】<code>Tmp=Tmp-&gt;Next</code></p><p>【2】<code>Tmp-&gt;Next=L1</code>&#x2F;&#x2F;注：<code>Tmp-&gt;Next=L1-&gt;Next</code>错误</p><p>【3】<code>L2</code></p><blockquote><p>该链表是一个不带头结点的单链表，从两个角度判断</p><ol><li><p>第4行代码    <code>if ( !L2 ) return L1;</code>&#x2F;&#x2F;链表L2为空，则返回，说明不带头结点</p><ul><li>带头结点应写为<code>if ( !L2-&gt;next ) return L1;</code></li></ul></li><li><p>题干   L1→1→2→3   ,  L2→4→5→6   和   L→4→5→6→1→2→3.</p></li></ol></blockquote><h2 id="链表分解"><a href="#链表分解" class="headerlink" title="链表分解"></a>链表分解</h2><h3 id="例一-2"><a href="#例一-2" class="headerlink" title="例一"></a>例一</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为**<font color='red'>奇数</font><strong>的元素；B链表中含有原链表A中序号为</strong><font color='red'>偶数</font><strong>的元素。</strong><font color='blue'>保持原来的相对顺序。</font>**</p><blockquote><p>因为要保持原来相对位置不变，所以要采用Lb和Lb采用**<font color='red'>尾插法</font><strong>,尾指针分别为</strong><code>rear1和rear2</code>**</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二-1"><a href="#例二-1" class="headerlink" title="例二"></a>例二</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为**<font color='red'>偶数</font><strong>的元素；B链表中含有原链表A中序号为</strong><font color='red'>奇数</font><strong>的元素。</strong><font color='blue'>保持原来的相对顺序。</font>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树】</title>
      <link href="/2023/09/24/%E3%80%90%E6%A0%91%E3%80%91/"/>
      <url>/2023/09/24/%E3%80%90%E6%A0%91%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h1><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">typedef</span> ElementType BinTree[MAX];</span><br><span class="line">BinTree T;</span><br></pre></td></tr></table></figure><blockquote><p>实际应用中可采用：**<font color='red'>1号单元存储根结点，0号单元存节点的个数</font>**。</p><p>此时左子树是2i，右子树是2i+1</p></blockquote><span id="more"></span><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left, *right;</span><br><span class="line">&#125;* BinTree;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li><p>**<code>ElementType</code>**既可以是<code>int</code>，<code>char</code>，<code>double</code>，<code>float</code>等，即</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> ElementType;    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ElementType ;      </span><br></pre></td></tr></table></figure><blockquote><p>注意typedef最后面的<font color='red'><strong>分号</strong></font></p></blockquote></li><li><p><strong><code>ElementType</code><strong>也可以是自定义的</strong>struct类型</strong>，eg：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;ElementType;</span><br></pre></td></tr></table></figure></blockquote><h1 id="二叉树常见函数"><a href="#二叉树常见函数" class="headerlink" title="二叉树常见函数"></a>二叉树常见函数</h1><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p><strong>前序遍历(先根遍历)</strong></p><ol><li>若二叉树为空，则返回；</li><li>若不空：<ol><li>访问根结点；</li><li>前序遍历左子树；</li><li>前序遍历右子树。</li></ol></li></ol><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  if(T==NULL)return;</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;data);</span><br><span class="line">        <span class="built_in">preorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(T-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h3><ul><li><p>通过**<font color='red'>堆栈</font>**来实现</p></li><li><p>从当前节点开始遍历：（当入栈时访问节点内容，则为前序遍历；出栈时访问，则为中序遍历）</p><ol><li>若当前节点存在，就存入栈中，并访问左子树；</li><li>直到当前节点不存在，就**<font color='blue'>出栈，并通过栈顶节点访问右子树</font>**；</li><li>不断重复1. 2，直到当前节点不存在且栈空。</li></ol></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951583.jpeg" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span>;    </span><br><span class="line">    BinTree p=T;stack&lt;BinTree&gt;s;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);<span class="comment">//先序，第一次遇到才输出</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">         p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>visit(p-&gt;data)</code></strong> 语句与 <strong><code>s.push(p)</code></strong> 语句成对出现，这表明&#x3D;&#x3D;<strong><font color='red'>先序遍历的序列就是入栈的顺序</font></strong>&#x3D;&#x3D;</p></blockquote><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>中序遍历(中根遍历)</strong></p><ol><li>若二叉树为空，则退出；</li><li>若不空：<ol><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树</li></ol></li></ol><h3 id="递归算法-1"><a href="#递归算法-1" class="headerlink" title="递归算法"></a>递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;data);</span><br><span class="line">        <span class="built_in">inorder</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归算法-1"><a href="#非递归算法-1" class="headerlink" title="非递归算法"></a>非递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    BinTree p=T;stack&lt;BinTree&gt;s;</span><br><span class="line"><span class="keyword">while</span>( p!=<span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;data);<span class="comment">//中序，第二次遇到才输出</span></span><br><span class="line">         p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>visit(p-&gt;data)</code></strong> 语句与 <strong><code>s.pop()</code></strong> 语句成对出现，这表明&#x3D;&#x3D;<strong><font color='red'>中序遍历的序列就是出栈的顺序</font></strong>&#x3D;&#x3D;</p></blockquote><ul><li><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951501.png" alt="image-20221104113447879"></p><ul><li><p>因为先序序列和中序序列可以唯一地确定一棵二叉树，并且题目已经给出了先序序列，所以我们只需要知道由该先序序列可以确定多少个中序序列，即可确定确定多少棵二叉树！</p></li><li><p>那么，问题来了，由一个先序序列如何确定有多少个中序序列呢？这就有两个“公式”需要大家去牢记了！</p></li></ul><blockquote><p>1、先序序列和中序序列的关系为：&#x3D;&#x3D;<strong><font color='blue'>以先序序列入栈，则出栈序列必为中序序列</font></strong>&#x3D;&#x3D;。</p></blockquote><blockquote><p> 2、一个入栈顺序可以确定的出栈顺序有 f(n)种（卡特兰数）。<img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951534.gif" alt="\huge f(n)=C_{2 n}^{n}-C_{2 n}^{n-1}=\frac{1}{n+1}C_{2 n}^{n}"></p><p> <strong>n为结点个数</strong></p></blockquote><ul><li><p>所以答案就清楚了，如果以abcd的顺序入栈，将有14种出栈顺序，也就是可以确定14个中序序列，即可以确定14个不同的二叉树。</p></li><li><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2></li></ul><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951603.jpeg" alt="cc293158eada8a006e03efc872bb308" style="zoom:67%;" /><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>后序遍历(后根遍历)</strong></p><ol><li>若二又树为空，则退出；</li><li>若不空：<ol><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点</li></ol></li></ol><h3 id="递归算法-2"><a href="#递归算法-2" class="headerlink" title="递归算法"></a>递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">postorder</span>(T-&gt;right);</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归算法-2"><a href="#非递归算法-2" class="headerlink" title="非递归算法"></a>非递归算法</h3><ul><li><p><strong>双栈法</strong>：用两个栈来实现后序遍历的非递归算法。</p></li><li><p>注意到**<font color='purple'>后序遍历</font><strong>可以看作是<font color='purple'><strong>下面遍历的逆过程</strong></font>：即</strong>先遍历<font color='red'>根结点</font>，然后遍历其<font color='red'>右子树</font>，然后遍历其<font color='red'>左子树</font><strong>。这个</strong><font color='blue'>过程逆过来就是后序遍历</font>**。算法步骤如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    BinTree p = T;stack&lt;BinTree&gt; s1, s2;</span><br><span class="line">    <span class="keyword">while</span> ( p!=<span class="literal">NULL</span> || !s1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(p);</span><br><span class="line">            s2.<span class="built_in">push</span>(p);<span class="comment">//visit(p)换成s2.push();</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            p = s1.<span class="built_in">top</span>();s1.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//逆序输出即为后序遍历    </span></span><br><span class="line">    <span class="keyword">while</span> (!s2.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        p = s2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951110.png" alt="image-20221001230537604"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="comment">/* 若是空树则直接返回 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;BinTree&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        BinTree t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(t-&gt;data); <span class="comment">/* 访问取出队列的结点 */</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left)</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果返回形式是下面的类型:<strong>:star2:LeetCode102</strong></p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20240220223112586.png" alt="image-20240220223112586" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                row.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.<span class="built_in">push_back</span>(row);</span><br><span class="line">            row.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="先序遍历建立二叉树"><a href="#先序遍历建立二叉树" class="headerlink" title="先序遍历建立二叉树"></a>先序遍历建立二叉树</h2><p><strong>扩充先序序列：先序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的先序遍历序列是：ABCDEFG</strong><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png" alt="在这里插入图片描述"></p><p><strong>扩充先序序列为：ABC##DE#G##F###</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">T-&gt;data = x;<span class="comment">//生成根结点</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历建立二叉树"><a href="#中序遍历建立二叉树" class="headerlink" title="中序遍历建立二叉树"></a>中序遍历建立二叉树</h2><p><strong>扩充中序序列：中序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的中序遍历序列是：CBEGDFA</strong><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png" alt="在这里插入图片描述"></p><p><strong>扩充先序序列为：#C#B#E#G#D#F#A#</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line">        T-&gt;data = x;<span class="comment">//生成根结点</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历建立二叉树"><a href="#后序遍历建立二叉树" class="headerlink" title="后序遍历建立二叉树"></a>后序遍历建立二叉树</h2><p><strong>扩充后序序列：后序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的后序遍历序列是：CGEFDBA</strong><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png" alt="在这里插入图片描述"></p><p><strong>扩充先序序列为：##C###GE##FDB#A</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">        T-&gt;data = x;<span class="comment">//生成根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树的高度（深度）"><a href="#求二叉树的高度（深度）" class="headerlink" title="求二叉树的高度（深度）"></a>求二叉树的高度（深度）</h2><blockquote><p>算法基本思想：</p><p>1、若二叉树为&#x3D;&#x3D;<strong>空树</strong>&#x3D;&#x3D;，则高度（深度）为0<br>2、否则，二叉树的高度（深度）为左右子树的高度（深度）的最大值+1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeHeight</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h1 = <span class="built_in">TreeHeight</span>(T-&gt;left);</span><br><span class="line">    <span class="type">int</span> h2 = <span class="built_in">TreeHeight</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (h1 &gt; h2)</span><br><span class="line">        <span class="keyword">return</span> h1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> h2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求二叉树的直径"><a href="#求二叉树的直径" class="headerlink" title="求二叉树的直径"></a>求二叉树的直径</h2><p>【LeetCode:543】</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402211129363.png" alt="image-20240221112902928"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left), r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        res = <span class="built_in">max</span>(res, l + r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="统计结点个数"><a href="#统计结点个数" class="headerlink" title="统计结点个数"></a>统计结点个数</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951318.png" alt="image-20221002083141111"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nodesum</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodesum</span>(T-&gt;left)+<span class="built_in">nodes</span>(T-&gt;right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计叶结点个数"><a href="#统计叶结点个数" class="headerlink" title="统计叶结点个数"></a>统计叶结点个数</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951178.png" alt="image-20221002085013531"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leafnodes</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;left == <span class="literal">NULL</span> &amp;&amp; T-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leafnodes</span>(T-&gt;left) + <span class="built_in">leafnodes</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计度数为2的结点个数"><a href="#统计度数为2的结点个数" class="headerlink" title="统计度数为2的结点个数"></a>统计度数为2的结点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nodes_two</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;left &amp;&amp; T-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodes_two</span>(T-&gt;left) + <span class="built_in">nodes_two</span>(T-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodes_two</span>(T-&gt;left) + <span class="built_in">nodes_two</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为对称二叉树"><a href="#判断是否为对称二叉树" class="headerlink" title="判断是否为对称二叉树"></a>判断是否为对称二叉树</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402202108310.png" alt="image-20240220210836661"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(TreeNode *a, TreeNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">nullptr</span> &amp;&amp; b != <span class="literal">nullptr</span> &amp;&amp; a-&gt;val == b-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(a-&gt;left, b-&gt;right) &amp;&amp; <span class="built_in">func</span>(a-&gt;right, b-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个二叉树是否相同"><a href="#判断两个二叉树是否相同" class="headerlink" title="判断两个二叉树是否相同"></a>判断两个二叉树是否相同</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBinTree</span><span class="params">(BinTree T1, BinTree T2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((T1 == <span class="literal">NULL</span> &amp;&amp; T2 != <span class="literal">NULL</span>) || (T1 != <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T1-&gt;data != T2-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isBinTree</span>(T1-&gt;left) &amp;&amp; <span class="built_in">isBinTree</span>(T1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出叶结点"><a href="#输出叶结点" class="headerlink" title="输出叶结点"></a>输出叶结点</h2><p>本题要求按照<strong>先序遍历</strong>的顺序输出二叉树的叶结点。</p><blockquote><p>思路：&#x3D;&#x3D;<strong>先序遍历</strong>&#x3D;&#x3D;输出根节点时**<font color='red'>加上判断</font>**其是否为叶结点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderPrintLeaves</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">visit</span>(T-&gt;data);</span><br><span class="line">        <span class="built_in">PreorderPrintLeaves</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">PreorderPrintLeaves</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除二叉树"><a href="#删除二叉树" class="headerlink" title="删除二叉树"></a>删除二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyTree</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">Destroy</span>(T-&gt;left);</span><br><span class="line">    <span class="built_in">Destrot</span>(T-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：必须**<code>Destroy(T-&gt;left);Destrot(T-&gt;right);</code>  <font color='red'>之后</font>才能<code>free(T);</code>**</p></blockquote><h2 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951514.png" alt="image-20221002113115794"></p><h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951555.png" alt="image-20221002113137163"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinTree &amp;b, BinTree &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        t == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;data = b-&gt;data;</span><br><span class="line">    <span class="built_in">CopyTree</span>(b-&gt;left, t-&gt;left);</span><br><span class="line">    <span class="built_in">CopyTree</span>(b-&gt;right, b-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">CopyTree</span><span class="params">(BinTree b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;data = b-&gt;data;</span><br><span class="line">    t-&gt;left = <span class="built_in">CopyTree</span>(b-&gt;left);</span><br><span class="line">    t-&gt;right = <span class="built_in">CopyTree</span>(b-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="交换二叉树的左右子树"><a href="#交换二叉树的左右子树" class="headerlink" title="交换二叉树的左右子树"></a>交换二叉树的左右子树</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951582.png" alt="image-20221002120102502"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402202059497.png" alt="image-20240220205942861"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">invertTree</span><span class="params">(BinTree b, BinTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;data = b-&gt;data;</span><br><span class="line">    <span class="built_in">invertTree</span>(b-&gt;left, t-&gt;right);</span><br><span class="line">    <span class="built_in">invertTree</span>(b-&gt;right, t-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以破坏原来的二叉树,则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回值为x的结点所在的层数"><a href="#返回值为x的结点所在的层数" class="headerlink" title="返回值为x的结点所在的层数"></a>返回值为x的结点所在的层数</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951796.jpeg" alt="38251992cd4cab160ebe3b423b0e74a"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodeLevel</span> <span class="params">(BinTree T,ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树的层号为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;data==X)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//规定根节点的层号为1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t1=<span class="built_in">NodeLevel</span>(T-&gt;left,X);</span><br><span class="line">        <span class="type">int</span> t2=<span class="built_in">NodeLevel</span>(T-&gt;right,X);</span><br><span class="line">        <span class="keyword">if</span>(t1 &gt; <span class="number">0</span>)<span class="keyword">return</span> t1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t2 &gt; <span class="number">0</span>)<span class="keyword">return</span> t2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若树中不存在值为X的结点，返回0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>若函数返回0，说明树中不存在值为X的结点</strong></p></blockquote><h2 id="前序中序建树"><a href="#前序中序建树" class="headerlink" title="前序中序建树"></a>前序中序建树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* BinTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType data;</span><br><span class="line">BinTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> preorder[<span class="number">50</span>],inorder[<span class="number">50</span>];</span><br><span class="line"><span class="function">BinTree <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> i=left;</span><br><span class="line"><span class="keyword">while</span>( i&lt;right &amp;&amp; preorder[root]!=inorder[i])i++;</span><br><span class="line">BinTree t=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">t-&gt;data=preorder[root];</span><br><span class="line">t-&gt;left=<span class="built_in">BuildTree</span>(root+<span class="number">1</span>,left,i<span class="number">-1</span>);</span><br><span class="line">t-&gt;right=<span class="built_in">BuildTree</span>(root+i-left+<span class="number">1</span>,i+<span class="number">1</span>,right);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序中序建树"><a href="#后序中序建树" class="headerlink" title="后序中序建树"></a>后序中序建树</h2><h3 id="法一：-1"><a href="#法一：-1" class="headerlink" title="法一："></a>法一：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* BinTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType data;</span><br><span class="line">BinTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>],inorder[<span class="number">50</span>];</span><br><span class="line"><span class="function">BinTree <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> i=left;</span><br><span class="line"><span class="keyword">while</span>( i&lt;right &amp;&amp; postorder[root]!=inorder[i])i++;</span><br><span class="line">BinTree t=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">t-&gt;data=postorder[root];</span><br><span class="line">t-&gt;left=<span class="built_in">BuildTree</span>(root -right + i - <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">t-&gt;right=<span class="built_in">BuildTree</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T=<span class="built_in">BuildTree</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><h3 id="法二：-1"><a href="#法二：-1" class="headerlink" title="法二："></a>法二：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* BinTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType data;</span><br><span class="line">BinTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>],inorder[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, BinTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&gt;right)T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=left;</span><br><span class="line"><span class="keyword">while</span>(i&lt;right &amp;&amp; preorder[root]!=inorder[i])i++;</span><br><span class="line">T=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line"><span class="comment">//T=new TreeNode;</span></span><br><span class="line">T-&gt;data=preorder[root];</span><br><span class="line"><span class="built_in">BuildTree</span>(root+<span class="number">1</span>, left, i<span class="number">-1</span>, T-&gt;left);</span><br><span class="line"><span class="built_in">BuildTree</span>(root+i-left+<span class="number">1</span>, i+<span class="number">1</span>, right, T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T;</span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>,T);</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>注意第10行<code>if(left&gt;right)T=NULL;</code>而<strong>不能直接</strong>&#x3D;&#x3D;<del>&#96;&#96;return;&#96;</del>&#x3D;&#x3D;</p></li><li><p><code>void BuildTree(int root, int left, int right, BinTree &amp;T)</code></p><p> 中注意**<code>T</code><strong>是引用类型，加一个&#x3D;&#x3D;</strong>&amp;**&#x3D;&#x3D;</p></li><li><p>递归模型</p><ul><li><p><strong><code>left&gt;rightT==NULL;</code></strong></p></li><li><p><strong><code>BuildTree(root+1, left, i-1, T-&gt;left);</code></strong></p><p>  <strong><code>BuildTree(root+i-left+1, i+1, right, T-&gt;right);</code></strong></p></li></ul></li></ol></blockquote><h2 id="前序中序转后序"><a href="#前序中序转后序" class="headerlink" title="前序中序转后序"></a>前序中序转后序</h2><p>已知前序与中序,请输出后序。<br>前序：1, 2, 3, 4, 5, 6（根左右）<br>中序：3, 2, 4, 1, 6, 5（左根右）</p><blockquote><p>分析：因为前序的第一个总是根结点，令i在中序中找到该根结点，<br>则i把中序分为两部分，左边是左子树，右边是右子树。因为是输出后序（左右根）<br>所以先打印出当前左子树，然后右子树，再打印根结点。</p></blockquote><p><strong>:smile:算法</strong></p><ol><li>root为当前子树的根结点在<strong>前序</strong><code>preorder</code>中的下标。<br> <strong>left和right</strong>为当前子树的最左边和最右边的结点在<strong>中序</strong><code>inorder</code>中的下标。</li><li>用<code>i</code>找到当前子树的<strong>根结点</strong>root在<strong>中序</strong>中的下标，<br> 然后左边和右边就分别为当前根结点root的左子树和右子树。递归实现～</li><li>左子树在<strong>前序</strong>中的根结点为当前根结点的后一个结点<code>root + 1</code>；<br> 左子树在<strong>中序</strong>中的起始点left为<code>left</code>，末尾点right为<code>i – 1</code>.</li><li>右子树的根结点在<strong>前序</strong>中为<code>root + (i -left + 1)</code>，即为当前根结点+(左子树的个数+1)。<br> 右子树在中序中的起始点left为<code>i+1</code>，末尾right点为<code>right</code>。</li></ol><p>输出的后序应为：3 4 2 6 5 1（左右根）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须使用数组，且数组必须是是全局变量 </span></span><br><span class="line"><span class="type">int</span> preorder[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;<span class="comment">//前序 </span></span><br><span class="line"><span class="type">int</span> inorder[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;<span class="comment">//中序 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = left;<span class="comment">//i从当前树的起点开始寻找 ，直到end </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; right &amp;&amp; inorder[i] != preorder[root]) i++;</span><br><span class="line">    <span class="built_in">postorder</span>(root +<span class="number">1</span> , left, i - <span class="number">1</span>);<span class="comment">//左子树 </span></span><br><span class="line">    <span class="built_in">postorder</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right);<span class="comment">//右子树 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, preorder[root]);<span class="comment">//或printf(&quot;%d &quot;, in[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">postorder</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>);<span class="comment">//初始根节点在preorder和最左最右结点在inorder中下标已知 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序中序转前序"><a href="#后序中序转前序" class="headerlink" title="后序中序转前序"></a>后序中序转前序</h2><p>已知后序与中序,请输出前序（先序）：<br>后序：3, 4, 2, 6, 5, 1（左右根）<br>中序：3, 2, 4, 1, 6, 5（左根右）</p><blockquote><p>分析：因为后序的最后一个总是根结点，令<code>i</code>在中序中找到该根结点，然后<code>i</code>把中序分为两部分，左边是左子树，右边是右子树。因为是输出先序（根左右），所以先打印出当前根结点，然后打印左子树，再打印右子树。 </p></blockquote><p><strong>:smile:算法</strong></p><ol><li><p>root为当前子树的根结点在<strong>后序</strong><code>postorder</code>中的下标。<br> <strong>left和right</strong>为当前子树的最左边和最右边的结点在<strong>中序</strong><code>inorder</code>中的下标。</p></li><li><p>用<code>i</code>找到当前子树的<strong>根结点</strong>root在<strong>中序</strong>中的下标，<br> 然后左边和右边就分别为当前根结点root的左子树和右子树。递归实现～</p></li><li><p>左子树的根结点在<strong>后序</strong>中为<code>root – (end – i + 1)</code>，即为当前根结点-(右子树的个数+1)；<br> 左子树在中序中的起始点left为<code>left</code>，末尾点right为<code>i – 1</code>.</p></li><li><p>右子树的根结点在后序中为当前根结点的前一个结点root – 1；<br> 右子树在中序中的起始点left为<code>i+1</code>，末尾right点为<code>right</code>。</p></li></ol><p>输出的前序应该为：1, 2, 3, 4, 5, 6（根左右）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> postorder[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;<span class="comment">//后序 </span></span><br><span class="line"><span class="type">int</span> inorder[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;<span class="comment">//中序 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法一： </span></span><br><span class="line"><span class="comment">//int i;</span></span><br><span class="line"><span class="comment">//for(i=left;i&lt;right&amp;&amp;inorder[i]!=postorder[root];i++) ;    </span></span><br><span class="line"><span class="comment">//法二： </span></span><br><span class="line">    <span class="type">int</span> i = left;<span class="comment">//i从当前树的起点开始寻找 ，直到end </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; right &amp;&amp; inorder[i] != postorder[root]) i++;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, postorder[root]);<span class="comment">//或printf(&quot;%d &quot;, inorder[i]);</span></span><br><span class="line">    <span class="built_in">preorder</span>(root - <span class="number">1</span> - right + i, left, i - <span class="number">1</span>);<span class="comment">//左子树 </span></span><br><span class="line">    <span class="built_in">preorder</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, right);<span class="comment">//右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">preorder</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>);<span class="comment">//初始根节点在postorder和最左最右结点在inorder中下标已知 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&#x3D;&#x3D;<strong><font color='blue'>二叉搜索树</font></strong> &#x3D;&#x3D; <strong><font color='blue'>二叉查找树</font></strong> （Binary Search Tree） &#x3D;&#x3D; <strong><font color='blue'>二叉排序树</font></strong> （Binary Sort Tree）&#x3D;&#x3D;</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951806.png" alt="在这里插入图片描述"></p><blockquote><ol><li><h2 id="二叉排序树的-中序遍历是递增-序列"><a href="#二叉排序树的-中序遍历是递增-序列" class="headerlink" title="&#x3D;&#x3D;二叉排序树的**中序遍历是递增**序列&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>二叉排序树</strong>的**<font color='red'>中序遍历</font><strong>是</strong><font color='gree'>递增</font>**序列&#x3D;&#x3D;</h2></li><li>在构造二叉排序树时，若关键字序列有序，则二叉排序树的高度最大</li></ol></blockquote><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left, *right;</span><br><span class="line">&#125;* BinTree;</span><br></pre></td></tr></table></figure><blockquote><p>**<code>struct TreeNode* left, *right;</code><strong>中</strong><code>*</code>**是跟着变量名的</p></blockquote><h2 id="操作集"><a href="#操作集" class="headerlink" title="操作集"></a>操作集</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li>函数<code>Find</code>在二叉搜索树<code>T</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li></ul><h4 id="法一：递归"><a href="#法一：递归" class="headerlink" title="法一：递归"></a>法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Find</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(X &gt; T-&gt;data)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Find</span>(T-&gt;right,X);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;data)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Find</span>(T-&gt;left,X);</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二：循环"><a href="#法二：循环" class="headerlink" title="法二：循环"></a>法二：循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Find</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;data)</span><br><span class="line">            T=T-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;data)</span><br><span class="line">            T=T-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最小值"><a href="#找最小值" class="headerlink" title="找最小值"></a>找最小值</h3><ul><li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li></ul><h4 id="法一：递归-1"><a href="#法一：递归-1" class="headerlink" title="法一：递归"></a>法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">FindMin</span>(T-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二-循环"><a href="#法二-循环" class="headerlink" title="法二:循环"></a>法二:循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">while</span>(T-&gt;left)</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最大值"><a href="#找最大值" class="headerlink" title="找最大值"></a>找最大值</h3><ul><li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li></ul><h4 id="法一：递归-2"><a href="#法一：递归-2" class="headerlink" title="法一：递归"></a>法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">FindMin</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二：循环-1"><a href="#法二：循环-1" class="headerlink" title="法二：循环"></a>法二：循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">while</span>(T-&gt;right)</span><br><span class="line">            T=T-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li></ul><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;data=X;</span><br><span class="line">        T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X&lt;T-&gt;Data)    </span><br><span class="line">            T-&gt;left=<span class="built_in">Insert</span>(T-&gt;left,X);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;data)</span><br><span class="line">            T-&gt;right=<span class="built_in">Insert</span>(T-&gt;right,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">( BinTree &amp;T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;data=X;T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;data)</span><br><span class="line">            <span class="built_in">Insert</span>( T-&gt;right, ElementType X );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;data)</span><br><span class="line">            <span class="built_in">Insert</span>( T-&gt;left, ElementType X );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>二叉树排序树中**<font color='red'>不存在</font>**相同的结点，故</p><p>  <strong><code>if( X==T-&gt;data )return;         //无需插入</code></strong></p></li><li><p>注意函数参数T是<font color='blue'><strong>引用&amp;类型</strong></font></p></li></ul></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li></ul><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951998.png" alt="image-20221019104744543" style="zoom:80%;" /><p><strong>（1）p为叶结点</strong></p><p>删除方法：释放结点p，修改p父节点指针f的相应指针</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951995.png" alt="image-20221019105019917" style="zoom:80%;" /><p><strong>（2）p只有左子树</strong></p><p>删除方法：释放结点p，p的左子树顶替p结点的位置</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952089.png" alt="image-20221019105212235"></p><p><strong>（3）p只有右子树</strong></p><p>删除方法：释放结点p，p的右子树顶替p结点的位置</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952098.png" alt="image-20221019105327790"></p><p><strong>(4）p既有左子树，也有右子树</strong></p><p>删除方法：寻找p**<font color='red'>左子树中最大的结点</font>** 或 p**<font color='red'>右子树中最小的结点</font>** 来替代结点p</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952259.png" alt="image-20221019191743343" style="zoom:67%;" /><h4 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;data)</span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(T-&gt;left,X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;data)</span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(T-&gt;right,X);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left &amp;&amp; T-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            BinTree t=<span class="built_in">FindMin</span>(T-&gt;right);</span><br><span class="line">            T-&gt;data=t-&gt;data;</span><br><span class="line">            T-&gt;right=<span class="built_in">Delete</span>(T-&gt;right,T-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            BinTree t=T;</span><br><span class="line">            <span class="keyword">if</span>(!T-&gt;left)</span><br><span class="line">                T=T-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!T-&gt;right)</span><br><span class="line">                T=T-&gt;left;  </span><br><span class="line">            <span class="built_in">free</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952414.jpeg" alt="微信图片_20221019200024"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">( BinTree &amp;T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;data)</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;left,X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;data)</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;right,X);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( T-&gt;left == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;BinTree t=T;T = T-&gt;left;<span class="built_in">free</span>(t);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;right == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;BinTree t=T;T = T-&gt;right;<span class="built_in">free</span>(t);&#125;          </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;<span class="comment">//在左子树中寻找最大的（最右边的）</span></span><br><span class="line">            BinTree p=T;BinTree t=T-&gt;left;</span><br><span class="line">            <span class="comment">//初始化：p为t的父节点,t为左子树的根节点</span></span><br><span class="line">            <span class="keyword">while</span>( t-&gt;right )</span><br><span class="line">            &#123;p = t;t=t-&gt;right;&#125;<span class="comment">//p为被删除结点t的前驱</span></span><br><span class="line">            T-&gt;data=t-&gt;data;</span><br><span class="line">            <span class="keyword">if</span>(p!=T )p-&gt;right=t-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;left=t-&gt;left；</span><br><span class="line">            <span class="built_in">free</span>(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​平衡二叉树 全称叫做 <code>平衡二叉搜索（排序）树</code>，简称 AVL树。英文：Balanced Binary Tree （BBT），注：二叉查找树(BST)</p><h3 id="AVL-什么意思-？"><a href="#AVL-什么意思-？" class="headerlink" title="AVL 什么意思 ？"></a>AVL 什么意思 ？</h3><p>​AVL 是大学教授 G.M. Adelson-Velsky 和 E.M. Landis 名称的缩写，他们提出的平衡二叉树的概念，为了纪念他们，将 平衡二叉树称为AVL树。</p><h3 id="为什么使用AVL树"><a href="#为什么使用AVL树" class="headerlink" title="为什么使用AVL树"></a>为什么使用AVL树</h3><p>​二叉搜索树能提高查找的效率 O(log n)，但是当你插入 <code>&#123;1,2,3,4,5,6&#125;</code> 这种数据的时候，二叉树的效率变为 O(n)</p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952506.png" alt="image-20210110143451761" style="zoom: 33%;" /><p>判断「平衡二叉树」的 2 个条件：</p><ul><li><strong>1. 是「二叉排序树」</strong></li><li><strong>2. 任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于 1）</strong></li></ul><h3 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h3><p>平衡因子（Balance Factor，简写为bf）<br><font color='red'> <strong>结点的平衡因子 &#x3D; 左子树的&#x3D;&#x3D;高度&#x3D;&#x3D; - 右子树的&#x3D;&#x3D;高度&#x3D;&#x3D;</strong> </font>。</p><blockquote><p> <strong>在 AVL树中，所有节点的平衡因子都必须满足： -1&lt;&#x3D;bf&lt;&#x3D;1;</strong></p></blockquote><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>详细请看<a href="https://zhuanlan.zhihu.com/p/165939383">【数据结构】AVL树（平衡二叉树）画法 速成教学 - 知乎 (zhihu.com)</a></p><blockquote><p>注：**<font color='red'>Ctrl+点击</font>**打开连接</p></blockquote><h3 id="LL型—右旋"><a href="#LL型—右旋" class="headerlink" title="LL型—右旋"></a>LL型—右旋</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BinTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree t=p-&gt;left;</span><br><span class="line">    p-&gt;left=t-&gt;right;</span><br><span class="line">    t-&gt;right=p;</span><br><span class="line">    p=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RR型—左旋"><a href="#RR型—左旋" class="headerlink" title="RR型—左旋"></a>RR型—左旋</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952586.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree t=p-&gt;right;</span><br><span class="line">    p-&gt;right=t-&gt;left;</span><br><span class="line">    t-&gt;left=p;</span><br><span class="line">    p=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LR型—左右旋"><a href="#LR型—左右旋" class="headerlink" title="LR型—左右旋"></a>LR型—左右旋</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952663.png" alt="在这里插入图片描述"></p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952646.png" alt="在这里插入图片描述" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LR_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">L_Rotate</span>(p-&gt;left);</span><br><span class="line">    <span class="built_in">R_Rotate</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RL型—右左旋"><a href="#RL型—右左旋" class="headerlink" title="RL型—右左旋"></a>RL型—右左旋</h3><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952836.png" alt="在这里插入图片描述" style="zoom:95%;" /><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952963.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RL_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">R_Rotate</span>(p-&gt;right);</span><br><span class="line">    <span class="built_in">L_Rotate</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AVL树的最小节点个数"><a href="#AVL树的最小节点个数" class="headerlink" title="AVL树的最小节点个数"></a>AVL树的最小节点个数</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952095.png" alt="image-20221025134419965"></p><p> <strong>N<del>5</del> &#x3D;12</strong></p><blockquote><h2 id="规律Nh-Nh-1-Nh-2-1"><a href="#规律Nh-Nh-1-Nh-2-1" class="headerlink" title="&#x3D;&#x3D;规律Nh &#x3D; Nh-1 + Nh-2 + 1&#x3D;&#x3D;"></a>&#x3D;&#x3D;规律<strong><font color='red'>N<del>h</del> &#x3D; N<del>h-1</del> + N<del>h-2</del> + 1</font></strong>&#x3D;&#x3D;</h2></blockquote><ul><li><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>  <img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952086.jpeg" alt="4dbdbc1fbebe98c53d33d4a2eb42fa5"></p><p>  <strong><code>1 2 4 7 12 20 33</code></strong> - # B</p><p>  21个结点达到了5层所需的最小结点数，但没有达到6层所需的最小结点数</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>1123 Is It a Complete AVL Tree</strong></p><p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><table><thead><tr><th><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952090.jpeg" alt="F1.jpg"></th><th><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952183.jpeg" alt="F2.jpg"></th></tr></thead><tbody><tr><td><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952280.jpeg" alt="F3.jpg"></td><td><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952482.jpeg" alt="F4.jpg"></td></tr></tbody></table><p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 63 65</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">70 63 88 61 65</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">88 70 61 96 120 90 65 68</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88 65 96 61 70 90 120 68</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    TreeNode *temp = tree-&gt;right;</span><br><span class="line">    tree-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = tree;</span><br><span class="line">    tree = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    TreeNode *temp = tree-&gt;left;</span><br><span class="line">    tree-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = tree;</span><br><span class="line">    tree = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftRightRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">leftRotate</span>(tree-&gt;left);</span><br><span class="line">    <span class="built_in">rightRotate</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rightLeftRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rightRotate</span>(tree-&gt;right);</span><br><span class="line">    <span class="built_in">leftRotate</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode *tree, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        tree-&gt;val = val;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;val &gt; val) &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">insert</span>(tree-&gt;left, val);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left), r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (l - r &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; tree-&gt;left-&gt;val)</span><br><span class="line">                <span class="built_in">rightRotate</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">leftRightRotate</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">insert</span>(tree-&gt;right, val);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left), r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; tree-&gt;right-&gt;val)</span><br><span class="line">                <span class="built_in">leftRotate</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">rightLeftRotate</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> isComplete = <span class="number">1</span>, after = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode *tree)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    queue&lt;TreeNode *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(tree);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *temp = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    TreeNode *tree = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        tree = <span class="built_in">insert</span>(tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">levelOrder</span>(tree);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s&quot;</span>, isComplete ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的深度-高度-层数"><a href="#树的深度-高度-层数" class="headerlink" title="树的深度&#x2F;高度&#x2F;层数"></a>树的深度&#x2F;高度&#x2F;层数</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><strong>深度定义是从上往下的，高度定义是从下往上的。</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952536.jpeg" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&#x3D;&#x3D;<strong>高度&#x3D;深度&#x3D;层数</strong>&#x3D;&#x3D;</p><blockquote><p>其中<strong>根结点</strong>的<strong>高度&#x2F;层数&#x2F;深度</strong>均为1</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952587.jpeg" alt="img"></p><table><thead><tr><th>图</th><th></th></tr></thead><tbody><tr><td>层数</td><td>第1层开始</td></tr><tr><td>最大层数</td><td>5</td></tr><tr><td>深度</td><td>5</td></tr><tr><td>高度</td><td>5</td></tr></tbody></table><h1 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h1><h2 id="树、二叉树、森林的关系"><a href="#树、二叉树、森林的关系" class="headerlink" title="树、二叉树、森林的关系"></a>树、二叉树、森林的关系</h2><blockquote><p>**<font color='blue'>树&lt; &#x3D;&#x3D; &gt;二叉树&lt; &#x3D;&#x3D; &gt;森林</font><strong>（三者</strong><font color='red'>一 一对应</font>**）</p><ul><li>树可以唯一地确定 二叉树 和 森林</li><li>二叉树（不含左子树）可以唯一地确定 树 和 森林</li><li>森林可以唯一地确定 树和二叉树</li></ul></blockquote><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>树(Tree)是n(n≥0)个结点的有限集合。在任意一棵非空树中，有以下两个性质：<br>(1) 有且<strong>仅有一个特定的结点</strong>，称为根(Root)。<br>(2) 当n＞1时，其余的结点可分为m个互不相交的集合T1，T2，…，Tm，其中每一个集合都是一棵树，并且称为根的<strong>子树</strong>(Subtree)。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952600.png" alt="树型结构实例"></p><h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>森林(Forest)是m(m≥0)棵互不相交的&#x3D;&#x3D;<strong>树的集合</strong>&#x3D;&#x3D;。对树中每个结点而言，其子树的集合即为森林</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952720.png" alt="image-20230924094551480"></p><h2 id="树转化为二叉树"><a href="#树转化为二叉树" class="headerlink" title="树转化为二叉树"></a>树转化为二叉树</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>树中每个结点最多只有一个&#x3D;&#x3D;<strong><font color='red'>最左边的孩子(长子)</font></strong>&#x3D;&#x3D;和一个&#x3D;&#x3D;<strong><font color='blue'>右邻的兄弟</font></strong>&#x3D;&#x3D;。按照这种关系很</p><p>自然地就能将树转换成相应的二叉树：</p><ol><li>在所有兄弟结点之间<strong>加一连线</strong></li><li>对每个结点，除了保留与其<strong>长子</strong>的连线外，去掉该结点与其它孩子的连线。</li></ol><blockquote><p>注</p><ul><li>二叉树的**<font color='cyan'>左结点为儿子节点</font><strong>，</strong><font color='purple'>右结点为兄弟节点</font>**</li><li>任何一棵和&#x3D;&#x3D;<strong><font color='red'>树</font></strong>&#x3D;&#x3D;对应的**<font color='red'>二叉树</font><strong>，其&#x3D;&#x3D;</strong><font color='blue'>右子树必定为空</font>**&#x3D;&#x3D;</li></ul></blockquote><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952797.png" alt="image-20221108225001648"></p><blockquote><p>◆由于一个结点可以有两棵以上的子树，因此一般**<font color='red'>不讨论中根遍历</font>**。</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952916.png" alt="image-20221108225308793"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952127.png" alt="image-20221108225333415"></p><blockquote><ol><li><p>树的&#x3D;&#x3D;<strong><font color='red'>先序遍历</font></strong>&#x3D;&#x3D;与转化为二叉树的&#x3D;&#x3D;<strong><font color='red'>先序遍历</font></strong>&#x3D;&#x3D;相同</p></li><li><p>树的&#x3D;&#x3D;<strong><font color='red'>后序遍历</font></strong>&#x3D;&#x3D;与转化为二叉树的&#x3D;&#x3D;<strong><font color='red'>中序遍历</font></strong>&#x3D;&#x3D;相同</p></li></ol></blockquote><h3 id="例一-1"><a href="#例一-1" class="headerlink" title="例一"></a>例一</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952060.jpeg" alt="在这里插入图片描述"></p><h3 id="例二-1"><a href="#例二-1" class="headerlink" title="例二"></a>例二</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952136.png" alt="image-20221030194329120"></p><h2 id="森林转化二叉树"><a href="#森林转化二叉树" class="headerlink" title="森林转化二叉树"></a>森林转化二叉树</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ol><li>将森林中的每一棵<strong>树</strong>转化为<strong>二叉树</strong></li><li>将各二叉树的根节点视为兄弟结点连在一起</li><li>再将其转化为二叉树</li></ol><blockquote><p>注：</p><ol><li>任何一个&#x3D;&#x3D;<strong>树或森林</strong>&#x3D;&#x3D;可以唯一地对应到一棵<strong>二叉树</strong></li><li>任何一个&#x3D;&#x3D;<strong>二叉树</strong>&#x3D;&#x3D;可以唯一地对应到一棵<strong>树或森林</strong></li></ol></blockquote><h3 id="例一-2"><a href="#例一-2" class="headerlink" title="例一"></a>例一</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952176.png" alt="image-20221030194059329"></p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952254.png" alt="image-20230924094405918"></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952755.png" alt="image-20230924094423337"></p><blockquote><p>将&#x3D;&#x3D;<strong>右边的一棵树</strong>&#x3D;&#x3D;依次作为&#x3D;&#x3D;<strong>左边那棵树</strong>&#x3D;&#x3D;的<strong>右子树</strong>，最后得到的那<strong>1棵树</strong>即为森林对应的二叉树</p></blockquote><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952695.png" alt="image-20230924094513604" style="zoom:33%;" /><h3 id="例二-2"><a href="#例二-2" class="headerlink" title="例二"></a>例二</h3><p>设森林 F 中有三棵树，第一、第二、第三棵树的结点个数分别为M1、M2和M3。与森林F</p><p>对应的二叉树根结点的左子树上的节点个数为（），根结点的右子树上的结点个数是（ )</p><p> A .M1 B .M1+M2 C . M3 D .M2+M3</p><p>E .M1-1F: M2-1G .M2H .M3-1</p><p>&#x3D;&#x3D;<strong>E D</strong>&#x3D;&#x3D;</p><blockquote><p>二叉树根节点<strong>右子树</strong>由森林<font color='red'><strong>除第一棵以外的</strong></font>&#x3D;&#x3D;其他所有树&#x3D;&#x3D;组成</p></blockquote><h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952748.png" alt="image-20221108224146379"></p><h1 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h1><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><h3 id="头结点的设定"><a href="#头结点的设定" class="headerlink" title="头结点的设定"></a>头结点的设定</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952955.png" alt="image-20220928190044829"></p><h3 id="结点的设定"><a href="#结点的设定" class="headerlink" title="结点的设定"></a>结点的设定</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952816.png" alt="image-20220928190232383"></p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952851.png" alt="image-20220928191319175"></p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>前序：ABCDEFGH</p><p>后序：CBDEAGHF</p><p>后序：CEDBHGFA</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952200.png" alt="image-20220928191441993"></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952307.png" alt="image-20220928191522050"></p><blockquote><p>注：</p><ol><li>每个结点用<strong>5个域</strong>来表示</li><li>注意根节点<code>ltag=0;lright=1;</code></li><li><code>tag=1;</code>的指针指向前驱后继，用&#x3D;&#x3D;<strong>带箭头的虚线</strong>&#x3D;&#x3D;表示；</li><li><code>tag=0;</code>的指针指向左右孩子，用&#x3D;&#x3D;<strong>不带箭头的实线</strong>&#x3D;&#x3D;表示；</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
