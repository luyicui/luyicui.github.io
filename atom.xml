<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天道酬勤，厚德载物</title>
  
  
  <link href="https://cuiluyi.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cuiluyi.gitee.io/"/>
  <updated>2024-03-19T07:05:38.573Z</updated>
  <id>https://cuiluyi.gitee.io/</id>
  
  <author>
    <name>tianchou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序运行时间</title>
    <link href="https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/others/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%B0%E7%AE%97/"/>
    <id>https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/others/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%B0%E7%AE%97/</id>
    <published>2024-03-17T06:33:49.000Z</published>
    <updated>2024-03-19T07:05:38.573Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1s 的运行数量大概在<span class="math inline">\(10^7\)</span> ~ <spanclass="math inline">\(10^8\)</span></li></ul><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;1s 的运行数量大概在&lt;span class=&quot;math inline&quot;&gt;&#92;(10^7&#92;)&lt;/span&gt; ~ &lt;span
class=&quot;math inline&quot;&gt;&#92;(10^8&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="others" scheme="https://cuiluyi.gitee.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>咖啡</title>
    <link href="https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/"/>
    <id>https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/</id>
    <published>2024-03-17T01:46:27.000Z</published>
    <updated>2024-03-19T07:03:18.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有关咖啡">有关咖啡</h1><h2id="咖啡因每日的安全使用量是多少">咖啡因每日的安全使用量是多少？</h2><p>一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。</p><span id="more"></span><h2id="雀巢咖啡伴侣是否含反式脂肪酸">雀巢咖啡伴侣是否含反式脂肪酸？</h2><p>在雀巢咖啡伴侣的包装上有明确的标识：反式脂肪酸为0克，所以您可以放心使用。</p><h2id="为什么咖啡伴侣的瓶子是棕色的">为什么咖啡伴侣的瓶子是棕色的？</h2><p>适量的咖啡因摄取对普通大多数的人都是安全的。可能会有一些人群对咖啡因较一般人敏感，与那些对咖啡因不太敏感的人相比，这类人群可能会对少量的咖啡感到不适。通常情况下，孕妇和老年人可能会相对更加敏感一些。</p><h2id="为什么咖啡伴侣的瓶子是棕色的-1">为什么咖啡伴侣的瓶子是棕色的？</h2><p>用棕色瓶子主要是为了避光，咖啡伴侣里某些营养成分是对光敏感的。我们为了在保质期内保证食品的安全和风味，采用了能避光的棕色玻璃瓶。</p><h2 id="喝咖啡对身体有害吗">喝咖啡对身体有害吗？</h2><p>咖啡是一种天然而且健康的饮料。咖啡中除含有咖啡因之外，它还含有对人体健康有利的多种生物活性物质和营养素，如抗氧化物质、矿物质、烟酸和内脂。咖啡能提高警觉性，让我们更有效地利用前额部的大脑皮层，提高注意力和记忆力。关于咖啡因，人们从古代的时候起就开始饮用咖啡类的饮品了。咖啡因是咖啡中的天然含有的成份。目前，人类在大约60种植物中发现了咖啡因，其中最为人知的便是茶和咖啡。而一些常见的食品，如巧克力、可乐中都含有少量咖啡因。</p><h2id="经常喝咖啡是否会导致人体内的钙流失">经常喝咖啡是否会导致人体内的钙流失?</h2><p>咖啡因对钙吸收的不良影响非常小，喝1-2勺牛奶就足以弥补了。所有证据显示，中量饮用咖啡不会改变对钙的消化吸收，不会增加尿钙排泄，也不会从大便中丢失。如果每日摄入咖啡超过1升，尿钙排泄和钙丢失就会增加，但将牛奶加到咖啡里面就可以解决这个问题。适量咖啡因摄入不会对骨代谢产生直接影响。（摘自《咖啡无罪的101个理由》）</p><h2 id="喝咖啡可以减肥吗">喝咖啡可以减肥吗？</h2><p>研究表明，适量喝咖啡有助于控制体重，咖啡中含有膳食纤维，有利于帮助肠道蠕动，促进代谢。如果您想要达到减肥的效果，我们建议您咨询专业的营养师。</p><h2 id="雀巢咖啡是如何诞生的">雀巢咖啡是如何诞生的？</h2><p>二十世纪三十年代，雀巢公司受巴西政府的委托，为其过剩的咖啡寻找保存方法。雀巢公司勇敢地接受了这一技术上的挑战，并于1938年成功开发出速溶咖啡生产工艺。采用该工艺，咖啡粉可以长久地保存而不失其香醇风味。从此，人们可以随时方便地享用美味咖啡。雀巢速溶咖啡便由此诞生了，雀巢咖啡(Nescafe)品牌名称就是由公司名称Nestlé及英文中代表咖啡的CAFE组成。</p><h2 id="咖啡中的12是什么意思">1+2咖啡中的1+2是什么意思？</h2><p>1+2咖啡中的1+2是指：1=咖啡，2=植脂末+糖</p><h2 id="每天在什么时间喝咖啡比较好">每天在什么时间喝咖啡比较好？</h2><p>建议白天饮用咖啡。如果想保持规律的生理周期，晚上不要饮用咖啡。</p><h2id="雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏">雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏？</h2><p>即饮咖啡产品冷热饮均可，如加热饮用，加热温度不宜超过55度，勿将瓶装产品放置于火上或微波炉中直接加热，以免发生危险。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;有关咖啡&quot;&gt;有关咖啡&lt;/h1&gt;
&lt;h2
id=&quot;咖啡因每日的安全使用量是多少&quot;&gt;咖啡因每日的安全使用量是多少？&lt;/h2&gt;
&lt;p&gt;一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:
研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://cuiluyi.gitee.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【数学知识】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/15/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/15/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/</id>
    <published>2024-03-15T02:27:16.000Z</published>
    <updated>2024-03-20T07:58:12.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学知识">数学知识</h1><p>:smile:<strong>数论</strong> 经常会出现 <strong>数的大小越界</strong>情况：</p><ul><li>尤其是在做<strong>乘法</strong>、其次是<strong>加法</strong>的时候非常容易溢出，此时可以使用<code>long long</code> 局部转换</li><li>比较稳妥的、一劳永逸的办法是<strong>变量类型</strong>不使用int，<strong>全部使用</strong> <code>long long</code></li></ul><h2 id="质数">质数</h2><ul><li><strong>质数</strong>：在大于 1 的整数中，如果只包含 1和本身这两个约数，就被成为质数，或者叫素数。</li><li><strong>算数基本定理</strong>：任一大于1的整数 <spanclass="math inline">\(n\)</span>​ 能够唯一地表示成</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_s}^{\alpha _s},  \alpha_i&gt;0,  i=1,2,\cdots ,s\left( * \right)\]</span></p><p>​ 分解式(*)叫做 的 n 的标准分解式</p><p>注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 n表成下面形式： <span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><span id="more"></span><h3 id="判定质数试除法">判定质数——试除法</h3><ul><li>一个数的因数都是成对出现的（例如 12 的因数有 3 和 4，2 和6）所以我们可以只枚举较小的那一个。假设较小的为 <spanclass="math inline">\(d\)</span>，较大的为 <spanclass="math inline">\(n/d\)</span>，则：</li></ul><p><span class="math display">\[d\leqslant \frac{n}{d}\Longrightarrow d\leqslant \sqrt{n}\]</span></p><ul><li>时间复杂度：<span class="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="comment">// 注意是小于等于</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数试除法">分解质因数——试除法</h3><ul><li>时间复杂度：<span class="math inline">\(O(\sqrt{n})\)</span>​</li><li>性质：整数 n 中最多只含有一个<strong>大于</strong> sqrt(n)的<font color ='red'><strong>质因子</strong></font><ul><li>证明：通过反证法：如果有两个大于 sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</li><li>eg：6 的质因子 3 &gt; sqrt(6)</li></ul></li><li>证明循环里面的 i 一定是一个质数:</li></ul><blockquote><p>假如 i是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是n 的质因子且比 i 要小，而比 i小的数在之前的循环过程中一定是被条件除完了的，所以 i不可能是合数，只可能是质数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 输出最后一个大于sqrt(n)的质数，注意这里的n可能已经被上面的代码更新过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eg：<span class="math inline">\(n = 96 = 2^5 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span> 且 <spanclass="math inline">\(3&gt;\sqrt{6}\)</span> ）</li><li>eg：<span class="math inline">\(n = 6 = 2 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span>）</li><li>eg：n=17，循环不会输出，直接跳到最后判断输出 17（<spanclass="math inline">\(17&gt;\sqrt{17}\)</span>）</li><li>eg：<spanclass="math inline">\(n=16=2^4\)</span>，循环输出后，直接跳到最后判断，不会输出（<spanclass="math inline">\(1=\sqrt{1}\)</span>）</li></ul><h3 id="求-1-n-中的所有素数">求 1 ~ n 中的所有素数</h3><h4 id="朴素筛法不用">朴素筛法【不用】</h4><ul><li><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span>​ <spanclass="math display">\[\frac{n}{2}+\frac{n}{3}+\cdots +\frac{n}{n}=n\left(\frac{1}{2}+\frac{1}{3}+\cdots +\frac{1}{n} \right) \approx n\log n\]</span></p></li><li><p>原理：任意<strong>整数</strong> x <spanclass="math inline">\((x&gt;1)\)</span> 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)<span class="comment">// 循环n/i次</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eratosthenes筛法不用">Eratosthenes筛法【不用】</h4><ul><li><p>时间复杂度：<spanclass="math inline">\(O(nloglogn)\)</span></p></li><li><p>原理：任意<font color='red'><strong>素数</strong></font> x <spanclass="math inline">\((x&gt;1)\)</span> 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="literal">true</span>;<span class="comment">// 可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法">线性筛法</h4><ul><li><p>朴素筛法和Eratosthenes筛法存在<strong>重复筛掉</strong>的情况（例如 12 既会被 2 筛掉，又会被 3筛掉：在标记 2 的倍数时，12 = 2 ∗ 6；在标记 3 的倍数时，12 = 3 ∗ 4）如何避免某个数被重复筛掉的情况呢？很简单，我们只需让 45只被它的最小质数（3）筛掉即可</p></li><li><p>原理：合数 x只会被其<font color='red'><strong>最小质因子</strong></font>筛掉一次</p></li><li><p>时间复杂度：<span class="math inline">\(O(n)\)</span>​</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为什么不需要写 j &lt; cnt？ */</span></span><br><span class="line">        <span class="comment">// 1.   primes 数组中存有 &lt;= i 的所有质数</span></span><br><span class="line">        <span class="comment">// 2.   当 i 是合数时, 肯定会在中间就 break 掉</span></span><br><span class="line">        <span class="comment">// 3.   当 i 是质数时, 那么 primes[cnt - 1] = i，因此 j == cnt - 1 时，break，依然不越界</span></span><br><span class="line">        <span class="comment">/* 为什么循环条件是primes[j] &lt;= n / i */</span></span><br><span class="line">        <span class="comment">// 1. 下面筛掉的数是 primes[j] * i</span></span><br><span class="line">        <span class="comment">// 2. 我们要求的是1~n之间的所有素数</span></span><br><span class="line">        <span class="comment">// 3. 当 primes[j] &gt; n / i，下面筛掉的数大于n，不符合我们的要求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">            <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">            <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">            <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">            <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">            <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>证明：</p><ul><li>合数 x 的最小质因子只有一个</li></ul><blockquote><p>显然成立</p></blockquote><ul><li>合数 x<font color='red'><strong>只会</strong></font>被其<font color='red'><strong>最小质因子</strong></font>筛掉<font color='blue'><strong>一次</strong></font></li></ul><blockquote><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">    <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">    <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">    st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">    <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">    <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">    <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">    <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>所有的合数一定会被筛掉</li></ul><blockquote><p>证明：对于合数 <span class="math inline">\(x\)</span>，假设 <spanclass="math inline">\(prime[k]\)</span> 是 <spanclass="math inline">\(x\)</span> 的最小质因子，当 <spanclass="math inline">\(i\)</span> 枚举到 <spanclass="math inline">\(x/primes[k]\)</span> 的时候，x一定会被 <spanclass="math inline">\(prime[k]\)</span> 筛掉（<spanclass="math inline">\(st[primes[k]*(x/primes[k])]=true\)</span>)</p></blockquote><p>因此，所有合数一定<strong>只</strong>会被<strong>最小质因子</strong><strong>筛掉一次</strong>，所以是线性的</p></li></ul><h2 id="约数">约数</h2><h3 id="求所有约数试除法">求所有约数——试除法</h3><ul><li>原理：<ul><li>若 <span class="math inline">\(d|n\)</span>​，则 <spanclass="math inline">\(\frac{n}{d}|n\)</span>​. 所以一个数 n的约数肯定是成对存在的，对称轴是<spanclass="math inline">\(\sqrt{n}\)</span></li><li>因此只需要用 n 除以 1 到 <spanclass="math inline">\(\sqrt{n}\)</span>​之间的数，如果余数是0，则把<code>除数</code>、<code>n / 除数</code>加到答案中</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != n / i)</span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><ul><li><strong>约束个数</strong>与<strong>约束之和</strong>定理：任一大于1的整数<span class="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数的个数为 $( _1+1 )( _1+1 ) ( _k+1 ) $</p><ul><li>证明：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150912687.png"alt="image-20240315091200551" /><figcaption aria-hidden="true">image-20240315091200551</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            res *= (s + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约束之和">约束之和</h3><ul><li><strong>约束之和</strong>定理：任一大于 1 的整数 <spanclass="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数之和为 $(p_{1}<sup>{0}+p_{1}</sup>{1}++p_{1}<sup>{<em>1} ) (p</em>{2}</sup>{0}+p_{2}<sup>{1}++p_{2}</sup>{<em>2} ) (p</em>{k}<sup>{0}+p_{k}</sup>{1}++p_{k}^{_k} ) $</p><ul><li>证明：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150917791.png"alt="image-20240315091535903" /><figcaption aria-hidden="true">image-20240315091535903</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s = s * i + <span class="number">1</span>;</span><br><span class="line">            res *= s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><ul><li>原理：</li></ul><p><span class="math display">\[\begin{cases}    gcd\left( a,b \right) =gcd\left( b,a\%b \right)\\    gcd\left( a,0 \right) =a\\\end{cases}\]</span></p><ul><li><span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的最大公约数 <spanclass="math inline">\(gcd(a,b)\)</span> 被记作 <spanclass="math inline">\((a,b)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><h3 id="求欧拉函数-varphi-left-n-right">求欧拉函数 <spanclass="math inline">\(\varphi \left( n \right)\)</span></h3><p>设正整数 <span class="math inline">\(n\)</span> 的标准分解式为：<span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span> 则欧拉函数 <span class="math display">\[\varphi \left( n \right) =n\left( 1-\frac{1}{p_1} \right) \left(1-\frac{1}{p_2} \right) \cdots \left( 1-\frac{1}{p_k} \right)\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求-1-n-中每个数的欧拉函数线性筛法">求 1 ~ n中每个数的欧拉函数——线性筛法</h3><p>给定一个正整数 <span class="math inline">\(n\)</span> ，求 <spanclass="math inline">\(1\)</span> ∼ <spanclass="math inline">\(n\)</span> 中<strong>每个数的</strong>欧拉函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> eulers[N];       <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉(状态state)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eulers[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求素数 i 的欧拉函数 phi(i) = i - 1</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            eulers[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 求合数 t = primes[j] * i 的欧拉函数</span></span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 情况1：i % primes[j] == 0，此时 primes[j] 既是 i 的最小质因数，也是 t 的最小质因数，phi(t) = phi(primes[j]*i) = primes[j] * phi(i)</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                eulers[t] = primes[j] * eulers[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2：i % primes[j] != 0，此时 primes[j] 不是 i 的质因数（primes[j] &lt; i的最小质因数），但却是 t 的最小质因数，此时 (primes[j], 1) == 1，因此phi(t) = phi(primes[j] * i) = phi(primes[j]) * phi(i) = (primes[j] - 1) * phi(i)</span></span><br><span class="line">            eulers[t] = (primes[j] - <span class="number">1</span>) * eulers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><p>快速求出 <span class="math inline">\(a^b\,\,mod\,\,p\)</span>​</p><ul><li>时间复杂度：<span class="math inline">\(O(logb)\)</span>​</li><li>原理：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151618057.png"alt="04a91bf62e0bd92e3db3b3a73c76793" /><figcaptionaria-hidden="true">04a91bf62e0bd92e3db3b3a73c76793</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151619524.png"alt="bb9db9bc6547be4cfcf9dba7ac9190a" /><figcaptionaria-hidden="true">bb9db9bc6547be4cfcf9dba7ac9190a</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 特判：p == 1</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left. \begin{array}{r}    a^{2^0}=a^1\\    a^{2^1}=a^2\\    a^{2^2}=a^4\\    \cdots\\    a^{2^{k-1}}\\\end{array} \right\} \Rightarrow a^{2^i}=\left( a^{2^{i-1}} \right) ^2\]</span></p><h2 id="拓展欧几里得算法">拓展欧几里得算法</h2><ul><li>Bezout(贝祖等式)</li></ul><p>设 <strong><span class="math inline">\(a, b\)</span></strong>是任意两个正整数，则存在整数 <strong><span class="math inline">\(x,y\)</span></strong> 使得 <span class="math display">\[ax+by=\left( a,b \right)\]</span></p><ul><li>如何求解上述等式的解 <strong><span class="math inline">\(x,y\)</span></strong> ？</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151722173.png"alt="image-20240315172217936" /><figcaption aria-hidden="true">image-20240315172217936</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求逆">求逆</h2><ul><li>定义：当 <span class="math inline">\(ax≡1 \ mod \ p\)</span>, <spanclass="math inline">\(a^{-1}\)</span> <spanclass="math inline">\(mod\)</span> <spanclass="math inline">\(p\)</span> 称为 <spanclass="math inline">\(a∈{1,2,…,p-1}\)</span> 的乘法逆</li><li>定理：当且仅当 <span class="math inline">\(gcd(a,p)=1, \ a^{-1} \mod \ p\)</span> 存在</li></ul><h3 id="费马小定理求逆元">费马小定理——求逆元</h3><ul><li><p>要求：<font color='red'> <span class="math inline">\(p\)</span>为素数 </font></p></li><li><p>有解判断：</p></li></ul><p><span class="math display">\[gcd\left( a,p \right) =1\xLeftrightarrow{p\text{为素数}}a\not \equiv0\,\, mod\,\,p\]</span></p><ul><li>费马小定理：若 <span class="math inline">\(p\)</span>为素数，则</li></ul><p><span class="math display">\[a^{p-1}\equiv 1 \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><ul><li>因此，<span class="math inline">\(a\)</span> 的逆为</li></ul><p><span class="math display">\[a^{-1}=a^{p-2}\, \, \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在逆元</span></span><br><span class="line"><span class="keyword">if</span> (a % p == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)<span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p) % p + p) % p);</span><br></pre></td></tr></table></figure><h3 id="拓展欧几里得求逆元">拓展欧几里得——求逆元</h3><ul><li><p>不要求 <span class="math inline">\(p\)</span> 为素数， <spanclass="math inline">\(p\)</span> 为任意数即可</p></li><li><p>使用拓展欧几里得算法求一个元素的逆</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断逆元是否存在</span></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line"><span class="keyword">if</span> (g != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x + p) % p); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x+p可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">+p %p 是为了将 x 转换到 0 ~ p-1</span></span><br><span class="line"><span class="comment">/ % 的优先级要高于 + -，所以这里必须加上括号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="求解同余式">求解同余式</h2><ul><li>定理：一次同余式</li></ul><p><span class="math display">\[ax\equiv b\left( mod\,\,m \right) \text{，}a\not \equiv 0\left( mod\,\,m\right)\]</span></p><ol type="1"><li>有解<span class="math inline">\(\Longleftrightarrow \left( a,m\right) |b\)</span>​</li><li>当同余式有解时<ol type="1"><li>其解数为 <span class="math inline">\(d=(a,m).\)</span>​​</li><li>求解 <span class="math inline">\(x\)</span>，满足 <spanclass="math inline">\(ax≡b(mod \ m)\)</span> &lt;==&gt; 求解 <spanclass="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>满足 <span class="math inline">\(ax+my=b\)</span><ol type="1"><li>使用 拓展欧几里得算法 ，求出 <spanclass="math inline">\(x_0\)</span>、<spanclass="math inline">\(y_0\)</span>，使得 <spanclass="math inline">\(ax_0+my_0=(a,m)\)</span></li><li>左右两侧同时乘以 <span class="math inline">\(\frac{b}{\left( a,m\right)}\)</span>，得到 $ a+m=b$</li><li>因此解 <span class="math inline">\(x=x_0*\frac{b}{\left( a,m\right)}\)</span></li></ol></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (b % g)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x * b / g + m)% m);</span><br><span class="line"><span class="comment">// x * b可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">// * / % 的优先级相同，按照顺序从左到右依次运行</span></span><br><span class="line"><span class="comment">// + m % m 是为了将 x 转换到 0 ~ p-1</span></span><br></pre></td></tr></table></figure><h2 id="求解一次同余组">求解一次同余组</h2><h3 id="中国剩余定理">中国剩余定理</h3><ul><li>要求： <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161457480.png"alt="image-20240316145735216" /><figcaption aria-hidden="true">image-20240316145735216</figcaption></figure><h3 id="拓展中国剩余定理">拓展中国剩余定理</h3><ul><li>不要求 <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li></ul><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161857618.png" /></p><p><ahref="https://www.acwing.com/problem/content/206/">表达整数的奇怪方式 -拓展中国剩余定理 - AcWing</a></p><h2 id="高斯消元">高斯消元</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192214816.png"alt="image-20240319221424411" /><figcaption aria-hidden="true">image-20240319221424411</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192222282.png"alt="image-20240319222223978" /><figcaption aria-hidden="true">image-20240319222223978</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断是否有解</span></span><br><span class="line"><span class="comment">- 返回0，表示无解</span></span><br><span class="line"><span class="comment">- 返回1：表示有无穷多组解</span></span><br><span class="line"><span class="comment">- 返回2：表示有解a[0][n]~a[n-1][n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r; <span class="comment">// c 代表 列 col ， r 代表 行 row</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先找到当前这一列绝对值最大的一个数字所在的行号 t</span></span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行，换到最上面（不是第一行，是第 r 行）去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行的第一个数，变成 1，方程两边同时除以第一个数，必须倒着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--)</span><br><span class="line">            a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把【当前列】下面的所有数，全部消成 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--) <span class="comment">// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];</span></span><br><span class="line">                a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r++; <span class="comment">// 这一行的工作做完，换下一行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r &lt; n 表明剩下方程的个数是小于 n 的，不是唯一解，判断是无解还是无穷多解</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;                                <span class="comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps) <span class="comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一解，从下往上回代，得到方程的解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] -= a[j][n] * a[i][j]; <span class="comment">// 因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要找绝对值最大的那一行？</p><ol type="1"><li>一是因为可以寻找一个非零行</li><li>二是作浮点数除法时，显然<strong>除以一个大数会让精度更好</strong>，误差更小</li></ol></blockquote><h2 id="组合数">组合数</h2><p><span class="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}\\    \\    \,\,C_{a}^{0}=1\end{cases}\ \ \ \ \ \ \ \ \ \    0\leqslant a\leqslant b\]</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403182224160.png"alt="image-20240318222419888" /><figcaption aria-hidden="true">image-20240318222419888</figcaption></figure><h3 id="模板一">模板一</h3><ul><li>适用条件：<ul><li>询问次数 n 非常多</li><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^5\\1&lt;=b&lt;=a&lt;=2000\\p=1e9 + 7\]</span></p><ul><li>原理：</li></ul><p><span class="math display">\[C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}\]</span></p><ul><li>时间复杂度：<font color='red'><spanclass="math inline">\(O(n^2)\)</span></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板二">模板二</h3><ul><li><strong>适用条件</strong></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^4\\1&lt;=b&lt;=a&lt;=10^5\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong></li></ul><p><span class="math display">\[\frac{a}{b}mod\,\,p=a*b^{-1}\,\,mod\,\,p\ne\frac{a\,\,mod\,\,p}{b\,\,mod\,\,p}\]</span></p><p><span class="math display">\[\left( a*b \right) ^{-1}\,\,mod\,\,p=a^{-1}*b^{-1}\,\,mod\,\,p\]</span></p><p><span class="math display">\[C_{a}^{b}=\frac{a!}{b!\left( a-b \right) !}=fact\left( a \right) \,\,*infact\left( b \right) \,\,* infact\left( a-b \right)\,\,   \text{其中}\begin{cases}    fact\left( a \right) =a! \% mod\\    infact\left( a \right) =\left( a! \right) ^{-1}\,\,\% mod\\\end{cases}\\\\\]</span> :smile:注意：<span class="math inline">\(mod=1e^9+7\)</span>为质数，所以计算逆元 <span class="math inline">\(i^{-1}\)</span>可以采用<strong>费马小定理</strong> <span class="math display">\[\text{递推公式：}\begin{cases}    fact\left( a \right) =fact\left( a-1 \right) \,\,* a\,\,\% mod\\    infact\left( a \right) =infact\left( a-1 \right) \,\,* a^{-1}\,\,\%mod\\\end{cases}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0! = 1, 1^&#123;-1&#125; = 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2个 int 相乘会爆 int ，使用类型转化为 long long</span></span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">// 三个 int 相乘会爆 long long，所以每2个数相乘就对 mod 取模</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)fact[a] * infact[b]) % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板三">模板三</h3><ul><li><strong>适用条件</strong></li></ul><p><span class="math display">\[1&lt;= n &lt;= 20\\1&lt;=b&lt;=a&lt;=10^{18}\\1&lt;=p&lt;=10^5，且\ p\ 为质数\]</span></p><ul><li><strong>卢卡斯定理 <span class="math inline">\(Lucas \Theory\)</span></strong></li></ul><p><span class="math display">\[C_{a}^{b}\equiv C_{a\,\,mod\,\,p}^{b\,\,mod\,\,p}\,\,*C_{a/p}^{b/p}\,\,mod\,\,p   \ \ \ \ \ \ p\ 为素数\]</span></p><p>​ 当 <span class="math inline">\(a&lt;p\)</span> 且 <spanclass="math inline">\(b&lt;p\)</span> 时，适用组合数定义求 <spanclass="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}\\    \,\,C_{a}^{0}=1\\\end{cases}\]</span></p><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这里的 a 和 b 需要保证小于 p , 因此(b!,p)=1, b!的逆元一定存在</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * j % p;</span><br><span class="line">        y = (LL)y * i % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)x * <span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lucas</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板四">模板四</h3><ul><li><strong>使用条件</strong></li></ul><p>当我们需要求出<strong>组合数的真实值</strong>，而非对某个数的余数时，分解质因数的方式比较好用：</p><ul><li><strong>原理</strong></li></ul><ol type="1"><li>筛法求出范围内的所有质数</li><li>通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n!中p的次数是</li></ol><p><span class="math display">\[n / p + n / p^2 + n / p^3 + ...\]</span></p><ol start="3" type="1"><li>用高精度乘法将所有质因子相乘</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403191527951.png"alt="image-20240319152754655" /><figcaption aria-hidden="true">image-20240319152754655</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];         <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求n！分解质因数后， p 的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高精度乘低精度模板 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a); <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j++)</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><h2 id="卡特兰数">卡特兰数</h2><p>​ 将 01 序列置于坐标系中，起点定于原点。若 0 表示向右走，1表示向上走，那么任何前缀中 0 的个数不少于 1的个数就转化为，路径上的任意一点，横坐标大于等于纵坐标。题目所求即为这样的合法路径数量​下图中，表示从(0,0)走到(n,n)的路径，<strong>在绿线及以下表示合法，若触碰红线即不合法</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403191806674.png"alt="Catalan.png" /><figcaption aria-hidden="true">Catalan.png</figcaption></figure><p>​ 由图可知：</p><ul><li><strong>任何</strong>一条不合法的路径（如黑色路径），都对应一条从(0,0)走到(n-1,n+1)的一条路径(如灰色路径)</li><li><strong>任意</strong>一条(0,0)走到(n-1,n+1)的路径，一定对应一条从(0,0)走到(n,n)的不合法路径</li></ul><p>所以<strong>从(0,0)走到(n,n)的不合法路径</strong>等价于<strong>从(0,0)走到(n-1,n+1)的任意路径</strong></p><blockquote><p>因为(0,0)在红色线以下，(n-1,n+1)在红色线以上</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * j % p;</span><br><span class="line">        y = (LL)y * i % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)x * <span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">C</span>(<span class="number">2</span> * n, n, mod) * <span class="built_in">qmi</span>(n + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容斥原理">容斥原理</h2><h3 id="原理">原理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201238750.png"alt="image-20240319184649042" /><figcaption aria-hidden="true">image-20240319184649042</figcaption></figure><h3 id="能被整除的数"><ahref="https://www.acwing.com/problem/content/description/892/">能被整除的数</a></h3><ul><li><strong>性质</strong></li></ul><p><span class="math display">\[a_1|x,a_2|x,\cdots ,a_n|x\Leftrightarrow \left[ a_1,a_2,\cdots a_n\right] |x\\\\\text{若}\ p_i\ \text{为素数，则}\left[ p_1,p_2,\cdots ,p_n \right] |x\]</span></p><ul><li><strong>原理</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201238780.png"alt="image-20240320120205917" /><figcaption aria-hidden="true">image-20240320120205917</figcaption></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> primes[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;primes[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 枚举从1 到 1111...(m个1)的每一个集合的状态, (至少选中一个集合)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> t = <span class="number">1</span>, s = <span class="number">0</span>; <span class="comment">// t 表示选中集合对应质数的乘积，s 表示选中的集合数量</span></span><br><span class="line">        <span class="comment">// 枚举当前状态的每一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="comment">// 选中一个集合</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 乘积大于n, 则n/t = 0, 跳出这轮循环，否则乘积会报long long</span></span><br><span class="line">                <span class="keyword">if</span> ((LL)t * primes[j] &gt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t *= primes[j];</span><br><span class="line">                s++; <span class="comment">// 有一个1，集合数量+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s % <span class="number">2</span>)  </span><br><span class="line">                res += n / t;<span class="comment">//选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res -= n / t;<span class="comment">//反之则为 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="博弈论公平组合游戏">博弈论——公平组合游戏</h1><p>若一个游戏满足：</p><ul><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ul><p>则称该游戏为一个<strong>公平组合游戏</strong>。</p><p>​NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h2 id="nim游戏">NIM游戏</h2><p>​给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><p>​我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。​所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临<strong>必败</strong>局面，则优先采取该行动。同时，这样的局面被称为<strong>必胜</strong>。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。​<font color='red'>NIM博弈不存在平局，只有<strong>先手必胜</strong>和<strong>先手必败</strong>两种情况。</font></p><h3 id="定理"><strong>定理</strong></h3><ul><li><p><strong>必胜状态</strong>：先手进行某一个操作，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即先手可以走到某一个必败状态。</p></li><li><p><strong>必败状态</strong>：先手无论如何操作，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即先手走不到任何一个必败状态。</p></li><li><p><strong>定理</strong>：假设 <spanclass="math inline">\(n\)</span> 堆石子，数目分别是 <spanclass="math inline">\(A_1,A_1,\cdots,A_n\)</span>，如果 <spanclass="math inline">\(A_1\oplus A_2\oplus \cdots \oplus A_n\ne0\)</span>，则先手必胜；否则先手必败。</p></li></ul><h3 id="nim游戏---acwing题库"><ahref="https://www.acwing.com/problem/content/description/893/">Nim游戏 -AcWing题库</a></h3><h2 id="有向图游戏">有向图游戏</h2><p>​给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。​任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p><h3 id="mex运算">Mex运算</h3><p>​ 设 <span class="math inline">\(S\)</span> 表示一个非负整数集合。定义<span class="math inline">\(mex(S)\)</span>为求出<strong>不属于</strong>集合 <span class="math inline">\(S\)</span>的最小非负整数的运算，即： <span class="math display">\[mex(S) = min\{x\},\ x\ 属于自然数，且\ x\ 不属于\ S\]</span></p><h3 id="sg函数">SG函数</h3><p>​ 在有向图游戏中，对于每个节点 <spanclass="math inline">\(x\)</span>，设从 <spanclass="math inline">\(x\)</span> 出发共有 <spanclass="math inline">\(k\)</span> 条有向边，分别到达节点 <spanclass="math inline">\(y1, y2, …, yk\)</span> ，定义 SG(x) 为 x的后继节点 y1, y2, …, yk 的 SG函数值 构成的集合再执行 mex(S)运算的结果，即： <span class="math display">\[SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})\]</span> 特别地，整个有向图游戏 G 的 SG 函数值被定义为有向图游戏起点 s的 SG 函数值，即： <span class="math display">\[SG(G) = SG(s)\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201408408.png"alt="image-20240320140827062" /></p><h3 id="有向图游戏的和">有向图游戏的和</h3><ul><li>设 G1，G2,····,Gm 是 m 个有向图游戏。定义有向图游戏G，他的行动规则是任选某个有向图游戏 Gi，并在 Gi 上行动一步。G被称为<strong>有向图游戏 G1，G2，·····，Gm的和</strong></li><li>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的异或和，即：</li></ul><p><span class="math display">\[SG\left( G \right) =SG\left( G_1 \right) \oplus SG\left( G_2 \right)\oplus \cdots \oplus SG\left( G_m \right)\]</span></p><h3 id="定理-1">定理</h3><ul><li>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0</li><li>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0</li></ul><h3 id="集合-nim游戏---acwing题库"><ahref="https://www.acwing.com/problem/content/description/895/">集合-Nim游戏- AcWing题库</a></h3>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数学知识&quot;&gt;数学知识&lt;/h1&gt;
&lt;p&gt;:smile:&lt;strong&gt;数论&lt;/strong&gt; 经常会出现 &lt;strong&gt;数的大小越界&lt;/strong&gt;
情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尤其是在做&lt;strong&gt;乘法&lt;/strong&gt;、其次是&lt;strong&gt;加法&lt;/strong&gt;的时候非常容易溢出，此时可以使用
&lt;code&gt;long long&lt;/code&gt; 局部转换&lt;/li&gt;
&lt;li&gt;比较稳妥的、一劳永逸的办法是&lt;strong&gt;变量类型&lt;/strong&gt;不使用
int，&lt;strong&gt;全部使用&lt;/strong&gt; &lt;code&gt;long long&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;质数&quot;&gt;质数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;质数&lt;/strong&gt;：在大于 1 的整数中，如果只包含 1
和本身这两个约数，就被成为质数，或者叫素数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算数基本定理&lt;/strong&gt;：任一大于1的整数 &lt;span
class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;​ 能够唯一地表示成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
n={p_1}^{&#92;alpha _1}{p_1}^{&#92;alpha _1}&#92;cdots {p_s}^{&#92;alpha _s},  &#92;alpha
_i&amp;gt;0,  i=1,2,&#92;cdots ,s&#92;left( * &#92;right)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 分解式(*)叫做 的 n 的标准分解式&lt;/p&gt;
&lt;p&gt;注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 n
表成下面形式： &lt;span class=&quot;math display&quot;&gt;&#92;[
n={p_1}^{&#92;alpha _1}{p_1}^{&#92;alpha _1}&#92;cdots {p_k}^{&#92;alpha _k},  &#92;alpha
_i&#92;geqslant 0,  i=1,2,&#92;cdots ,k
&#92;]&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>优先队列priority_queue</title>
    <link href="https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/"/>
    <id>https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/</id>
    <published>2024-03-08T05:29:27.000Z</published>
    <updated>2024-03-19T07:07:35.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列priority_queue">优先队列priority_queue</h1><p>:smile: priority_queue实际上就是<strong>堆</strong></p><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>堆大小</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>插入</font></strong>堆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分别返回<strong><font color='red'>堆顶元素</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p><font color='blue'><strong>删除</strong></font>堆顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 queue 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><h2 id="举例">举例</h2><ol type="1"><li>基本类型例子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(i);</span><br><span class="line">        c.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">cbd abcd abc</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>pari的比较，先比较第一个元素，第一个相等比较第二个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>对于自定义类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;优先队列priority_queue&quot;&gt;优先队列priority_queue&lt;/h1&gt;
&lt;p&gt;:smile: priority_queue实际上就是&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;头文件&quot;&gt;头文件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;queue&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 大根堆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;priority_queue &amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; heap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 小根堆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;priority_queue &amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;,vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;,greater&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;gt;q;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="STL" scheme="https://cuiluyi.gitee.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【数组模拟数据结构】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84AcWing%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84AcWing%E3%80%91/</id>
    <published>2024-03-08T01:40:37.000Z</published>
    <updated>2024-03-19T07:02:56.472Z</updated>
    
    <content type="html"><![CDATA[<ul><li>以下<strong>数据结构</strong>都是采用<strong>数组</strong>模拟实现（而非 C++ STL容器），效率更高、支持更多操作</li></ul><h1 id="单链表">单链表</h1><h2 id="模板">模板</h2><p><font color='red'><strong>空指针用 -1 表示</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数 x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 x 插到下标是 k 的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是 k 的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="acwing">AcWing</h2><h3 id="单链表-1"><ahref="https://www.acwing.com/problem/content/828/">单链表</a></h3><h1 id="双链表">双链表</h1><h2 id="模板-1">模板</h2><ul><li>双链表实现中：0 号节点表示头节点，1 号节点表示尾节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// l[i] 表示节点i的左指针</span></span><br><span class="line"><span class="comment">// r[i] 表示节点i的右指针是多少</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在节点 k 的右边插入一个数 x */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在节点 k 的左边插入一个数 x，则调用insert(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除节点 k */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="acwing-1">AcWing</h2><h3 id="双链表-1"><ahref="https://www.acwing.com/activity/content/problem/content/864/">双链表</a></h3><h1 id="栈">栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶元素下标</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt;= 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列">队列</h1><h2 id="普通队列">普通队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈">单调栈</h1><p>常见模型：</p><ul><li>找出每个数左边离它最近的比它<strong>小</strong>的数——维护递<strong>增</strong>栈</li><li>找出每个数左边离它最近的比它<strong>大</strong>的数——维护递<strong>减</strong>栈</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i))</span><br><span class="line">        tt--;</span><br><span class="line">    stk[++tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列">单调队列</h1><p>常见模型：找出<strong>滑动窗口</strong>中的<strong>最大值/最小值</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181602001.png"alt="image-20240307130347476" /><figcaption aria-hidden="true">image-20240307130347476</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) <span class="comment">// 维持单调队列</span></span><br><span class="line">        tt--;</span><br><span class="line">    q[++tt] = i;                         <span class="comment">// 将数据加入队尾</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">        hh++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单调栈/单调队列总结</p><ul><li>先考虑用普通 栈/队列 暴力模拟</li><li>再将普通 栈/队列中没有用的元素删除，看一下<strong>剩下的元素是否有单调性</strong>——单调栈/单调队列</li><li>考虑优化（队头最小/队尾最大/二分查找…）</li></ul></blockquote><h1 id="trie树">Trie树</h1><ul><li><strong>Trie</strong>：高效地<strong>存储</strong>和<strong>查找</strong>字符串集合的数据结构</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403071732565.png"alt="image-20240307173227428" /><figcaption aria-hidden="true">image-20240307173227428</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点下标</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入一个字符串 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++idx;<span class="comment">// 不能是 idx++，因为son[0][]存放的是根节点，从下标 1 开始存储</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询字符串出现的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集">并查集</h1><h2 id="作用">作用</h2><ol type="1"><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><h2 id="基本原理">基本原理：</h2><p>​每个集合用一棵树来表示。<strong>树根</strong>的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code>表示 <code>x</code> 的父节点</p><h2 id="模板-2">模板</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081538288.png"alt="image-20240308153805104" /><figcaption aria-hidden="true">image-20240308153805104</figcaption></figure><h3 id="朴素并查集">朴素并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集是可以用来维护很多额外信息的，如集合大小cnt，到祖宗节点距离 d等等</p></blockquote><h3 id="维护-cnt-的并查集">维护 cnt 的并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// cnt[]只对祖宗节点有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    cnt[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护到祖宗节点距离-d-的并查集">维护到祖宗节点距离 d的并查集</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181631186.jpeg"alt="JIE.jpg" /><figcaption aria-hidden="true">JIE.jpg</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// d[x]存储 x 到 p[x] 的距离</span></span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];<span class="comment">// d[x]存储 x 到 p[x] 的距离，</span></span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆">堆</h1><h2 id="定义">定义</h2><p>==采用<strong><font color='blue'>数组存储</font></strong>的<strong><font color='red'>完全二叉树</font></strong>==</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036286.png"alt="image-20230916123313335" /><figcaption aria-hidden="true">image-20230916123313335</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036865.png"alt="image-20221019101952011" /><figcaption aria-hidden="true">image-20221019101952011</figcaption></figure><ul><li>从<font color='red'><code>h[1]</code>开始存储数据</font>，<code>h[0]</code>用来存放==<strong>哨兵</strong>==</li><li><code>i</code> 的左儿子 <code>2 * i</code>，右儿子<code>2 * i + 1</code></li></ul><!--more--><h2 id="分类">分类</h2><blockquote><p><code>最小堆</code>（MinHeap）：任一结点的<code>data</code>小于其所有子树结点的data</p></blockquote><blockquote><p><code>最大堆</code>（MinHeap）：任一结点的<code>data</code>大于其所有子树结点的data</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036053.png"alt="image-20230916123453824" /><figcaption aria-hidden="true">image-20230916123453824</figcaption></figure><h2 id="模板-3">模板</h2><ul><li><p>使用数组来模拟堆，堆中的数据从 <code>h[1]</code> 开始存储</p><blockquote><p>因为如果从0开始存储，根节点0按照公式计算得到的左右节点都是0，显然不成了，需要特判，麻烦</p></blockquote></li><li><p>所有关于堆的操作均建立在堆的 <code>down()</code> 和<code>up()</code> 函数基础上</p></li></ul><h3 id="模板1">模板1</h3><p>如果只希望实现与C++ STL堆中相同的功能1、2、3，则堆的下滤和上滤操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>down() 注意：</p><ol type="1"><li>down 操作需要保证左右儿子是堆</li><li>t 是根节点 <code>h[u]</code>, 左儿子 <code>h[2 * u]</code>, 右儿子<code>h[2 * u + 1]</code>中最小值的下标</li><li><code>2 * u &lt;= cnt</code>说明存在左儿子，<code>2 * u + 1 &lt;= cnt</code> 说明存在右儿子</li></ol><p>up() 注意：</p><ol type="1"><li><code>u / 2 != 0</code> 说明存在父节点</li></ol></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[++cnt]=x;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>] = h[cnt--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h3 id="模板2">模板2</h3><p>如果希望实现在 C++ STL堆中功能的基础上，添加在任意位置修改/删除的功能，需要存储映射：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036897.png" alt="image-20240308101556244" style="zoom:15%;" /></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036983.jpeg" alt="b9b669b4a3a28e34e104b0c5bda7d7c" style="zoom:13%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的下标p:pointer</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的h:heap</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="comment">// m是当前堆中插入操作的次数</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换 h[] 中的两个点，及其映射关系 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>p:pointer</li><li>h:heap</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt++, m++;</span><br><span class="line">h[cnt] = x, hp[cnt] = m, ph[m] = cnt;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt--);</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除第 k 个插入的数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line"><span class="built_in">heap_swap</span>(k, cnt--);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改第 k 个插入的数,将其变为 x</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><blockquote><p>修改后的值与原来值相比，有3种情况</p><ul><li>相等：不需要调整堆</li><li>小于：up(k)</li><li>大于：down(k)</li></ul><p>把上面 3 种情况综合考虑，不管是相等/大于/小于，为了简单起见:</p><ul><li>如果修改h[1]：down(1)</li><li>在最后插入数据：up(++size)</li><li>如果修改其他： up(k); down(k)</li></ul><p>【实际运行时要么都不执行，要么只 up(k) ，要么只 down(k) 】</p></blockquote><ol start="6" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h1 id="哈希表">哈希表</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081905012.png" alt="image-20240308190529753" style="zoom: 25%;" /></p><ul><li>离散化是一种<strong>极其特殊</strong>的哈希方式（数据有序排列）</li><li>在算法题中，通常在哈希表 查找/添加 元素，而不会 删除 元素</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081918152.png"alt="image-20240308191829923" /><figcaption aria-hidden="true">image-20240308191829923</figcaption></figure><h2 id="一般哈希">一般哈希</h2><h3 id="拉链法">拉链法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x,ne[idx] = h[k],h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这里的 N 通常取质数eg：100003</li></ul></blockquote><h3 id="开放寻址法">开放寻址法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span> (t == N)</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希">字符串哈希</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403082108366.png" alt="image-20240308210833057" style="zoom: 50%;" /></p><ul><li>核心思想：将字符串（注意不能把某个字符映射成 0）看成 P 进制数， P的经验值是 131 或 13331，取这两个值的冲突概率低</li><li>小技巧：取模的数Q用 <spanclass="math inline">\(2^{64}\)</span>​，这样直接用<code>unsigned long long</code>存储，溢出的结果就是取模的结果</li><li>字符串哈希非常有用的利器，是KMP的劲敌，字符串哈希除了循环节不能处理，其他均可代替KMP</li><li><code>str[]</code> 从下标 1 开始存储</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">// h[k]存储字符串前k个字母 str[1 ~ k] 的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 h[ ], p[ ]</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结</p><ol type="1"><li>把字符串看成是一个 P 进制数，每个字符的 ASCII 码对应数的一位</li><li>ASCII 范围 0 - 127，最少 128 进制，经验上取 131 或 13331冲突率低</li><li>字符串很长，对应的数太大，通过模 <spanclass="math inline">\(2^{64}\)</span> 把它映射到 <spanclass="math inline">\([0, 2^{64} - 1]\)</span></li><li>用 <code>unsigned long long</code> 存储，溢出相当于对 <spanclass="math inline">\(2^{64}\)</span> 取模，省略了手动运算</li><li>该方法的好处是，可以利用前缀哈希直接求出子串哈希（减去高位）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(DEF) = <span class="built_in">hash</span>(ABCDEF) - <span class="built_in">hash</span>(ABC) x P^<span class="number">3</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">    A       B       C       D       E       F  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">5</span> + <span class="number">2</span>xP^<span class="number">4</span> + <span class="number">3</span>xP^<span class="number">3</span> + <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                            D       E       F</span><br><span class="line">                          <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    A       B       C  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">2</span> + <span class="number">2</span>xP^<span class="number">1</span> + <span class="number">3</span>xP^<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意点</p><ol type="1"><li><strong>不要把某一位映射成 P 进制 0</strong>，例如，A 如果是 0，则AA 也是 0，就会出现冲突</li><li><code>\0</code> 的 ASCII 是 0，本题不出现该字符，不用担心上一点</li><li>使用这种方法就假定了人品足够好，不出现冲突</li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;以下&lt;strong&gt;数据结构&lt;/strong&gt;
都是采用&lt;strong&gt;数组&lt;/strong&gt;模拟实现（而非 C++ STL
容器），效率更高、支持更多操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;单链表&quot;&gt;单链表&lt;/h1&gt;
&lt;h2 id=&quot;模板&quot;&gt;模板&lt;/h2&gt;
&lt;p&gt;&lt;font color=&#39;red&#39;&gt;&lt;strong&gt;空指针用 -1 表示&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; N = &lt;span class=&quot;number&quot;&gt;100005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// head 表示头结点的下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// e[i] 表示节点i的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ne[i] 表示节点i的next指针是多少&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// idx 存储当前已经用到了哪个点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; head, e[N], ne[N], idx;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    idx = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在链表头插入一个数 x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert_to_head&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e[idx] = x, ne[idx] = head, head = idx++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将 x 插到下标是 k 的点后面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; k, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将头结点删除，需要保证头结点存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove_head&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head = ne[head];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将下标是 k 的点后面的点删掉&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ne[k] = ne[ne[k]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://cuiluyi.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【离散化】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/06/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/06/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%91/</id>
    <published>2024-03-06T04:27:16.000Z</published>
    <updated>2024-03-19T07:01:34.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散化">离散化</h1><h2 id="模板">模板</h2><ul><li><p>本质：建立了<strong>一段数列</strong>到<strong>自然数</strong>之间的映射关系（value-&gt;index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作（比如二分，前缀和等…）</p></li><li><p>离散化首先需要排序去重：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 排序：sort(alls.begin(),alls.end())</span><br><span class="line">2. 去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());    </span><br></pre></td></tr></table></figure><blockquote><p>unique()函数的底层原理</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) <span class="comment">// 如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];          <span class="comment">// 每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j; <span class="comment">// 返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><span id="more"></span><ul><li>适用条件：<font color='red'><strong>值域 ＞个数</strong></font></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403061237710.png" alt="image-20240306123731542" style="zoom: 25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls;                                         <span class="comment">// 存储所有【待离散化的值】</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());                           <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="acwing">AcWing</h2><h3 id="区间和"><ahref="https://www.acwing.com/problem/content/804/">区间和</a></h3>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;离散化&quot;&gt;离散化&lt;/h1&gt;
&lt;h2 id=&quot;模板&quot;&gt;模板&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本质：建立了&lt;strong&gt;一段数列&lt;/strong&gt;到&lt;strong&gt;自然数&lt;/strong&gt;之间的映射关系（value
-&amp;gt;
index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作（比如二分，前缀和等…）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;离散化首先需要排序去重：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 排序：sort(alls.begin(),alls.end())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());    &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;unique()函数的底层原理&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;::&lt;span class=&quot;function&quot;&gt;iterator &lt;span class=&quot;title&quot;&gt;unique&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;amp;a)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; a.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;(); ++i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!i || a[i] != a[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;// 如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a[j++] = a[i];          &lt;span class=&quot;comment&quot;&gt;// 每存在一个不同元素，j++&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;() + j; &lt;span class=&quot;comment&quot;&gt;// 返回的是前j个不重复元素的下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【区间合并】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/06/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/06/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%E3%80%91/</id>
    <published>2024-03-06T02:27:16.000Z</published>
    <updated>2024-03-19T07:00:23.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板">模板</h1><p>将所有存在交集的区间合并</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403061426215.png" alt="image-20240306142625082" style="zoom: 25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="acwing">AcWing</h1><h2 id="区间合并"><ahref="https://www.acwing.com/problem/content/805/">区间合并</a></h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;模板&lt;/h1&gt;
&lt;p&gt;将所有存在交集的区间合并&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403061426215.png&quot; alt=&quot;image-20240306142625082&quot; style=&quot;zoom: 25%;&quot; /&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vector&amp;lt;PII&amp;gt; &amp;amp;segs)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;PII&amp;gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(segs.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), segs.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; st = &lt;span class=&quot;number&quot;&gt;-2e9&lt;/span&gt;, ed = &lt;span class=&quot;number&quot;&gt;-2e9&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; seg : segs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ed &amp;lt; seg.first)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (st != &lt;span class=&quot;number&quot;&gt;-2e9&lt;/span&gt;) res.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(&amp;#123;st, ed&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st = seg.first, ed = seg.second;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; ed = &lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt;(ed, seg.second);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (st != &lt;span class=&quot;number&quot;&gt;-2e9&lt;/span&gt;) res.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(&amp;#123;st, ed&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    segs = res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【高精度】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/05/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E9%AB%98%E7%B2%BE%E5%BA%A6%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/05/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E9%AB%98%E7%B2%BE%E5%BA%A6%E3%80%91/</id>
    <published>2024-03-05T07:03:16.000Z</published>
    <updated>2024-03-20T02:09:14.808Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403051508638.jpg" alt="8147590f449a6d0077d9bd05a829853" style="zoom: 33%;" /></p><blockquote><ul><li>对于两个高精度数相乘/相除很少见，在此不予阐述</li><li>高精度数采用<strong>数组</strong>、从<font color='purple'><strong>个位向高位</strong></font>依次存储</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403051512649.jpg" alt="7f7747b40d2f813ace3c448acb250a5" style="zoom: 25%;" /></p></blockquote><span id="more"></span><h1 id="模板">模板</h1><h2 id="高精度加法">高精度加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘低精度">高精度乘低精度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除以低精度">高精度除以低精度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403051508638.jpg&quot; alt=&quot;8147590f449a6d0077d9bd05a829853&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于两个高精度数相乘/相除很少见，在此不予阐述&lt;/li&gt;
&lt;li&gt;高精度数采用&lt;strong&gt;数组&lt;/strong&gt;、从&lt;font color=&#39;purple&#39;&gt;&lt;strong&gt;个位向高位&lt;/strong&gt;&lt;/font&gt;依次存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403051512649.jpg&quot; alt=&quot;7f7747b40d2f813ace3c448acb250a5&quot; style=&quot;zoom: 25%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【二分】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91/</id>
    <published>2024-03-04T07:27:16.000Z</published>
    <updated>2024-03-19T07:02:02.242Z</updated>
    
    <content type="html"><![CDATA[<p>​只要一个序列满足在某一<font color='red'>分割点</font><strong>左侧满足性质A</strong>，<strong>右侧满足性质B</strong>，就可以使用二分求出这个边界.</p><h1 id="模板">模板</h1><h2 id="整数二分">整数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403051115293.jpeg"alt="57ac86165a5b843d61595f2983a9be5" /><figcaptionaria-hidden="true">57ac86165a5b843d61595f2983a9be5</figcaption></figure><span id="more"></span><p>具体使用时：</p><ul><li>首先确定性质A、性质B、我们要求的是 <strong>满足性质A的边界</strong>or <strong>满足性质B的边界</strong></li><li>然后编写check函数，<code>mid = l + r &gt;&gt; 1</code><ul><li>求满足性质A的边界：<ul><li>check(mid满足性质A) <code>l=mid</code></li><li>check(mid不满足性质A) <code>r=mid-1</code></li><li>改为<code>mid = l + r + 1 &gt;&gt; 1</code></li></ul></li><li>求满足性质B的边界：<ul><li>check(mid满足性质B) <code>r=mid</code></li><li>check(mid不满足性质B) <code>l=mid+1</code></li></ul></li></ul></li></ul><p>:taco:循环结束时，<code>l = r</code></p><h2 id="浮点数二分">浮点数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>; <span class="comment">// eps 表示精度，取决于题目对精度的要求，通常比题目精度高2位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="acwing">AcWing</h1><h2 id="整数二分-数的范围"><ahref="https://www.acwing.com/problem/content/791/">整数二分-数的范围</a></h2><h2 id="浮点数二分-数的三次方根"><ahref="https://www.acwing.com/problem/content/792/">浮点数二分-数的三次方根</a></h2><h1 id="leetcode">LeetCode</h1><h2 id="二分查找"><ahref="https://leetcode.cn/problems/binary-search/">二分查找</a></h2><p>​ 给定一个 <code>n</code> 个元素有序的（升序）整型数组<code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索<code>nums</code> 中的<code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。<strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="搜索插入位置"><ahref="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></h2><p>​给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="搜索二维矩阵-i"><ahref="https://leetcode.cn/problems/search-a-2d-matrix/">搜索二维矩阵I</a></h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code>在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250139360.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250139629.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">binarySearch</span>(matrix[i],target)==<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="搜索二维矩阵-ii"><ahref="https://leetcode.cn/problems/search-a-2d-matrix-ii/">搜索二维矩阵II</a></h2><p>​ 编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵<code>matrix</code> 中的一个目标值<code>target</code>。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402251557052.jpeg" alt="img" style="zoom: 33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402251557068.jpeg" alt="img" style="zoom: 33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>数组从左到右和从上到下都是升序的，如果&lt;&gt;<strong>从右上角出发开始遍历</strong>呢？</p><p>​会发现每次都是向左数字会变小，向下数字会变大，有点和二分查找树相似。二分查找树的话，是向左数字变小，向右数字变大。所以我们可以把target 和当前值比较：</p><ul><li><p>如果 target 的值大于当前值，那么就向下走。</p></li><li><p>如果 target 的值小于当前值，那么就向左走。</p></li><li><p>如果相等的话，直接返回 true 。</p></li></ul><p>​ 也可以换个角度思考。</p><ul><li>如果 target 的值小于当前值，也就意味着当前值所在的列肯定不会存在target 了，可以把当前列去掉，从新的右上角的值开始遍历。</li><li>同理，如果 target的值大于当前值，也就意味着当前值所在的行肯定不会存在 target了，可以把当前行去掉，从新的右上角的值开始遍历。</li></ul><p>看下边的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[1,   4,  7, 11, 15],</span><br><span class="line">[2,   5,  8, 12, 19],</span><br><span class="line">[3,   6,  9, 16, 22],</span><br><span class="line">[10, 13, 14, 17, 24],</span><br><span class="line">[18, 21, 23, 26, 30]</span><br><span class="line"></span><br><span class="line">如果 target  = 9，如果我们从 15 开始遍历, cur = 15</span><br><span class="line">    </span><br><span class="line">target &lt; 15, 去掉当前列, cur = 11</span><br><span class="line">[1,   4,  7, 11],</span><br><span class="line">[2,   5,  8, 12],</span><br><span class="line">[3,   6,  9, 16],</span><br><span class="line">[10, 13, 14, 17],</span><br><span class="line">[18, 21, 23, 26]</span><br><span class="line">    </span><br><span class="line">target &lt; 11, 去掉当前列, cur = 7  </span><br><span class="line">[1,   4,  7],</span><br><span class="line">[2,   5,  8],</span><br><span class="line">[3,   6,  9],</span><br><span class="line">[10, 13, 14],</span><br><span class="line">[18, 21, 23]</span><br><span class="line"></span><br><span class="line">target &gt; 7, 去掉当前行, cur = 8   </span><br><span class="line">[2,   5,  8],</span><br><span class="line">[3,   6,  9],</span><br><span class="line">[10, 13, 14],</span><br><span class="line">[18, 21, 23]</span><br><span class="line"></span><br><span class="line">target &gt; 8, 去掉当前行, cur = 9, 遍历结束</span><br><span class="line">[3,   6,  9],</span><br><span class="line">[10, 13, 14],</span><br><span class="line">[18, 21, 23]</span><br></pre></td></tr></table></figure><p>不管从哪种角度考虑，代码的话都是一样的。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> row = matrix.<span class="built_in">size</span>(), col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="在排序数组中查找元素的第一个和最后一个位置"><ahref="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值<code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值<code>target</code>，返回<code>[-1, -1]</code>。你必须设计并实现时间复杂度为<code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>利用二分查找，如果mid位置正好等于target的话，<strong>从该位置往左右查找起止位置</strong></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 二分查找 */</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">/* 从mid向左，寻找左边界 */</span></span><br><span class="line">        <span class="type">int</span> low = mid;</span><br><span class="line">        <span class="keyword">while</span> (low &gt;= <span class="number">0</span> &amp;&amp; nums[low] == target)</span><br><span class="line">            low--;</span><br><span class="line">        ans[<span class="number">0</span>] = ++low;</span><br><span class="line">        <span class="comment">/* 从mid向右，寻找右边界 */</span></span><br><span class="line">        <span class="type">int</span> high = mid;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[high] == target)</span><br><span class="line">            high++;</span><br><span class="line">        ans[<span class="number">1</span>] = --high;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="搜索旋转排序数组"><ahref="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值<strong>互不相同</strong> 。在传递给函数之前，<code>nums</code>在预先未知的某个下标<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了<strong>旋转</strong>，使数组变为<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标<strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code>在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数<code>target</code> ，如果 <code>nums</code> 中存在这个目标值<code>target</code> ，则返回它的下标，否则返回 <code>-1</code>。你必须设计一个时间复杂度为 <code>O(log n)</code>的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>​对于有序数组，可以使用二分查找的方法查找元素。但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p><p>​可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2]两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。</p><p>​ 这启示我们<strong>可以在常规二分查找的时候查看当前 mid为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r]哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界</strong>，因为我们能够根据有序的那部分判断出target 在不在这个部分</p><ul><li><p>定理一：只有在顺序区间内才可以通过区间两端的数值判断target是否在其中。</p></li><li><p>定理二：判断顺序区间还是乱序区间，只需要对比 left 和 right是否是顺序对即可，left &lt;= right，顺序区间，否则乱序区间。</p></li><li><p>定理三：每次二分都会至少存在一个顺序区间。</p></li></ul><p>​<strong>通过不断的用Mid二分，根据定理二，将整个数组划分成顺序区间和乱序区间，然后利用定理一判断target是否在顺序区间，如果在顺序区间，下次循环就直接取顺序区间，如果不在，那么下次循环就取乱序区间。</strong></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// left 到 mid 是顺序区间</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mid 到 right 是顺序区间</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="寻找旋转排序数组中的最小值"><ahref="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h2><p>​ 已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由<code>1</code> 到 <code>n</code> 次 <strong>旋转</strong>后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code>在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到<code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到<code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code><strong>旋转一次</strong> 的结果为数组<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的<strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code>的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​
只要一个序列满足在某一&lt;font color=&#39;red&#39;&gt;分割点&lt;/font&gt;&lt;strong&gt;左侧满足性质A&lt;/strong&gt;，&lt;strong&gt;右侧满足性质B&lt;/strong&gt;，就可以使用二分求出这个边界.&lt;/p&gt;
&lt;h1 id=&quot;模板&quot;&gt;模板&lt;/h1&gt;
&lt;h2 id=&quot;整数二分&quot;&gt;整数二分&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&amp;#125; &lt;span class=&quot;comment&quot;&gt;// 检查x是否满足某种性质&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bsearch_1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; l, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (l &amp;lt; r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; mid = l + r &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;check&lt;/span&gt;(mid))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            r = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            l = mid + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bsearch_2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; l, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (l &amp;lt; r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; mid = l + r + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;check&lt;/span&gt;(mid))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            l = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            r = mid - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403051115293.jpeg&quot;
alt=&quot;57ac86165a5b843d61595f2983a9be5&quot; /&gt;
&lt;figcaption
aria-hidden=&quot;true&quot;&gt;57ac86165a5b843d61595f2983a9be5&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【C++标准库函数】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/</id>
    <published>2024-03-04T05:59:27.000Z</published>
    <updated>2024-03-20T08:18:10.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c标准库函数">C++标准库函数</h1><p>[TOC]</p><h2 id="max_elementmin_element">max_element、min_element</h2><h3 id="头文件">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用">作用</h3><p><strong>1. 求数组的最大值或最小值</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a, a + <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a, a + <span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//获取最大值</span></span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//获取最小值</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>2. 求数组最大值最小值对应的下标</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a, a + <span class="number">8</span>) - a; </span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a, a + <span class="number">8</span>) - a;</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); <span class="comment">//获取最大值对应的下标</span></span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();<span class="comment">//获取最小值对应的下标</span></span><br></pre></td></tr></table></figure><h2 id="fill">fill</h2><h3 id="头文件-1">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-1">作用</h3><p><ahref="https://blog.csdn.net/liu16659/article/details/87152348?ops_request_misc=%7B%22request%5Fid%22%3A%22167715751316800188555444%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167715751316800188555444&amp;biz_id=0&amp;spm=1018.2226.3001.4187">(96条消息)C++ 中 fill() 的使用_LawsonAbs的博客-CSDN博客_c++ fill</a></p><h2 id="memset">memset</h2><h3 id="头文件-2">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型">原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, Byte c, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>s：为指针或是数组</li><li>c：是赋给 s 的值</li><li>count：是 s 的长度</li></ul><p>返回值</p><ul><li>指向存储区 s 的指针。</li></ul><h3 id="作用-2">作用</h3><p>​ memset是按照 c 的值（看作字节），按字节将 s赋值，因此我们最常见的就是</p><ul><li>将每一字节赋值全 0 ，整体就是 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><ul><li>将每一字节赋值全 1 ，整体就是 -1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">-1</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p>注意：-1 = 0XFF</p></blockquote><ul><li>将每一个字节赋值 0x3f，整体就是 INF【<strong>无穷大</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/qq_42386788/article/details/116427457">关于memset函数和赋值0x3f</a></p></blockquote><h3 id="说明">说明</h3><p>memset可以方便的==<strong>清空</strong>或初始化一个<strong>数组</strong>。==</p><h3 id="举例">举例</h3><ol type="1"><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/weixin_44162361/article/details/115790452?ops_request_misc=%7B%22request%5Fid%22%3A%22169735623116800180650624%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169735623116800180650624&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115790452-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=memset&amp;spm=1018.2226.3001.4187">memset的用法详解_薛定谔的猫ovo的博客-CSDN博客</a></p></blockquote><h2 id="memcmp">memcmp</h2><h3 id="头文件-3">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="基本原型">基本原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf1, <span class="type">const</span> <span class="type">void</span> *buf2, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong></p><ul><li><p>当 buf1&lt;buf2 时，返回值&lt;0</p></li><li><p>当 buf1=buf2 时，返回值=0</p></li><li><p>当 buf1&gt;buf2 时，返回值&gt;0</p></li></ul><h3 id="作用-3">作用</h3><p>memcmp 是比较内存区域 buf1 和 buf2 的前 count个字节。该函数是按字节比较的</p><h3 id="举例-1">举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">r = <span class="built_in">memcmp</span>(&amp;s1,&amp;s2,<span class="built_in">strlen</span>(s1));</span><br><span class="line"><span class="keyword">if</span>(!r)<span class="comment">//！r 非零返回的是 1  这个是非运算，计算机是二进制的，不是零就是一了 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 and s2 are identical\n&quot;</span>);<span class="comment">/*s1等于s2*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);<span class="comment">/*s1小于s2*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);<span class="comment">/*s1大于s2*/</span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,!r); //输出是一， </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,r);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明-1">说明</h3><ol type="1"><li>该函数是按字节比较的：当s1,s2为字符串时</li></ol><ul><li><p><code>memcmp(s1,s2,1)</code>就是比较s1和s2的第一个字节的ascII码值；</p></li><li><p><code>memcmp(s1,s2,n)</code>就是比较s1和s2的前n个字节的ascII码值；</p><p>例如:</p></li></ul><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> *s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *s2=<span class="string">&quot;acd&quot;</span>;</span><br><span class="line">&gt;<span class="type">int</span> r=<span class="built_in">memcmp</span>(s1,s2,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>​比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了所以<spanclass="math display">\[r=-1\]</span>.</p></blockquote><ol start="2" type="1"><li><p>对于<code>memcmp()</code>，如果两个字符串相同而且<code>count</code>大于字符串长度的话，<code>memcmp</code>不会在<code>\0</code>处停下来，会继续比较<code>\0</code>后面的内存单元，直到<code>_res</code>不为零或者达到<code>count</code>次数。</p><p>例如：</p></li></ol><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> a1[]=<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">  <span class="type">char</span> a2[]=<span class="string">&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure></p><p>对于<code>memcmp(a1,a2,10)</code>，<code>memcmp</code>在两个字符串的<code>\0</code>之后继续比较。所以，如果想使用memcmp比较字符串，要保证count不能超过最短字符串的长度，否则结果有可能是错误的。</p></blockquote><h2 id="memcpy">memcpy</h2><h3 id="头文件-4">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="声明">声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>str1</strong> --指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li><li><strong>str2</strong> -- 指向要复制的数据源，类型强制转换为 void*指针。</li><li><strong>n</strong> -- 要被复制的字节数。</li></ul><p><strong>返回值：</strong></p><ul><li>该函数返回一个指向目标存储区 str1 的指针。</li></ul><h3 id="作用-4">作用</h3><p>​ 从存储区 <strong>str2</strong> 复制 <strong>n</strong>个字节到存储区 <strong>str1</strong></p><h3 id="实例">实例</h3><ul><li>将字符串复制到数组 dest 中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="keyword">sizeof</span> src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest = http://www.runoob.com</span><br></pre></td></tr></table></figure><ul><li>将 s 中第 11 个字符开始的 6个连续字符复制到 d 中：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(d, s + <span class="number">11</span>, <span class="number">6</span>); <span class="comment">// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob)</span></span><br><span class="line">    <span class="comment">// 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));</span></span><br><span class="line">    d[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob</span><br></pre></td></tr></table></figure><ul><li>覆盖原有部分数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;***&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 前: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 后: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 memcpy 前: abcdefg</span><br><span class="line">使用 memcpy 后: ***defg</span><br></pre></td></tr></table></figure><h2 id="strcmp">strcmp</h2><h3 id="头文件-5">头文件</h3><p><code>#include &lt;cstring&gt;</code></p><h3 id="作用-5">作用</h3><p>​ 比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较</p><h3 id="原型-1">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>第一个字符串大于第二个字符串，则返回大于 0 的数字</li><li>第一个字符串<font color='red'><strong>等于</strong></font>第二个字符串，则返回<font color='red'><strong>0</strong></font></li><li>第一个字符串小于第二个字符串，则返回小于 0 的数字</li></ul><h3 id="举例-2">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* p1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p2 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p4 = <span class="string">&quot;bcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1,p2 ));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1,p3 ));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p3,p4 ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="new">new</h2><h3 id="作用-6">作用</h3><p><code>new()</code>使计算机开辟一块内存空间，并返回<strong>内存空间的首地址</strong></p><h3 id="格式">格式</h3><ol type="1"><li><p>使用new函数创建变量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType;</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建变量并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> <span class="built_in">ElementType</span>(val);</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size];</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size]&#123;&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="说明-2">说明</h3><ol type="1"><li>new开辟的空间在堆上，而一般声明的变量存放在栈上</li><li><strong><font color='red'>通常用new函数代替malloc函数</font></strong></li><li>new不需要头文件</li><li>使用 new 函数之后要<strong><font color='red'>使用 delete函数释放内存空间</font></strong></li></ol><h3 id="举例-3">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">example1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以在new后面直接赋值</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以单独赋值</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">example2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用new创建数组</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// 也可以依次赋值</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        q[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *st = <span class="keyword">new</span> <span class="built_in">student</span>(&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *stlist = <span class="keyword">new</span> student[<span class="number">3</span>]&#123;&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;bac&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="string">&quot;ccd&quot;</span>, <span class="number">93</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> e1 = <span class="built_in">example1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e1: &quot;</span> &lt;&lt; e1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *e2 = <span class="built_in">example2</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; e2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st1 = <span class="built_in">example3</span>();</span><br><span class="line">    cout &lt;&lt; st1-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st1-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st2 = <span class="built_in">example4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; st2[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st2[i].score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152190.png"alt="image-20240220165632598" /><figcaption aria-hidden="true">image-20240220165632598</figcaption></figure><h2 id="swap">swap</h2><h3 id="作用-7">作用</h3><p><strong><code>swap(a,b);</code></strong>交换两个变量<strong><code>a,b</code></strong>的值</p><blockquote><p><strong><code>a,b</code></strong>可以是<strong><font color='red'>任何数据类型</font></strong></p></blockquote><h3 id="原型-2">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ElementType &amp;a, ElementType &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="举例-4">举例</h3><h4 id="例一">例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="例二">例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;ABCD&quot;</span>;     string b = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ABCD</span><br></pre></td></tr></table></figure><h2 id="absfabs">abs/fabs</h2><h3 id="头文件-6">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-3">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span></span><br></pre></td></tr></table></figure><h3 id="作用-8">作用</h3><ul><li><code>abs</code> 是对<strong>整数</strong>取绝对值</li><li><code>fabs</code> 是对<strong>浮点数</strong>取绝对值</li></ul><h2 id="sqrt">sqrt</h2><h3 id="头文件-7">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-4">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-9">作用</h3><p><code>sqrt()</code> 用来求给定值的平方根</p><h3 id="常见错误">常见错误</h3><ol type="1"><li><strong>输出 36的开根号</strong></li></ol><ul><li><strong>错误写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152182.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><blockquote><p>忽略了sqrt()函数的返回值是 double型。导致出错</p></blockquote></blockquote><ul><li><strong>正确写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152197.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>常见的使用sqrt()函数的规范写法</strong> 例如:我们要判断一个数是不是质数，只需要判断 2 ~ n开根号之间有没有可以整除的数就可以了</p><ul><li><strong>错误写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，其实并不推荐这样写。虽然我也经常这样写。但是在一次做题的过程中，就因为这样写程序出现了bug。我就改用下面的这种稳妥的写法了</p><ul><li><strong>正确写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.0*n的目的是——隐式转换成浮点数，开根号后再强制转换成整型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span> * n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse">reverse</h2><h3 id="头文件-8">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-10">作用</h3><p>反转在<strong><font color='red'> [ first,last )</font></strong>范围内的顺序（包括first指向的元素，不包括last指向的元素）</p><h3 id="原型-5">原型</h3><p><strong><code>void reverse (BidirectionalIterator first,BidirectionalIterator last);</code></strong></p><ul><li>参数first：待排区域的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排区域的<strong><font color='blue'>末尾地址</font></strong></li></ul><h3 id="举例-5">举例</h3><ul><li>反转<strong>向量</strong><font color='blue'><strong>vector</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//v的值为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><ul><li>反转数组<strong><code>ElementType A[]</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[]=&#123;<span class="number">12</span>,<span class="number">-5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(A, A+<span class="number">6</span>);<span class="comment">//数组A为19,1,7,0,-5,12</span></span><br></pre></td></tr></table></figure><ul><li>反转<strong>字符串<font color='blue'>string</font></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;www.mathor.top&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//str结果为pot.rohtam.wwww</span></span><br></pre></td></tr></table></figure><h3 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="sort">sort</h2><h3 id="头文件-9">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-11">作用</h3><p>对==<strong><font color='red'>数组排序</font></strong>==</p><blockquote><ul><li>数组可以是<strong><code>ElementType A[]</code></strong>，也可以是<strong><code>vector &lt;ElementType&gt; A</code></strong><ul><li><strong><code>ElementType A[]</code></strong>：<strong><code>A</code></strong>表示<strong><font color='blue'>数组首地址</font></strong>，<strong><code>A+n</code></strong>表示<strong><font color='blue'>数组尾部</font></strong></li><li><strong><code>vector &lt;ElementType&gt; A</code></strong>：<strong><code>A.begin()</code></strong>和<strong><code>A.end()</code></strong>表示<strong><font color='blue'>头尾</font></strong></li></ul></li></ul></blockquote><h3 id="原型-6">原型</h3><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>默认</th><th><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last);</code></strong></th></tr></thead><tbody><tr class="odd"><td><strong>自定义</strong></td><td><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last,Compare comp);</code></strong></td></tr></tbody></table><ul><li>参数first：待排数组的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排数组的<strong><font color='blue'>末尾地址</font></strong></li><li>参数comp：自定义排序方法<ul><li>如果第三个参数不写，则<strong>默认的排序方法</strong>是<strong><font color='red'>从小到大</font></strong>排序。</li></ul></li></ul><h3 id="举例-6">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// cmp函数返回的值是bool类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 从大到⼩排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 因为这里没有传入参数cmp，所以按照默认,v从小到大排列</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, cmp); <span class="comment">// arr从大到小排列，因为cmp函数排序规则设置了从大到小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见cmp函数">常见cmp函数</h3><ul><li></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br></pre></td></tr></table></figure><ul><li></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score!=b.score)</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">return</span> a.score!=b.score ? a.score&gt;b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> node a,<span class="keyword">struct</span> node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height!=b.height ? a.height&gt;b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注： <strong><code>sort</code></strong> 函数的<strong><code>cmp</code></strong> 必须按照规定来写，即必须只是<strong><code>&gt;</code></strong> 或者<strong><code>&lt;</code></strong> ，比如：<strong><code>return a &gt; b;</code></strong> 或者<strong><code>return a &lt; b;</code></strong> 而不能是<strong><code>&lt;=</code></strong> 或者<strong><code>&gt;=</code></strong></p></blockquote><h2 id="find">find</h2><h3 id="头文件-10">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-12">作用</h3><p>​可以在<strong>任何容器</strong>中<strong>查找指定元素</strong>，返回一个迭代器指向<strong>第一个匹配</strong>的元素</p><ul><li><p>string、map、set有内置的成员方法find()，所以对于string、map、set的查找通常使用内置的find()方法</p></li><li><p>但是vector、queue没有内置的成员方法find()，他们通常使用<algorithm>头文件下通用的find()函数</p></li></ul><h3 id="参数">参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>first</strong> 和 <strong>last</strong>为输入迭代器，<strong>[first,last)</strong>用于指定该函数的查找范围</li><li><strong>val</strong>为要查找的目标元素</li></ul><h3 id="返回值">返回值</h3><p>​该函数返回一个<strong>迭代器</strong>，指向范围内搜索元素的<strong>第一次</strong>出现。如果没有找到目标元素，则返回<strong>last</strong></p><h3 id="例子">例子</h3><ul><li>在<code>vector</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element found: 3</span><br></pre></td></tr></table></figure><ul><li>在<code>string</code>中查找指定字符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;This is a string&quot;</span>; <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  ^  ^  ^</span></span><br><span class="line"><span class="comment">                  1  2  3           */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>s.rfind()</code><strong>从左往右</strong>寻找、<code>s.lfind()</code><strong>从右往左</strong>寻找</p></blockquote><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从首个位置开始搜索，在下标 2 处找到子串 is</span><br><span class="line">从下标 5 开始搜索，在下标 5 处找到子串 is</span><br><span class="line">从首个位置开始搜索，在下标 3 处找到字符 s</span><br><span class="line">从下标 5 开始搜索，在下标 6 处找到字符 s</span><br></pre></td></tr></table></figure><ul><li>在<code>set</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法1：使用find方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">2</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法2：使用count方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy">copy</h2><h2 id="unique">unique</h2><h3 id="头文件-11">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-13">作用</h3><p>​ <code>unique</code>可以对 <strong>vector</strong>容器内的元素去重</p><h3 id="原型-7">原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a);</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>vector&lt;int&gt;</code></li><li><strong>返回值</strong>：指向去重后<strong>最后一个元素</strong>的迭代器<code>vector&lt;int&gt;::iterator</code></li></ul><h3 id="底层原理">底层原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) <span class="comment">// 如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];          <span class="comment">// 每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j; <span class="comment">// 返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next_permutation">next_permutation</h2><h3 id="头文件-12">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-14">作用</h3><p>​<code>next_permutation</code>是求当前排列的下一个排列（按字典序升序的下一个序列），如1234的next_permutation 是1243，在<strong>全排列</strong>当中经常会用。</p><h3 id="参数-1">参数</h3><p>​和<code>sort</code>的参数一样，一般传两个参数，第一个是排列开始的地址，第二个是排列结束的下一个地址，如实现数组第1-3排列的下一个排列：<code>next_permutation(a,a+3)</code>。一般作用对象是数组。</p><h3 id="返回值-1">返回值</h3><p>​ 返回值是 <span class="math inline">\(Ture\)</span> 或者 <spanclass="math inline">\(False\)</span>，若当前排列有下一个排列，则返回Ture，反之返回False：如54321的返回值为False。该函数会直接修改数组为下一个排列。</p><h3 id="原理">原理</h3><ul><li>从后往前找原数组中第一个<code>a[i] &lt; a[i+1]</code>的地方，其后面全是降序，说明已经排好了，所以我们就要将a[i]的值改大一点</li><li>将a[i]和其后面所有数中大于他的最小的数交换位置，则a[i]后面的数仍是个降序</li><li>然后将其后面这些降序的元素翻转，就得到了原排列的下一个增序排列了</li></ul><blockquote><blockquote><p>例如：对于排列2431来说</p><p>①我们先找到2和4处</p><p>②然后交换2和3的位置，就得到了3421</p><p>③最后翻转421，就得到了3124，则3124就是2431的下一个排列，如下图。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152332.png"alt="eg" /><figcaption aria-hidden="true">eg</figcaption></figure></blockquote></blockquote><h3 id="全排列">全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:sunny:如果你希望生成所有的排列方式，一定要<strong>先将序列按升序排列</strong>，这里可以与sort函数结合起来使用，先用sort升序排列，再调用next_permutation函数。</p><h1 id="typedef">typedef</h1><h2 id="介绍">介绍</h2><pre><code>使用关键字`typedef`可以为数据类型起一个新的别名</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br><span class="line">newName a,b;</span><br></pre></td></tr></table></figure><ul><li><code>oldName</code> 是类型原来的名字，</li><li><code>newName</code> 是类型新的名字</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure><p>==<code>typedef</code>去掉，<code>oldname</code>保留，<code>newname</code>换成a,b==</p></blockquote><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldName a,b;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol type="1"><li>typedef是赋予<strong>现有类型</strong>一个<strong>新的名字</strong>，而==<strong>不是创建新的类型</strong>==。</li><li>为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。</li><li>==<font color='red'><strong>最后的分号<code>;</code>不要忘记</strong></font>==</li></ol></blockquote><h2 id="定义">定义</h2><ol type="1"><li>typedef给如<code>int</code>，<code>double</code>，<code>char</code>，<code>long</code>，<code>float</code>等类型定义别名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br></pre></td></tr></table></figure><hr /><ol start="2" type="1"><li><strong>typedef 给数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> array[<span class="number">20</span>];</span><br><span class="line">array a1, a2, s1, s2;</span><br></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><blockquote><p>注：数组也是有类型的。例如char a1[20];定义了一个数组 a1，它的类型就是==<strong>char [20]</strong>==。</p></blockquote><hr /><ol start="3" type="1"><li><strong>typedef 给结构体类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure><p><code>stu</code> 是 <code>struct node</code> 的别名，可以用<code>stu</code> 定义结构体变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu x;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> x;</span><br></pre></td></tr></table></figure><hr /><ol start="4" type="1"><li><strong>typedef 给结构数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li><strong>typedef 给指针类型定义别名</strong></li></ol><ul><li>例一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_ARR)</span>[4]</span>;</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR是类型<code>int [4] *</code>的别名，它是一个==<strong>二维数组指针</strong>==类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><hr /><ul><li>例二</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * PTR_TO_ARR [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR是类型<code>int * [4]</code>的别名，它是一个==<strong>元素指向整形数据的指针数组</strong>==类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><ol start="6" type="1"><li><strong>typedef为函数指针类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">PTR_TO_FUNC pfunc;</span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*PTR_TO_ARR)</span>[30]</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">3</span>][<span class="number">30</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;百度搜索引擎&quot;</span>,</span><br><span class="line">    <span class="string">&quot;C-Language&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PTR_TO_ARR parr = str;</span><br><span class="line">    PTR_TO_FUNC pfunc = max;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max: %d\n&quot;</span>, (*pfunc)(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str[%d]: %s\n&quot;</span>, i, *(parr+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max: <span class="number">20</span></span><br><span class="line">str[<span class="number">0</span>]: http:<span class="comment">//www.baidu.com</span></span><br><span class="line">str[<span class="number">1</span>]: 百度搜索引擎</span><br><span class="line">str[<span class="number">2</span>]: C-Language</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><blockquote><ol type="1"><li><ahref="https://blog.csdn.net/weixin_51635753/article/details/115434999?ops_request_misc=%7B%22request%5Fid%22%3A%22167049370716782414992762%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167049370716782414992762&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-21-115434999-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&amp;utm_term=C%2B%2B自带swap函数&amp;spm=1018.2226.3001.4187">(82条消息)C++ STL 常用函数_Mr.bei的博客-CSDN博客_c++stl常用函数</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;c标准库函数&quot;&gt;C++标准库函数&lt;/h1&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;max_elementmin_element&quot;&gt;max_element、min_element&lt;/h2&gt;
&lt;h3 id=&quot;头文件&quot;&gt;头文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 求数组的最大值或最小值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通数组&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; max = *&lt;span class=&quot;built_in&quot;&gt;max_element&lt;/span&gt;(a, a + &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; min = *&lt;span class=&quot;built_in&quot;&gt;min_element&lt;/span&gt;(a, a + &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;vector容器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; a = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; max = *&lt;span class=&quot;built_in&quot;&gt;max_element&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;()); &lt;span class=&quot;comment&quot;&gt;//获取最大值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; min = *&lt;span class=&quot;built_in&quot;&gt;min_element&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//获取最小值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《致谢》——黄国平</title>
    <link href="https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/"/>
    <id>https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/</id>
    <published>2024-03-04T05:59:27.000Z</published>
    <updated>2024-03-19T07:05:15.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="致谢">致谢</h1><p>​<strong>我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。</strong></p><p>​出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。<strong>每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。</strong></p><p>​<strong>人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。</strong>家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。</p><span id="more"></span><p>​<strong>人后的苦尚旦还能克服，人前的尊严却无比脆弱。</strong>上课的时候，因拖欠学费而经常被老师叫出教室约谈。雨天湿漉着上课，屁股后面说不定还是泥。夏天光着脚走在滚烫的路上。冬天穿着破旧衣服打着寒颤穿过那条长长的过道领作业本。这些都可能成为压垮骆驼的最后一根稻草。如果不是考试后常能从主席台领奖金，顺便能贴一墙奖状满足最后的虚荣心，我可能早已放弃。</p><p>​<strong>身处命运的旋涡，耗尽心力去争取那些可能本就是稀松平常的东西，每次转折都显得那么的身不由己。幸运的是，命运到底还有一丝怜惜。</strong>进入高中后,学校免了全部学杂费，■■■一家帮助解决了生活费。进入大学后，计算机终于成了我一生的事业与希望，胃溃疡和胃出血也终与我作别。</p><p>​我很庆幸保研时选择了自动化所，感谢研究生部的老师们将我从别的部门调剂到模式识别实验室，感谢导师宗成庆老师选择了我，宗老师将我引入了科学研究的大门，博士这五年无疑是我过去最幸福的时光。惭愧的是，离宗老师的期望显然还有很远的距离，我也知道本可以做得更好。这一段经历已经成为我这一生值得回味的美好瞬间之一。我很喜欢人机交互式机器翻译这个题目，但也仅开了个头。在未来，希望能有机会弥补这段遗憾。</p><p>​从家出发坐大巴需要两个半小时才能到县城，一直盼着走出大山。从炬光乡小学、大寅镇中学、仪陇县中学、绵阳市南山中学，到重庆的西南大学，再到中科院自动化所，我也记不清有多少次因为现实的压力而觉得自己快扛不下去了。<strong>这一路，信念很简单。把书念下去，然后走出去，不枉活一世。世事难科，未来注定还会面对更为复杂的局面。但因为有了这些点点滴滴，我已经有勇气和耐心面对任何困难和挑战。理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。</strong></p><p>​ 最近这些年，特别感谢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■重塑了我的人生。</p><p>​感谢■■■老师和■■■老师为我的研究提出诸多建设性的意见和建议。与他们的交流过程中，我也被他们坦诚为人、踏实做事的处事风格所感染。感谢所有和我一起在课题组工作的老师们和学习的同学们：■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■。我们在研究上共同努力，互相学习，如亲兄弟姐妹一般谈笑风生。不论大家将来在何处，我想我们都不会忘记这些年一起度过的时光。感谢课题组■■■女士，感谢模式识别综合办实验室的■■■、■■■和■■■等老师，感谢研究生部的■■■、■■■、■■■和■■■等老师，他们为我的学习和工作给予了极大的帮助。这会成为我日后工作的动力，希望最后能成为课题组值得骄傲的学生。</p><p>​感谢父母给了我生命，感谢婆婆和叔辈对我的抚养，感谢■■■■■■■■■■■■■■■■■■对我的牵挂，感谢■■■和■■■对我的支持，感谢一路上让我生活变得美好或者不那么美好的人和事。</p><p>​ 最后，对参加论文评审、答辩的各位老师表示衷心的感谢！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;致谢&quot;&gt;致谢&lt;/h1&gt;
&lt;p&gt;​
&lt;strong&gt;我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​
出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。&lt;strong&gt;每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​
&lt;strong&gt;人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。&lt;/strong&gt;家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，
黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。&lt;/p&gt;</summary>
    
    
    
    
    <category term="fighting" scheme="https://cuiluyi.gitee.io/tags/fighting/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cuiluyi.gitee.io/2024/03/01/[object%20Object]/project/"/>
    <id>https://cuiluyi.gitee.io/2024/03/01/[object%20Object]/project/</id>
    <published>2024-03-01T10:43:06.350Z</published>
    <updated>2024-03-19T07:07:53.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="result">Result</h1><h2 id="baseline">baseline：</h2><ul><li><a href="https://arxiv.org/abs/1602.05629">FedAvg</a> (Hugh BrendanMcMahan et al., AISTATS 2017)</li><li><a href="https://arxiv.org/abs/2007.07481">FedNova</a> (Jianyu Wanget al., NeurIPS 2020) <ahref="https://github.com/JYWa/FedNova">:octocat:</a></li><li><a href="https://arxiv.org/abs/1812.06127">FedProx</a> (Tian Li etal., MLSys 2020) <ahref="https://github.com/litian96/FedProx">:octocat:</a></li><li><a href="https://arxiv.org/abs/1910.06378">SCAFFOLD</a> (SaiPraneeth Karimireddy et al.,ICML 2020) <ahref="https://github.com/ki-ljl/Scaffold-Federated-Learning">:octocat:</a></li></ul><h2 id="数据集">数据集</h2><ul><li>MNIST</li><li>Fashion-MNIST</li></ul><h2 id="模型">模型</h2><ul><li>LeNet</li><li>AlexCifarNet</li><li>ResNet18/34/50/101/152</li><li>CNN</li></ul><span id="more"></span><h2 id="可视化">可视化</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091907015.png"alt="image-20240309190716897" /><figcaption aria-hidden="true">image-20240309190716897</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091908515.png"alt="image-20240309190826462" /><figcaption aria-hidden="true">image-20240309190826462</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091909686.png"alt="image-20240309190936633" /><figcaption aria-hidden="true">image-20240309190936633</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091910062.png"alt="image-20240309191039009" /><figcaption aria-hidden="true">image-20240309191039009</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;result&quot;&gt;Result&lt;/h1&gt;
&lt;h2 id=&quot;baseline&quot;&gt;baseline：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1602.05629&quot;&gt;FedAvg&lt;/a&gt; (Hugh Brendan
McMahan et al., AISTATS 2017)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/2007.07481&quot;&gt;FedNova&lt;/a&gt; (Jianyu Wang
et al., NeurIPS 2020) &lt;a
href=&quot;https://github.com/JYWa/FedNova&quot;&gt;:octocat:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1812.06127&quot;&gt;FedProx&lt;/a&gt; (Tian Li et
al., MLSys 2020) &lt;a
href=&quot;https://github.com/litian96/FedProx&quot;&gt;:octocat:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1910.06378&quot;&gt;SCAFFOLD&lt;/a&gt; (Sai
Praneeth Karimireddy et al.,ICML 2020) &lt;a
href=&quot;https://github.com/ki-ljl/Scaffold-Federated-Learning&quot;&gt;:octocat:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;数据集&quot;&gt;数据集&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MNIST&lt;/li&gt;
&lt;li&gt;Fashion-MNIST&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;模型&quot;&gt;模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LeNet&lt;/li&gt;
&lt;li&gt;AlexCifarNet&lt;/li&gt;
&lt;li&gt;ResNet18/34/50/101/152&lt;/li&gt;
&lt;li&gt;CNN&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【双指针】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91/</id>
    <published>2024-02-28T07:23:16.000Z</published>
    <updated>2024-03-19T07:00:04.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板">模板</h1><ul><li><p>双指针的主要作用是 ——<strong>优化时间复杂度</strong>，通常可以将时间复杂度从 <spanclass="math inline">\(O(n^2)\)</span> 优化到 <spanclass="math inline">\(O(n)\)</span></p></li><li><p>可以从朴素思想开始，思考两个指针是否具有某种性质，eg：</p><ul><li>2 个指针均只能向前移动，而不能向后移动</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">        j++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 个指针只能向前移动，1 个指针只能向后移动</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">        j++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常见问题分类：</p><ol type="1"><li>对于<strong>一个序列</strong>，2个指针一前一后【快慢指针】，用两个指针维护一段区间</li><li>对于<strong>两个序列</strong>，2 个指针分别指向 2个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</li></ol></li></ul><span id="more"></span><ul><li><p>简单例子：</p><p>给你一个字符串，请将其中的每个单词依次输出（假设字符串开头没有空格，且单词之间有且仅有一个空格）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">            cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="acwing">AcWing</h1><h2 id="最长连续不重复子序列"><ahref="https://www.acwing.com/problem/content/801/">最长连续不重复子序列</a></h2><h2 id="数组元素的目标和"><ahref="https://www.acwing.com/problem/content/802/">数组元素的目标和</a></h2><h2 id="判断子序列"><ahref="https://www.acwing.com/activity/content/problem/content/2981/">判断子序列</a></h2><h1 id="leetcode">LeetCode</h1><h2 id="三数之和"><ahref="https://leetcode.cn/problems/3sum/">三数之和</a></h2><p>​ 给你一个整数数组 <code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code> 满足<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code>。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>将 sum 数组排序</li><li>先确定 nums[i] 为第一个元素【<strong>为了避免重复，如果 nums[i]和刚刚的 nums[i-1] 相同就跳过 continue</strong>】</li><li>然后 left 指向 i+1，right 指向 n-1，判断此时的 sum 是否等于0，如果等于 0 就将结果放入 result 数组中，且<code>left++</code>，<code>right--</code>【<strong>为了避免重复，如果<code>left++</code>后的元素依旧和刚才的元素相同，继续<code>left++</code>，<code>right--</code></strong>】</li><li>同理～如果 <code>sum&gt;0</code> 就将<code>right--</code>，如果<code>sum&lt;0</code>就将<code>left++</code>，最后返回result结果集～～</li></ul><p><strong>代码：</strong></p><ul><li>法一【推荐】：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[i] + nums[l] + nums[r] &gt; <span class="number">0</span>)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">if</span> (l &lt; r &amp;&amp; nums[i] + nums[l] + nums[r] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>])</span><br><span class="line">                        r--;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>])</span><br><span class="line">                        l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>法二：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">                        left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">                        right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="盛最多水的容器"><ahref="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h2><p>​ 给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有<code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是<code>(i, 0)</code> 和 <code>(i, height[i])</code>。找出其中的两条线，使得它们与 <code>x</code>轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041857557.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li><p>可容纳水的高度由两板中的 <strong>短板</strong> 决定：<spanclass="math inline">\(S(i,j)=min(h[i],h[j])×(j−i)\)</span></p></li><li><p>从<strong>最大宽度</strong>开始枚举计，用<strong>首尾双指针</strong>的方法，计算<strong>不同宽度下对应的能选择的最大高度</strong></p></li></ul><blockquote><p>为什么是从最大宽度开始枚举，而不是从最小宽度开始枚举呢？</p><p>——因为最大宽度（数组长度n）下的的最大容量很好计算，即<spanclass="math inline">\(S(0,n-1)=min(h[0],h[n-1])×n\)</span>，相反最小宽度（1）下的最大容量就不太好计算，即<spanclass="math inline">\(S(i,i+1)=min(h[i],h[i+1])×1\)</span>，需要我们遍历一遍i才能求出来</p></blockquote><ul><li>每次移动时，选定<strong>两板高度中的短板</strong>，向中间收窄一格</li></ul><blockquote><p>为什么要选定<strong>两板高度中的短板</strong>，向中间收窄一格呢？</p><p>——假如当前两板宽度为 <span class="math inline">\(i\)</span>，每次这样移动，都可以保证移动后当前容量为<strong>两板宽度为 <spanclass="math inline">\(i-1\)</span>情况下的最大容量</strong>，才有可能大于移动前（两板宽度为 <spanclass="math inline">\(i\)</span> ）时的最大容量</p></blockquote><ul><li>我们最后求得的就是<strong>所有宽度下的最大容量</strong>，只要求出<strong>所有宽度下的最大容量</strong>（彩色区域）的最大值即可</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041930585.png" alt="image-20240304193007507" style="zoom:22%;" /></p><p>综上所述，算法流程如下：</p><ol type="1"><li>初始化：双指针 <span class="math inline">\(i\)</span> , <spanclass="math inline">\(j\)</span> 分列水槽左右两端</li><li>循环收窄，直至双指针相遇时跳出：<ol type="1"><li>更新面积最大值 ans</li><li>选定<strong>两板高度中的短板</strong>，向中间收窄一格；</li><li>返回值：返回面积最大值 <span class="math inline">\(res\)</span>即可；</li></ol></li></ol><p><ahref="https://www.bilibili.com/video/BV1za411q7QG/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】11. 盛最多水的容器 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[left], height[right]) * (right - left));</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;模板&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;双指针的主要作用是 ——
&lt;strong&gt;优化时间复杂度&lt;/strong&gt;，通常可以将时间复杂度从 &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n^2)&#92;)&lt;/span&gt; 优化到 &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n)&#92;)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以从朴素思想开始，思考两个指针是否具有某种性质，eg：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 个指针均只能向前移动，而不能向后移动&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; i &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;check&lt;/span&gt;(i, j))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 具体问题的逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;1 个指针只能向前移动，1 个指针只能向后移动&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, j = m - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;check&lt;/span&gt;(i, j))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 具体问题的逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见问题分类：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;对于&lt;strong&gt;一个序列&lt;/strong&gt;，2
个指针一前一后【快慢指针】，用两个指针维护一段区间&lt;/li&gt;
&lt;li&gt;对于&lt;strong&gt;两个序列&lt;/strong&gt;，2 个指针分别指向 2
个序列，维护某种次序，比如归并排序中合并两个有序序列的操作&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【搜索与图论】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%E3%80%91/</id>
    <published>2024-02-28T07:23:16.000Z</published>
    <updated>2024-03-19T06:59:56.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树与图的存储">树与图的存储</h1><ul><li>树是一种特殊的图，与图的存储方式相同<ul><li>树：<span class="math inline">\(n\)</span> 个顶点，最多有 <spanclass="math inline">\(m=n-1\)</span> 条边</li><li>图：<span class="math inline">\(n\)</span> 个顶点，无向图最多有<span class="math inline">\(m=n(n-1)/2\)</span> 条边，有向图最多有 <spanclass="math inline">\(m=n(n-1)\)</span> 条边<ul><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span>是一个量级的——<strong>稀疏图</strong></li><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n^2\)</span>​是一个量级的——<strong>稠密图</strong></li></ul></li></ul></li></ul><blockquote><p>eg：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稠密图</span></span><br><span class="line"><span class="number">1</span> ≤ n ≤ <span class="number">500</span>,</span><br><span class="line"><span class="number">1</span> ≤ m ≤ <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="comment">// 稀疏图</span></span><br><span class="line"><span class="number">1</span> ≤ n,m ≤ <span class="number">10</span>^<span class="number">5</span>,</span><br></pre></td></tr></table></figure></p></blockquote><span id="more"></span><ul><li><p>对于无向图中的边ab，存储两条有向边 <code>a-&gt;b</code>,<code>b-&gt;a</code> 即可。因此我们可以只考虑有向图的存储</p></li><li><p>邻接矩阵：<code>g[a][b]</code>存储边 <code>a-&gt;b</code></p><ul><li>空间复杂度：<span class="math inline">\(O(n^2)\)</span>，适合存储<strong>稠密图</strong></li><li>无权图</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b</span></span><br><span class="line">g[a][b] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span>(g[a][b])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有权图</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化邻接矩阵</span></span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b，权重为c</span></span><br><span class="line">g[a][b] = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span> (g[a][b] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有边的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有边的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>邻接表：【除非题目交代为稠密图，我们更常用临界表】</p><ul><li>空间复杂度：适合存储<strong>稀疏图</strong></li><li>无权图</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有权图</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点 k，开一个单链表，存储 k 所有可以走到的点。</span></span><br><span class="line"><span class="comment">// h[k] 存储这个单链表的头结点, w[] 存储边的权重</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure></li><li><p>自环、重边</p></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101605409.jpeg" style="zoom:20%;" /></p><h1 id="树与图的遍历">树与图的遍历</h1><ul><li><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>连通图遍历时只需要遍历任何一个点即可，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(1);</span><br><span class="line">bfs(1);</span><br></pre></td></tr></table></figure></li><li><p>非连通图遍历时要依次遍历所有点，确保能够遍历所有连通分量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">dfs</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">bfs</span>(i)</span><br></pre></td></tr></table></figure></li></ul><h2 id="深度优先遍历">深度优先遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="宽度优先遍历">宽度优先遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                st[j] = <span class="literal">true</span>; <span class="comment">// 表示点 j 已经被遍历过</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这里的 st 可以有以下2种作用</p><ol type="1"><li>【必备】记录节点 i 是否已被访问</li><li>【可选】记录子问题的解（类似 DP问题中的<code>dp[]</code>），此时通常在<code>dfs()</code> /<code>bfs()</code>最前面加一句<code>memset(st,-1,sizeof st);</code></li></ol><h1 id="拓扑排序">拓扑排序</h1><ul><li>理论表明：<font color='red'><strong>有向无环图</strong></font>一定有拓扑排序（拓扑图又叫<font color='red'><strong>有向无环图</strong></font>）</li><li>时间复杂度：<span class="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界矩阵存储</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// d[i] 存储点 i 的入度</span></span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始时：所有入度为零的点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 t 的所有出边，并更新入度d[], 队列q[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在拓扑排序，输出-1；否则输出其中的一个拓扑排序</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">toposort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路">最短路</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101426248.png"alt="image-20240310110004460" /><figcaption aria-hidden="true">image-20240310110004460</figcaption></figure><h2 id="朴素dijkstra算法">朴素Dijkstra算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131123733.png"alt="image-20240313112344516" /><figcaption aria-hidden="true">image-20240313112344516</figcaption></figure><ul><li>时间复杂度：<span class="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>朴素Dijkstra算法适合于<strong>稠密图</strong>：采用<strong>邻接矩阵</strong>存储</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每循环一次,就会找到一条最短路径,循环n-1次,最后一个的dist一定也是最短的，当然你写n也是完全没问题的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明最短路不存在（即非连通图）</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆优化版dijkstra">堆优化版dijkstra</h2><ul><li>时间复杂度：<span class="math inline">\(O(mlogn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                            <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bellman-ford算法">Bellman-Ford算法</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131128358.png" alt="image-20240313112833199" style="zoom:33%;" /></p><ul><li>如果图中存在负权回路，最短路<strong>不一定</strong>存在<ul><li>如果负环不在从 1 号点到 n 号点的路径上的话，就没有影响</li><li>如果题目限制了<strong>最短路边的个数</strong>（即不能无限转），则一定存在最短路径</li></ul></li><li>Bellman-Ford算法迭代 k 次，dist[]表示从1号点，经过<font color='red'><strong>不超过k条边</strong></font>，走到每个点的最短距离</li><li>Bellman-Ford算法可以判断图中是否存在负权回路<ul><li>迭代 n 次，第 n次仍有最短距离更新的话，说明存在一条边数为n的最短路径</li><li>n 个点最多有 n-1 条边，所以一定存在一个负权回路</li></ul></li><li>时间复杂度：<span class="math inline">\(O(nm)\)</span>​</li></ul><blockquote><p><strong><font color='red'>由于 Bellman-Ford算法只需要在每次循环中，对所有边进行遍历，因此我们可以采用结构体数组存储边的集合即可，不需要存储图</font></strong></p></blockquote><h3 id="有边数限制的bellman-ford算法">有边数限制的Bellman-Ford算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, k;   <span class="comment">// n表示点数，m表示边数，k表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N];   <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="type">int</span> backup[N]; <span class="comment">// back[x]存储上次循环中，1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边，a表示出点，b表示入点，c表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 k 次，最短路最多经历 k 条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>last[]</code>是备份数组，用于存储上次迭代的结果，用上次迭代的结果更新当前的距离，防止发生串联</p></li><li><p>为什么需要使用 <code>last[]</code> ?</p></li></ul><blockquote><p>​ 为了避免如下的串联情况，在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452123.png" alt="2.PNG" style="zoom:45%;" /></p><p>​ 正确做法是用上轮节点2更新的距离--无穷大，来更新节点3，再取最小值，所以节点3离起点的距离是3。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452285.png" alt="3.PNG" style="zoom:45%;" /></p></blockquote><ul><li><p>为什么是<code>dist[n] &gt; 0x3f3f3f3f/2</code>，而不是<code>dist[n] &gt; 0x3f3f3f3f</code></p><blockquote><p>​ 5 号节点距离起点的距离是无穷大，利用 5 号节点更新 n号节点距离起点的距离，将得到<spanclass="math inline">\(10^9-2\)</span>，虽然小于<spanclass="math inline">\(10^9\)</span>，但并不存在最短路(在边数限制在k条的条件下)</p></blockquote></li></ul><h3id="没有边数限制的bellman-ford算法">没有边数限制的Bellman-Ford算法</h3><ul><li>实际上是“有边数限制的Bellman-Ford算法”的特殊情况，这是的边数限制是 n，但是不需要使用 backup 数组，因为最短路上最多也就是 n个顶点，即使串联也没关系</li><li>可以用于判读是否存在负权路</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;    <span class="comment">// n表示点数，m表示边数，k表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边，a表示出点，b表示入点，c表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第 n 次迭代仍然会松弛三角不等式，就说明存在一条长度是 n+1 的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], dist[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spfa-算法队列优化的bellman-ford算法">spfa算法（队列优化的Bellman-Ford算法）</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131416112.png"alt="image-20240313141627490" /><figcaption aria-hidden="true">image-20240313141627490</figcaption></figure><ul><li>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</li><li>Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是<font color='red'><strong>SPFA算法不可以存在负权回路</strong></font>，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</li><li>时间复杂度：<ul><li>平均情况下 <span class="math inline">\(O(m)\)</span></li><li>最坏情况下 <span class="math inline">\(O(nm)\)</span></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">// 从队列中取出来之后该节点st被标记为false，之后该节点如果发生更新可再次入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>⭐️为什么 Bellman_ford 算法里最后 <code>return -1</code>的判断条件写的是 <code>dist[n] &gt; 0x3f3f3f3f/2</code>，而 spfa算法写的是<code>dist[n]==0x3f3f3f3f</code>？</li></ul><blockquote><p>​原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p></blockquote><ul><li>st数组的作用是什么？</li></ul><blockquote><p>​判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。</p></blockquote><ul><li>SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</li></ul><blockquote><ol type="1"><li>Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。</li><li>Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</li></ol></blockquote><ul><li>由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为<spanclass="math inline">\(O(nm)\)</span>，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)</li></ul><h2 id="spfa判断图中是否存在负环">spfa判断图中是否存在负环</h2><ul><li><p><strong>求负环一般使用SPFA算法</strong>，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环</p></li><li><p>时间复杂度：<span class="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];              <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的边数</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组（因为如果存在负环，那么dist不管初始化为多少，都会被更新）</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么把所有点入队?</li></ul><blockquote><p>​我们可以假设一个虚拟源点0点，从虚拟源点连一条权值是0的边到所有点，这样这个新图其实是和原图等价的（原图上有负环等价于新图上有负环），那我们做spfa的时候首先把0入队，第一次迭代的时候会把0出队，然后把和0点相连的点全部入队，那么就相当于把1~n的所有点入队，所以我们直接把所有点入队，效果是一样的，相当于自己手动迭代了一次spfa.</p></blockquote><ul><li>dist[]为什么初始化为什么值都无所谓？</li></ul><blockquote><p>​假设有负环，那么负环上的点到虚拟源点0的距离一定是-INF对不对，因为我可以在负环上跑无限次，每次都能把我到0点的距离减小。然后因为边上的权值都是有限值，所以每次在负环上跑一圈就相当于dt[]减去一个有限值，最终dt[]==-INF，所以意味着会减无限次（简单明了的说就是我们在负环上跑无限次，就可以把我到0点的距离减成-INF）。重点来了，dt[]初值肯定是一个有限值，一个有限值每次减一个有限值（负环上跑一次），然后减无限次，最终dt[]减成-INF。即dt[]初值是多少都无所谓，因为会减无限次有限值，你再大的数减无限次有限值肯定减成-INF。我们只要用抽屉原理保证迭代超过n次的时候，说明路径上有起码n+1个点，说明有重复点，即有负环就行。所以我们甚至可以把判断条件改为cnt[j]&gt; 99999都行，只要大于n。</p></blockquote><blockquote></blockquote><h2 id="floyd算法">Floyd算法</h2><ul><li>先循环 k ，再循环 i , j（ i , j 顺序可以颠倒）</li><li>Floyd算法的原理是<strong>动态规划</strong>，在代码实现的时候省去了一维状态。<ul><li><code>f[i, j, k]</code>表示从<code>i</code>走到<code>j</code>的路径上除了<code>i, j</code>以外不包含点<code>k</code>的所有路径的最短距离。那么<code>f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]</code>。因此在计算第<code>k</code>层的<code>f[i, j]</code>的时候必须先将第<code>k - 1</code>层的所有状态计算出来，所以需要把k放在最外层</li></ul></li><li>时间复杂度：<span class="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树">最小生成树</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131944187.png"alt="image-20240313194446005" /><figcaption aria-hidden="true">image-20240313194446005</figcaption></figure><ul><li>最小生成树是针对无向图的</li><li><strong>连通图</strong>一定存在最小生成树</li><li><strong><span class="math inline">\(n\)</span></strong>个顶点的无向连通图，最小生成树的边数为 <strong><spanclass="math inline">\(n - 1\)</span></strong></li></ul><h2 id="prim算法">Prim算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131953561.png"alt="image-20240313195326359" /><figcaption aria-hidden="true">image-20240313195326359</figcaption></figure><ul><li>时间复杂度：<span class="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;       <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF, 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[t] == INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal算法">Kruskal算法</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403132026795.png" alt="image-20240313202628601" style="zoom: 33%;" /></p><ul><li><p>Kruskal算法使用到了<strong>并查集</strong></p></li><li><p><strong><font color='red'>由于 Kruskal算法只需要在每次循环中，对所有边进行遍历，因此我们可以采用结构体数组存储边的集合即可，不需要存储图</font></strong></p></li><li><p>时间复杂度：<span class="math inline">\(O(mlogm)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m; <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; W.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集核心操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(edges, edges + m, [](Edge x, Edge y)</span><br><span class="line">         &#123; <span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res表示最小生成树的权重之和，cnt表示最小生成树集合中边的数量</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += c;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的数量小于n-1，说明图是非连通图，不存在最小生成树</span></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分图">二分图</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131944501.png"alt="image-20240313194459355" /><figcaption aria-hidden="true">image-20240313194459355</figcaption></figure><ul><li>二分图当且仅当<font color='red'><strong>图中不含奇数环</strong></font></li><li>二分图不一定是连通图</li></ul><h2 id="判断是否为二分图染色法">判断是否为二分图——染色法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> i 未染色</span><br><span class="line">        dfs(i, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;                   <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];               <span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数：u表示当前节点，c表示当前点的颜色 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">// u 点染成颜色 c</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 相邻的点没有颜色,则递归处理这个相邻点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="comment">// （3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）</span></span><br><span class="line">                                <span class="comment">// （3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="comment">// 如果已经染色，判断颜色是否为 c</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 作用：染色法判断是否为二分图 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二分图不一定是连通图，所以要依次对每个点遍历判断，而不能直接 dfs(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>)) <span class="comment">// 第一次染色的一定是某个连通分量中的第一个点，所以染成颜色 1/2 都可以，然后调用dfs即可将其所在连通分量的所以点染色</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="求二分图的最大匹配匈牙利算法">求二分图的最大匹配——匈牙利算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403141306955.gif"alt="匈牙利算法" /><figcaption aria-hidden="true">匈牙利算法</figcaption></figure><ul><li>时间复杂度：<span class="math inline">\(O(mn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li><li>第一个集合表示男生，第二个集合表示女生</li><li>匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;                 <span class="comment">// n1表示第一个集合中男生人数，n2表示第二个集合中女生人数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];               <span class="comment">// match[i]表示第二个集合中点i当前匹配的第一个集合中的点</span></span><br><span class="line"><span class="type">bool</span> st[N];                 <span class="comment">// 表示第二个集合中的每个点是否已经被考虑过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果妹子还没有匹配任何男生 或者 匹配的那个男生可以更换妹子</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="comment">// 第一个集合中的点i能找到对应的匹配</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">        res++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;树与图的存储&quot;&gt;树与图的存储&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;树是一种特殊的图，与图的存储方式相同
&lt;ul&gt;
&lt;li&gt;树：&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个顶点，最多有 &lt;span
class=&quot;math inline&quot;&gt;&#92;(m=n-1&#92;)&lt;/span&gt; 条边&lt;/li&gt;
&lt;li&gt;图：&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个顶点，无向图最多有
&lt;span class=&quot;math inline&quot;&gt;&#92;(m=n(n-1)/2&#92;)&lt;/span&gt; 条边，有向图最多有 &lt;span
class=&quot;math inline&quot;&gt;&#92;(m=n(n-1)&#92;)&lt;/span&gt; 条边
&lt;ul&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(m&#92;)&lt;/span&gt; 和 &lt;span
class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;
是一个量级的——&lt;strong&gt;稀疏图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(m&#92;)&lt;/span&gt; 和 &lt;span
class=&quot;math inline&quot;&gt;&#92;(n^2&#92;)&lt;/span&gt;​
是一个量级的——&lt;strong&gt;稠密图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 稠密图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ≤ n ≤ &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ≤ m ≤ &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 稀疏图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ≤ n,m ≤ &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【贪心】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/</id>
    <published>2024-02-28T07:23:16.000Z</published>
    <updated>2024-03-19T06:59:38.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="买卖股票的最佳时机"><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h2><p>​ 给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素<code>prices[i]</code> 表示一支给定股票第 <code>i</code>天的价格。你只能选择 <strong>某一天</strong> 买入这只股票，并选择在<strong>未来的某一个不同的日子</strong>卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>​ 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>分析：</strong></p><p>​ 如果我们在图表上绘制给定数组中的数字，我们将会得到：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402291747999.png" alt="Profit Graph" style="zoom: 67%;" /></p><p>​我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？</p><p>​显然，<strong>如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！</strong>太好了，在题目中，我们只要用一个变量记录一个历史最低价格minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i天卖出股票能得到的利润就是 prices[i] - minprice。</p><p>​因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minprice = INT_MAX, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="跳跃游戏"><ahref="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h2><p>​ 给你一个非负整数数组 <code>nums</code> ，你最初位于数组的<strong>第一个下标</strong>。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回<code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3个格子都可以作为 起跳点</li><li>可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离不断更新</li><li>如果可以一直跳到最后，就成功了</li></ul><figure><imgsrc="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20240303223709599.png"alt="image-20240303223709599" /><figcaption aria-hidden="true">image-20240303223709599</figcaption></figure><p><ahref="https://www.bilibili.com/video/BV1KU4y1f76S/?buvid=XY3CA67352B7F82D3CAB27E191FA025EB4053&amp;from_spmid=united.player-video-detail.drama-float.0&amp;is_story_h5=false&amp;mid=ivlqRrACJE6aj0QtF6a%2FzA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=731b05d0-fb4a-4568-aa5e-aa5ae01b4284&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1709425948&amp;unique_k=XDZkCBH&amp;up_id=320530935&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】55. 跳跃游戏 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><ul><li><strong>法一</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxdistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxdistance)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            maxdistance = <span class="built_in">max</span>(maxdistance, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改进一下，增加提前结束的条件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxdistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxdistance)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (maxdistance &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            maxdistance = <span class="built_in">max</span>(maxdistance, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>法二：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxdistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxdistance; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxdistance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            maxdistance = <span class="built_in">max</span>(maxdistance, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="跳跃游戏-ii"><ahref="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a></h2><p>​ 给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组<code>nums</code>。初始位置为 <code>nums[0]</code>。每个元素<code>nums[i]</code> 表示从索引 <code>i</code>向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code>处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code>的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><font color='red'>题目保证可以到达<code>nums[n-1]</code></font></li></ul><p><strong>分析：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032246330.png" alt="image-20240303224623217" style="zoom: 25%;" /></p><ul><li>同一个区间代表到达他们的最少跳跃次数是相同的</li><li>所以我们只需要在遍历的同时维护两个变量，分别是<font color='red'><strong>当前能走到的最远位置</strong></font>和<font color='red'><strong>上次跳跃可到达区间的右边界</strong></font>。当遍历到边界时，说明到达了下一个区间，这时只要把边界更新为当前能走到的最远位置就可以了。</li></ul><p><strong>分析：</strong></p><ul><li>题目保证可以到达<code>nums[n-1]</code>，因此不必考虑能否到达的问题</li><li>在遍历数组时，我们<strong>不访问最后一个元素</strong>（<code>i &lt; nums.size() - 1</code>），这是因为在访问最后一个元素之前，我们的masPos一定大于等于最后一个位置，否则就无法跳到最后一个位置了（而题目保证可以到达<code>nums[n-1]</code>）。如果访问最后一个元素，在边界正好为maxPos位置的情况下，我们会增加一次「不必要的跳跃次数」（eg:<code>nums = [2,3,1,1,4]</code>），因此我们不必访问最后一个元素。</li></ul><p><ahref="https://www.bilibili.com/video/BV1i5411o7wi/?buvid=XY3CA67352B7F82D3CAB27E191FA025EB4053&amp;from_spmid=united.player-video-detail.drama-float.0&amp;is_story_h5=false&amp;mid=ivlqRrACJE6aj0QtF6a%2FzA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=36e7d624-3129-40a7-a161-d4fd0c74f4b1&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1709425826&amp;unique_k=T2wqaew&amp;up_id=320530935">【LeetCode每日一题】45. 跳跃游戏 II | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxdistance = <span class="number">0</span>, cnt = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxdistance = <span class="built_in">max</span>(maxdistance, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxdistance;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词拆分"><ahref="https://leetcode.cn/problems/word-break/">单词拆分</a></h2><p>​ 给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>则返回 <code>true</code>。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><ahref="https://www.bilibili.com/video/BV1mt4y1s7H1/?buvid=XY3CA67352B7F82D3CAB27E191FA025EB4053&amp;from_spmid=united.player-video-detail.drama-float.0&amp;is_story_h5=false&amp;mid=ivlqRrACJE6aj0QtF6a%2FzA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=4b01997d-4fbc-45a3-a5b3-6905e14fa012&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1709426244&amp;unique_k=cmhk4wX&amp;up_id=320530935&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】139. 单词拆分 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;例题&quot;&gt;例题&lt;/h1&gt;
&lt;h2 id=&quot;买卖股票的最佳时机&quot;&gt;&lt;a
href=&quot;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/&quot;&gt;买卖股票的最佳时机&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;​ 给定一个数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素
&lt;code&gt;prices[i]&lt;/code&gt; 表示一支给定股票第 &lt;code&gt;i&lt;/code&gt;
天的价格。你只能选择 &lt;strong&gt;某一天&lt;/strong&gt; 买入这只股票，并选择在
&lt;strong&gt;未来的某一个不同的日子&lt;/strong&gt;
卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;​ 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回
&lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[7,1,5,3,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：prices = [7,6,4,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【数组】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E7%BB%84%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E7%BB%84%E3%80%91/</id>
    <published>2024-02-25T05:59:27.000Z</published>
    <updated>2024-03-19T07:00:11.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="最大子列和">最大子列和</h2><h3 id="类型一">类型一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252307752.png"alt="image-20231023145758457" /><figcaption aria-hidden="true">image-20231023145758457</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = 0;</code></p></blockquote><span id="more"></span><h3 id="类型二">类型二</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252307730.png"alt="image-20231023151341432" /><figcaption aria-hidden="true">image-20231023151341432</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = -MAX_INT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = -MAX_INT;</code></p></blockquote><p>:package:一定是先更新<code>maxsum = max(maxsum, thissum);</code>，再判断是否重新<code>thissum = 0;</code></p><h2 id="合并区间"><ahref="https://leetcode.cn/problems/merge-intervals/">合并区间</a></h2><p>​ 以数组 <code>intervals</code>表示若干个区间的集合，其中单个区间为<code>intervals[i] = [starti, endi]</code>。请你合并所有重叠的区间，并返回<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">             [](vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b) &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>])</span><br><span class="line">                ans.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(ans.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h2><p>​ 给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="除自身以外数组的乘积"><ahref="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h2><p>​ 给你一个整数数组 <code>nums</code>，返回 <em>数组<code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code>中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><ul><li><p>题目数据 <strong>保证</strong> 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32位</strong> 整数范围内。</p></li><li><p>请 <strong>不要使用除法，</strong> 且在 <code>O(*n*)</code>时间复杂度内完成此题。</p></li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析</span></span><br><span class="line"><span class="comment">1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]</span></span><br><span class="line"><span class="comment">2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]  */</span></span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right */</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right = right * nums[i + <span class="number">1</span>];</span><br><span class="line">            v[i] *= right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;例题&quot;&gt;例题&lt;/h1&gt;
&lt;h2 id=&quot;最大子列和&quot;&gt;最大子列和&lt;/h2&gt;
&lt;h3 id=&quot;类型一&quot;&gt;类型一&lt;/h3&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252307752.png&quot;
alt=&quot;image-20231023145758457&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20231023145758457&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MaxSubseqSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; A[], &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; thissum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, maxsum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thissum += A[i];      &lt;span class=&quot;comment&quot;&gt;/* 向右累加 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (thissum &amp;gt; maxsum) &lt;span class=&quot;comment&quot;&gt;/* 发现更大和则更新当前结果 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxsum = thissum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// maxsum = max(maxsum, thissum);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (thissum &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)      &lt;span class=&quot;comment&quot;&gt;/* 如果当前子列和为负 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            thissum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;      &lt;span class=&quot;comment&quot;&gt;/* 则不可能使后面的部分和增大，抛弃之 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxsum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;maxsum的初值 &lt;code&gt;int maxsum = 0;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【位运算】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91/</id>
    <published>2024-02-24T17:02:27.000Z</published>
    <updated>2024-03-20T04:07:13.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板">模板</h1><ul><li>求 <span class="math inline">\(x\)</span> 二进制的第 <spanclass="math inline">\(k\)</span> 位数字：<ol type="1"><li>先把第 <span class="math inline">\(k\)</span> 位移到最后一位 <spanclass="math inline">\(x&gt;&gt;k\)</span></li><li>看个位是几 <span class="math inline">\(x \&amp; 1\)</span></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt;&gt; k &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>返回 <span class="math inline">\(x\)</span> 的最后一位1：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lowbit</span>(x) = x &amp; -x</span><br></pre></td></tr></table></figure><p><span class="math display">\[x=\left( 1010 \right) _2\Rightarrow lobit\left( x \right) =\left( 10\right) _2\\x=\left( 101000 \right) _2\Rightarrow lobit\left( x \right) =\left( 1000\right) _2\]</span></p><blockquote><p>最常见的应用：统计某个二进制数中 1 的个数</p></blockquote><ul><li>将 x 乘以 <span class="math inline">\(2^k\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&lt; k</span><br><span class="line"><span class="comment">// eg: 2^k 可以表示为 2 &lt;&lt; k</span></span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="acwing">AcWing</h1><h2 id="二进制中1的个数---acwing题库"><ahref="https://www.acwing.com/problem/content/803/">二进制中1的个数 -AcWing题库</a></h2><h1 id="leetcode">LeetCode</h1><h2 id="只出现一次的数字"><ahref="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></h2><p>​ 给你一个 <strong>非空</strong> 整数数组 <code>nums</code>，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>分析</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402240152523.png"alt="image-20240224015214406" /><figcaption aria-hidden="true">image-20240224015214406</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402240151023.png"alt="image-20240224015146875" /><figcaption aria-hidden="true">image-20240224015146875</figcaption></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        res = res ^ nums[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集"><ahref="https://leetcode.cn/problems/subsets/">子集</a></h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集<strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong>返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>​ 记原序列中元素的总数为 <spanclass="math inline">\(n\)</span>。原序列中的每个数字 <spanclass="math inline">\(a_i\)</span>的状态可能有2种，即「在子集中」和「不在子集中」。我们用1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 n的 0/1 序列，第 i 位表示 <spanclass="math inline">\(a_i\)</span>是否在子集中。例如，<spanclass="math inline">\(n=3\)</span>，$a={ 5,2,9 } $ 时：</p><table><thead><tr class="header"><th>0/1 序列</th><th>子集</th><th>0/1 序列对应的二进制数</th></tr></thead><tbody><tr class="odd"><td>000</td><td>{}</td><td>0</td></tr><tr class="even"><td>001</td><td>{9}</td><td>1</td></tr><tr class="odd"><td>010</td><td>{2}</td><td>2</td></tr><tr class="even"><td>011</td><td>{2,9}</td><td>3</td></tr><tr class="odd"><td>100</td><td>{5}</td><td>4</td></tr><tr class="even"><td>101</td><td>{5,9}</td><td>5</td></tr><tr class="odd"><td>110</td><td>{5,2}</td><td>6</td></tr><tr class="even"><td>111</td><td>{5,2,9}</td><td>7</td></tr></tbody></table><p>​ 可以发现 0/1 序列对应的二进制数正好从 0 到 <spanclass="math inline">\(2^n - 1\)</span> 。我们可以枚举 <spanclass="math inline">\(mask∈[0,2n−1]\)</span>，mask 的二进制表示是一个0/1 序列，我们可以按照这个 0/1 序列在原集合当中取数。当我们枚举完所有<span class="math inline">\(2^n\)</span> 个<spanclass="math inline">\(mask\)</span>，我们也就能构造出所有的子集。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxn = <span class="built_in">pow</span>(<span class="number">2</span>, len);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(maxn);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                    res[i].<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:sunny:用位运算，i 从 0 到 maxn 变化，每⼀次计算 i 移动 j 位( j 从 1到 len )后，判断最后一位是否为1【实际是第j位是否为1】，如果为1，就将nums[j]的值放入res[i]～</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;模板&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;求 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 二进制的第 &lt;span
class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 位数字：
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;先把第 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 位移到最后一位 &lt;span
class=&quot;math inline&quot;&gt;&#92;(x&amp;gt;&amp;gt;k&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;看个位是几 &lt;span class=&quot;math inline&quot;&gt;&#92;(x &#92;&amp;amp; 1&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x &amp;gt;&amp;gt; k &amp;amp; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;返回 &lt;span class=&quot;math inline&quot;&gt;&#92;(x&#92;)&lt;/span&gt; 的最后一位1：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;lowbit&lt;/span&gt;(x) = x &amp;amp; -x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
x=&#92;left( 1010 &#92;right) _2&#92;Rightarrow lobit&#92;left( x &#92;right) =&#92;left( 10
&#92;right) _2
&#92;&#92;
x=&#92;left( 101000 &#92;right) _2&#92;Rightarrow lobit&#92;left( x &#92;right) =&#92;left( 1000
&#92;right) _2
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最常见的应用：统计某个二进制数中 1 的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将 x 乘以 &lt;span class=&quot;math inline&quot;&gt;&#92;(2^k&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x &amp;lt;&amp;lt; k&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// eg: 2^k 可以表示为 2 &amp;lt;&amp;lt; k&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【前缀和&amp;&amp;差分】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%89%8D%E7%BC%80%E5%92%8C&amp;&amp;%E5%B7%AE%E5%88%86%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%89%8D%E7%BC%80%E5%92%8C&amp;&amp;%E5%B7%AE%E5%88%86%E3%80%91/</id>
    <published>2024-02-24T17:02:27.000Z</published>
    <updated>2024-03-19T07:00:27.360Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>前缀和</strong> 与 <strong>差分</strong>是一对<font color='red'><strong>逆运算</strong></font><ul><li>前缀和最用：求某一区域/区间 的和</li><li>差分作用：将某一区域/区间内的数全部<strong>减去指定数值</strong></li></ul></li><li>差分序列通常<strong>不需要构建</strong>：<ul><li>将<strong>前缀和序列</strong>、<strong>差分序列</strong>均初始化为0（满足前缀和定义）</li><li>然后将原始数据<strong>依次插入</strong>前缀和序列，即可自动更新差分序列</li></ul></li><li><font color='red'><strong>原始数据 a[ ]，前缀和 S[ ]，差分序列 B[ ]都是从下标 1 开始存储的</strong></font></li></ul><span id="more"></span><h1 id="模板">模板</h1><h2 id="一维前缀和">一维前缀和</h2><ul><li>定义</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i], S[<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>性质：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i] = S[i - <span class="number">1</span>] + a[i]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1]</span><br></pre></td></tr></table></figure><blockquote><p>切记：前缀和 S 从下标 1 开始，S[0] = 0 用来解决边界问题</p></blockquote><h2 id="二维前缀和">二维前缀和</h2><ul><li>定义：</li></ul><p><span class="math display">\[S\left[ x \right] \left[ y \right] =\sum_{i=1}^x{\sum_{j=1}^y{a\left[ i\right] \left[ j \right]}}\]</span></p><ul><li>性质：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]</span><br></pre></td></tr></table></figure><p>​ 以 <span class="math inline">\((x1, y1)\)</span> 为左上角， <spanclass="math inline">\((x2, y2)\)</span> 为右下角的子矩阵的和为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403051726377.png" alt="image-20240305172624211" style="zoom: 15%;" /></p><h2 id="一维差分">一维差分</h2><ul><li>定义【不用记，用不到】：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i] = a[i] - a[i - 1], B[0] = 0</span><br></pre></td></tr></table></figure><ul><li>性质：<code>a[]</code>是<code>B[]</code>的前缀和，<code>B[]</code>是<code>a[]</code>的差分，所以：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i] = B[<span class="number">1</span>] + B[<span class="number">2</span>] + ... B[i]</span><br><span class="line">a[i] = a[i<span class="number">-1</span>] + B[i]</span><br></pre></td></tr></table></figure><p>:smile:以上​实际上是前缀和的定于与性质</p><ul><li>操作：给区间 <span class="math inline">\([l, r]\)</span>中的每个数加上 <span class="math inline">\(c\)</span>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[l] += c;</span><br><span class="line">    B[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维差分">二维差分</h2><ul><li>定义【不用记，用不到】：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i][j] = a[i][j] - a[i - <span class="number">1</span>][j] - a[i][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li>性质：<code>a[][]</code>是<code>B[][]</code>的前缀和，<code>B[][]</code>是<code>a[][]</code>的差分，因此：</li></ul><p><span class="math display">\[a\left[ i \right] \left[ j \right] =\sum_{i=1}^n{\sum_{j=1}^m{B\left[ i\right] \left[ j \right]}}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j] = a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>] + B[i][j];</span><br></pre></td></tr></table></figure><p>:smile:以上实际上是前缀和的定于与性质</p><ul><li>操作：给以(x1, y1)为左上角，(x2,y2)为右下角的子矩阵中的所有元素加上c：</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403052101952.png" alt="20201217174836198.png" style="zoom:30%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[x1][y1] += c;</span><br><span class="line">    B[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403052101614.png"alt="20201217170336254.png" /><figcaption aria-hidden="true">20201217170336254.png</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前缀和&lt;/strong&gt; 与 &lt;strong&gt;差分&lt;/strong&gt;
是一对&lt;font color=&#39;red&#39;&gt;&lt;strong&gt;逆运算&lt;/strong&gt;&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;前缀和最用：求某一区域/区间 的和&lt;/li&gt;
&lt;li&gt;差分作用：将某一区域/区间
内的数全部&lt;strong&gt;减去指定数值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;差分序列通常&lt;strong&gt;不需要构建&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt;前缀和序列&lt;/strong&gt;、&lt;strong&gt;差分序列&lt;/strong&gt;均初始化为0（满足前缀和定义）&lt;/li&gt;
&lt;li&gt;然后将原始数据&lt;strong&gt;依次插入&lt;/strong&gt;前缀和序列，即可自动更新差分序列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#39;red&#39;&gt;&lt;strong&gt;原始数据 a[ ]，前缀和 S[ ]，差分序列 B[ ]
都是从下标 1 开始存储的&lt;/strong&gt;&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/</id>
    <published>2024-02-24T17:02:27.000Z</published>
    <updated>2024-03-20T12:48:59.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png"alt="Snipaste_2019-09-13_17-06-58.png" /><figcaptionaria-hidden="true">Snipaste_2019-09-13_17-06-58.png</figcaption></figure><blockquote><p>集合划分原则</p><ol type="1"><li><p>不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】</p></li><li><p>如何将现有的集合划分为更小的子集，使得<strong>所有子集</strong>都可以计算出来</p></li></ol></blockquote><h2 id="背包问题">背包问题</h2><ul><li>0/1 背包：每种物品只有 1 个</li><li>完全背包：每种物品有无限个</li><li>多重背包：每种物品有 <span class="math inline">\(S_i\)</span>个</li><li>分组背包：有 N 组物品，每一组中有 若干个 物品</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081245014.png"alt="image-20240308124413525" /><figcaption aria-hidden="true">image-20240308124413525</figcaption></figure><span id="more"></span><h3 id="背包"><ahref="https://www.acwing.com/activity/content/code/content/8133547/">0/1背包</a></h3><h3 id="完全背包问题"><ahref="https://www.acwing.com/activity/content/code/content/8134352/">完全背包问题</a></h3><h3 id="分组背包">分组背包</h3><h2 id="概念">概念</h2><ol type="1"><li><p><strong>动态规划：</strong>将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解</p><ul><li>动态规划会将每个求解过的子问题的解记录下来，这样下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算</li><li>采用<strong>递归</strong>（又叫<strong>记忆化搜索</strong>）实现</li></ul></li><li><p><strong>重叠子问题：</strong>如果<strong>一个问题可以被分解成若干个子问题</strong>，且这些子问题会重复出现，就称这个问题拥有重叠子问题。一个问题必须拥有重叠子问题，才能用动态规划去解决。</p></li><li><p><strong>最优子结构：</strong>如果<strong>一个问题的最优解可以由其子问题的最优解有效地构造出来</strong>，那么称为这个问题拥有的最优子结构。最优子结构保证了动态规划中的原问题的最优解可以由子问题的最优解推导而来</p></li><li><p><strong>动态规划</strong> vs<strong>分治：</strong>都是分解为子问题然后合并子问题得到解，但是：</p><ul><li>动态规划分解出的子问题是重叠的</li><li>分治分解出的子问题是不重叠的</li></ul></li><li><p><strong>动态规划 vs 贪心：</strong>都有最优子结构，但是：</p><ul><li>贪心直接选择一个子问题去求解，会抛弃一些子问题，这种选择的正确性需要用归纳法证明</li><li>而动态规划会考虑所有的子问题，所以这种选择一定是正确的</li></ul></li></ol><h2 id="最长递增子序列lis">最长递增子序列（LIS）</h2><ul><li>求一个序列的最长的子序列（可以不连续），使得这个子序列是不下降的</li><li><strong><span class="math inline">\(dp[i]\)</span> 表示必须以 <spanclass="math inline">\(a[i]\)</span>结尾的最长递增子序列的长度</strong>，<spanclass="math inline">\(dp\)</span> 数组中所有数据的最大值即为所求</li><li><span class="math inline">\(i\)</span> 从 <spanclass="math inline">\(0\)</span> 到 <spanclass="math inline">\(n-1\)</span> 依次更新 <spanclass="math inline">\(dp[i]\)</span> 的值，<spanclass="math inline">\(dp[i]\)</span> 的值需要由之前所生成的所有 <spanclass="math inline">\(dp[j]\)</span> 递推而得（<spanclass="math inline">\(j\)</span> 从 <spanclass="math inline">\(1\)</span> 到<spanclass="math inline">\(i-1\)</span>），每次检查是否 <spanclass="math inline">\(a[i]&gt;=a[j]\)</span>（如果要求严格递增，改为<spanclass="math inline">\(a[i]&gt;a[j]\)</span>），即是否构成最长不下降子序列，如果构成，会有两种结果：<ul><li><span class="math inline">\(dp[j]+1\)</span> 比 <spanclass="math inline">\(dp[i]\)</span> 大，则更新 <spanclass="math inline">\(dp[i] = dp[j] + 1\)</span></li><li><span class="math inline">\(dp[j]+1\)</span> 比 <spanclass="math inline">\(dp[i]\)</span> 小，则 <spanclass="math inline">\(dp[i]\)</span> 保持不变</li></ul></li><li>所以递推方程为 <span class="math inline">\(dp[i] = max{dp[i], dp[j]+ 1}\)</span></li><li><span class="math inline">\(dp\)</span>数组中所有数据的最大值即为所求：<span class="math inline">\(ans =max(dp[i], ans)\)</span></li></ul><p><strong>例题：</strong></p><p><a href="#section1">Leetcode 最长递增子序列</a></p><h2 id="最长公共子序列lcs">最长公共子序列（LCS）</h2><blockquote><p><strong>最长公共字串</strong>问题——参考KMP</p></blockquote><h2 id="最长回文子串">最长回文子串</h2><h2 id="最大连续子序列和">最大连续子序列和</h2><h2 id="背包问题-1">背包问题</h2><h2 id="找零钱">找零钱</h2><h1 id="单维dp">单维DP</h1><h2 id="最长递增子序列"><a id="section1"><ahref="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></a></h2><p>​ 给你一个整数数组 <code>nums</code>，找到其中最长严格递增子序列的长度。<strong>子序列</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/* dp[i]的初值设置为1 */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="乘积最大子数组"><ahref="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></h2><p>​ 给你一个整数数组 <code>nums</code>，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。测试用例的答案是一个<strong>32-位</strong> 整数。<strong>子数组</strong>是数组的连续子序列。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li><p>遍历数组时计算当前最大值，不断更新</p></li><li><p><strong>由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值</strong></p></li><li><p><code>dp_max[i] = max(dp_max[i - 1] * nums[i], dp_min[i - 1] * nums[i], nums[i])</code></p></li><li><p><code>dp_min[i] = min(dp_max[i - 1] * nums[i], dp_min[i - 1] * nums[i], nums[i])</code></p></li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_max</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_min</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp_max[<span class="number">0</span>] = nums[<span class="number">0</span>], dp_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_max[i] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp_max[i - <span class="number">1</span>] * nums[i], dp_min[i - <span class="number">1</span>] * nums[i]), nums[i]);</span><br><span class="line">            dp_min[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp_max[i - <span class="number">1</span>] * nums[i], dp_min[i - <span class="number">1</span>] * nums[i]), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp_max.<span class="built_in">begin</span>(), dp_max.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red'>特别地：当<spanclass="math inline">\(dp[i]\)</span>仅与<spanclass="math inline">\(dp[i-1]\)</span>有关时，可以<strong>不采用备忘录</strong>，<strong>仅使用中间变量</strong>即可</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxValue = nums[<span class="number">0</span>], minValue = nums[<span class="number">0</span>], res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 会改变 maxValue，使用临时变量保存一下~</span></span><br><span class="line">            <span class="type">int</span> tempMax = maxValue;</span><br><span class="line">            maxValue = <span class="built_in">max</span>(<span class="built_in">max</span>(maxValue * nums[i], minValue * nums[i]), nums[i]);</span><br><span class="line">            minValue = <span class="built_in">min</span>(<span class="built_in">min</span>(tempMax * nums[i], minValue * nums[i]), nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="零钱兑换"><ahref="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h2><p>​ 给你一个整数数组 <code>coins</code>，表示不同面额的硬币；以及一个整数 <code>amount</code>，表示总金额。计算并返回可以凑成总金额所需的<strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p><ahref="https://leetcode.cn/problems/coin-change/solutions/132979/322-ling-qian-dui-huan-by-leetcode-solution">动态规划——组成金额的最少硬币数量</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coins.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coins[j] &amp;&amp; dp[i - coins[j]] != <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">if</span> (dp[i] != <span class="number">-1</span>)</span><br><span class="line">                        dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i] = dp[i - coins[j]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数字金字塔"><ahref="https://www.luogu.com.cn/problem/P1216">数字金字塔</a></h2><p>​观察下面的数字金字塔。写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png" style="zoom:50%;" /></p><p>​ 在上面的样例中，从 <span class="math inline">\(7 \to 3 \to 8 \to 7\to 5\)</span> 的路径产生了最大权值。</p><p><strong>输入格式：</strong></p><p>​ 第一个行一个正整数 <span class="math inline">\(r\)</span>,表示行的数目。后面每行为这个数字金字塔特定行包含的整数。</p><p><strong>输出格式：</strong></p><p>​ 单独的一行,包含那个可能得到的最大的和。</p><p><strong>样例输入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure><p><strong>样例输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><h2 id="爬楼梯"><ahref="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h2><p>​ 假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬<code>1</code> 或 <code>2</code>个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h3 id="递归">递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>递归会超时</p></blockquote></blockquote><h3 id="迭代">迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 方式1 */</span></span><br><span class="line">        <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/* 方式2 */</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; a(n + 1);</span></span><br><span class="line"></span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><blockquote><ul><li>以空间换时间</li><li>方式2 容器 更耗时</li></ul></blockquote></blockquote><h2 id="杨辉三角"><ahref="https://leetcode.cn/problems/pascals-triangle/">杨辉三角</a></h2><p>​ 给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前<em><code>numRows</code></em>行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250127726.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)</span><br><span class="line">            res[i].<span class="built_in">resize</span>(i + <span class="number">1</span>);</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">1</span>][<span class="number">0</span>] = res[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = res[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><ahref="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2><p>​你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>​ 给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p><ahref="https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap">图解动态规划——打家劫舍</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* n&gt;=2 */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词拆分"><ahref="https://leetcode.cn/problems/word-break/">单词拆分</a></h2><p>​ 给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>则返回<code>true</code>。<strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>dp[i]：前 i 个字符s[0…i-1]能否被字典中的单词拼接</li><li><span class="math inline">\(dp[i]=dp[j] \&amp;\&amp;check(s[j…i-1])\)</span>​</li></ul><p><ahref="https://www.bilibili.com/video/BV1mt4y1s7H1/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】139. 单词拆分 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt; &amp;wordDict)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; <span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>(), s.<span class="built_in">substr</span>(j, i - j)) != wordDict.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="多维dp">多维DP</h1><h2 id="不同路径"><ahref="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><p>​ 一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041400223.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><ul><li><strong>方式1：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>方式2：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>方式3：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最小路径和"><ahref="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h2><p>​ 给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code>，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;动态规划&lt;/h1&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png&quot;
alt=&quot;Snipaste_2019-09-13_17-06-58.png&quot; /&gt;
&lt;figcaption
aria-hidden=&quot;true&quot;&gt;Snipaste_2019-09-13_17-06-58.png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;集合划分原则&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何将现有的集合划分为更小的子集，使得&lt;strong&gt;所有子集&lt;/strong&gt;都可以计算出来&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背包问题&quot;&gt;背包问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;0/1 背包：每种物品只有 1 个&lt;/li&gt;
&lt;li&gt;完全背包：每种物品有无限个&lt;/li&gt;
&lt;li&gt;多重背包：每种物品有 &lt;span class=&quot;math inline&quot;&gt;&#92;(S_i&#92;)&lt;/span&gt;
个&lt;/li&gt;
&lt;li&gt;分组背包：有 N 组物品，每一组中有 若干个 物品&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081245014.png&quot;
alt=&quot;image-20240308124413525&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20240308124413525&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【回溯】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%9E%E6%BA%AF%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%9E%E6%BA%AF%E3%80%91/</id>
    <published>2024-02-24T17:02:27.000Z</published>
    <updated>2024-03-19T07:01:50.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="全排列">全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:sunny:如果你希望生成所有的排列方式，一定要<strong>先将序列按升序排列</strong>，这里可以与sort函数结合起来使用，先用sort升序排列，再调用next_permutation函数。</p><span id="more"></span><h2 id="子集">子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集<strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong>返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>​ 记原序列中元素的总数为 <spanclass="math inline">\(n\)</span>。原序列中的每个数字 <spanclass="math inline">\(a_i\)</span>的状态可能有2种，即「在子集中」和「不在子集中」。我们用1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 n的 0/1 序列，第 i 位表示 <spanclass="math inline">\(a_i\)</span>是否在子集中。例如，<spanclass="math inline">\(n=3\)</span>，$a={ 5,2,9 } $ 时：</p><table><thead><tr class="header"><th>0/1 序列</th><th>子集</th><th>0/1 序列对应的二进制数</th></tr></thead><tbody><tr class="odd"><td>000</td><td>{}</td><td>0</td></tr><tr class="even"><td>001</td><td>{9}</td><td>1</td></tr><tr class="odd"><td>010</td><td>{2}</td><td>2</td></tr><tr class="even"><td>011</td><td>{2,9}</td><td>3</td></tr><tr class="odd"><td>100</td><td>{5}</td><td>4</td></tr><tr class="even"><td>101</td><td>{5,9}</td><td>5</td></tr><tr class="odd"><td>110</td><td>{5,2}</td><td>6</td></tr><tr class="even"><td>111</td><td>{5,2,9}</td><td>7</td></tr></tbody></table><p>​ 可以发现 0/1 序列对应的二进制数正好从 0 到 <spanclass="math inline">\(2^n - 1\)</span> 。我们可以枚举 <spanclass="math inline">\(mask∈[0,2n−1]\)</span>，mask 的二进制表示是一个0/1 序列，我们可以按照这个 0/1 序列在原集合当中取数。当我们枚举完所有<span class="math inline">\(2^n\)</span> 个<spanclass="math inline">\(mask\)</span>，我们也就能构造出所有的子集。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxn = <span class="built_in">pow</span>(<span class="number">2</span>, len);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(maxn);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                    res[i].<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:sunny:用位运算，i 从 0 到 maxn 变化，每⼀次计算 i 移动 j 位( j 从 1到 len )后，判断最后一位是否为1【实际是第j位是否为1】，如果为1，就将nums[j]的值放入res[i]～</p><h2 id="电话号码的字母组合"><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></h2><p>​ 给定一个仅包含数字 <code>2-9</code>的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong>返回。给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250044589.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">length</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        vector&lt;string&gt; v = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digits.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s = v[digits[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">            vector&lt;string&gt; t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">length</span>(); j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; res.<span class="built_in">size</span>(); k++)</span><br><span class="line">                    t.<span class="built_in">push_back</span>(res[k] + s[j]);</span><br><span class="line">            res = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合总和"><ahref="https://leetcode.cn/problems/combination-sum/">组合总和</a></h2><p>​ 给你一个 <strong>无重复元素</strong> 的整数数组<code>candidates</code> 和一个目标整数 <code>target</code> ，找出<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合<code>candidates</code> 中的<strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031938915.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><ahref="https://www.bilibili.com/video/BV1vL4y1s7Bh/?buvid=XY3CA67352B7F82D3CAB27E191FA025EB4053&amp;from_spmid=main.space-contribution.0.0&amp;is_story_h5=false&amp;mid=ivlqRrACJE6aj0QtF6a%2FzA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=d5a92a01-12a6-45e4-a94f-bc0012b3f215&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1709394069&amp;unique_k=a93Hn7c&amp;up_id=320530935&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】39. 组合总和 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* 选择1：跳过当前数字 */</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 选择2：选择当前数字 */</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt;= candidates[idx]) <span class="comment">// 剪枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            combine.<span class="built_in">push_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], idx);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="括号生成"><ahref="https://leetcode.cn/problems/generate-parentheses/">括号生成</a></h2><p>​ 数字 <code>n</code>代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><p><strong>分析：</strong></p><p>​ <strong>有效的括号组合</strong>需要同时满足以下2个条件</p><ol type="1"><li>任意前缀<code>(</code>数量 <strong>≥</strong><code>)</code>数量</li></ol><blockquote><p>任意前缀剩余<code>(</code>数量 <strong>≤</strong><code>)</code>数量</p></blockquote><ol start="2" type="1"><li>左右括号数量相等</li></ol><p><ahref="https://www.bilibili.com/video/BV1Pq4y1C7QC/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】22. 括号生成 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> ln, <span class="type">int</span> rn, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="number">0</span> &amp;&amp; rn == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 只要有左括号就可以添加左括号 */</span></span><br><span class="line">        <span class="keyword">if</span> (ln &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(ln - <span class="number">1</span>, rn, t + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="comment">/* 有左括号且左括号数量 ＜ 右括号数量就可以添加右括号（因为要保证加上右括号后仍然满足左括号的数量小于等于右括号的数量） */</span></span><br><span class="line">        <span class="keyword">if</span> (ln &lt; rn &amp;&amp; rn &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(ln, rn - <span class="number">1</span>, t + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词搜索"><ahref="https://leetcode.cn/problems/word-search/">单词搜索</a></h2><p>​ 给定一个 <code>m x n</code> 二维字符网格 <code>board</code>和一个字符串单词 <code>word</code> 。如果 <code>word</code>存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code>。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032046711.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032046671.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032046677.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>​用DFS来做，我们可以<strong>举枚矩阵的每个位置作为单词的起点</strong>，只要能够找到对应单词，就直接返回True。具体在每次搜索中可以依次尝试相邻未访问格子的字母，只要能和单词的对应位置匹配，就继续线下搜索。<ahref="https://www.bilibili.com/video/BV16T4y1i76C/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】79. 单词搜索 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码</strong></p><p>原版：空间复杂度<strong>O(nm)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dir_y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> id, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != word[id])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (id == word.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; !visited[tx][ty])</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, id + <span class="number">1</span>, tx, ty))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        visited.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改版：空间复杂度<strong>O(1)</strong></p><p>​这里有一点可以优化的地方。正常情况下，我们需要一个和矩阵一样大的数组visited来记录格子的访问状态。在这道题中指出，<strong>每个格子的字符仅由大小写英文字母组成。那么我们就可以用原始数组来记录格子的访问状态。</strong>比如每次都把选择后的格子标记为特殊符号（比如<code>!</code>）。那么在当前的搜索过程中，就不会再访问到这个格子了，这样就把空间复杂度从<strong>O(MN)</strong>优化到了<strong>O(1)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dir_y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> id, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != word[id])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (id == word.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span> t = board[x][y]; <span class="comment">// 记录原值，用于还原</span></span><br><span class="line">        board[x][y] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; board[tx][ty] != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, id + <span class="number">1</span>, tx, ty))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = t; <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;例题&quot;&gt;例题&lt;/h1&gt;
&lt;h2 id=&quot;全排列&quot;&gt;全排列&lt;/h2&gt;
&lt;p&gt;给定一个不含重复数字的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其
&lt;em&gt;所有可能的全排列&lt;/em&gt; 。你可以 &lt;strong&gt;按任意顺序&lt;/strong&gt;
返回答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 ：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [1,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;permute&lt;/span&gt;(vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vector&amp;lt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;sort&lt;/span&gt;(nums.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), nums.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res.&lt;span class=&quot;built_in&quot;&gt;push_back&lt;/span&gt;(nums);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;next_permutation&lt;/span&gt;(nums.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), nums.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;:sunny:如果你希望生成所有的排列方式，一定要&lt;strong&gt;先将序列按升序排列&lt;/strong&gt;，这里可以与sort函数结合起来使用，先用sort升序排列，再调用next_permutation函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
