<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天道酬勤，厚德载物</title>
  
  
  <link href="https://cuiluyi.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cuiluyi.gitee.io/"/>
  <updated>2024-03-31T14:12:16.200Z</updated>
  <id>https://cuiluyi.gitee.io/</id>
  
  <author>
    <name>tianchou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://cuiluyi.gitee.io/2024/03/31/[object%20Object]/%E6%89%93%E5%8D%B0/"/>
    <id>https://cuiluyi.gitee.io/2024/03/31/[object%20Object]/%E6%89%93%E5%8D%B0/</id>
    <published>2024-03-31T02:17:10.273Z</published>
    <updated>2024-03-31T14:12:16.200Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ssize_t&amp;&amp;size_t</title>
    <link href="https://cuiluyi.gitee.io/2024/03/30/[object%20Object]/C++/ssize_t&amp;&amp;size_t/"/>
    <id>https://cuiluyi.gitee.io/2024/03/30/[object%20Object]/C++/ssize_t&amp;&amp;size_t/</id>
    <published>2024-03-30T09:49:49.000Z</published>
    <updated>2024-03-30T14:59:32.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="size_t">size_t</h2><p>​ <strong><code>size_t</code></strong> 是一些C/C++标准在<code>stddef.h</code> 中定义的，<code>size_t</code> 类型表示 C中任何对象所能达到的最大长度，它是无符号整数。</p><p>​ 它是为了方便系统之间的移植而定义的，不同的系统上，定义<code>size_t</code> 可能不一样。<code>size_t</code> 在 32 位系统上定义为<code>unsigned int</code>，也就是 32 位无符号整型。在64位系统上定义为<code>unsigned long</code> ，也就是 64 位无符号整形。<code>size_t</code>的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。</p><p>​ <code>size_t</code>在数组下标和内存管理函数之类的地方广泛使用。例如，<code>size_t</code>用做 <code>sizeof</code>操作符的返回值类型，同时也是很多函数的参数类型，包括 <code>malloc</code>和 <code>strlen</code>。</p><p>​ 在声明诸如字符数或者数组索引这样的长度变量时用 <code>size_t</code>是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。<code>size_t</code>的声明是实现相关的。它出现在一个或多个标准头文件中，比如<code>stdio.h</code> 和 <code>stblib.h</code>，典型的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZE_T</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><p>​ <code>define</code>指令确保它只被定义一次。实际的长度取决于实现。通常在 32位系统上它的长度是 32 位，而在 64 位系统上则是 64位。一般来说，<code>size_t</code> 可能的最大值是<code>SIZE_MAX</code></p><p>​ 打印 <code>size_t</code>类型的值时要小心。这是无符号值，如果选错格式说明符，可能会得到不可靠的结果。推荐的格式说明符是<code>%zu</code>。不过，某些情况下不能用这个说明符， 作为替代，可以考虑<code>%u</code> 或 <code>%lu</code>。下面这个例子将一个变量定义为<code>size_t</code>，然后用两种不同的格式说明符来打印：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sizet = <span class="number">-5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet);</span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code>本来是用于表示正整数的，如果用来表示负数就会出问题。如果为其赋一个负数，然后用<code>%d</code> 和 <code>%zu</code> 格式说明符打印，就得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-5</span><br><span class="line">4294967291</span><br></pre></td></tr></table></figure><p>​ <code>%d</code> 把 <code>size_t</code> 当做有符号整数，它打印出-5。因为变量中存放的就是 -5。<code>%zu</code> 把 <code>size_t</code>当做无符号整数。当 -5 被解析为有符号数时，高位置为1，表示这个数是负数。当它被解析为无符号数时，高位的 1 被当做 2的乘幂。所以在用 <code>%zu</code> 格式说明符时才会看到那个大整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizet = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code> 是无符号的，一定要给这种类型的变量赋正数。</p><h2 id="ssize_t">ssize_t</h2><p><strong><code>ssize_t</code></strong> 和 <code>size_t</code>类似，但必需是<strong>signed</strong>（表示 <code>signed size_t</code>类型）， 用来表示可以被执行读写操作的数据块的大小。</p><h2 id="size_t-和-int-比较">size_t 和 int 比较</h2><ul><li><code>size_t</code>在32位架构中定义为：<code>typedef  unsigned int size_t</code></li><li><code>size_t</code>在64位架构中被定义为：<code>typedef  unsigned long size_t</code></li><li><code>size_t</code> 是无符号的，并且是平台无关的，表示 0 ~MAXINT的范围；<code>int</code> 为是有符号的；</li><li><code>int</code> 在不同架构上都是4字节，<code>size_t</code>在32位和64位架构上分别是 4 字节和 8字节，在不同架构上进行编译时需要注意这个问题。</li><li><strong><code>ssize_t</code></strong>是<strong>有符号</strong>整型，在32 位机器上等同与 <code>int</code>，在 64 位机器上等同与<code>long int</code>.</li></ul><h2id="c语言编程需要注意的64位和32机器的区别">C语言编程需要注意的64位和32机器的区别</h2><table><thead><tr class="header"><th></th><th>char</th><th>short</th><th>int</th><th>long</th><th>long long</th><th>指针</th></tr></thead><tbody><tr class="odd"><td>16 位 平台</td><td>1Byte</td><td>2Byte</td><td>2Byte</td><td>4Byte</td><td></td><td>2 Byte</td></tr><tr class="even"><td>32 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>4Byte</td><td>8Byte</td><td>4 Byte</td></tr><tr class="odd"><td>64 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>8Byte</td><td>8Byte</td><td>8Byte</td></tr></tbody></table><h2 id="编程注意事项">编程注意事项</h2><p>​ 为了保证平台的通用性，程序中尽量不要使用 <code>long</code>数据库型。可以使用固定大小的数据类型宏定义，这些宏定义需要引用<code>stdint.h</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __extension__</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="intptr_t">intptr_t</h2><p>​ 使用 <code>int</code> 时也可以使用 <code>intptr_t</code>来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台字长，比如64 位机器它的长度就是 8 字节，32位机器它的长度是4字节，使用它可以安全地进行整数与指针的转换运算，也就是说当需要将指针作为整数运算时，将它转换成<code>intptr_t</code> 进行运算才是安全的。<code>intptr_t</code>需要引用<code>stddef.h</code> 头文件，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​ 编程中要尽量使用 <code>sizeof</code>来计算数据类型的大小。以上类型定义都有相应的无符号类型。</p><h2 id="使用ssize_t和size_t">使用ssize_t和size_t</h2><p>​ 它们分别是 <code>unsigned</code> 和 <code>signed</code> size ofcomputer word size。它们也是表示<strong>计算机的字长</strong>，在 32位机器上是 <code>int</code>型，在64位机器上 <code>long</code>型。使用它们对于增加平台的通用性有很大好处，从某种意义上来说它们等同于<code>intptr_t</code> 和 <code>uintptr_t</code>。使用它们也需要引用<code>stddef.h</code> 头文件。</p><p>​ socket 的 <code>accept</code> 函数在有些操作系统上使用<code>size_t</code> 是不正确的，因为 <code>accept</code> 接收的<code>int</code> 类型，而size_t的长度可能会超过 <code>int*</code>的长度限制，导致错误。后来BSD使用 <code>sock_t</code> 来替代它。</p><blockquote><p>参考：</p><ul><li>https://blog.csdn.net/bzhxuexi/article/details/19899803</li><li>https://blog.csdn.net/qq_30866297/article/details/51465473</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;size_t&quot;&gt;size_t&lt;/h2&gt;
&lt;p&gt;​ &lt;strong&gt;&lt;code&gt;size_t&lt;/code&gt;&lt;/strong&gt; 是一些C/C++标准在
&lt;code&gt;stddef.h&lt;/code&gt; 中定义的，&lt;code&gt;size_t&lt;/code&gt; 类型表示 C
中任何对象所能达到的最大长度，它是无符号整数。&lt;/p&gt;
&lt;p&gt;​ 它是为了方便系统之间的移植而定义的，不同的系统上，定义
&lt;code&gt;size_t&lt;/code&gt; 可能不一样。&lt;code&gt;size_t&lt;/code&gt; 在 32 位系统上定义为
&lt;code&gt;unsigned int&lt;/code&gt;，也就是 32 位无符号整型。在64位系统上定义为
&lt;code&gt;unsigned long&lt;/code&gt; ，也就是 64 位无符号整形。&lt;code&gt;size_t&lt;/code&gt;
的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;size_t&lt;/code&gt;
在数组下标和内存管理函数之类的地方广泛使用。例如，&lt;code&gt;size_t&lt;/code&gt;
用做 &lt;code&gt;sizeof&lt;/code&gt;
操作符的返回值类型，同时也是很多函数的参数类型，包括 &lt;code&gt;malloc&lt;/code&gt;
和 &lt;code&gt;strlen&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;​ 在声明诸如字符数或者数组索引这样的长度变量时用 &lt;code&gt;size_t&lt;/code&gt;
是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。&lt;code&gt;size_t&lt;/code&gt;
的声明是实现相关的。它出现在一个或多个标准头文件中，比如
&lt;code&gt;stdio.h&lt;/code&gt; 和 &lt;code&gt;stblib.h&lt;/code&gt;，典型的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifndef&lt;/span&gt; __SIZE_T&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; __SIZE_T&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【数组模拟数据结构】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/29/[object%20Object]/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/29/[object%20Object]/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/</id>
    <published>2024-03-29T01:40:37.000Z</published>
    <updated>2024-04-01T07:11:58.437Z</updated>
    
    <content type="html"><![CDATA[<ul><li>以下<strong>数据结构</strong>都是采用<strong>数组</strong>模拟实现（而非 C++ STL容器），效率更高、支持更多操作</li></ul><h1 id="单链表">单链表</h1><h2 id="模板">模板</h2><ul><li><font color='red'><strong>空指针用 -1 表示</strong></font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7966770/">AcWing826. 单链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数 x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 x 插到下标是 k 的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是 k 的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="双链表">双链表</h1><ul><li>双链表实现中：0 号节点表示头节点，1 号节点表示尾节点</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7968200/">AcWing827. 双链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// l[i] 表示节点i的左指针</span></span><br><span class="line"><span class="comment">// r[i] 表示节点i的右指针是多少</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在节点 k 的右边插入一个数 x */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在节点 k 的左边插入一个数 x，则调用insert(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除节点 k */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈">栈</h1><h2 id="模板-1">模板</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7970372/">AcWing828. 模拟栈 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶元素下标</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt;= 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8210610/">AcWing3302. 表达式求值 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/decode-string/">394.字符串解码 - 力扣（LeetCode）</a></p></li></ul><h1 id="队列">队列</h1><h2 id="普通队列">普通队列</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7971050/">AcWing829. 模拟队列 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈">单调栈</h1><h2 id="模板-2">模板</h2><ul><li>找出每个数左边离它最近的比它<strong>小</strong>的数——维护递<strong>增</strong>栈</li><li>找出每个数左边离它最近的比它<strong>大</strong>的数——维护递<strong>减</strong>栈</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i))</span><br><span class="line">        tt--;</span><br><span class="line">    stk[++tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7971357/">AcWing830. 单调栈 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/daily-temperatures/description/">739.每日温度 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/min-stack/description/">155. 最小栈 -力扣（LeetCode）</a></p></li></ul><h1 id="单调队列">单调队列</h1><h2 id="模板-3">模板</h2><p>常见模型：找出<strong>滑动窗口</strong>中的<strong>最大值/最小值</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181602001.png"alt="image-20240307130347476" /><figcaption aria-hidden="true">image-20240307130347476</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) <span class="comment">// 维持单调队列</span></span><br><span class="line">        tt--;</span><br><span class="line">    q[++tt] = i;                         <span class="comment">// 将数据加入队尾</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">        hh++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color ='red'><strong>单调栈/单调队列总结</strong></font></p><ul><li>先考虑用普通 栈/队列 暴力模拟</li><li>再将普通 栈/队列中没有用的元素删除，看一下<strong>剩下的元素是否有单调性</strong>——单调栈/单调队列</li><li>考虑优化（队头最小/队尾最大/二分查找…）</li></ul><h2 id="例题-2">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7971364/">AcWing154. 滑动窗口 - AcWing</a></li></ul><h1 id="kmp">KMP</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849900.png"alt="image-20240307143945027" /><figcaption aria-hidden="true">image-20240307143945027</figcaption></figure><ol type="1"><li>若匹配成功，返回<strong>模式串T</strong>在<strong>目标串S</strong>中<strong><font color='red'>首次出现的有效位移</font></strong></li><li>若匹配失败，返回1</li></ol><!--more--><p>注意：</p><ul><li>主串 <code>S[]</code> 、模式串 <code>P[]</code>、<code>next[]</code> 均从下标 1 开始存储</li><li>每次 <code>S[i]</code> 与 <code>P[j + 1]</code> 比较<ul><li>当 <code>S[i] == P[j + 1]</code> 时，<code>i++, j++;</code></li><li>当 <code>S[i] != P[j + 1]</code> 时，<code>j = next[j];</code></li></ul></li><li><code>i</code>一直往前走，不会后退</li><li><code>j</code> 在 <code>S[i]</code> 与 <code>P[j + 1]</code>不匹配时会向后退，退到 <code>next[j]</code> 处</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849828.png"alt="a8e37396968a427a0efaffde2c68e78" /><figcaptionaria-hidden="true">a8e37396968a427a0efaffde2c68e78</figcaption></figure><ul><li><code>next[i]</code> 表示 <code>P[1…i]</code>最大前缀与后缀相等的长度（一定小于<code>i</code>，不能自己与自己相等~）</li><li><code>next[]</code>是通过模板串<strong>自己与自己匹配</strong>操作得出来的（代码和匹配操作几乎一样）<ul><li>next[0]=next[1]=0</li><li>由于是从 <code>i =2</code> 开始求<code>next[]</code>，所以：<ul><li>不可能匹配成功（不需要<code>j == m</code>的判断）</li><li><code>j &lt; i</code>，回退时 <code>next[j]</code> 一定存在</li></ul></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849565.jpeg"alt="3ff244326727713da33759bd2784289" /><figcaptionaria-hidden="true">3ff244326727713da33759bd2784289</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7973749/">AcWing831. KMP字符串 - AcWing</a>】</li><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n)\)</span>，<spanclass="math inline">\(n\)</span> 为长文本主串的长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本</span></span><br><span class="line"><span class="comment">// p[]是模式串</span></span><br><span class="line"><span class="comment">// n 是 s 的长度</span></span><br><span class="line"><span class="comment">// m 是 p 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求模式串的Next数组：*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到0处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 此时 j 的长度即为 next[i] 最大前缀与后缀相等的长度</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配过程 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到0处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 j 移动到下一次比较的位置</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">/* 匹配成功后的逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><h1 id="trie树">Trie树</h1><h2 id="模板-4">模板</h2><p>​<strong>Trie</strong>：高效地<strong>存储</strong>和<strong>查找</strong>字符串/二进制数 集合的数据结构</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403071732565.png"alt="image-20240307173227428" /><figcaption aria-hidden="true">image-20240307173227428</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点下标</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入一个字符串 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++idx;<span class="comment">// 不能是 idx++，因为son[0][]存放的是根节点，从下标 1 开始存储</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询字符串出现的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-3">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7975276/">AcWing835. Trie字符串统计 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8217089/">AcWing143. 最大异或对 - AcWing</a></li></ul><h1 id="并查集">并查集</h1><h2 id="模板-5">模板</h2><p><strong>作用</strong></p><ol type="1"><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><p><strong>基本原理：</strong></p><p>​每个集合用一棵树来表示。<strong>树根</strong>的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code>表示 <code>x</code> 的父节点</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081538288.png"alt="image-20240308153805104" /><figcaption aria-hidden="true">image-20240308153805104</figcaption></figure><h3 id="朴素并查集">朴素并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集是可以用来维护很多额外信息的，如集合大小cnt，到祖宗节点距离 d等等</p></blockquote><h3 id="维护-cnt-的并查集">维护 cnt 的并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// cnt[]只对祖宗节点有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    cnt[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护到祖宗节点距离-d-的并查集">维护到祖宗节点距离 d的并查集</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181631186.jpeg"alt="JIE.jpg" /><figcaption aria-hidden="true">JIE.jpg</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// d[x]存储 x 到 p[x] 的距离</span></span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];<span class="comment">// d[x]存储 x 到 p[x] 的距离，</span></span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-4">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7986586/">AcWing836. 合并集合 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7986712/">AcWing837. 连通块中点的数量 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7987057/">AcWing240. 食物链 - AcWing</a></li></ul><h1 id="堆">堆</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036286.png"alt="image-20230916123313335" /><figcaption aria-hidden="true">image-20230916123313335</figcaption></figure><p><strong>堆的特性：</strong></p><ul><li>结构性：==采用<strong><font color='blue'>数组存储</font></strong>的<strong><font color='red'>完全二叉树</font></strong>==<ul><li>从<font color='red'><code>h[1]</code>开始存储数据</font>，<code>h[0]</code>用来存放==<strong>哨兵</strong>==</li><li><code>i</code> 的左儿子 <code>2 * i</code>，右儿子<code>2 * i + 1</code></li></ul></li><li>有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)<ul><li>“<strong>最大堆(MaxHeap)</strong>”，也称“<strong>大顶堆</strong>”：任一结点的<code>data</code>大于其所有子树结点的<code>data</code></li><li>“<strong>最小堆(MinHeap)</strong>”，也称“<strong>小顶堆</strong>”：任一结点的<code>data</code>小于其所有子树结点的<code>data</code></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036053.png"alt="image-20230916123453824" /><figcaption aria-hidden="true">image-20230916123453824</figcaption></figure><p><strong>堆的实现：</strong></p><ul><li><p>使用数组来模拟堆，堆中的数据从 <code>h[1]</code> 开始存储</p><blockquote><p>因为如果从0开始存储，根节点0按照公式计算得到的左右节点都是0，显然不成了，需要特判，麻烦</p></blockquote></li><li><p>所有关于堆的操作均建立在堆的 <code>down()</code> 和<code>up()</code> 函数基础上</p></li></ul><h2 id="模板1">模板1</h2><p>​ 如果只希望实现与C++ STL堆中相同的功能1、2、3，则堆的下滤和上滤操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>down() 注意：</p><ol type="1"><li>down 操作需要保证左右儿子是堆</li><li>t 是根节点 <code>h[u]</code>, 左儿子 <code>h[2 * u]</code>, 右儿子<code>h[2 * u + 1]</code>中最小值的下标</li><li><code>2 * u &lt;= cnt</code>说明存在左儿子，<code>2 * u + 1 &lt;= cnt</code> 说明存在右儿子</li></ol><p>up() 注意：</p><ol type="1"><li><code>u / 2 != 0</code> 说明存在父节点</li></ol></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[++cnt]=x;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>] = h[cnt--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="模板2">模板2</h2><p>​ 如果希望实现在 C++ STL堆中功能的基础上，添加在任意位置修改/删除的功能，需要存储映射：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036897.png" alt="image-20240308101556244" style="zoom:15%;" /></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036983.jpeg" alt="b9b669b4a3a28e34e104b0c5bda7d7c" style="zoom:13%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的下标p:pointer</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的h:heap</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="comment">// m是当前堆中插入操作的次数</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换 h[] 中的两个点，及其映射关系 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>p:pointer</li><li>h:heap</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt++, m++;</span><br><span class="line">h[cnt] = x, hp[cnt] = m, ph[m] = cnt;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt--);</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除第 k 个插入的数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line"><span class="built_in">heap_swap</span>(k, cnt--);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改第 k 个插入的数,将其变为 x</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><blockquote><p>修改后的值与原来值相比，有3种情况</p><ul><li>相等：不需要调整堆</li><li>小于：up(k)</li><li>大于：down(k)</li></ul><p>把上面 3 种情况综合考虑，不管是相等/大于/小于，为了简单起见:</p><ul><li>如果修改h[1]：down(1)</li><li>在最后插入数据：up(++size)</li><li>如果修改其他： up(k); down(k)</li></ul><p>【实际运行时要么都不执行，要么只 up(k) ，要么只 down(k) 】</p></blockquote><ol start="6" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="例题-5">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7979479/">AcWing838. 堆排序 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7983190/">AcWing839. 模拟堆 - AcWing</a></li></ul><h1 id="哈希表">哈希表</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081905012.png" alt="image-20240308190529753" style="zoom: 25%;" /></p><ul><li>离散化是一种<strong>极其特殊</strong>的哈希方式（数据有序排列）</li><li>在算法题中，通常在哈希表 查找/添加 元素，而不会 删除 元素</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081918152.png"alt="image-20240308191829923" /><figcaption aria-hidden="true">image-20240308191829923</figcaption></figure><h2 id="一般哈希">一般哈希</h2><h3 id="拉链法">拉链法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x,ne[idx] = h[k],h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这里的 N 通常取质数eg：100003</li></ul></blockquote><h3 id="开放寻址法">开放寻址法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span> (t == N)</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希">字符串哈希</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403082108366.png" alt="image-20240308210833057" style="zoom: 50%;" /></p><ul><li><strong>核心思想</strong>：将字符串（注意不能把某个字符映射成0）看成 P 进制数， P 的经验值是 131 或13331，取这两个值的冲突概率低</li><li><strong>小技巧</strong>：取模的数Q用 <spanclass="math inline">\(2^{64}\)</span>​，这样直接用<code>unsigned long long</code>存储，溢出的结果就是取模的结果</li><li><strong>注意</strong>：字符串哈希非常有用的利器，是KMP的劲敌，字符串哈希除了循环节不能处理，其他均可代替KMP</li><li><code>str[]</code> 从下标 1 开始存储</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">// h[k]存储字符串前k个字母 str[1 ~ k] 的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 h[ ], p[ ]</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结</p><ol type="1"><li>把字符串看成是一个 P 进制数，每个字符的 ASCII 码对应数的一位</li><li>ASCII 范围 0 - 127，最少 128 进制，经验上取 131 或 13331冲突率低</li><li>字符串很长，对应的数太大，通过模 <spanclass="math inline">\(2^{64}\)</span> 把它映射到 <spanclass="math inline">\([0, 2^{64} - 1]\)</span></li><li>用 <code>unsigned long long</code> 存储，溢出相当于对 <spanclass="math inline">\(2^{64}\)</span> 取模，省略了手动运算</li><li>该方法的好处是，可以利用前缀哈希直接求出子串哈希（减去高位）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(DEF) = <span class="built_in">hash</span>(ABCDEF) - <span class="built_in">hash</span>(ABC) x P^<span class="number">3</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">    A       B       C       D       E       F  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">5</span> + <span class="number">2</span>xP^<span class="number">4</span> + <span class="number">3</span>xP^<span class="number">3</span> + <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                            D       E       F</span><br><span class="line">                          <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    A       B       C  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">2</span> + <span class="number">2</span>xP^<span class="number">1</span> + <span class="number">3</span>xP^<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意点</p><ol type="1"><li><strong>不要把某一位映射成 P 进制 0</strong>，例如，A 如果是 0，则AA 也是 0，就会出现冲突</li><li><code>\0</code> 的 ASCII 是 0，本题不出现该字符，不用担心上一点</li><li>使用这种方法就假定了人品足够好，不出现冲突</li></ol><h2 id="例题-6">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7988981/">AcWing840. 模拟散列表 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7992616/">AcWing841. 字符串哈希 - AcWing</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;以下&lt;strong&gt;数据结构&lt;/strong&gt;
都是采用&lt;strong&gt;数组&lt;/strong&gt;模拟实现（而非 C++ STL
容器），效率更高、支持更多操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;单链表&quot;&gt;单链表&lt;/h1&gt;
&lt;h2 id=&quot;模板&quot;&gt;模板&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#39;red&#39;&gt;&lt;strong&gt;空指针用 -1 表示&lt;/strong&gt;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;【&lt;strong&gt;模板题：&lt;/strong&gt;&lt;a
href=&quot;https://www.acwing.com/activity/content/code/content/7966770/&quot;&gt;AcWing
826. 单链表 - AcWing&lt;/a&gt;】&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; N = &lt;span class=&quot;number&quot;&gt;100005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// head 表示头结点的下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// e[i] 表示节点i的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ne[i] 表示节点i的next指针是多少&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// idx 存储当前已经用到了哪个点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; head, e[N], ne[N], idx;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    idx = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在链表头插入一个数 x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert_to_head&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e[idx] = x, ne[idx] = head, head = idx++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将 x 插到下标是 k 的点后面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; k, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将头结点删除，需要保证头结点存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove_head&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head = ne[head];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将下标是 k 的点后面的点删掉&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ne[k] = ne[ne[k]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://cuiluyi.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/</id>
    <published>2024-03-24T17:02:27.000Z</published>
    <updated>2024-03-31T11:16:37.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><h2 id="概念了解">概念【了解】</h2><ol type="1"><li><p><strong>动态规划：</strong>将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解</p><ul><li>动态规划会将每个求解过的子问题的解记录下来，这样下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算</li><li>采用<strong>递归</strong>（又叫<strong>记忆化搜索</strong>）实现</li></ul></li><li><p><strong>重叠子问题：</strong>如果<strong>一个问题可以被分解成若干个子问题</strong>，且这些子问题会重复出现，就称这个问题拥有重叠子问题。一个问题必须拥有重叠子问题，才能用动态规划去解决。</p></li><li><p><strong>最优子结构：</strong>如果<strong>一个问题的最优解可以由其子问题的最优解有效地构造出来</strong>，那么称为这个问题拥有的最优子结构。最优子结构保证了动态规划中的原问题的最优解可以由子问题的最优解推导而来</p></li><li><p><strong>动态规划</strong> vs<strong>分治：</strong>都是分解为子问题然后合并子问题得到解，但是：</p><ul><li>动态规划分解出的子问题是重叠的</li><li>分治分解出的子问题是不重叠的</li></ul></li><li><p><strong>动态规划 vs 贪心：</strong>都有最优子结构，但是：</p><ul><li>贪心直接选择一个子问题去求解，会抛弃一些子问题，这种选择的正确性需要用归纳法证明</li><li>而动态规划会考虑所有的子问题，所以这种选择一定是正确的</li></ul></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png"alt="Snipaste_2019-09-13_17-06-58.png" /><figcaptionaria-hidden="true">Snipaste_2019-09-13_17-06-58.png</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403231407219.jpeg"alt="闫式dp.jpg" /><figcaption aria-hidden="true">闫式dp.jpg</figcaption></figure><ol type="1"><li>集合划分原则</li></ol><ul><li><p>不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】</p></li><li><p>如何将现有的集合划分为更小的子集，使得<strong>所有子集</strong>都可以计算出来</p></li></ul><ol start="2" type="1"><li>下标从 0 开始递归还是下标从 1开始递归？</li></ol><ul><li>如果涉及到 <code>f[i-1]</code>，建议下标从 1开始递归，<code>f[0]</code>存储初始值</li><li>否则下标从 0 开始递归</li></ul><ol start="3" type="1"><li>考虑状态函数初始化</li></ol><ul><li>你看看在for遍历的时候需要用到的但是你事先没有的（往往就是下标0）就要预处理</li><li>如果要找min的话别忘了INF，要找有负数的max的话别忘了-INF</li></ul><h2 id="背包问题">背包问题</h2><ul><li>0/1 背包：每种物品只有 1 个</li><li>完全背包：每种物品有无限个</li><li>多重背包：每种物品有 <span class="math inline">\(S_i\)</span>个</li><li>分组背包：有 N 组物品，每一组中有 若干个 物品</li></ul><p>标记</p><ul><li>N：物品种数</li><li>V：背包容量</li><li>S：物品数量</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081245014.png"alt="image-20240308124413525" /><figcaption aria-hidden="true">image-20240308124413525</figcaption></figure><span id="more"></span><h3 id="背包">0/1 背包</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8133547/">AcWing2. 01背包问题 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&amp;envId=top-100-liked">279.完全平方数 - 力扣（LeetCode）</a></p></li></ul><h3 id="完全背包问题">完全背包问题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8134352/">AcWing3. 完全背包问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8229758/">AcWing4700. 何以包邮？ - AcWing</a></p></li></ul><h3 id="多重背包">多重背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8140913/">AcWing4. 多重背包问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8141818/">AcWing5. 多重背包问题 II - AcWing</a></li></ul><h3 id="分组背包">分组背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8144220/">AcWing9. 分组背包问题 - AcWing</a></li></ul><h3 id="找零钱">找零钱</h3><ul><li><a href="https://leetcode.cn/problems/coin-change/description/">322.零钱兑换 - 力扣（LeetCode）</a></li></ul><h2 id="线性dp">线性DP</h2><p>线性DP指的是<strong>状态转移方程</strong>存在某种线性关系</p><h3 id="数字三角形">数字三角形</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8147866/">AcWing898. 数字三角形 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/pascals-triangle/description/">118.杨辉三角 - 力扣（LeetCode）</a></p></li></ul><h3 id="编辑距离">编辑距离</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8161653/">AcWing902. 最短编辑距离 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8178931/">AcWing899. 编辑距离 - AcWing</a></li></ul><h3 id="最长上升子序列">最长上升子序列</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8155307/">AcWing895. 最长上升子序列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8159736/">AcWing896. 最长上升子序列 II - AcWing</a></p></li></ul><h3 id="最长公共子序列lcs">最长公共子序列（LCS）</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8155566/">AcWing897. 最长公共子序列 - AcWing</a></li></ul><blockquote><p><strong>最长公共字串</strong>问题——参考KMP</p></blockquote><h3 id="乘积最大子数组">乘积最大子数组</h3><ul><li><ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">152.乘积最大子数组 - 力扣（LeetCode）</a></li></ul><h3 id="最大子列和">最大子列和</h3><h4 id="类型一">类型一</h4><p>​ 给定 <span class="math inline">\(N\)</span> 个整数的序列${A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ 0,_{k=i}^j{A_k} } $ 的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = 0;</code></p></blockquote><h4 id="类型二">类型二</h4><p>​ 给定 <span class="math inline">\(N\)</span> 个整数的序列${A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ _{k=i}^j{A_k} } $ 的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = -MAX_INT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = -MAX_INT;</code></p></blockquote><p>:package:一定是先更新<code>maxsum = max(maxsum, thissum);</code>，再判断是否重新<code>thissum = 0;</code></p><h3 id="其他">其他</h3><h2 id="区间dp">区间DP</h2><h3 id="模板">模板</h3><ul><li><p>区间 DP的状态<code>f[i][j]</code>是一个<strong>区间</strong></p></li><li><p>区间 DP要注意<strong>循环的先后顺序</strong>，否则可能会出现当前要计算的状态值并未在先前循环计算过，通常按照以下顺序进行循环</p><ol type="1"><li><strong>从小到大</strong>枚举<strong>区间长度</strong><ol type="1"><li>一般 len = 1 时用来初始化</li><li>枚举从 len = 2 开始</li></ol></li><li>枚举<strong>区间左端点</strong></li><li>枚举决策</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = 初始值</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8157696/">AcWing282. 石子合并 - AcWing</a></li></ul><h2 id="计数dp">计数DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8179224/">AcWing900. 整数划分 - AcWing</a></li></ul><h2 id="数位统计dp">数位统计DP</h2><h2 id="状态压缩dp">状态压缩DP</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8182668/">AcWing291. 蒙德里安的梦想 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8228208/">AcWing91. 最短Hamilton路径 - AcWing</a></p></li></ul><h2 id="树形dp">树形DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8190672/">AcWing285. 没有上司的舞会 - AcWing</a></li></ul><h2 id="记忆化搜索">记忆化搜索</h2><ul><li><ahref="https://www.acwing.com/activity/content/problem/content/1013/">AcWing901. 滑雪 - AcWing</a></li></ul><h1 id="单维dp">单维DP</h1><h2 id="爬楼梯"><ahref="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h2><p>​ 假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬<code>1</code> 或 <code>2</code>个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h3 id="递归">递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>递归会超时</p></blockquote><h3 id="迭代">迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 方式1 */</span></span><br><span class="line">        <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/* 方式2 */</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; a(n + 1);</span></span><br><span class="line"></span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>以空间换时间</p><p>方式2 容器 更耗时</p></blockquote><h2 id="打家劫舍"><ahref="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2><p>​你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>​ 给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p><ahref="https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap">图解动态规划——打家劫舍</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* n&gt;=2 */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词拆分"><ahref="https://leetcode.cn/problems/word-break/">单词拆分</a></h2><p>​ 给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>则返回<code>true</code>。<strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>dp[i]：前 i 个字符s[0…i-1]能否被字典中的单词拼接</li><li><span class="math inline">\(dp[i]=dp[j] \&amp;\&amp;check(s[j…i-1])\)</span>​</li></ul><p><ahref="https://www.bilibili.com/video/BV1mt4y1s7H1/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】139. 单词拆分 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt; &amp;wordDict)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; <span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>(), s.<span class="built_in">substr</span>(j, i - j)) != wordDict.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="多维dp">多维DP</h1><h2 id="不同路径"><ahref="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><p>​ 一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041400223.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><ul><li><strong>方式1：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>方式2：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>方式3：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最小路径和"><ahref="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h2><p>​ 给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code>，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;动态规划&lt;/h1&gt;
&lt;h2 id=&quot;概念了解&quot;&gt;概念【了解】&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划：&lt;/strong&gt;将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态规划会将每个求解过的子问题的解记录下来，这样下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;递归&lt;/strong&gt;（又叫&lt;strong&gt;记忆化搜索&lt;/strong&gt;）实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;重叠子问题：&lt;/strong&gt;如果&lt;strong&gt;一个问题可以被分解成若干个子问题&lt;/strong&gt;，且这些子问题会重复出现，就称这个问题拥有重叠子问题。
一个问题必须拥有重叠子问题，才能用动态规划去解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;最优子结构：&lt;/strong&gt;如果&lt;strong&gt;一个问题的最优解可以由其子问题的最优解有效地构造出来&lt;/strong&gt;，那么称为这个问题拥有的最优子结构。最优子结构保证了动态规划中的原问题的最优解可以由子问题的最优解推导而来&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt; vs
&lt;strong&gt;分治：&lt;/strong&gt;都是分解为子问题然后合并子问题得到解，但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态规划分解出的子问题是重叠的&lt;/li&gt;
&lt;li&gt;分治分解出的子问题是不重叠的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划 vs 贪心：&lt;/strong&gt;都有最优子结构，但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贪心直接选择一个子问题去求解，会抛弃一些子问题，这种选择的正确性需要用归纳法证明&lt;/li&gt;
&lt;li&gt;而动态规划会考虑所有的子问题，所以这种选择一定是正确的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png&quot;
alt=&quot;Snipaste_2019-09-13_17-06-58.png&quot; /&gt;
&lt;figcaption
aria-hidden=&quot;true&quot;&gt;Snipaste_2019-09-13_17-06-58.png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403231407219.jpeg&quot;
alt=&quot;闫式dp.jpg&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;闫式dp.jpg&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;集合划分原则&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何将现有的集合划分为更小的子集，使得&lt;strong&gt;所有子集&lt;/strong&gt;都可以计算出来&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot; type=&quot;1&quot;&gt;
&lt;li&gt;下标从 0 开始递归还是下标从 1开始递归？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果涉及到 &lt;code&gt;f[i-1]&lt;/code&gt;，建议下标从 1
开始递归，&lt;code&gt;f[0]&lt;/code&gt;存储初始值&lt;/li&gt;
&lt;li&gt;否则下标从 0 开始递归&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;考虑状态函数初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;你看看在for遍历的时候需要用到的但是你事先没有的（往往就是下标0）就要预处理&lt;/li&gt;
&lt;li&gt;如果要找min的话别忘了INF，要找有负数的max的话别忘了-INF&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;背包问题&quot;&gt;背包问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;0/1 背包：每种物品只有 1 个&lt;/li&gt;
&lt;li&gt;完全背包：每种物品有无限个&lt;/li&gt;
&lt;li&gt;多重背包：每种物品有 &lt;span class=&quot;math inline&quot;&gt;&#92;(S_i&#92;)&lt;/span&gt;
个&lt;/li&gt;
&lt;li&gt;分组背包：有 N 组物品，每一组中有 若干个 物品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标记&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N：物品种数&lt;/li&gt;
&lt;li&gt;V：背包容量&lt;/li&gt;
&lt;li&gt;S：物品数量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081245014.png&quot;
alt=&quot;image-20240308124413525&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20240308124413525&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>时空复杂度分析</title>
    <link href="https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/others/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/others/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2024-03-17T06:33:49.000Z</published>
    <updated>2024-03-30T13:50:16.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度分析">时间复杂度分析</h1><ul><li><p><strong>C++ 1s 的运行数量大概在 <spanclass="math inline">\(10^7\)</span> ~ <spanclass="math inline">\(10^8\)</span></strong></p></li><li><p>一般ACM或者笔试题的<strong>时间限制</strong>是<strong>1秒</strong>或<strong>2秒</strong>，在这种情况下，C++代码中的操作次数控制在<span class="math inline">\(10^7\)</span>​~ <spanclass="math inline">\(10^8\)</span>​ 为最佳</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403302109655.png"alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress" /><figcaptionaria-hidden="true">aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress</figcaption></figure><ul><li>【由<strong>数据范围</strong>反推<strong>算法复杂度</strong>以及<strong>算法内容</strong>】下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</li></ul><ol type="1"><li><span class="math inline">\(n \leqslant 30\)</span> =&gt;指数级别：dfs+剪枝、状态压缩 dp</li><li><span class="math inline">\(n \leqslant 10^2\)</span> =&gt; <spanclass="math inline">\(O(n^3)\)</span>：floyd、dp、高斯消元</li><li><span class="math inline">\(n \leqslant 10^3\)</span> =&gt; <spanclass="math inline">\(O(n^2)\)</span>、<spanclass="math inline">\(O(n^2logn)\)</span>：dp、二分、朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li><span class="math inline">\(n \leqslant 10^4\)</span> =&gt; <spanclass="math inline">\(O(n\sqrt{n})\)</span>：块状链表、分块、莫队</li><li><span class="math inline">\(n \leqslant 10^5\)</span> =&gt; <spanclass="math inline">\(O(nlogn)\)</span>：各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li><span class="math inline">\(n \leqslant 10^6\)</span>​<ol type="1"><li><span class="math inline">\(O(n)\)</span>​​：单调队列、hash、双指针扫描、BFS、并查集、kmp、AC自动机</li><li>常数比较小的 <span class="math inline">\(O(nlogn)\)</span>​算法：sort、树状数组、heap、dijkstra、spfa</li></ol></li><li><span class="math inline">\(n \leqslant 10^7\)</span>​ =&gt;O(n)：双指针扫描、kmp、AC自动机、线性筛素数</li><li><span class="math inline">\(n \leqslant 10^9\)</span>​ =&gt; <spanclass="math inline">\(O(\sqrt{n})\)</span>​：判断质数</li><li><span class="math inline">\(n \leqslant 10^{18}\)</span>​ =&gt; <spanclass="math inline">\(O(logn)\)</span>​：最大公约数、快速幂、数位DP</li><li><span class="math inline">\(n \leqslant 10^{1000}\)</span> =&gt;<span class="math inline">\(O((logn)^2)\)</span>：高精度加减乘除</li><li><span class="math inline">\(n \leqslant 10^{100000}\)</span> =&gt;<span class="math inline">\(O(logk *loglogk)\)</span>，k表示位数：高精度加减、FFT/NTT</li></ol><span id="more"></span><h1 id="空间复杂度">空间复杂度</h1><h2 id="单位换算">单位换算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> KB= <span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> MB=<span class="number">1024</span>*<span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> Byte</span><br></pre></td></tr></table></figure><h2 id="数据类型空间大小">数据类型空间大小</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="number">4</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>, <span class="type">long</span> <span class="type">long</span>   <span class="number">6B</span>yte</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line">*指针 <span class="number">32</span>位系统 <span class="number">4B</span><span class="number">64</span>位系统 <span class="number">8B</span></span><br></pre></td></tr></table></figure><h2 id="空间分析">空间分析</h2><ul><li>一般 ACM或者笔试题的<strong>空间限制</strong>是<strong>64MB</strong>，最多只能使用<span class="math inline">\(1.6*10^7\)</span>个<code>int</code>类型变量</li></ul><p><span class="math display">\[64MB=2^{26}Byte=2^{24} int =1.6*10^7 int\]</span></p><ul><li>分析时要注意，计算全局<strong>变量</strong>的空间复杂度要看<strong>实际运行时会用到的空间</strong>，而不是总空间，因为全局变量在未被使用时分配的是<strong>虚拟内存</strong></li><li>当代码里有<strong>递归</strong>函数或需要<strong>大量调用函数</strong>时，需要调用系统栈，因此分析空间复杂度还要加上<strong>栈空间</strong><ul><li>快速排序：需要递归 <span class="math inline">\(log\ n\)</span>​层，因此空间复杂度是 <span class="math inline">\(O(log n)\)</span></li><li>归并排序：而归并排序在递归时每一层还需要开一个长度为 <spanclass="math inline">\(n\)</span> 的数组，因此空间复杂度是 <spanclass="math inline">\(O(nlog\ n)\)</span></li></ul></li></ul><h2 id="实例">实例</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261751495.png"alt="image-20240326175147312" /><figcaption aria-hidden="true">image-20240326175147312</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;时间复杂度分析&quot;&gt;时间复杂度分析&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;C++ 1s 的运行数量大概在 &lt;span
class=&quot;math inline&quot;&gt;&#92;(10^7&#92;)&lt;/span&gt; ~ &lt;span
class=&quot;math inline&quot;&gt;&#92;(10^8&#92;)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一般ACM或者笔试题的&lt;strong&gt;时间限制&lt;/strong&gt;是&lt;strong&gt;1秒&lt;/strong&gt;或&lt;strong&gt;2秒&lt;/strong&gt;，在这种情况下，C++代码中的操作次数控制在
&lt;span class=&quot;math inline&quot;&gt;&#92;(10^7&#92;)&lt;/span&gt;​~ &lt;span
class=&quot;math inline&quot;&gt;&#92;(10^8&#92;)&lt;/span&gt;​ 为最佳&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403302109655.png&quot;
alt=&quot;aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress&quot; /&gt;
&lt;figcaption
aria-hidden=&quot;true&quot;&gt;aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;【由&lt;strong&gt;数据范围&lt;/strong&gt;反推&lt;strong&gt;算法复杂度&lt;/strong&gt;以及&lt;strong&gt;算法内容&lt;/strong&gt;】下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 30&#92;)&lt;/span&gt; =&amp;gt;
指数级别：dfs+剪枝、状态压缩 dp&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^2&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n^3)&#92;)&lt;/span&gt;：floyd、dp、高斯消元&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^3&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n^2)&#92;)&lt;/span&gt;、&lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n^2logn)&#92;)&lt;/span&gt;：dp、二分、朴素版Dijkstra、朴素版Prim、Bellman-Ford&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^4&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n&#92;sqrt{n})&#92;)&lt;/span&gt;：块状链表、分块、莫队&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^5&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(nlogn)&#92;)&lt;/span&gt;：各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^6&#92;)&lt;/span&gt;​
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(O(n)&#92;)&lt;/span&gt;​​：单调队列、
hash、双指针扫描、BFS、并查集、kmp、AC自动机&lt;/li&gt;
&lt;li&gt;常数比较小的 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(nlogn)&#92;)&lt;/span&gt;​
算法：sort、树状数组、heap、dijkstra、spfa&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^7&#92;)&lt;/span&gt;​ =&amp;gt;
O(n)：双指针扫描、kmp、AC自动机、线性筛素数&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^9&#92;)&lt;/span&gt;​ =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(&#92;sqrt{n})&#92;)&lt;/span&gt;​：判断质数&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^{18}&#92;)&lt;/span&gt;​ =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(logn)&#92;)&lt;/span&gt;​：最大公约数、快速幂、数位DP&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^{1000}&#92;)&lt;/span&gt; =&amp;gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(O((logn)^2)&#92;)&lt;/span&gt;：高精度加减乘除&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^{100000}&#92;)&lt;/span&gt; =&amp;gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(O(logk *
loglogk)&#92;)&lt;/span&gt;，k表示位数：高精度加减、FFT/NTT&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="others" scheme="https://cuiluyi.gitee.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>咖啡</title>
    <link href="https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/"/>
    <id>https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/</id>
    <published>2024-03-17T01:46:27.000Z</published>
    <updated>2024-03-19T07:03:18.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有关咖啡">有关咖啡</h1><h2id="咖啡因每日的安全使用量是多少">咖啡因每日的安全使用量是多少？</h2><p>一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。</p><span id="more"></span><h2id="雀巢咖啡伴侣是否含反式脂肪酸">雀巢咖啡伴侣是否含反式脂肪酸？</h2><p>在雀巢咖啡伴侣的包装上有明确的标识：反式脂肪酸为0克，所以您可以放心使用。</p><h2id="为什么咖啡伴侣的瓶子是棕色的">为什么咖啡伴侣的瓶子是棕色的？</h2><p>适量的咖啡因摄取对普通大多数的人都是安全的。可能会有一些人群对咖啡因较一般人敏感，与那些对咖啡因不太敏感的人相比，这类人群可能会对少量的咖啡感到不适。通常情况下，孕妇和老年人可能会相对更加敏感一些。</p><h2id="为什么咖啡伴侣的瓶子是棕色的-1">为什么咖啡伴侣的瓶子是棕色的？</h2><p>用棕色瓶子主要是为了避光，咖啡伴侣里某些营养成分是对光敏感的。我们为了在保质期内保证食品的安全和风味，采用了能避光的棕色玻璃瓶。</p><h2 id="喝咖啡对身体有害吗">喝咖啡对身体有害吗？</h2><p>咖啡是一种天然而且健康的饮料。咖啡中除含有咖啡因之外，它还含有对人体健康有利的多种生物活性物质和营养素，如抗氧化物质、矿物质、烟酸和内脂。咖啡能提高警觉性，让我们更有效地利用前额部的大脑皮层，提高注意力和记忆力。关于咖啡因，人们从古代的时候起就开始饮用咖啡类的饮品了。咖啡因是咖啡中的天然含有的成份。目前，人类在大约60种植物中发现了咖啡因，其中最为人知的便是茶和咖啡。而一些常见的食品，如巧克力、可乐中都含有少量咖啡因。</p><h2id="经常喝咖啡是否会导致人体内的钙流失">经常喝咖啡是否会导致人体内的钙流失?</h2><p>咖啡因对钙吸收的不良影响非常小，喝1-2勺牛奶就足以弥补了。所有证据显示，中量饮用咖啡不会改变对钙的消化吸收，不会增加尿钙排泄，也不会从大便中丢失。如果每日摄入咖啡超过1升，尿钙排泄和钙丢失就会增加，但将牛奶加到咖啡里面就可以解决这个问题。适量咖啡因摄入不会对骨代谢产生直接影响。（摘自《咖啡无罪的101个理由》）</p><h2 id="喝咖啡可以减肥吗">喝咖啡可以减肥吗？</h2><p>研究表明，适量喝咖啡有助于控制体重，咖啡中含有膳食纤维，有利于帮助肠道蠕动，促进代谢。如果您想要达到减肥的效果，我们建议您咨询专业的营养师。</p><h2 id="雀巢咖啡是如何诞生的">雀巢咖啡是如何诞生的？</h2><p>二十世纪三十年代，雀巢公司受巴西政府的委托，为其过剩的咖啡寻找保存方法。雀巢公司勇敢地接受了这一技术上的挑战，并于1938年成功开发出速溶咖啡生产工艺。采用该工艺，咖啡粉可以长久地保存而不失其香醇风味。从此，人们可以随时方便地享用美味咖啡。雀巢速溶咖啡便由此诞生了，雀巢咖啡(Nescafe)品牌名称就是由公司名称Nestlé及英文中代表咖啡的CAFE组成。</p><h2 id="咖啡中的12是什么意思">1+2咖啡中的1+2是什么意思？</h2><p>1+2咖啡中的1+2是指：1=咖啡，2=植脂末+糖</p><h2 id="每天在什么时间喝咖啡比较好">每天在什么时间喝咖啡比较好？</h2><p>建议白天饮用咖啡。如果想保持规律的生理周期，晚上不要饮用咖啡。</p><h2id="雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏">雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏？</h2><p>即饮咖啡产品冷热饮均可，如加热饮用，加热温度不宜超过55度，勿将瓶装产品放置于火上或微波炉中直接加热，以免发生危险。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;有关咖啡&quot;&gt;有关咖啡&lt;/h1&gt;
&lt;h2
id=&quot;咖啡因每日的安全使用量是多少&quot;&gt;咖啡因每日的安全使用量是多少？&lt;/h2&gt;
&lt;p&gt;一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:
研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://cuiluyi.gitee.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【数学知识】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/15/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/15/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/</id>
    <published>2024-03-15T02:27:16.000Z</published>
    <updated>2024-04-01T01:46:29.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学知识">数学知识</h1><p>:smile:<strong>数论</strong> 经常会出现 <strong>数的大小越界</strong>情况：</p><ul><li>尤其是在做<strong>乘法</strong>、其次是<strong>加法</strong>的时候非常容易溢出，此时可以使用<code>long long</code> 局部转换</li><li>比较稳妥的、一劳永逸的办法是<strong>变量类型</strong>不使用int，<strong>全部使用</strong> <code>long long</code></li></ul><h2 id="质数">质数</h2><ul><li><strong>质数</strong>：在大于 1 的整数中，如果只包含 1和本身这两个约数，就被成为质数，或者叫素数。</li><li><strong>算数基本定理</strong>：任一大于1的整数 <spanclass="math inline">\(n\)</span>​ 能够唯一地表示成</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_s}^{\alpha _s},  \alpha_i&gt;0,  i=1,2,\cdots ,s\left( * \right)\]</span></p><p>​ 分解式(*)叫做 的 n 的标准分解式</p><p>注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 n表成下面形式： <span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><span id="more"></span><h3 id="判定质数试除法">判定质数——试除法</h3><ul><li>一个数的因数都是成对出现的（例如 12 的因数有 3 和 4，2 和6）所以我们可以只枚举较小的那一个。假设较小的为 <spanclass="math inline">\(d\)</span>，较大的为 <spanclass="math inline">\(n/d\)</span>，则：</li></ul><p><span class="math display">\[d\leqslant \frac{n}{d}\Longrightarrow d\leqslant \sqrt{n}\]</span></p><ul><li>时间复杂度：<span class="math inline">\(O(\sqrt{n})\)</span>​</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8063046/">AcWing866. 试除法判定质数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="comment">// 注意是小于等于</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数试除法">分解质因数——试除法</h3><ul><li><strong>性质</strong>：整数 n 中最多只含有一个<strong>大于</strong>sqrt(n) 的<font color ='red'><strong>质因子</strong></font><ul><li>证明：通过反证法：如果有两个大于 sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</li><li>eg：6 的质因子 3 &gt; sqrt(6)</li></ul></li><li><strong>证明</strong>：循环里面的 <spanclass="math inline">\(i\)</span> 一定是一个质数:</li></ul><blockquote><p>假如 i是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是n 的质因子且比 i 要小，而比 i小的数在之前的循环过程中一定是被条件除完了的，所以 i不可能是合数，只可能是质数</p></blockquote><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8065120/">AcWing867. 分解质因数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 输出最后一个大于sqrt(n)的质数，注意这里的n可能已经被上面的代码更新过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eg：<span class="math inline">\(n = 96 = 2^5 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span> 且 <spanclass="math inline">\(3&gt;\sqrt{6}\)</span> ）</li><li>eg：<span class="math inline">\(n = 6 = 2 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span>）</li><li>eg：n=17，循环不会输出，直接跳到最后判断输出 17（<spanclass="math inline">\(17&gt;\sqrt{17}\)</span>）</li><li>eg：<spanclass="math inline">\(n=16=2^4\)</span>，循环输出后，直接跳到最后判断，不会输出（<spanclass="math inline">\(1=\sqrt{1}\)</span>）</li></ul><h3 id="求-1-n-中的所有素数">求 1 ~ n 中的所有素数</h3><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8068049/">AcWing868. 筛质数 - AcWing</a>】</p><h4 id="朴素筛法不用">朴素筛法（不用）</h4><ul><li><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span>​ <spanclass="math display">\[\frac{n}{2}+\frac{n}{3}+\cdots +\frac{n}{n}=n\left(\frac{1}{2}+\frac{1}{3}+\cdots +\frac{1}{n} \right) \approx n\log n\]</span></p></li><li><p>原理：任意<strong>整数</strong> x <spanclass="math inline">\((x&gt;1)\)</span>​ 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)<span class="comment">// 循环n/i次</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eratosthenes筛法不用">Eratosthenes筛法（不用）</h4><ul><li><p>时间复杂度：<spanclass="math inline">\(O(nloglogn)\)</span></p></li><li><p>原理：任意<font color='red'><strong>素数</strong></font> x <spanclass="math inline">\((x&gt;1)\)</span> 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="literal">true</span>;<span class="comment">// 可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法">线性筛法</h4><ul><li><p>朴素筛法和Eratosthenes筛法存在<strong>重复筛掉</strong>的情况（例如 12 既会被 2 筛掉，又会被 3筛掉：在标记 2 的倍数时，12 = 2 ∗ 6；在标记 3 的倍数时，12 = 3 ∗ 4）如何避免某个数被重复筛掉的情况呢？很简单，我们只需让 45只被它的最小质数（3）筛掉即可</p></li><li><p>原理：合数 x只会被其<font color='red'><strong>最小质因子</strong></font>筛掉一次</p></li><li><p>时间复杂度：<span class="math inline">\(O(n)\)</span>​</p></li></ul><p>第二层循环<code>st[primes[j] * i] = true;</code>只会对所有<strong>合数</strong>执行一次，所以时间复杂度为<span class="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为什么不需要写 j &lt; cnt？ */</span></span><br><span class="line">        <span class="comment">// 1.   primes 数组中存有 &lt;= i 的所有质数</span></span><br><span class="line">        <span class="comment">// 2.   当 i 是合数时, 肯定会在中间就 break 掉</span></span><br><span class="line">        <span class="comment">// 3.   当 i 是质数时, 那么 primes[cnt - 1] = i，因此 j == cnt - 1 时，break，依然不越界</span></span><br><span class="line">        <span class="comment">/* 为什么循环条件是primes[j] &lt;= n / i */</span></span><br><span class="line">        <span class="comment">// 1. 下面筛掉的数是 primes[j] * i</span></span><br><span class="line">        <span class="comment">// 2. 我们要求的是1~n之间的所有素数</span></span><br><span class="line">        <span class="comment">// 3. 当 primes[j] &gt; n / i，下面筛掉的数大于n，不符合我们的要求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">            <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">            <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">            <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">            <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">            <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>证明：</p><ul><li>合数 x 的最小质因子只有一个</li></ul><blockquote><p>显然成立</p></blockquote><ul><li>合数 x<font color='red'><strong>只会</strong></font>被其<font color='red'><strong>最小质因子</strong></font>筛掉<font color='blue'><strong>一次</strong></font></li></ul><blockquote><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">    <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">    <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">    st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">    <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">    <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">    <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">    <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>所有的合数一定会被筛掉</li></ul><blockquote><p>证明：对于合数 <span class="math inline">\(x\)</span>，假设 <spanclass="math inline">\(prime[k]\)</span> 是 <spanclass="math inline">\(x\)</span> 的最小质因子，当 <spanclass="math inline">\(i\)</span> 枚举到 <spanclass="math inline">\(x/primes[k]\)</span> 的时候，x一定会被 <spanclass="math inline">\(prime[k]\)</span> 筛掉（<spanclass="math inline">\(st[primes[k]*(x/primes[k])]=true\)</span>)</p></blockquote><p>因此，所有合数一定<strong>只</strong>会被<strong>最小质因子</strong><strong>筛掉一次</strong>，所以是线性的</p></li></ul><h2 id="约数">约数</h2><h3 id="求所有约数试除法">求所有约数——试除法</h3><ul><li><strong>原理</strong>：<ul><li>若 <span class="math inline">\(d|n\)</span>​，则 <spanclass="math inline">\(\frac{n}{d}|n\)</span>​. 所以一个数 n的约数肯定是成对存在的，对称轴是<spanclass="math inline">\(\sqrt{n}\)</span></li><li>因此只需要用 n 除以 1 到 <spanclass="math inline">\(\sqrt{n}\)</span>​之间的数，如果余数是0，则把<code>除数</code>、<code>n / 除数</code>加到答案中</li></ul></li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8068610/">AcWing869. 试除法求约数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != n / i)</span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><ul><li><strong>约束个数</strong>定理：任一大于 <spanclass="math inline">\(1\)</span> 的整数 <spanclass="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数的个数为 $( _1+1 )( _1+1 ) ( _k+1 ) $</p><ul><li><strong>证明</strong>：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150912687.png"alt="image-20240315091200551" /><figcaption aria-hidden="true">image-20240315091200551</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8070605/">AcWing870. 约数个数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            res *= (s + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约束之和">约束之和</h3><ul><li><strong>约束之和</strong>定理：任一大于 1 的整数 <spanclass="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数之和为 $(p_{1}<sup>{0}+p_{1}</sup>{1}++p_{1}<sup>{<em>1} ) (p</em>{2}</sup>{0}+p_{2}<sup>{1}++p_{2}</sup>{<em>2} ) (p</em>{k}<sup>{0}+p_{k}</sup>{1}++p_{k}^{_k} ) $</p><ul><li><strong>证明</strong>：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150917791.png"alt="image-20240315091535903" /><figcaption aria-hidden="true">image-20240315091535903</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071116/">AcWing871. 约数之和 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s = s * i + <span class="number">1</span>;</span><br><span class="line">            res *= s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><ul><li><strong>欧几里得算法</strong>：</li></ul><p><span class="math display">\[\begin{cases}    gcd\left( a,b \right) =gcd\left( b,a\%b \right)\\    gcd\left( a,0 \right) =a\\\end{cases}\]</span></p><ul><li><span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的最大公约数 <spanclass="math inline">\(gcd(a,b)\)</span> 被记作 <spanclass="math inline">\((a,b)\)</span>​</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071167/">AcWing872. 最大公约数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><h3 id="求欧拉函数-varphi-left-n-right">求欧拉函数 <spanclass="math inline">\(\varphi \left( n \right)\)</span></h3><ul><li><strong>定理</strong>：设正整数 <spanclass="math inline">\(n\)</span> 的标准分解式为：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span> ​ 则欧拉函数 <span class="math display">\[\varphi \left( n \right) =n\left( 1-\frac{1}{p_1} \right) \left(1-\frac{1}{p_2} \right) \cdots \left( 1-\frac{1}{p_k} \right)\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8072352/">AcWing873. 欧拉函数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求-1-n-中每个数的欧拉函数线性筛法">求 1 ~ n中每个数的欧拉函数——线性筛法</h3><ul><li>给定一个正整数 <span class="math inline">\(n\)</span> ，求 <spanclass="math inline">\(1\)</span> ∼ <spanclass="math inline">\(n\)</span>中<strong>每个数的</strong>欧拉函数</li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8073032/">AcWing874. 筛法求欧拉函数 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> eulers[N];       <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉(状态state)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eulers[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求素数 i 的欧拉函数 phi(i) = i - 1</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            eulers[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 求合数 t = primes[j] * i 的欧拉函数</span></span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 情况1：i % primes[j] == 0，此时 primes[j] 既是 i 的最小质因数，也是 t 的最小质因数，phi(t) = phi(primes[j]*i) = primes[j] * phi(i)</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                eulers[t] = primes[j] * eulers[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2：i % primes[j] != 0，此时 primes[j] 不是 i 的质因数（primes[j] &lt; i的最小质因数），但却是 t 的最小质因数，此时 (primes[j], 1) == 1，因此phi(t) = phi(primes[j] * i) = phi(primes[j]) * phi(i) = (primes[j] - 1) * phi(i)</span></span><br><span class="line">            eulers[t] = (primes[j] - <span class="number">1</span>) * eulers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><p>快速求出 <span class="math inline">\(a^b\,\,mod\,\,p\)</span>​</p><ul><li><strong>原理：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151618057.png"alt="04a91bf62e0bd92e3db3b3a73c76793" /><figcaptionaria-hidden="true">04a91bf62e0bd92e3db3b3a73c76793</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151619524.png"alt="bb9db9bc6547be4cfcf9dba7ac9190a" /><figcaptionaria-hidden="true">bb9db9bc6547be4cfcf9dba7ac9190a</figcaption></figure><blockquote><p>《算法进阶指南》P4</p></blockquote><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(logb)\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8074336/">AcWing875. 快速幂 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 特判：p == 1</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left. \begin{array}{r}    a^{2^0}=a^1\\    a^{2^1}=a^2\\    a^{2^2}=a^4\\    \cdots\\    a^{2^{k-1}}\\\end{array} \right\} \Rightarrow a^{2^i}=\left( a^{2^{i-1}} \right) ^2\]</span></p><h2 id="拓展欧几里得算法">拓展欧几里得算法</h2><ul><li><strong>Bezout(贝祖等式)</strong></li></ul><p>设 <strong><span class="math inline">\(a, b\)</span></strong>是任意两个正整数，则存在整数 <strong><span class="math inline">\(x,y\)</span></strong> 使得 <span class="math display">\[ax+by=\left( a,b \right)\]</span></p><ul><li>如何求解上述等式的解 <strong><span class="math inline">\(x,y\)</span></strong> ？</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151722173.png"alt="image-20240315172217936" /><figcaption aria-hidden="true">image-20240315172217936</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8074640/">AcWing877. 扩展欧几里得算法 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求逆">求逆</h2><ul><li><strong>定义</strong>：当 <span class="math inline">\(ax≡1 \ mod \p\)</span>, <span class="math inline">\(a^{-1}\)</span> <spanclass="math inline">\(mod\)</span> <spanclass="math inline">\(p\)</span> 称为 <spanclass="math inline">\(a∈{1,2,…,p-1}\)</span> 的乘法逆</li><li><strong>定理</strong>：当且仅当 <spanclass="math inline">\(gcd(a,p)=1, \ a^{-1} \ mod \ p\)</span>​ 存在</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8078478/">AcWing876. 求逆元 - AcWing</a>】</li></ul><h3 id="费马小定理求逆元">费马小定理——求逆元</h3><ul><li><p><strong>前提要求</strong>：<font color='red'> <spanclass="math inline">\(p\)</span> 为素数 </font></p></li><li><p><strong>有解判断</strong>：</p></li></ul><p><span class="math display">\[gcd\left( a,p \right) =1\xLeftrightarrow{p\text{为素数}}a\not \equiv0\,\, mod\,\,p\]</span></p><ul><li><strong>费马小定理</strong>：若 <spanclass="math inline">\(p\)</span> 为素数，则</li></ul><p><span class="math display">\[a^{p-1}\equiv 1 \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><ul><li>因此，<span class="math inline">\(a\)</span> 的逆为</li></ul><p><span class="math display">\[a^{-1}=a^{p-2}\, \, \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(logp)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在逆元</span></span><br><span class="line"><span class="keyword">if</span> (a % p == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)<span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p) % p + p) % p);</span><br></pre></td></tr></table></figure><h3 id="拓展欧几里得求逆元">拓展欧几里得——求逆元</h3><ul><li><p>不要求 <span class="math inline">\(p\)</span> 为素数， <spanclass="math inline">\(p\)</span> 为任意数即可</p></li><li><p>使用拓展欧几里得算法求一个元素的逆</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断逆元是否存在</span></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line"><span class="keyword">if</span> (g != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x + p) % p); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x+p可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">+p %p 是为了将 x 转换到 0 ~ p-1</span></span><br><span class="line"><span class="comment">/ % 的优先级要高于 + -，所以这里必须加上括号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="求解同余式">求解同余式</h2><ul><li><strong>定理：</strong>一次同余式</li></ul><p><span class="math display">\[ax\equiv b\left( mod\,\,m \right) \text{，}a\not \equiv 0\left( mod\,\,m\right)\]</span></p><ol type="1"><li>有解<span class="math inline">\(\Longleftrightarrow \left( a,m\right) |b\)</span>​</li><li>当同余式有解时<ol type="1"><li>其解数为 <span class="math inline">\(d=(a,m).\)</span>​​</li><li>求解 <span class="math inline">\(x\)</span>，满足 <spanclass="math inline">\(ax≡b(mod \ m)\)</span> &lt;==&gt; 求解 <spanclass="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>满足 <span class="math inline">\(ax+my=b\)</span><ol type="1"><li>使用 拓展欧几里得算法 ，求出 <spanclass="math inline">\(x_0\)</span>、<spanclass="math inline">\(y_0\)</span>，使得 <spanclass="math inline">\(ax_0+my_0=(a,m)\)</span></li><li>左右两侧同时乘以 <span class="math inline">\(\frac{b}{\left( a,m\right)}\)</span>，得到 $ a+m=b$</li><li>因此解 <span class="math inline">\(x=x_0*\frac{b}{\left( a,m\right)}\)</span></li></ol></li></ol></li></ol><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8082881/">AcWing878. 线性同余方程 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (b % g)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x * b / g + m)% m);</span><br><span class="line"><span class="comment">// x * b可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">// * / % 的优先级相同，按照顺序从左到右依次运行</span></span><br><span class="line"><span class="comment">// + m % m 是为了将 x 转换到 0 ~ p-1</span></span><br></pre></td></tr></table></figure><h2 id="求解一次同余组">求解一次同余组</h2><h3 id="中国剩余定理">中国剩余定理</h3><ul><li>要求： <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161457480.png"alt="image-20240316145735216" /><figcaption aria-hidden="true">image-20240316145735216</figcaption></figure><h3 id="拓展中国剩余定理">拓展中国剩余定理</h3><ul><li>不要求 <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8086576/">AcWing204. 表达整数的奇怪方式 - AcWing</a>】</strong></li></ul><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161857618.png" /></p><h2 id="高斯消元">高斯消元</h2><h3 id="解线性方程组">解线性方程组</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192214816.png"alt="image-20240319221424411" /><figcaption aria-hidden="true">image-20240319221424411</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192222282.png"alt="image-20240319222223978" /><figcaption aria-hidden="true">image-20240319222223978</figcaption></figure><p>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8128731/">AcWing883. 高斯消元解线性方程组 - AcWing</a>】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断是否有解</span></span><br><span class="line"><span class="comment">- 返回0，表示无解</span></span><br><span class="line"><span class="comment">- 返回1：表示有无穷多组解</span></span><br><span class="line"><span class="comment">- 返回2：表示有解a[0][n]~a[n-1][n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r; <span class="comment">// c 代表 列 col ， r 代表 行 row</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先找到当前这一列绝对值最大的一个数字所在的行号 t</span></span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行，换到最上面（不是第一行，是第 r 行）去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行的第一个数，变成 1，方程两边同时除以第一个数，必须倒着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--)</span><br><span class="line">            a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把【当前列】下面的所有数，全部消成 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--) <span class="comment">// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];</span></span><br><span class="line">                a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r++; <span class="comment">// 这一行的工作做完，换下一行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r &lt; n 表明剩下方程的个数是小于 n 的，不是唯一解，判断是无解还是无穷多解</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;                                <span class="comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps) <span class="comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一解，从下往上回代，得到方程的解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n]; <span class="comment">// 因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要找绝对值最大的那一行？</p><ol type="1"><li>一是因为可以寻找一个非零行</li><li>二是作浮点数除法时，显然<strong>除以一个大数会让精度更好</strong>，误差更小</li></ol></blockquote><h3 id="解异或方程组">解异或方程组</h3><ul><li><strong>核心思想</strong>：<strong>异或</strong>&lt;==&gt;<strong>不进位的加法</strong></li><li>等式与等式间的异或要一起进行才能保证等式左右两边依然是相等关系：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a^b^c = x</span><br><span class="line">   d^f = y</span><br><span class="line">则</span><br><span class="line"> a^b^d^c^f = x^y</span><br></pre></td></tr></table></figure><ul><li><strong>算法步骤</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 左下角消0</span><br><span class="line">  1.1 枚举列</span><br><span class="line">  1.2 找第一个非零行</span><br><span class="line">  1.3 交换</span><br><span class="line">  1.4 把同列下面行消零(异或)</span><br><span class="line">2 判断3种情况</span><br><span class="line">  2.1 唯一解</span><br><span class="line">  2.2 秩&lt;n</span><br><span class="line">      2.2.1 有矛盾 无解</span><br><span class="line">      2.2.2 无矛盾 无穷多解</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8161242/">AcWing884. 高斯消元解异或线性方程组 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">            &#123;</span><br><span class="line">                t = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!a[t][c])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= n; j++)</span><br><span class="line">                    a[i][j] ^= a[r][j];</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][n])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 无解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无穷解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] ^= a[i][j] * a[j][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数">组合数</h2><p><span class="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}\\    \\    \,\,C_{a}^{0}=1\end{cases}\ \ \ \ \ \ \ \ \ \    0\leqslant a\leqslant b\]</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403182224160.png"alt="image-20240318222419888" /><figcaption aria-hidden="true">image-20240318222419888</figcaption></figure><h3 id="模板一">模板一</h3><ul><li>适用条件：<ul><li>询问次数 n 非常多</li><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^5\\1&lt;=b&lt;=a&lt;=2000\\p=1e9 + 7\]</span></p><ul><li>原理：</li></ul><p><span class="math display">\[C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}\]</span></p><ul><li>时间复杂度：<font color='red'><spanclass="math inline">\(O(n^2)\)</span>​</font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8108970/">AcWing885. 求组合数 I - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板二">模板二</h3><ul><li><strong>适用条件</strong></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^4\\1&lt;=b&lt;=a&lt;=10^5\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong></li></ul><p><span class="math display">\[\frac{a}{b}mod\,\,p=a*b^{-1}\,\,mod\,\,p\ne\frac{a\,\,mod\,\,p}{b\,\,mod\,\,p}\]</span></p><p><span class="math display">\[\left( a*b \right) ^{-1}\,\,mod\,\,p=a^{-1}*b^{-1}\,\,mod\,\,p\]</span></p><p><span class="math display">\[C_{a}^{b}=\frac{a!}{b!\left( a-b \right) !}=fact\left( a \right) \,\,*infact\left( b \right) \,\,* infact\left( a-b \right)\,\,   \text{其中}\begin{cases}    fact\left( a \right) =a! \% mod\\    infact\left( a \right) =\left( a! \right) ^{-1}\,\,\% mod\\\end{cases}\\\\\]</span> :smile:注意：<span class="math inline">\(mod=1e^9+7\)</span>为质数，所以计算逆元 <span class="math inline">\(i^{-1}\)</span>可以采用<strong>费马小定理</strong> <span class="math display">\[\text{递推公式：}\begin{cases}    fact\left( a \right) =fact\left( a-1 \right) \,\,* a\,\,\% mod\\    infact\left( a \right) =infact\left( a-1 \right) \,\,* a^{-1}\,\,\%mod\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8110941/">AcWing886. 求组合数 II - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0! = 1, 1^&#123;-1&#125; = 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2个 int 相乘会爆 int ，使用类型转化为 long long</span></span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">// 三个 int 相乘会爆 long long，所以每2个数相乘就对 mod 取模</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)fact[a] * infact[b]) % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板三">模板三</h3><ul><li><strong>适用条件</strong></li></ul><p><span class="math display">\[1&lt;= n &lt;= 20\\1&lt;=b&lt;=a&lt;=10^{18}\\1&lt;=p&lt;=10^5，且\ p\ 为质数\]</span></p><ul><li><strong>卢卡斯定理 <span class="math inline">\(Lucas \Theory\)</span></strong></li></ul><p><span class="math display">\[C_{a}^{b}\equiv C_{a\,\,mod\,\,p}^{b\,\,mod\,\,p}\,\,*C_{a/p}^{b/p}\,\,mod\,\,p   \ \ \ \ \ \ p\ 为素数\]</span></p><p>​ 当 <span class="math inline">\(a&lt;p\)</span> 且 <spanclass="math inline">\(b&lt;p\)</span> 时，适用组合数定义求 <spanclass="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}\\    \,\,C_{a}^{0}=1\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121840/">AcWing887. 求组合数 III - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这里的 a 和 b 需要保证小于 p , 因此(b!,p)=1, b!的逆元一定存在</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * j % p;</span><br><span class="line">        y = (LL)y * i % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)x * <span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lucas</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板四">模板四</h3><ul><li><strong>使用条件</strong></li></ul><p>当我们需要求出<strong>组合数的真实值</strong>，而非对某个数的余数时，分解质因数的方式比较好用：</p><ul><li><strong>原理</strong></li></ul><ol type="1"><li>筛法求出范围内的所有质数</li><li>通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n!中p的次数是</li></ol><p><span class="math display">\[n / p + n / p^2 + n / p^3 + ...\]</span></p><ol start="3" type="1"><li>用高精度乘法将所有质因子相乘</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403191527951.png"alt="image-20240319152754655" /><figcaption aria-hidden="true">image-20240319152754655</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121842/">AcWing888. 求组合数 IV - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];         <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求n！分解质因数后， p 的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高精度乘低精度模板 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a); <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j++)</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><h2 id="卡特兰数">卡特兰数</h2><h3 id="原理">原理</h3><p>​ 给定 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(1\)</span>，它们按照某种顺序排成长度为 <spanclass="math inline">\(2n\)</span> 的序列，满足任意前缀中 <spanclass="math inline">\(0\)</span> 的个数都不少于 <spanclass="math inline">\(1\)</span> 的个数的序列的数量为： <spanclass="math display">\[Cat_n=\frac{C_{2n}^{n}}{n+1}\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403282301866.png"alt="image-20240328230128530" /></p><h3 id="例题">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8121833/">AcWing889. 满足条件的01序列 - AcWing</a></li></ul><h2 id="容斥原理">容斥原理</h2><h3 id="原理-1">原理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201238750.png"alt="image-20240319184649042" /><figcaption aria-hidden="true">image-20240319184649042</figcaption></figure><h3 id="例题-1">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8129504/">AcWing890. 能被整除的数 - AcWing</a></li></ul><h2 id="博弈论之sg函数">博弈论之SG函数</h2><h3 id="nim游戏">NIM游戏</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403281718365.png"alt="image-20240328171850955" /><figcaption aria-hidden="true">image-20240328171850955</figcaption></figure><h4 id="定理">定理</h4><p>​ 假设 <span class="math inline">\(n\)</span>​ 堆石子，数目分别是 <spanclass="math inline">\(A_1,A_1,\cdots,A_n\)</span>​</p><ul><li>如果 <span class="math inline">\(A_1\oplus A_2\oplus \cdots \oplusA_n\ne 0\)</span>​​，则先手必胜</li><li>否则先手必败</li></ul><h4 id="证明">证明</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403281928376.png"alt="image-20240328192818930" /><figcaption aria-hidden="true">image-20240328192818930</figcaption></figure><p>:tomato:基于上述三个证明：</p><ol type="1"><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n\ne0\)</span>，那么先手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，最后一定是后手面临最终没有石子可拿的状态，先手必胜。</li><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n=0\)</span>，那么无论先手怎么拿，都会将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplus a_n\ne0\)</span>，那么后手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，后一定是先手面临最终没有石子可拿的状态，先手必败。</li></ol><h3 id="公平组合游戏icg">公平组合游戏ICG</h3><p>若一个游戏满足：</p><ol type="1"><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个<strong>公平组合游戏</strong>。</p><p>​NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h3 id="有向图游戏">有向图游戏</h3><p>​给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为<strong>有向图游戏</strong>。​<strong>任何一个公平组合游戏都可以转化为有向图游戏</strong>。具体方法是，<font color ='red'>把每个<strong>局面</strong>看成图中的一个<strong>节点</strong>，并且从<strong>每个局面</strong>向沿着合法行动能够到达的<strong>下一个局面</strong>连<strong>有向边</strong>。</font></p><h3 id="mex运算">Mex运算</h3><p>​ 设 <span class="math inline">\(S\)</span> 表示一个非负整数集合。定义<span class="math inline">\(mex(S)\)</span>为求出<strong>不属于</strong>集合 <span class="math inline">\(S\)</span>的最小非负整数的运算，即： <span class="math display">\[mex(S) = min\{x\},\ x\ 属于自然数，且\ x\ 不属于\ S\]</span></p><h3 id="sg函数">SG函数</h3><p>​ 在有向图游戏中，对于每个节点 <spanclass="math inline">\(x\)</span>，设从 <spanclass="math inline">\(x\)</span> 出发共有 <spanclass="math inline">\(k\)</span> 条有向边，分别到达节点 <spanclass="math inline">\(y_1, y_2, …, y_k\)</span> ，定义 SG(x) 为 x的后继节点 <span class="math inline">\(y_1, y_2, …, y_k\)</span> 的SG函数值 构成的集合再执行 mex(S) 运算的结果，即： <spanclass="math display">\[SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})\]</span> 特别地，整个有向图游戏 G 的 SG 函数值被定义为有向图游戏起点 s的 SG 函数值，即： <span class="math display">\[SG(G) = SG(s)\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201408408.png"alt="image-20240320140827062" /></p><h3 id="有向图游戏的和">有向图游戏的和</h3><p>​ 设 G1，G2,····,Gm 是 m 个有向图游戏。定义有向图游戏G，他的行动规则是任选某个有向图游戏 Gi，并在 Gi 上行动一步。G被称为<strong>有向图游戏 G1，G2，·····，Gm的和</strong></p><p>​有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的<strong>异或和</strong>，即：<span class="math display">\[SG\left( G \right) =SG\left( G_1 \right) \oplus SG\left( G_2 \right)\oplus \cdots \oplus SG\left( G_m \right)\]</span></p><h3 id="定理-1">定理</h3><ul><li>有向图游戏的某个局面<strong>必胜</strong>，当且仅当该局面对应节点的<strong>SG函数值大于0</strong></li><li>有向图游戏的某个局面<strong>必败</strong>，当且仅当该局面对应节点的<strong>SG函数值等于0</strong></li></ul><p>我们不再详细证明该定理。读者可以这样理解：</p><ul><li>在一个<strong>没有出边</strong>的节点上，棋子<strong>不能</strong>移动，它的SG 值为 0，对应必败局面。</li><li>若一个节点的某个后继节点 SG 值为 0，在 mex 运算后，该节点的 SG值大于0。这等价于，若一个局面的后继局面中存在必败局面，则当前局面为必胜局面。</li><li>若一个节点的后继节点 SG 值均不为 0，在mex运算后，该节点的 SG 值为0。这等价于，若一个局面的后继局面全部为必胜局面，则当前局面为必败局面。</li></ul><p>对于若干个有向图游戏的和，其证明方法与 NIM 博弈类似。</p><h3 id="例题-2">例题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8129672/">AcWing891. Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8221695/">AcWing892. 台阶-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8131666/">AcWing893. 集合-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8223036/">AcWing894. 拆分-Nim游戏 - AcWing</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数学知识&quot;&gt;数学知识&lt;/h1&gt;
&lt;p&gt;:smile:&lt;strong&gt;数论&lt;/strong&gt; 经常会出现 &lt;strong&gt;数的大小越界&lt;/strong&gt;
情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尤其是在做&lt;strong&gt;乘法&lt;/strong&gt;、其次是&lt;strong&gt;加法&lt;/strong&gt;的时候非常容易溢出，此时可以使用
&lt;code&gt;long long&lt;/code&gt; 局部转换&lt;/li&gt;
&lt;li&gt;比较稳妥的、一劳永逸的办法是&lt;strong&gt;变量类型&lt;/strong&gt;不使用
int，&lt;strong&gt;全部使用&lt;/strong&gt; &lt;code&gt;long long&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;质数&quot;&gt;质数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;质数&lt;/strong&gt;：在大于 1 的整数中，如果只包含 1
和本身这两个约数，就被成为质数，或者叫素数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算数基本定理&lt;/strong&gt;：任一大于1的整数 &lt;span
class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;​ 能够唯一地表示成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
n={p_1}^{&#92;alpha _1}{p_1}^{&#92;alpha _1}&#92;cdots {p_s}^{&#92;alpha _s},  &#92;alpha
_i&amp;gt;0,  i=1,2,&#92;cdots ,s&#92;left( * &#92;right)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 分解式(*)叫做 的 n 的标准分解式&lt;/p&gt;
&lt;p&gt;注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 n
表成下面形式： &lt;span class=&quot;math display&quot;&gt;&#92;[
n={p_1}^{&#92;alpha _1}{p_1}^{&#92;alpha _1}&#92;cdots {p_k}^{&#92;alpha _k},  &#92;alpha
_i&#92;geqslant 0,  i=1,2,&#92;cdots ,k
&#92;]&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Tips】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/14/[object%20Object]/C++/%E3%80%90Tips%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/14/[object%20Object]/C++/%E3%80%90Tips%E3%80%91/</id>
    <published>2024-03-14T05:59:27.000Z</published>
    <updated>2024-03-29T04:38:51.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="i"><code>~i</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i != <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">~i;</span><br></pre></td></tr></table></figure><h2 id="大数组要定义在全局变量">大数组要定义在全局变量</h2><ul><li><p>在函数（包含main）内部声明的变量属于局部变量</p></li><li><p>局部变量存放在<strong>栈空间</strong>，栈空间默认为4MB，最多只能存储 <code>1e6</code> 大小的 <code>int</code> 数组</p></li><li><p>全局变量存放在<strong>堆空间</strong>，堆空间很大，如果内存为4GB，堆空间也可以达到 4GB</p></li></ul><p>​ 因此C++ 中若要设置长度大于 <code>1e6</code>的数组，不能在函数内部声明，因为这样属于局部变量，存放在栈空间上，容易造成内存溢出</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291023786.png" alt="image-20240329102329729" style="zoom: 50%;" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291024238.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;i&quot;&gt;&lt;code&gt;~i&lt;/code&gt;&lt;/h2&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>优先队列priority_queue</title>
    <link href="https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/"/>
    <id>https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/</id>
    <published>2024-03-08T05:29:27.000Z</published>
    <updated>2024-03-19T07:07:35.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列priority_queue">优先队列priority_queue</h1><p>:smile: priority_queue实际上就是<strong>堆</strong></p><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>堆大小</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>插入</font></strong>堆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分别返回<strong><font color='red'>堆顶元素</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p><font color='blue'><strong>删除</strong></font>堆顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 queue 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><h2 id="举例">举例</h2><ol type="1"><li>基本类型例子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(i);</span><br><span class="line">        c.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">cbd abcd abc</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>pari的比较，先比较第一个元素，第一个相等比较第二个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>对于自定义类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;优先队列priority_queue&quot;&gt;优先队列priority_queue&lt;/h1&gt;
&lt;p&gt;:smile: priority_queue实际上就是&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;头文件&quot;&gt;头文件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;queue&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 大根堆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;priority_queue &amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; heap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 小根堆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;priority_queue &amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;,vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;,greater&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;gt;q;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="STL" scheme="https://cuiluyi.gitee.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【C++标准库函数】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/</id>
    <published>2024-03-04T05:59:27.000Z</published>
    <updated>2024-03-31T13:57:56.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c标准库函数">C++标准库函数</h1><p>[TOC]</p><h2 id="lower_bound-upper_bound">lower_bound &amp;&amp; upper_bound</h2><h3 id="头文件">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用">作用</h3><ul><li><p>在一个<strong>排好序的数组</strong>中进行<strong>二分查找</strong></p></li><li><p><strong>基于二分查找！数组或容器必须有序！</strong></p></li></ul><h3 id="用法">用法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142542.png"alt="image-20240331214206385" /><figcaption aria-hidden="true">image-20240331214206385</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142606.png"alt="image-20240331214221383" /><figcaption aria-hidden="true">image-20240331214221383</figcaption></figure><h3 id="举例">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数组，假设已经从小到大排序</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 最后一个小于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 最后一个小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 没有小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 最后一个小于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p2 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 最后一个小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 没有小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第一个大于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p3 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p3 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 第一个大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 没有大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第一个大于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p4 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p4 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p4 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 没有大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">7</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">7</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">2.</span> 没有小于等于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">10</span> 的元素</span><br><span class="line"><span class="number">4.</span> 没有大于等于 <span class="number">10</span> 的元素</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">1</span> 的元素</span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">1</span> 的元素是: <span class="number">3</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">9</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">9</span> 的元素</span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="nth_element">nth_element</h2><h3 id="头文件-1">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="原型">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序规则采用默认的升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//排序规则为自定义的 comp 排序规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>first</code> 、 <code>last</code>为<strong>迭代器/指针</strong>，用于指定该函数的作用范围<code>[first, last)</code></li><li><code>nth</code>：也为<strong>迭代器/指针</strong>，其功能是令函数查找“<strong>第nth 小</strong>”的元素，并将其移动到 <code>nth</code> 指向的位置</li><li><code>comp</code>：用于<strong>自定义排序规则</strong></li></ul><blockquote><p><code>comp</code> 是可选参数，默认是求第 <spanclass="math inline">\(k\)</span> 小</p></blockquote><p><strong>返回值：</strong></p><ul><li>无</li></ul><h3 id="作用-1">作用</h3><ul><li>将数组中<strong>第 <span class="math inline">\(k\)</span>小</strong>的数 放在 <code>nth</code> 指向的位置</li><li>函数执行后， <code>nth</code>指向的元素将处于正确位置，其他位置元素顺序相较于初始顺序会被<strong>打乱</strong>，但前面的都比它小，后面的都比它大</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li></ul><h3 id="举例-1">举例</h3><h4 id="求第k小">求第k小</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> </span><br></pre></td></tr></table></figure><h4 id="求第k大">求第k大</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n, [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><h2 id="max_elementmin_element">max_element、min_element</h2><h3 id="头文件-2">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-2">作用</h3><p><strong>1. 求数组的最大值或最小值</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a, a + <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a, a + <span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//获取最大值</span></span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//获取最小值</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>2. 求数组最大值最小值对应的下标</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a, a + <span class="number">8</span>) - a; </span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a, a + <span class="number">8</span>) - a;</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); <span class="comment">//获取最大值对应的下标</span></span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();<span class="comment">//获取最小值对应的下标</span></span><br></pre></td></tr></table></figure><h2 id="fill">fill</h2><h3 id="头文件-3">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-3">作用</h3><p><ahref="https://blog.csdn.net/liu16659/article/details/87152348?ops_request_misc=%7B%22request%5Fid%22%3A%22167715751316800188555444%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167715751316800188555444&amp;biz_id=0&amp;spm=1018.2226.3001.4187">(96条消息)C++ 中 fill() 的使用_LawsonAbs的博客-CSDN博客_c++ fill</a></p><h2 id="memset">memset</h2><h3 id="头文件-4">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型-1">原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, Byte c, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>s：为指针或是数组</li><li>c：是赋给 s 的值</li><li>count：是 s 的长度</li></ul><p>返回值</p><ul><li>指向存储区 s 的指针。</li></ul><h3 id="作用-4">作用</h3><p>​ memset是按照 c 的值（看作字节），按字节将 s赋值，因此我们最常见的就是</p><ul><li>将每一字节赋值全 0 ，整体就是 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><ul><li>将每一字节赋值全 1 ，整体就是 -1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">-1</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p>注意：-1 = 0XFF</p></blockquote><ul><li>将每一个字节赋值 0x3f，整体就是 INF【<strong>正无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/qq_42386788/article/details/116427457">关于memset函数和赋值0x3f</a></p></blockquote><ul><li>将每一个字节赋值 0xbf，整体就是 INF【<strong>正无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0xbf</span>, <span class="built_in">sizeof</span>(s))</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><p>memset可以方便的==<strong>清空</strong>或初始化一个<strong>数组</strong>。==</p><h3 id="举例-2">举例</h3><ol type="1"><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/weixin_44162361/article/details/115790452?ops_request_misc=%7B%22request%5Fid%22%3A%22169735623116800180650624%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169735623116800180650624&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115790452-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=memset&amp;spm=1018.2226.3001.4187">memset的用法详解_薛定谔的猫ovo的博客-CSDN博客</a></p></blockquote><h2 id="memcmp">memcmp</h2><h3 id="头文件-5">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="基本原型">基本原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf1, <span class="type">const</span> <span class="type">void</span> *buf2, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong></p><ul><li><p>当 buf1&lt;buf2 时，返回值&lt;0</p></li><li><p>当 buf1=buf2 时，返回值=0</p></li><li><p>当 buf1&gt;buf2 时，返回值&gt;0</p></li></ul><h3 id="作用-5">作用</h3><p>memcmp 是比较内存区域 buf1 和 buf2 的前 count个字节。该函数是按字节比较的</p><h3 id="举例-3">举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">r = <span class="built_in">memcmp</span>(&amp;s1,&amp;s2,<span class="built_in">strlen</span>(s1));</span><br><span class="line"><span class="keyword">if</span>(!r)<span class="comment">//！r 非零返回的是 1  这个是非运算，计算机是二进制的，不是零就是一了 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 and s2 are identical\n&quot;</span>);<span class="comment">/*s1等于s2*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);<span class="comment">/*s1小于s2*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);<span class="comment">/*s1大于s2*/</span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,!r); //输出是一， </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,r);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明-1">说明</h3><ol type="1"><li>该函数是按字节比较的：当s1,s2为字符串时</li></ol><ul><li><p><code>memcmp(s1,s2,1)</code>就是比较s1和s2的第一个字节的ascII码值；</p></li><li><p><code>memcmp(s1,s2,n)</code>就是比较s1和s2的前n个字节的ascII码值；</p><p>例如:</p></li></ul><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> *s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *s2=<span class="string">&quot;acd&quot;</span>;</span><br><span class="line">&gt;<span class="type">int</span> r=<span class="built_in">memcmp</span>(s1,s2,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>​比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了所以<spanclass="math display">\[r=-1\]</span>.</p></blockquote><ol start="2" type="1"><li><p>对于<code>memcmp()</code>，如果两个字符串相同而且<code>count</code>大于字符串长度的话，<code>memcmp</code>不会在<code>\0</code>处停下来，会继续比较<code>\0</code>后面的内存单元，直到<code>_res</code>不为零或者达到<code>count</code>次数。</p><p>例如：</p></li></ol><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> a1[]=<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">  <span class="type">char</span> a2[]=<span class="string">&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure></p><p>对于<code>memcmp(a1,a2,10)</code>，<code>memcmp</code>在两个字符串的<code>\0</code>之后继续比较。所以，如果想使用memcmp比较字符串，要保证count不能超过最短字符串的长度，否则结果有可能是错误的。</p></blockquote><h2 id="memcpy">memcpy</h2><h3 id="头文件-6">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="声明">声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>str1</strong> --指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li><li><strong>str2</strong> -- 指向要复制的数据源，类型强制转换为 void*指针。</li><li><strong>n</strong> -- 要被复制的字节数。</li></ul><p><strong>返回值：</strong></p><ul><li>该函数返回一个指向目标存储区 str1 的指针。</li></ul><h3 id="作用-6">作用</h3><p>​ 从存储区 <strong>str2</strong> 复制 <strong>n</strong>个字节到存储区 <strong>str1</strong></p><h3 id="实例">实例</h3><ul><li>将字符串复制到数组 dest 中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="keyword">sizeof</span> src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest = http://www.runoob.com</span><br></pre></td></tr></table></figure><ul><li>将 s 中第 11 个字符开始的 6个连续字符复制到 d 中：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(d, s + <span class="number">11</span>, <span class="number">6</span>); <span class="comment">// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob)</span></span><br><span class="line">    <span class="comment">// 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));</span></span><br><span class="line">    d[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob</span><br></pre></td></tr></table></figure><ul><li>覆盖原有部分数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;***&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 前: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 后: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 memcpy 前: abcdefg</span><br><span class="line">使用 memcpy 后: ***defg</span><br></pre></td></tr></table></figure><h2 id="strcmp">strcmp</h2><h3 id="头文件-7">头文件</h3><p><code>#include &lt;cstring&gt;</code></p><h3 id="作用-7">作用</h3><p>​ 比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较</p><h3 id="原型-2">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>第一个字符串大于第二个字符串，则返回大于 0 的数字</li><li>第一个字符串<font color='red'><strong>等于</strong></font>第二个字符串，则返回<font color='red'><strong>0</strong></font></li><li>第一个字符串小于第二个字符串，则返回小于 0 的数字</li></ul><h3 id="举例-4">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* p1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p2 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p4 = <span class="string">&quot;bcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1,p2 ));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1,p3 ));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p3,p4 ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="new">new</h2><h3 id="作用-8">作用</h3><p><code>new()</code>使计算机开辟一块内存空间，并返回<strong>内存空间的首地址</strong></p><h3 id="格式">格式</h3><ol type="1"><li><p>使用new函数创建变量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType;</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建变量并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> <span class="built_in">ElementType</span>(val);</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size];</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size]&#123;&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="说明-2">说明</h3><ol type="1"><li>new开辟的空间在堆上，而一般声明的变量存放在栈上</li><li><strong><font color='red'>通常用new函数代替malloc函数</font></strong></li><li>new不需要头文件</li><li>使用 new 函数之后要<strong><font color='red'>使用 delete函数释放内存空间</font></strong></li></ol><h3 id="举例-5">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">example1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 可以在new后面直接赋值 */</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以单独赋值 */</span></span><br><span class="line">    <span class="comment">// int *p = new int;</span></span><br><span class="line">    <span class="comment">// *p = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">example2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 用new创建数组 */</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">/* 也可以依次赋值 */</span></span><br><span class="line">    <span class="comment">// int *q = new int[3];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        q[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *st = <span class="keyword">new</span> <span class="built_in">student</span>(&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *stlist = <span class="keyword">new</span> student[<span class="number">3</span>]&#123;&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;bac&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="string">&quot;ccd&quot;</span>, <span class="number">93</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> e1 = <span class="built_in">example1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e1: &quot;</span> &lt;&lt; e1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *e2 = <span class="built_in">example2</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; e2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st1 = <span class="built_in">example3</span>();</span><br><span class="line">    cout &lt;&lt; st1-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st1-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st2 = <span class="built_in">example4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; st2[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st2[i].score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e1: 3</span><br><span class="line">0 1 2</span><br><span class="line">abc 90</span><br><span class="line">abc 90</span><br><span class="line">bac 78</span><br><span class="line">ccd 93</span><br></pre></td></tr></table></figure><h2 id="swap">swap</h2><h3 id="作用-9">作用</h3><p><strong><code>swap(a,b);</code></strong>交换两个变量<strong><code>a,b</code></strong>的值</p><blockquote><p><strong><code>a,b</code></strong>可以是<strong><font color='red'>任何数据类型</font></strong></p></blockquote><h3 id="原型-3">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ElementType &amp;a, ElementType &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="举例-6">举例</h3><h4 id="例一">例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="例二">例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;ABCD&quot;</span>;     string b = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ABCD</span><br></pre></td></tr></table></figure><h2 id="absfabs">abs/fabs</h2><h3 id="头文件-8">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-4">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span></span><br></pre></td></tr></table></figure><h3 id="作用-10">作用</h3><ul><li><code>abs</code> 是对<strong>整数</strong>取绝对值</li><li><code>fabs</code> 是对<strong>浮点数</strong>取绝对值</li></ul><h2 id="sqrt">sqrt</h2><h3 id="头文件-9">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-5">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-11">作用</h3><p><code>sqrt()</code> 用来求给定值的平方根</p><h3 id="常见错误">常见错误</h3><ol type="1"><li><strong>输出 36的开根号</strong></li></ol><ul><li><strong>错误写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152182.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><blockquote><p>忽略了sqrt()函数的返回值是 double型。导致出错</p></blockquote></blockquote><ul><li><strong>正确写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152197.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>常见的使用sqrt()函数的规范写法</strong> 例如:我们要判断一个数是不是质数，只需要判断 2 ~ n开根号之间有没有可以整除的数就可以了</p><ul><li><strong>错误写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，其实并不推荐这样写。虽然我也经常这样写。但是在一次做题的过程中，就因为这样写程序出现了bug。我就改用下面的这种稳妥的写法了</p><ul><li><strong>正确写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.0*n的目的是——隐式转换成浮点数，开根号后再强制转换成整型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span> * n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse">reverse</h2><h3 id="头文件-10">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-12">作用</h3><p>反转在<strong><font color='red'> [ first,last )</font></strong>范围内的顺序（包括first指向的元素，不包括last指向的元素）</p><h3 id="原型-6">原型</h3><p><strong><code>void reverse (BidirectionalIterator first,BidirectionalIterator last);</code></strong></p><ul><li>参数first：待排区域的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排区域的<strong><font color='blue'>末尾地址</font></strong></li></ul><h3 id="举例-7">举例</h3><ul><li>反转<strong>向量</strong><font color='blue'><strong>vector</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//v的值为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><ul><li>反转数组<strong><code>ElementType A[]</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[]=&#123;<span class="number">12</span>,<span class="number">-5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(A, A+<span class="number">6</span>);<span class="comment">//数组A为19,1,7,0,-5,12</span></span><br></pre></td></tr></table></figure><ul><li>反转<strong>字符串<font color='blue'>string</font></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;www.mathor.top&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//str结果为pot.rohtam.wwww</span></span><br></pre></td></tr></table></figure><h3 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="sort">sort</h2><h3 id="头文件-11">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-13">作用</h3><p>对==<strong><font color='red'>数组排序</font></strong>==</p><blockquote><ul><li>数组可以是<strong><code>ElementType A[]</code></strong>，也可以是<strong><code>vector &lt;ElementType&gt; A</code></strong><ul><li><strong><code>ElementType A[]</code></strong>：<strong><code>A</code></strong>表示<strong><font color='blue'>数组首地址</font></strong>，<strong><code>A+n</code></strong>表示<strong><font color='blue'>数组尾部</font></strong></li><li><strong><code>vector &lt;ElementType&gt; A</code></strong>：<strong><code>A.begin()</code></strong>和<strong><code>A.end()</code></strong>表示<strong><font color='blue'>头尾</font></strong></li></ul></li></ul></blockquote><h3 id="原型-7">原型</h3><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>默认</th><th><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last);</code></strong></th></tr></thead><tbody><tr class="odd"><td><strong>自定义</strong></td><td><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last,Compare comp);</code></strong></td></tr></tbody></table><ul><li>参数first：待排数组的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排数组的<strong><font color='blue'>末尾地址</font></strong></li><li>参数comp：自定义排序方法<ul><li>如果第三个参数不写，则<strong>默认的排序方法</strong>是<strong><font color='red'>从小到大</font></strong>排序。</li></ul></li></ul><h3 id="举例-8">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// cmp函数返回的值是bool类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 从大到⼩排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 因为这里没有传入参数cmp，所以按照默认,v从小到大排列</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, cmp); <span class="comment">// arr从大到小排列，因为cmp函数排序规则设置了从大到小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见cmp函数">常见cmp函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score!=b.score)</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">return</span> a.score!=b.score ? a.score&gt;b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> node a,<span class="keyword">struct</span> node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height!=b.height ? a.height&gt;b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注： <strong><code>sort</code></strong> 函数的<strong><code>cmp</code></strong> 必须按照规定来写，即必须只是<strong><code>&gt;</code></strong> 或者<strong><code>&lt;</code></strong> ，比如：<strong><code>return a &gt; b;</code></strong> 或者<strong><code>return a &lt; b;</code></strong> 而不能是<strong><code>&lt;=</code></strong> 或者<strong><code>&gt;=</code></strong></p></blockquote><h2 id="find">find</h2><h3 id="头文件-12">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-14">作用</h3><p>​可以在<strong>任何容器</strong>中<strong>查找指定元素</strong>，返回一个迭代器指向<strong>第一个匹配</strong>的元素</p><ul><li><p>string、map、set有内置的成员方法find()，所以对于string、map、set的查找通常使用内置的find()方法</p></li><li><p>但是vector、queue没有内置的成员方法find()，他们通常使用<algorithm>头文件下通用的find()函数</p></li></ul><h3 id="参数">参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>first</strong> 和 <strong>last</strong>为输入迭代器，<strong>[first,last)</strong>用于指定该函数的查找范围</li><li><strong>val</strong>为要查找的目标元素</li></ul><h3 id="返回值">返回值</h3><p>​该函数返回一个<strong>迭代器</strong>，指向范围内搜索元素的<strong>第一次</strong>出现。如果没有找到目标元素，则返回<strong>last</strong></p><h3 id="例子">例子</h3><ul><li>在<code>vector</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element found: 3</span><br></pre></td></tr></table></figure><ul><li>在<code>string</code>中查找指定字符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;This is a string&quot;</span>; <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  ^  ^  ^</span></span><br><span class="line"><span class="comment">                  1  2  3           */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>s.rfind()</code><strong>从左往右</strong>寻找、<code>s.lfind()</code><strong>从右往左</strong>寻找</p></blockquote><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从首个位置开始搜索，在下标 2 处找到子串 is</span><br><span class="line">从下标 5 开始搜索，在下标 5 处找到子串 is</span><br><span class="line">从首个位置开始搜索，在下标 3 处找到字符 s</span><br><span class="line">从下标 5 开始搜索，在下标 6 处找到字符 s</span><br></pre></td></tr></table></figure><ul><li>在<code>set</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法1：使用find方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">2</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法2：使用count方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy">copy</h2><h2 id="unique">unique</h2><h3 id="头文件-13">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-15">作用</h3><p>​ <code>unique</code>可以对 <strong>vector</strong>容器内的元素去重</p><h3 id="原型-8">原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a);</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>vector&lt;int&gt;</code></li><li><strong>返回值</strong>：指向去重后<strong>最后一个元素</strong>的迭代器<code>vector&lt;int&gt;::iterator</code></li></ul><h3 id="底层原理">底层原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) <span class="comment">// 如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];          <span class="comment">// 每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j; <span class="comment">// 返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next_permutation">next_permutation</h2><h3 id="头文件-14">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-16">作用</h3><p>​<code>next_permutation</code>是求当前排列的下一个排列（按字典序升序的下一个序列），如1234的next_permutation 是1243，在<strong>全排列</strong>当中经常会用。</p><h3 id="参数-1">参数</h3><p>​和<code>sort</code>的参数一样，一般传两个参数，第一个是排列开始的地址，第二个是排列结束的下一个地址，如实现数组第1-3排列的下一个排列：<code>next_permutation(a,a+3)</code>。一般作用对象是数组。</p><h3 id="返回值-1">返回值</h3><p>​ 返回值是 <span class="math inline">\(Ture\)</span> 或者 <spanclass="math inline">\(False\)</span>，若当前排列有下一个排列，则返回Ture，反之返回False：如54321的返回值为False。该函数会直接修改数组为下一个排列。</p><h3 id="原理">原理</h3><ul><li>从后往前找原数组中第一个<code>a[i] &lt; a[i+1]</code>的地方，其后面全是降序，说明已经排好了，所以我们就要将a[i]的值改大一点</li><li>将a[i]和其后面所有数中大于他的最小的数交换位置，则a[i]后面的数仍是个降序</li><li>然后将其后面这些降序的元素翻转，就得到了原排列的下一个增序排列了</li></ul><blockquote><blockquote><p>例如：对于排列2431来说</p><p>①我们先找到2和4处</p><p>②然后交换2和3的位置，就得到了3421</p><p>③最后翻转421，就得到了3124，则3124就是2431的下一个排列，如下图。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152332.png"alt="eg" /><figcaption aria-hidden="true">eg</figcaption></figure></blockquote></blockquote><h3 id="全排列">全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:sunny:如果你希望生成所有的排列方式，一定要<strong>先将序列按升序排列</strong>，这里可以与sort函数结合起来使用，先用sort升序排列，再调用next_permutation函数。</p><h2 id="int_maxint_min">INT_MAX，INT_MIN</h2><h3 id="头文件-15">头文件</h3><p><strong><code>#include &lt;climits&gt;</code></strong></p><h3 id="介绍">介绍</h3><p>C中<strong>常量</strong><code>INT_MAX</code>和<code>INT_MIN</code>分别表示int类型的最大值和最小值</p><blockquote><ol type="1"><li>``` INT_MAX = 2^31-1 = 2147483647; INT_MIN = -2^31 = -2147483648;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 所有超过该限值的int类型变量，都会出现溢出，出现warning，但是并不会出现error。</span><br><span class="line"></span><br><span class="line">3. 如果想表示的整数超过了该限值，可以使用长整型long long （占8字节64位）表示。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">### 建议</span><br><span class="line"></span><br><span class="line">-   由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对INT_MAX和INT_MIN的运算应当格外注意，在出现溢出的时候，不遵循数学规则：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">INT_MAX + 1 = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 = INT_MAX</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MAX + 1 &lt; INT_MAX</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 &gt; INT_MIN</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) &lt; 0</span><br></pre></td></tr></table></figure></li></ol></blockquote><ul><li><p>建议在表示正负无穷时：</p><ul><li><p>使用 <code>2e9</code> 表示<strong>正无穷</strong></p></li><li><p><code>-2e9</code> 表示<strong>负无穷</strong></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e9</span>;</span><br></pre></td></tr></table></figure><h3 id="实例-1">实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX = %d\n&quot;</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN = %d\n&quot;</span>, INT_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX + 1 = %d\n&quot;</span>, INT_MAX + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN - 1 = %d\n&quot;</span>, INT_MIN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;abs(INT_MIN) = %d\n&quot;</span>, <span class="built_in">abs</span>(INT_MIN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = 2147483647</span><br><span class="line">INT_MIN = -2147483648</span><br><span class="line">INT_MAX + 1 = -2147483648</span><br><span class="line">INT_MIN - 1 = 2147483647</span><br><span class="line">abs(INT_MIN) = -2147483648</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://blog.csdn.net/weixin_51635753/article/details/115434999?ops_request_misc=%7B%22request%5Fid%22%3A%22167049370716782414992762%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167049370716782414992762&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-21-115434999-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&amp;utm_term=C%2B%2B自带swap函数&amp;spm=1018.2226.3001.4187">(82条消息)C++ STL 常用函数_Mr.bei的博客-CSDN博客_c++stl常用函数</a></li><li><ahref="https://zh.cppreference.com/w/首页">cppreference.com</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;c标准库函数&quot;&gt;C++标准库函数&lt;/h1&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;lower_bound-upper_bound&quot;&gt;lower_bound &amp;amp;&amp;amp; upper_bound&lt;/h2&gt;
&lt;h3 id=&quot;头文件&quot;&gt;头文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个&lt;strong&gt;排好序的数组&lt;/strong&gt;中进行&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;基于二分查找！数组或容器必须有序！&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;用法&quot;&gt;用法&lt;/h3&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142542.png&quot;
alt=&quot;image-20240331214206385&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20240331214206385&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142606.png&quot;
alt=&quot;image-20240331214221383&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20240331214221383&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;举例&quot;&gt;举例&lt;/h3&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; a = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;; &lt;span class=&quot;comment&quot;&gt;// 示例数组，假设已经从小到大排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cin &amp;gt;&amp;gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1. 最后一个小于x的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; p1 = &lt;span class=&quot;built_in&quot;&gt;lower_bound&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(), x) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p1 &amp;gt;= a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;1. 最后一个小于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素是: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; *p1 &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;1. 没有小于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2. 最后一个小于等于x的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; p2 = &lt;span class=&quot;built_in&quot;&gt;upper_bound&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(), x) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p2 &amp;gt;= a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;2. 最后一个小于等于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素是: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; *p2 &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;2. 没有小于等于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3. 第一个大于x的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; p3 = &lt;span class=&quot;built_in&quot;&gt;upper_bound&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(), x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p3 != a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;3. 第一个大于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素是: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; *p3 &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;3. 没有大于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 4. 第一个大于等于x的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; p4 = &lt;span class=&quot;built_in&quot;&gt;lower_bound&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(), x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p4 != a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;4. 第一个大于等于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素是: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; *p4 &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;4. 没有大于等于 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; 的元素&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输入 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输出 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 最后一个小于 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 最后一个小于等于 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; 第一个大于 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4.&lt;/span&gt; 第一个大于等于 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输入 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输出 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 最后一个小于 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 最后一个小于等于 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; 第一个大于 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4.&lt;/span&gt; 第一个大于等于 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输入 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输出 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 没有小于 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 没有小于等于 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; 第一个大于 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4.&lt;/span&gt; 第一个大于等于 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输入 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输出 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 最后一个小于 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 最后一个小于等于 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; 没有大于 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4.&lt;/span&gt; 没有大于等于 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输入 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输出 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 没有小于 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 最后一个小于等于 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; 第一个大于 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4.&lt;/span&gt; 第一个大于等于 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输入 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 输出 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 最后一个小于 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 最后一个小于等于 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; 没有大于 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4.&lt;/span&gt; 第一个大于等于 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 的元素是: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;nth_element&quot;&gt;nth_element&lt;/h2&gt;
&lt;h3 id=&quot;头文件-1&quot;&gt;头文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;原型&quot;&gt;原型&lt;/h3&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//排序规则采用默认的升序排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nth_element&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(RandomAccessIterator first,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                  RandomAccessIterator nth,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                  RandomAccessIterator last)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//排序规则为自定义的 comp 排序规则&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nth_element&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(RandomAccessIterator first,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                  RandomAccessIterator nth,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                  RandomAccessIterator last,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                  Compare comp)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;first&lt;/code&gt; 、 &lt;code&gt;last&lt;/code&gt;
为&lt;strong&gt;迭代器/指针&lt;/strong&gt;，用于指定该函数的作用范围
&lt;code&gt;[first, last)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nth&lt;/code&gt;：也为&lt;strong&gt;迭代器/指针&lt;/strong&gt;，其功能是令函数查找“&lt;strong&gt;第
nth 小&lt;/strong&gt;”的元素，并将其移动到 &lt;code&gt;nth&lt;/code&gt; 指向的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comp&lt;/code&gt;：用于&lt;strong&gt;自定义排序规则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;comp&lt;/code&gt; 是可选参数，默认是求第 &lt;span
class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt; 小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;返回值：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;作用-1&quot;&gt;作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将数组中&lt;strong&gt;第 &lt;span class=&quot;math inline&quot;&gt;&#92;(k&#92;)&lt;/span&gt;
小&lt;/strong&gt;的数 放在 &lt;code&gt;nth&lt;/code&gt; 指向的位置&lt;/li&gt;
&lt;li&gt;函数执行后， &lt;code&gt;nth&lt;/code&gt;
指向的元素将处于正确位置，其他位置元素顺序相较于初始顺序会被&lt;strong&gt;打乱&lt;/strong&gt;，但前面的都比它小，后面的都比它大&lt;/li&gt;
&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;&#92;(O(n)&#92;)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;举例-1&quot;&gt;举例&lt;/h3&gt;
&lt;h4 id=&quot;求第k小&quot;&gt;求第k小&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; &lt;code&gt;a[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[] = &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// n为数组中元素的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 求第 k 小 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;nth_element&lt;/span&gt;(a, a + k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, a + n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;第 k 小为 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; a[k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第 k 小为 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器&lt;/strong&gt; &lt;code&gt;vector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; a = &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n = a.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;(), k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// n为数组中元素的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 求第 k 小 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;nth_element&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;() + k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;第 k 小为 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; a[k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第 k 小为 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;求第k大&quot;&gt;求第k大&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; &lt;code&gt;a[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[] = &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// n为数组中元素的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 求第 k 大 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;nth_element&lt;/span&gt;(a, a + k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, a + n, [](&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a &amp;gt; b; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;第 k 大为 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; a[k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第 k 大为 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器&lt;/strong&gt; &lt;code&gt;vector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; a = &amp;#123;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; n = a.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;(), k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// n为数组中元素的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 求第 k 大 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;nth_element&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;() + k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;(), [](&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a &amp;gt; b; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;第 k 大为 &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; a[k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第 k 大为 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;max_elementmin_element&quot;&gt;max_element、min_element&lt;/h2&gt;
&lt;h3 id=&quot;头文件-2&quot;&gt;头文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;作用-2&quot;&gt;作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 求数组的最大值或最小值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通数组&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; max = *&lt;span class=&quot;built_in&quot;&gt;max_element&lt;/span&gt;(a, a + &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; min = *&lt;span class=&quot;built_in&quot;&gt;min_element&lt;/span&gt;(a, a + &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;vector容器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; a = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;33&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; max = *&lt;span class=&quot;built_in&quot;&gt;max_element&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;()); &lt;span class=&quot;comment&quot;&gt;//获取最大值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; min = *&lt;span class=&quot;built_in&quot;&gt;min_element&lt;/span&gt;(a.&lt;span class=&quot;built_in&quot;&gt;begin&lt;/span&gt;(), a.&lt;span class=&quot;built_in&quot;&gt;end&lt;/span&gt;());&lt;span class=&quot;comment&quot;&gt;//获取最小值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《致谢》——黄国平</title>
    <link href="https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/"/>
    <id>https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/</id>
    <published>2024-03-04T05:59:27.000Z</published>
    <updated>2024-03-19T07:05:15.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="致谢">致谢</h1><p>​<strong>我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。</strong></p><p>​出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。<strong>每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。</strong></p><p>​<strong>人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。</strong>家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。</p><span id="more"></span><p>​<strong>人后的苦尚旦还能克服，人前的尊严却无比脆弱。</strong>上课的时候，因拖欠学费而经常被老师叫出教室约谈。雨天湿漉着上课，屁股后面说不定还是泥。夏天光着脚走在滚烫的路上。冬天穿着破旧衣服打着寒颤穿过那条长长的过道领作业本。这些都可能成为压垮骆驼的最后一根稻草。如果不是考试后常能从主席台领奖金，顺便能贴一墙奖状满足最后的虚荣心，我可能早已放弃。</p><p>​<strong>身处命运的旋涡，耗尽心力去争取那些可能本就是稀松平常的东西，每次转折都显得那么的身不由己。幸运的是，命运到底还有一丝怜惜。</strong>进入高中后,学校免了全部学杂费，■■■一家帮助解决了生活费。进入大学后，计算机终于成了我一生的事业与希望，胃溃疡和胃出血也终与我作别。</p><p>​我很庆幸保研时选择了自动化所，感谢研究生部的老师们将我从别的部门调剂到模式识别实验室，感谢导师宗成庆老师选择了我，宗老师将我引入了科学研究的大门，博士这五年无疑是我过去最幸福的时光。惭愧的是，离宗老师的期望显然还有很远的距离，我也知道本可以做得更好。这一段经历已经成为我这一生值得回味的美好瞬间之一。我很喜欢人机交互式机器翻译这个题目，但也仅开了个头。在未来，希望能有机会弥补这段遗憾。</p><p>​从家出发坐大巴需要两个半小时才能到县城，一直盼着走出大山。从炬光乡小学、大寅镇中学、仪陇县中学、绵阳市南山中学，到重庆的西南大学，再到中科院自动化所，我也记不清有多少次因为现实的压力而觉得自己快扛不下去了。<strong>这一路，信念很简单。把书念下去，然后走出去，不枉活一世。世事难科，未来注定还会面对更为复杂的局面。但因为有了这些点点滴滴，我已经有勇气和耐心面对任何困难和挑战。理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。</strong></p><p>​ 最近这些年，特别感谢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■重塑了我的人生。</p><p>​感谢■■■老师和■■■老师为我的研究提出诸多建设性的意见和建议。与他们的交流过程中，我也被他们坦诚为人、踏实做事的处事风格所感染。感谢所有和我一起在课题组工作的老师们和学习的同学们：■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■。我们在研究上共同努力，互相学习，如亲兄弟姐妹一般谈笑风生。不论大家将来在何处，我想我们都不会忘记这些年一起度过的时光。感谢课题组■■■女士，感谢模式识别综合办实验室的■■■、■■■和■■■等老师，感谢研究生部的■■■、■■■、■■■和■■■等老师，他们为我的学习和工作给予了极大的帮助。这会成为我日后工作的动力，希望最后能成为课题组值得骄傲的学生。</p><p>​感谢父母给了我生命，感谢婆婆和叔辈对我的抚养，感谢■■■■■■■■■■■■■■■■■■对我的牵挂，感谢■■■和■■■对我的支持，感谢一路上让我生活变得美好或者不那么美好的人和事。</p><p>​ 最后，对参加论文评审、答辩的各位老师表示衷心的感谢！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;致谢&quot;&gt;致谢&lt;/h1&gt;
&lt;p&gt;​
&lt;strong&gt;我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​
出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。&lt;strong&gt;每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​
&lt;strong&gt;人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。&lt;/strong&gt;家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，
黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。&lt;/p&gt;</summary>
    
    
    
    
    <category term="fighting" scheme="https://cuiluyi.gitee.io/tags/fighting/"/>
    
  </entry>
  
  <entry>
    <title>【基本算法】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/03/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/03/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%91/</id>
    <published>2024-03-03T02:27:16.000Z</published>
    <updated>2024-03-31T13:17:31.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><h2 id="模板">模板</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403260909414.png"alt="image-20240306185054453" /><figcaption aria-hidden="true">image-20240306185054453</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// q[l...j] 均 &lt;=x , q[j...r] 均 &gt;=x</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不要轻易改动，非常容易出错</p></blockquote><span id="more"></span><blockquote><ul><li><p><strong>分界点的位置不一定是<code>x</code></strong>，因为<code>x</code>参与交换之后仍然会被留在左右区间中的一个里</p></li><li><p>这里考虑一个边界问题，为什么移动i和j指针的条件是q[i] &lt; x和q[j]&gt; x，而不是q[i] &lt;= x和q[j] &gt;= x ？</p><p>——因为如果选取的x是数组里最大的数，那么一直都满足q[i] &lt;=x，所以i会一直++发生越界都不会停下来。同理，如果选取的x是数组里最小的数，那么一直都满足q[j]&gt;= x，所以j会一直--发生越界都不会停下来</p></li><li><p>指针i和j初始化为数组两侧外一个元素，即i = l - 1，j = r +1，然后在数组中使用do-while循环每次先进行一次指针的移动，再去看循环条件。这里考虑一个边界问题，为什么不能让i= l和j = r然后使用while循环代替do-while循环 ？</p></li></ul><p>——因为如果数组中存在重复的数字，那么某一轮可能存在i和j都指向重复的数字，并且划分数字x也是这个数字，那么while(q[i] &lt; x)和while (q[j] &gt; x)判断不成立不会进入，又因为q[i] = q[j]=x，交换它们之后这个局面仍然不会改变，从而陷入死循环。所以要使用do-while循环，确保每次两个指针都至少会移动一步，以保证上一次交换的结果能被走掉</p><p><ahref="https://blog.csdn.net/SHU15121856/article/details/109839618">【算法学习笔记】8：快速排序中的边界问题_快速排序分界点-CSDN博客</a></p></blockquote><h2 id="例题">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7946447/">AcWing785. 快速排序 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7963364/">AcWing786. 第k个数 - AcWing</a></p></li></ul><h1 id="归并排序">归并排序</h1><h2 id="模板-1">模板</h2><ul><li>[ L , R ] =&gt; [ L , mid ] , [ mid + 1 , R ]</li><li>递归排序 [ L , mid ] 和 [ mid + 1 , R]</li><li>归并，将左右 2 个有序序列合并成 1 个有序序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> q[N], temp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归排序 [ L , mid ] 和 [ mid + 1 , R]</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并，将左右 2 个有序序列合并成 1 个有序序列</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j])<span class="comment">// 此处也可以是 &lt; ,但在某些情况下只能是 &lt;=</span></span><br><span class="line">            tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7946634/">AcWing787. 归并排序 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7962764/">AcWing788. 逆序对的数量 - AcWing</a></p></li></ul><h1 id="二分">二分</h1><ul><li>只要一个序列满足在某一<font color='red'>分割点</font><strong>左侧满足性质A</strong>，<strong>右侧满足性质B</strong>，就可以使用二分求出这个边界</li></ul><h2 id="整数二分">整数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403260942345.jpeg"alt="57ac86165a5b843d61595f2983a9be5" /><figcaptionaria-hidden="true">57ac86165a5b843d61595f2983a9be5</figcaption></figure><p>:smile:具体使用时：</p><ul><li>首先确定性质A、性质B、我们要求的是 <strong>满足性质A的边界</strong>or <strong>满足性质B的边界</strong></li><li>然后编写check函数，<code>mid = l + r &gt;&gt; 1</code><ul><li>求满足性质A的边界：<ul><li>check(mid满足性质A) <code>l=mid</code></li><li>check(mid不满足性质A) <code>r=mid-1</code></li><li>改为<code>mid = l + r + 1 &gt;&gt; 1</code></li></ul></li><li>求满足性质B的边界：<ul><li>check(mid满足性质B) <code>r=mid</code></li><li>check(mid不满足性质B) <code>l=mid+1</code></li></ul></li></ul></li></ul><p>:tada:注意</p><ul><li>二分的循环的条件是<code>i &lt; j</code>，当<code>l = r</code>时，循环结束，返回<code>l</code></li><li>所有用到二分思想的算法，循环条件都是<strong>小于</strong>，而不是<strong>小于等于</strong></li></ul><p>🌮技巧</p><ul><li>上述模板<strong>题目</strong>需要保证<strong>边界一定存在</strong>，否则就会出错，具体而言：<ul><li>如果我们求的是满足<strong>左侧性质A</strong>的边界，但是区间<code>[l,r]</code>均不满足性质A，那么就会返回区间的<strong>最左侧端点<code>l</code></strong></li><li>如果我们求的是满足<strong>右侧性质B</strong>的边界，但是区间<code>[l,r]</code>均不满足性质B，那么就会返回区间的<strong>最右侧端点<code>r</code></strong></li></ul></li><li>因此，如果题目<strong>不能确保边界一定存在</strong>，我们有 2种处理办法</li></ul><ol type="1"><li><p><strong>二分结束后进行判断</strong>【推荐】</p><ol type="1"><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质A</strong>的边界，但是返回的边界不满足<strong>性质A</strong>（<code>check(l)</code>返回<code>false</code>），说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质A</strong>的边界</li><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质B</strong>的边界，但是返回的边界不满足<strong>性质B</strong>（<code>check(l)</code>返回<code>false</code>），说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质B</strong>的边界</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="built_in">bsearch</span>(l, r);</span><br><span class="line"><span class="keyword">if</span>(l &lt;= r &amp;&amp; <span class="built_in">check</span>(k))</span><br><span class="line"><span class="comment">/* k为边界 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 不存在边界 */</span></span><br></pre></td></tr></table></figure></li><li><p>在<strong>二分开始前设置哨兵</strong>【不推荐】</p><ol type="1"><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质A</strong>的边界，则设置哨兵a[l-1]，随便赋值使<code>a[l-1]</code>满足性质A，然后将搜索区间改为<code>[l-1,r]</code>，这样当<code>返回边界=l-1</code>时，说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质A</strong>的边界</li><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>右侧性质B</strong>的边界，则设置哨兵a[l-1]，随便赋值使<code>a[r+1]</code>满足性质B，然后将搜索区间改为<code>[l,r+1]</code>，这样当<code>返回边界=r+1</code>时，说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质B</strong>的边界</li></ol></li></ol><h2 id="浮点数二分">浮点数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>; <span class="comment">// eps 表示精度，取决于题目对精度的要求，通常比题目精度高2位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-2">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7945110/">AcWing789. 数的范围 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7945336/">AcWing790. 数的三次方根 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/binary-search/description/">704.二分查找 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-a-2d-matrix/description/">74.搜索二维矩阵 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240.搜索二维矩阵 II - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.在排序数组中查找元素的第一个和最后一个位置 -力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33.搜索旋转排序数组 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">153.寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p></li></ul><h1 id="高精度">高精度</h1><ul><li>当数据过大时，此时longlong存储不下，因此需要使用vector或者数组存储，然后计算</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261025399.jpeg" alt="8147590f449a6d0077d9bd05a829853" style="zoom: 33%;" /></p><blockquote><ul><li>对于两个高精度数相乘/相除很少见，在此不予阐述</li><li>高精度数采用<strong>数组</strong>、从<font color='purple'><strong>个位向高位</strong></font>依次存储</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261025407.jpeg" alt="7f7747b40d2f813ace3c448acb250a5" style="zoom: 25%;" /></p><ul><li><p>一般vector或者数组中每个数据都是一个int，<strong>如果每个位置只是存储0~9一位数字的话，比较浪费空间，并且计算也会变慢</strong>。因此可以让每个位置存储连续的多位数字，这被称作<font color='red'><strong>压位</strong></font></p></li><li><p>压位和不压位的高精度计算存在三点不同点（以下提到的压位都是压4位）：</p><ol type="1"><li>存储：不压位的话，vector或者数组中每个数据是0 ~9；压位以后，每个数据是0 ~ 9999</li><li>计算过程：不压位的话，除数和模数都是10；压位以后，除数和模数都是10000</li><li>输出：不压位的话，直接输出；压位的话，需要格式化输出，<strong>最高位直接输出</strong>，<strong>其他位都需要输出4位数字，不足的前面补零</strong></li></ol></li><li><p>高精度<strong>加减</strong>法<strong>最多可以压 9位</strong>，高精度<strong>乘除</strong>法<strong>最多可以压 4位</strong>，这里为了演示，均以压4位为例，也就是说：vector或者数组中每个位置存储四个连续的数字</p></li></ul></blockquote><h2 id="高精度加法">高精度加法</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7947226/">AcWing791. 高精度加法 - AcWing</a>】</li></ul><h3 id="不压位">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % M);</span><br><span class="line">        t /= M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        B.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><ul><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/7947515/">AcWing792. 高精度减法 - AcWing</a>】</strong></li></ul><h3 id="不压位-1">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>(); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(A, B);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位-1">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 比较a, b大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line"></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + M) % M);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        B.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(A, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘低精度">高精度乘低精度</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7947712/">AcWing793. 高精度乘法 - AcWing</a>】</li></ul><h3 id="不压位-2">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位-2">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % M);</span><br><span class="line">        t /= M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除以低精度">高精度除以低精度</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7947725/">AcWing794. 高精度除法 - AcWing</a></li></ul><h3 id="不压位-3">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位-3">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * M + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C.<span class="built_in">back</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前缀和差分">前缀和&amp;&amp;差分</h1><ul><li><p><strong>前缀和</strong> 与 <strong>差分</strong>是一对<font color='red'><strong>逆运算</strong></font></p><ul><li>前缀和最用：求某一区域/区间 的和</li><li>差分作用：将某一区域/区间内的数全部<strong>加上/减去指定数值</strong></li></ul></li><li><p>差分序列通常<strong>不需要构建</strong>：</p><ul><li>将<strong>前缀和序列</strong>、<strong>差分序列</strong>均初始化为0（满足前缀和定义）</li><li>然后将原始数据<strong>依次插入</strong>前缀和序列，即可自动更新差分序列</li></ul></li><li><p><font color='red'><strong>原始数据 a[ ]，前缀和 S[ ]，差分序列 B[] 都是从下标 1 开始存储的</strong></font></p></li><li><p><strong>原数据 <code>a[ ]</code></strong>与<strong>前缀和<code>S[ ]</code></strong>，<strong>原数据<code>a[ ]</code></strong>与<strong>差分序列<code>B[ ]</code></strong>没有实时联动关系，<strong>对某一数组操作以后需要通过手动操作同步</strong></p></li></ul><h2 id="一维前缀和">一维前缀和</h2><ul><li><strong>定义：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i], S[<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><strong>性质：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i] = S[i - <span class="number">1</span>] + a[i]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1]</span><br></pre></td></tr></table></figure><blockquote><p>切记：前缀和 S 从下标 1 开始，S[0] = 0 用来解决边界问题</p></blockquote><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7948798/">AcWing795. 前缀和 - AcWing</a>】</li></ul><h2 id="二维前缀和">二维前缀和</h2><ul><li><strong>定义：</strong></li></ul><p><span class="math display">\[S\left[ x \right] \left[ y \right] =\sum_{i=1}^x{\sum_{j=1}^y{a\left[ i\right] \left[ j \right]}}\]</span></p><ul><li><strong>性质：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]</span><br></pre></td></tr></table></figure><p>​ 以 <span class="math inline">\((x1, y1)\)</span> 为左上角， <spanclass="math inline">\((x2, y2)\)</span> 为右下角的子矩阵的和为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032157.png" alt="image-20240305172624211" style="zoom: 15%;" /></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7949245/">AcWing796. 子矩阵的和 - AcWing</a>】</li></ul><h2 id="一维差分">一维差分</h2><ul><li><strong>定义：</strong>【不用记，用不到】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i] = a[i] - a[i - 1], B[0] = 0</span><br></pre></td></tr></table></figure><ul><li><strong>性质：</strong><code>a[]</code>是<code>B[]</code>的前缀和，<code>B[]</code>是<code>a[]</code>的差分，所以：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i] = B[<span class="number">1</span>] + B[<span class="number">2</span>] + ... B[i]</span><br><span class="line">a[i] = a[i<span class="number">-1</span>] + B[i]</span><br></pre></td></tr></table></figure><p>:smile:以上​实际上是前缀和的定于与性质</p><ul><li><strong>操作：</strong>给区间 <span class="math inline">\([l,r]\)</span> 中的每个数加上 <span class="math inline">\(c\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[l] += c;</span><br><span class="line">    B[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7949620/">AcWing797. 差分 - AcWing</a>】</li></ul><h2 id="二维差分">二维差分</h2><ul><li><strong>定义：</strong>【不用记，用不到】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i][j] = a[i][j] - a[i - <span class="number">1</span>][j] - a[i][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>性质：</strong><code>a[][]</code>是<code>B[][]</code>的前缀和，<code>B[][]</code>是<code>a[][]</code>的差分，因此：</li></ul><p><span class="math display">\[a\left[ i \right] \left[ j \right] =\sum_{i=1}^n{\sum_{j=1}^m{B\left[ i\right] \left[ j \right]}}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j] = a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>] + B[i][j];</span><br></pre></td></tr></table></figure><p>:smile:以上实际上是前缀和的定于与性质</p><ul><li><strong>操作：</strong>给以(x1, y1)为左上角，(x2,y2)为右下角的子矩阵中的所有元素加上c：</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032057.png" alt="20201217174836198.png" style="zoom:30%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[x1][y1] += c;</span><br><span class="line">    B[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032099.png"alt="20201217170336254.png" /><figcaption aria-hidden="true">20201217170336254.png</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7954891/">AcWing798. 差分矩阵 - AcWing</a>】</li></ul><h1 id="双指针">双指针</h1><h2 id="模板-2">模板</h2><ul><li><p>双指针的主要<strong>作用</strong>是 ——<strong>优化时间复杂度</strong>，通常可以将时间复杂度从 <spanclass="math inline">\(O(n^2)\)</span> 优化到 <spanclass="math inline">\(O(n)\)</span></p></li><li><p>可以从朴素思想开始，思考两个指针是否具有某种性质，eg：<strong>分类：</strong></p></li></ul><ol type="1"><li>对于<strong>一个序列</strong></li></ol><ul><li>2 个指针一前一后【快慢指针】，用两个指针维护一段区间，2个指针<strong>均只能向前移动</strong>，而不能向后移动</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312109496.png"alt="image-20240331210906340" /><figcaption aria-hidden="true">image-20240331210906340</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 快指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动慢指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= i &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 慢指针 j 移动后的操作 */</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描，<spanclass="math inline">\(j\)</span> 指针<strong>从后往前</strong>扫描</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312117865.png"alt="image-20240331211703704" /><figcaption aria-hidden="true">image-20240331211703704</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= i &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 指针 j 移动后的操作 */</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>对于<strong>两个序列</strong>，2 个指针分别指向 2个序列，维护某种次序</li></ol><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描 <span class="math inline">\(A\)</span>序列，<span class="math inline">\(j\)</span>指针<strong>从后往前</strong>扫描 <span class="math inline">\(B\)</span>序列</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312055114.png"alt="image-20240331205557944" /><figcaption aria-hidden="true">image-20240331205557944</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 指针 j 移动后的操作*/</span></span><br><span class="line">        j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描 <span class="math inline">\(A\)</span>序列，<span class="math inline">\(j\)</span>指针<strong>从后往前</strong>扫描 <span class="math inline">\(B\)</span>​序列</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312057578.png"alt="image-20240331205747366" /><figcaption aria-hidden="true">image-20240331205747366</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i 指针移动后的操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否要移动 j 指针</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* j 指针移动后的操作 */</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>举例：分行输出字符串</strong></li></ul><p>​给你一个字符串，请将其中的每个单词依次输出（假设字符串开头没有空格，且单词之间有且仅有一个空格）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">            cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-3">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7957914/">AcWing799. 最长连续不重复子序列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7958047/">AcWing800. 数组元素的目标和 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7958255/">AcWing2816. 判断子序列 - AcWing</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum/description/">15.三数之和 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/container-with-most-water/description/">11.盛最多水的容器 - 力扣（LeetCode）</a></p></li></ul><h1 id="位运算">位运算</h1><h2 id="模板-3">模板</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261639341.jpg"alt="aa5212f8f0993c186015d618c0e496e" /><figcaptionaria-hidden="true">aa5212f8f0993c186015d618c0e496e</figcaption></figure><ul><li>求 <span class="math inline">\(x\)</span> 二进制的第 <spanclass="math inline">\(k\)</span> 位数字：<ol type="1"><li>先把第 <span class="math inline">\(k\)</span> 位移到最后一位 <spanclass="math inline">\(x&gt;&gt;k\)</span></li><li>看个位是几 <span class="math inline">\(x \&amp; 1\)</span></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt;&gt; k &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>返回 <span class="math inline">\(x\)</span> 的最后一位1：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lowbit</span>(x) = x &amp; -x</span><br></pre></td></tr></table></figure><p><span class="math display">\[x=\left( 1010 \right) _2\Rightarrow lobit\left( x \right) =\left( 10\right) _2\\x=\left( 101000 \right) _2\Rightarrow lobit\left( x \right) =\left( 1000\right) _2\]</span></p><blockquote><p>最常见的应用：统计某个二进制数中 1 的个数</p></blockquote><ul><li>将 x 乘以 <span class="math inline">\(2^k\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&lt; k</span><br><span class="line"><span class="comment">// eg: 2^k 可以表示为 2 &lt;&lt; k</span></span><br></pre></td></tr></table></figure><h2 id="例题-4">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7958394/">AcWing801. 二进制中1的个数 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/single-number/description/">136.只出现一次的数字 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/subsets/description/">78.子集 - 力扣（LeetCode）</a></p></li></ul><h1 id="离散化">离散化</h1><h2 id="模板-4">模板</h2><ul><li><p>本质：建立了<strong>一段数列</strong>到<strong>自然数</strong>之间的映射关系（value-&gt;index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作（比如二分，前缀和等…）</p></li><li><p>离散化首先需要排序去重：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 排序：sort(alls.begin(),alls.end())</span><br><span class="line"><span class="number">2.</span> 去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());    </span><br></pre></td></tr></table></figure><ul><li>适用条件：<font color='red'><strong>值域 ＞个数</strong></font></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261049242.png" alt="image-20240306123731542" style="zoom: 25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls;                                         <span class="comment">// 存储所有【待离散化的值】</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());                           <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-5">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7958787/">AcWing802. 区间和 - AcWing</a></li></ul><h1 id="区间合并">区间合并</h1><h2 id="模板-5">模板</h2><ul><li>将所有存在交集的区间合并</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261048486.png" alt="image-20240306142625082" style="zoom: 25%;" /></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7960049/">AcWing803. 区间合并 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://www.acwing.com/activity/content/code/content/8155307/">AcWing895. 最长上升子序列 - AcWing</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;快速排序&lt;/h1&gt;
&lt;h2 id=&quot;模板&quot;&gt;模板&lt;/h2&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403260909414.png&quot;
alt=&quot;image-20240306185054453&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20240306185054453&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quick_sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; q[], &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; l, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; r)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l &amp;gt;= r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = l - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j = r + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, x = q[l + r &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (q[i] &amp;lt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (q[j] &amp;gt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;swap&lt;/span&gt;(q[i], q[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// q[l...j] 均 &amp;lt;=x , q[j...r] 均 &amp;gt;=x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;quick_sort&lt;/span&gt;(q, l, j), &lt;span class=&quot;built_in&quot;&gt;quick_sort&lt;/span&gt;(q, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;不要轻易改动，非常容易出错&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cuiluyi.gitee.io/2024/03/01/[object%20Object]/project/"/>
    <id>https://cuiluyi.gitee.io/2024/03/01/[object%20Object]/project/</id>
    <published>2024-03-01T10:43:06.350Z</published>
    <updated>2024-03-19T07:07:53.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="result">Result</h1><h2 id="baseline">baseline：</h2><ul><li><a href="https://arxiv.org/abs/1602.05629">FedAvg</a> (Hugh BrendanMcMahan et al., AISTATS 2017)</li><li><a href="https://arxiv.org/abs/2007.07481">FedNova</a> (Jianyu Wanget al., NeurIPS 2020) <ahref="https://github.com/JYWa/FedNova">:octocat:</a></li><li><a href="https://arxiv.org/abs/1812.06127">FedProx</a> (Tian Li etal., MLSys 2020) <ahref="https://github.com/litian96/FedProx">:octocat:</a></li><li><a href="https://arxiv.org/abs/1910.06378">SCAFFOLD</a> (SaiPraneeth Karimireddy et al.,ICML 2020) <ahref="https://github.com/ki-ljl/Scaffold-Federated-Learning">:octocat:</a></li></ul><h2 id="数据集">数据集</h2><ul><li>MNIST</li><li>Fashion-MNIST</li></ul><h2 id="模型">模型</h2><ul><li>LeNet</li><li>AlexCifarNet</li><li>ResNet18/34/50/101/152</li><li>CNN</li></ul><span id="more"></span><h2 id="可视化">可视化</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091907015.png"alt="image-20240309190716897" /><figcaption aria-hidden="true">image-20240309190716897</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091908515.png"alt="image-20240309190826462" /><figcaption aria-hidden="true">image-20240309190826462</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091909686.png"alt="image-20240309190936633" /><figcaption aria-hidden="true">image-20240309190936633</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091910062.png"alt="image-20240309191039009" /><figcaption aria-hidden="true">image-20240309191039009</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;result&quot;&gt;Result&lt;/h1&gt;
&lt;h2 id=&quot;baseline&quot;&gt;baseline：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1602.05629&quot;&gt;FedAvg&lt;/a&gt; (Hugh Brendan
McMahan et al., AISTATS 2017)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/2007.07481&quot;&gt;FedNova&lt;/a&gt; (Jianyu Wang
et al., NeurIPS 2020) &lt;a
href=&quot;https://github.com/JYWa/FedNova&quot;&gt;:octocat:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1812.06127&quot;&gt;FedProx&lt;/a&gt; (Tian Li et
al., MLSys 2020) &lt;a
href=&quot;https://github.com/litian96/FedProx&quot;&gt;:octocat:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1910.06378&quot;&gt;SCAFFOLD&lt;/a&gt; (Sai
Praneeth Karimireddy et al.,ICML 2020) &lt;a
href=&quot;https://github.com/ki-ljl/Scaffold-Federated-Learning&quot;&gt;:octocat:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;数据集&quot;&gt;数据集&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MNIST&lt;/li&gt;
&lt;li&gt;Fashion-MNIST&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;模型&quot;&gt;模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LeNet&lt;/li&gt;
&lt;li&gt;AlexCifarNet&lt;/li&gt;
&lt;li&gt;ResNet18/34/50/101/152&lt;/li&gt;
&lt;li&gt;CNN&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>【搜索】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/29/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/29/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91/</id>
    <published>2024-02-29T07:23:16.000Z</published>
    <updated>2024-03-30T02:03:21.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dfs">DFS</h1><h2 id="连通性模型">连通性模型</h2><h2 id="搜索顺序">搜索顺序</h2><h2 id="剪枝与优化">剪枝与优化</h2><h2 id="迭代加深">迭代加深</h2><h2 id="双向dfs">双向DFS</h2><h2 id="ida">IDA*</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7993461/">AcWing842. 排列数字 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7994793/">AcWing843. n-皇后问题 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/word-search/description/">79.单词搜索 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/rotting-oranges/">994.腐烂的橘子 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/generate-parentheses/description/">22.括号生成 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/combination-sum/">39.组合总和 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17.电话号码的字母组合 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&amp;envId=top-100-liked">78.子集 - 力扣（LeetCode）</a></p></li></ul><h1 id="bfs">BFS</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403300912028.png" alt="image-20240330091250874" style="zoom: 25%;" /></p><p><code>BFS</code> 通常用于“<strong>求最小</strong>”，相较于<code>DFS</code> 是基于<strong>迭代</strong>，不会发生爆栈</p><h2 id="flood-fill">Flood FIll</h2><ul><li>洪水覆盖算法，技巧在于使用类似于下面的代码，进行<strong>不同方向的搜索</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4 联通</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 联通</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟中国象棋中的“马”</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li><ahref="https://leetcode.cn/problems/number-of-islands/description/">200.岛屿数量 - 力扣（LeetCode）</a></li></ul><h2 id="最短路模型">最短路模型</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7996829/">AcWing844. 走迷宫 - AcWing</a></li></ul><h2 id="多源bfs">多源BFS</h2><h2 id="最小步数模型">最小步数模型</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8218005/">AcWing845. 八数码 - AcWing</a></li></ul><h2 id="双端队列广搜">双端队列广搜</h2><h2 id="双向bfs">双向BFS</h2><h2 id="a">A*</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dfs&quot;&gt;DFS&lt;/h1&gt;
&lt;h2 id=&quot;连通性模型&quot;&gt;连通性模型&lt;/h2&gt;
&lt;h2 id=&quot;搜索顺序&quot;&gt;搜索顺序&lt;/h2&gt;
&lt;h2 id=&quot;剪枝与优化&quot;&gt;剪枝与优化&lt;/h2&gt;
&lt;h2 id=&quot;迭代加深&quot;&gt;迭代加深&lt;/h2&gt;
&lt;h2 id=&quot;双向dfs</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Tag】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90tag%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90tag%E3%80%91/</id>
    <published>2024-02-28T07:23:16.000Z</published>
    <updated>2024-03-28T00:30:10.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tag">Tag</h1><h2 id="二分差分">二分+差分</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8212454/">AcWing503. 借教室（每日一题） - AcWing</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tag&quot;&gt;Tag&lt;/h1&gt;
&lt;h2 id=&quot;二分差分&quot;&gt;二分+差分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a
href=&quot;https://www.acwing.com/activity/content/code/content/8212454/&quot;&gt;AcWing
</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【贪心】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/</id>
    <published>2024-02-28T07:23:16.000Z</published>
    <updated>2024-03-29T12:28:55.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="区间问题">区间问题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8193086/">AcWing905. 区间选点 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8201655/">AcWing908. 最大不相交区间数量 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8200554/">AcWing906. 区间分组 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8203105/">AcWing907. 区间覆盖 - AcWing</a></li></ul><h2 id="huffman算法">Huffman算法</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206166/">AcWing148. 合并果子 - AcWing</a></li></ul><h2 id="排序不等式">排序不等式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206351/">AcWing913. 排队打水 - AcWing</a></li></ul><h2 id="绝对值不等式">绝对值不等式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206765/">AcWing104. 货仓选址 - AcWing</a></li></ul><h2 id="推公式">推公式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8208811/">AcWing125. 耍杂技的牛 - AcWing</a></li></ul><h2 id="其他">其他</h2><ul><li><p><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/jump-game/description/">55.跳跃游戏 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏 II - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/word-break/description/">139.单词拆分 - 力扣（LeetCode）</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;例题&quot;&gt;例题&lt;/h1&gt;
&lt;h2 id=&quot;区间问题&quot;&gt;区间问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a
href=&quot;https://www.acwing.com/activity/content/code/content/8193086/&quot;&gt;AcWing
905</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【图论】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/28/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91/</id>
    <published>2024-02-28T07:23:16.000Z</published>
    <updated>2024-04-01T07:31:52.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树与图的存储">树与图的存储</h1><ul><li>树是一种特殊的图，与图的存储方式相同<ul><li>树：<span class="math inline">\(n\)</span> 个顶点，最多有 <spanclass="math inline">\(m=n-1\)</span> 条边</li><li>图：<span class="math inline">\(n\)</span> 个顶点，无向图最多有<span class="math inline">\(m=n(n-1)/2\)</span> 条边，有向图最多有 <spanclass="math inline">\(m=n(n-1)\)</span> 条边<ul><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span>是一个量级的——<strong>稀疏图</strong></li><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n^2\)</span>​是一个量级的——<strong>稠密图</strong></li></ul></li></ul></li></ul><blockquote><p>eg：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稠密图</span></span><br><span class="line"><span class="number">1</span> ≤ n ≤ <span class="number">500</span>,</span><br><span class="line"><span class="number">1</span> ≤ m ≤ <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="comment">// 稀疏图</span></span><br><span class="line"><span class="number">1</span> ≤ n,m ≤ <span class="number">10</span>^<span class="number">5</span>,</span><br></pre></td></tr></table></figure></p></blockquote><span id="more"></span><ul><li>对于无向图中的边ab，存储两条有向边 <code>a-&gt;b</code>,<code>b-&gt;a</code> 即可。因此我们可以只考虑有向图的存储</li></ul><h2 id="邻接矩阵">邻接矩阵</h2><ul><li><p><code>g[a][b]</code> 存储边 <code>a-&gt;b</code></p></li><li><p><strong>空间复杂度</strong>：<spanclass="math inline">\(O(n^2)\)</span>，适合存储<strong>稠密图</strong></p></li></ul><h3 id="无权图">无权图</h3><ul><li><strong>自己到自己的边长</strong>以及<strong>不存在的边长</strong>均为 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b</span></span><br><span class="line">g[a][b] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span>(g[a][b])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有权图">有权图</h3><ul><li><strong>自己到自己的边长</strong>以及<strong>不存在的边长</strong>均为 <code>INF</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化邻接矩阵</span></span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b，权重为c</span></span><br><span class="line">g[a][b] = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span> (g[a][b] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有边的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有边的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="邻接表除非题目交代为稠密图我们更常用临界表">邻接表：【除非题目交代为稠密图，我们更常用临界表】</h2><ul><li><strong>空间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span>，适合存储<strong>稀疏图</strong></li></ul><h3 id="无权图-1">无权图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有权图-1">有权图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点 k，开一个单链表，存储 k 所有可以走到的点。</span></span><br><span class="line"><span class="comment">// h[k] 存储这个单链表的头结点, w[] 存储边的权重</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b,权重为c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><ul><li>自环、重边</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101605409.jpeg" style="zoom:20%;" /></p><h1 id="树与图的遍历">树与图的遍历</h1><ul><li><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>连通图遍历时只需要遍历任何一个点即可，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(1);</span><br><span class="line">bfs(1);</span><br></pre></td></tr></table></figure></li><li><p>非连通图遍历时要依次遍历所有点，确保能够遍历所有连通分量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">bfs</span>(i);</span><br></pre></td></tr></table></figure></li></ul><h2 id="深度优先遍历">深度优先遍历</h2><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>树</strong>的 dfs 可以<strong>不用</strong><code>st[]</code></li><li><strong>图</strong>的 dfs <strong>必须使用</strong><code>st[]</code></li></ul><h2 id="宽度优先遍历">宽度优先遍历</h2><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                st[j] = <span class="literal">true</span>; <span class="comment">// 表示点 j 已经被遍历过</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>树</strong>的 bfs 可以<strong>不用</strong><code>st[]</code></li><li><strong>图</strong>的 bfs <strong>必须使用</strong><code>st[]</code></li></ul><blockquote><p><strong>注意：</strong>这里的 st 可以有以下2种作用</p><ol type="1"><li>【必备】记录节点 i 是否已被访问</li><li>【可选】记录子问题的解（类似 DP问题中的<code>dp[]</code>），此时通常在<code>dfs()</code> /<code>bfs()</code>最前面加一句<code>memset(st,-1,sizeof st);</code></li></ol></blockquote><h2 id="例题">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8006099/">AcWing846. 树的重心 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8007322/">AcWing847. 图中点的层次 - AcWing</a></li></ul><h1 id="拓扑排序">拓扑排序</h1><ul><li>理论表明：<font color='red'><strong>有向无环图</strong></font>一定有拓扑排序（拓扑图又叫<font color='red'><strong>有向无环图</strong></font>）</li><li>时间复杂度：<span class="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8010400/">AcWing848. 有向图的拓扑序列 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界矩阵存储</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// d[i] 存储点 i 的入度</span></span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始时：所有入度为零的点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 t 的所有出边，并更新入度d[], 队列q[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图的同时初始化 d[]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y);</span><br><span class="line">    d[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在拓扑排序，输出-1；否则输出其中的一个拓扑排序</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">toposort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路">最短路</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101426248.png"alt="image-20240310110004460" /><figcaption aria-hidden="true">image-20240310110004460</figcaption></figure><h2 id="朴素dijkstra算法">朴素Dijkstra算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131123733.png"alt="image-20240313112344516" /><figcaption aria-hidden="true">image-20240313112344516</figcaption></figure><ul><li>时间复杂度：<span class="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>朴素Dijkstra算法适合于<strong>稠密图</strong>：采用<strong>邻接矩阵</strong>存储</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8010586/">AcWing849. Dijkstra求最短路 I - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每循环一次,就会找到一条最短路径,循环n-1次,最后一个的dist一定也是最短的，当然你写n也是完全没问题的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明最短路不存在（即非连通图）</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆优化版dijkstra">堆优化版dijkstra</h2><ul><li>时间复杂度：<span class="math inline">\(O(mlogn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8046169/">AcWing850. Dijkstra求最短路 II - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                            <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bellman-ford算法">Bellman-Ford算法</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131128358.png" alt="image-20240313112833199" style="zoom:33%;" /></p><ul><li>如果图中存在负权回路，最短路<strong>不一定</strong>存在<ul><li>如果负环不在从 1 号点到 n 号点的路径上的话，就没有影响</li><li>如果题目限制了<strong>最短路边的个数</strong>（即不能无限转），则一定存在最短路径</li></ul></li><li>Bellman-Ford算法迭代 k 次，dist[]表示从1号点，经过<font color='red'><strong>不超过k条边</strong></font>，走到每个点的最短距离</li><li>Bellman-Ford算法可以判断图中是否存在负权回路<ul><li>迭代 n 次，第 n次仍有最短距离更新的话，说明存在一条边数为n的最短路径</li><li>n 个点最多有 n-1 条边，所以一定存在一个负权回路</li></ul></li><li>时间复杂度：<span class="math inline">\(O(nm)\)</span>​</li></ul><blockquote><p><strong><font color='red'>由于 Bellman-Ford算法只需要在每次循环中，对所有边进行遍历，因此我们可以采用结构体数组存储边的集合即可，不需要存储图</font></strong></p></blockquote><h3 id="有边数限制的bellman-ford算法">有边数限制的Bellman-Ford算法</h3><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8048290/">AcWing853. 有边数限制的最短路 - AcWing</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, k;   <span class="comment">// n表示点数，m表示边数，k表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N];   <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="type">int</span> backup[N]; <span class="comment">// back[x]存储上次循环中，1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边，a表示出点，b表示入点，c表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 k 次，最短路最多经历 k 条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>last[]</code>是备份数组，用于存储上次迭代的结果，用上次迭代的结果更新当前的距离，防止发生串联</p></li><li><p>为什么需要使用 <code>last[]</code> ?</p></li></ul><blockquote><p>​ 为了避免如下的串联情况，在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452123.png" alt="2.PNG" style="zoom:45%;" /></p><p>​ 正确做法是用上轮节点2更新的距离--无穷大，来更新节点3，再取最小值，所以节点3离起点的距离是3。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452285.png" alt="3.PNG" style="zoom:45%;" /></p></blockquote><ul><li><p>为什么是<code>dist[n] &gt; 0x3f3f3f3f/2</code>，而不是<code>dist[n] &gt; 0x3f3f3f3f</code></p><blockquote><p>​ 5 号节点距离起点的距离是无穷大，利用 5 号节点更新 n号节点距离起点的距离，将得到<spanclass="math inline">\(10^9-2\)</span>，虽然小于<spanclass="math inline">\(10^9\)</span>，但并不存在最短路(在边数限制在k条的条件下)</p></blockquote></li></ul><h3id="没有边数限制的bellman-ford算法">没有边数限制的Bellman-Ford算法</h3><ul><li>实际上是“有边数限制的Bellman-Ford算法”的特殊情况，这是的边数限制是 n，但是不需要使用 backup 数组，因为最短路上最多也就是 n个顶点，即使串联也没关系</li><li>可以用于判读是否存在负权路</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;    <span class="comment">// n表示点数，m表示边数，k表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边，a表示出点，b表示入点，c表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第 n 次迭代仍然会松弛三角不等式，就说明存在一条长度是 n+1 的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], dist[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spfa-算法">spfa 算法</h2><p>​ spfa算法是<strong>队列优化</strong>的<strong>Bellman-Ford</strong>算法</p><h3 id="求最短路">求最短路</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131416112.png"alt="image-20240313141627490" /><figcaption aria-hidden="true">image-20240313141627490</figcaption></figure><ul><li>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</li><li>Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是<font color='red'><strong>SPFA算法不可以存在负权回路</strong></font>，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</li><li>时间复杂度：<ul><li>平均情况下 <span class="math inline">\(O(m)\)</span></li><li>最坏情况下 <span class="math inline">\(O(nm)\)</span>​</li></ul></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8050444/">AcWing851. spfa求最短路 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">// 从队列中取出来之后该节点st被标记为false，之后该节点如果发生更新可再次入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>⭐️为什么 Bellman_ford 算法里最后 <code>return -1</code>的判断条件写的是 <code>dist[n] &gt; 0x3f3f3f3f/2</code>，而 spfa算法写的是<code>dist[n]==0x3f3f3f3f</code>？</li></ul><blockquote><p>​原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p></blockquote><ul><li>st数组的作用是什么？</li></ul><blockquote><p>​判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。</p></blockquote><ul><li>SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</li></ul><blockquote><ol type="1"><li>Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。</li><li>Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</li></ol></blockquote><ul><li>由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为<spanclass="math inline">\(O(nm)\)</span>，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)</li></ul><h3 id="判断负环">判断负环</h3><ul><li><p><strong>求负环一般使用SPFA算法</strong>，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环</p></li><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8051410/">AcWing852. spfa判断负环 - AcWing</a>】</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];              <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的边数</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组（因为如果存在负环，那么dist不管初始化为多少，都会被更新）</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么把所有点入队?</li></ul><blockquote><p>​我们可以假设一个虚拟源点0点，从虚拟源点连一条权值是0的边到所有点，这样这个新图其实是和原图等价的（原图上有负环等价于新图上有负环），那我们做spfa的时候首先把0入队，第一次迭代的时候会把0出队，然后把和0点相连的点全部入队，那么就相当于把1~n的所有点入队，所以我们直接把所有点入队，效果是一样的，相当于自己手动迭代了一次spfa.</p></blockquote><ul><li>dist[]为什么初始化为什么值都无所谓？</li></ul><blockquote><p>​假设有负环，那么负环上的点到虚拟源点0的距离一定是-INF对不对，因为我可以在负环上跑无限次，每次都能把我到0点的距离减小。然后因为边上的权值都是有限值，所以每次在负环上跑一圈就相当于dt[]减去一个有限值，最终dt[]==-INF，所以意味着会减无限次（简单明了的说就是我们在负环上跑无限次，就可以把我到0点的距离减成-INF）。重点来了，dt[]初值肯定是一个有限值，一个有限值每次减一个有限值（负环上跑一次），然后减无限次，最终dt[]减成-INF。即dt[]初值是多少都无所谓，因为会减无限次有限值，你再大的数减无限次有限值肯定减成-INF。我们只要用抽屉原理保证迭代超过n次的时候，说明路径上有起码n+1个点，说明有重复点，即有负环就行。所以我们甚至可以把判断条件改为cnt[j]&gt; 99999都行，只要大于n。</p></blockquote><h2 id="floyd算法">Floyd算法</h2><ul><li>Floyd算法的原理是<strong>动态规划</strong>，在代码实现的时候省去了一维状态。<ul><li><p><code>f[i, j, k]</code>：从<code>i</code>走到<code>j</code>的路径上除了<code>i</code>、<code>j</code>以外不包含点<code>k</code>的所有路径的最短距离</p></li><li><p>```c f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k- 1] <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -   因此在计算第`k`层的`f[i, j]`的时候必须先将第`k - 1`层的所有状态计算出来，所以需要把`k`放在最外层</span><br><span class="line"></span><br><span class="line">-   `d[i][j]`</span><br><span class="line"></span><br><span class="line">    -   含义：**&lt;font color=&#x27;red&#x27;&gt;从【顶点i 】到 【顶点j】 的最短路径长度&lt;/font&gt;**`</span><br><span class="line">    -   初值：</span><br><span class="line">        -   `d[i][i] = 0`【Caution!】</span><br><span class="line">        -   若 a -&gt; b 存在一条边，权重为 c，则 `d[a][b] = c`</span><br><span class="line">        -   其余的 `d[i][i] = INF`</span><br><span class="line"></span><br><span class="line">-   **时间复杂度**：$O(n+m)$ ，$n$ 表示点数，$m$​ 表示边数</span><br><span class="line"></span><br><span class="line">-   先循环 `k` ，再循环 `i` 、 `j`（ `i` 、 `j` 顺序可以颠倒），每层循环遍历所有的顶点，下面的模板顶点编号从 1 开始。如果顶点编号从 0 开始，每层循环从 `0 -&gt; n - 1` 即可</span><br><span class="line"></span><br><span class="line">-   【**模板题：**[AcWing 854. Floyd求最短路 - AcWing](https://www.acwing.com/activity/content/code/content/8055095/)】</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">// 初始化</span><br><span class="line">memset(d, 0x3f, sizeof d);</span><br><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    d[i][i] = 0;</span><br><span class="line"></span><br><span class="line">// 算法结束后，d[a][b]表示 a 到 b 的最短距离</span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for (int k = 1; k &lt;= n; k++)</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)</span><br><span class="line">            for (int j = 1; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><h1 id="最小生成树">最小生成树</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131944187.png"alt="image-20240313194446005" /><figcaption aria-hidden="true">image-20240313194446005</figcaption></figure><ul><li>最小生成树是针对无向图的</li><li><strong>连通图</strong>一定存在最小生成树</li><li><strong><span class="math inline">\(n\)</span></strong>个顶点的无向连通图，最小生成树的边数为 <strong><spanclass="math inline">\(n - 1\)</span></strong></li></ul><h2 id="prim算法">Prim算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131953561.png"alt="image-20240313195326359" /><figcaption aria-hidden="true">image-20240313195326359</figcaption></figure><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8055703/">AcWing858. Prim算法求最小生成树 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;       <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF, 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[t] == INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal算法">Kruskal算法</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403132026795.png" alt="image-20240313202628601" style="zoom: 33%;" /></p><ul><li><p>Kruskal算法使用到了<strong>并查集</strong></p></li><li><p><strong><font color='red'>由于 Kruskal算法只需要在每次循环中，对所有边进行遍历，因此我们可以采用结构体数组存储边的集合即可，不需要存储图</font></strong></p></li><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>【<ahref="https://www.acwing.com/activity/content/code/content/8056398/">AcWing859. Kruskal算法求最小生成树 - AcWing</a>】</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m; <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; W.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集核心操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(edges, edges + m, [](Edge x, Edge y)</span><br><span class="line">         &#123; <span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res表示最小生成树的权重之和，cnt表示最小生成树集合中边的数量</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += c;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的数量小于n-1，说明图是非连通图，不存在最小生成树</span></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分图">二分图</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131944501.png"alt="image-20240313194459355" /><figcaption aria-hidden="true">image-20240313194459355</figcaption></figure><ul><li>二分图当且仅当<font color='red'><strong>图中不含奇数环</strong></font></li><li>二分图不一定是连通图</li></ul><h2 id="判断是否为二分图染色法">判断是否为二分图——染色法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> i 未染色</span><br><span class="line">        dfs(i, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8056401/">AcWing860. 染色法判定二分图 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;                   <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];               <span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数：u表示当前节点，c表示当前点的颜色 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">// u 点染成颜色 c</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 相邻的点没有颜色,则递归处理这个相邻点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="comment">// （3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）</span></span><br><span class="line">                                <span class="comment">// （3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="comment">// 如果已经染色，判断颜色是否为 c</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 作用：染色法判断是否为二分图 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二分图不一定是连通图，所以要依次对每个点遍历判断，而不能直接 dfs(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>)) <span class="comment">// 第一次染色的一定是某个连通分量中的第一个点，所以染成颜色 1/2 都可以，然后调用dfs即可将其所在连通分量的所以点染色</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="求二分图的最大匹配匈牙利算法">求二分图的最大匹配——匈牙利算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403141306955.gif"alt="匈牙利算法" /><figcaption aria-hidden="true">匈牙利算法</figcaption></figure><ul><li>第一个集合表示男生，第二个集合表示女生</li><li>匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8060126/">AcWing861. 二分图的最大匹配 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;                 <span class="comment">// n1表示第一个集合中男生人数，n2表示第二个集合中女生人数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];               <span class="comment">// match[i]表示第二个集合中点i当前匹配的第一个集合中的点</span></span><br><span class="line"><span class="type">bool</span> st[N];                 <span class="comment">// 表示第二个集合中的每个点是否已经被考虑过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果妹子还没有匹配任何男生 或者 匹配的那个男生可以更换妹子</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="comment">// 第一个集合中的点i能找到对应的匹配</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">        res++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;树与图的存储&quot;&gt;树与图的存储&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;树是一种特殊的图，与图的存储方式相同
&lt;ul&gt;
&lt;li&gt;树：&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个顶点，最多有 &lt;span
class=&quot;math inline&quot;&gt;&#92;(m=n-1&#92;)&lt;/span&gt; 条边&lt;/li&gt;
&lt;li&gt;图：&lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt; 个顶点，无向图最多有
&lt;span class=&quot;math inline&quot;&gt;&#92;(m=n(n-1)/2&#92;)&lt;/span&gt; 条边，有向图最多有 &lt;span
class=&quot;math inline&quot;&gt;&#92;(m=n(n-1)&#92;)&lt;/span&gt; 条边
&lt;ul&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(m&#92;)&lt;/span&gt; 和 &lt;span
class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;
是一个量级的——&lt;strong&gt;稀疏图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(m&#92;)&lt;/span&gt; 和 &lt;span
class=&quot;math inline&quot;&gt;&#92;(n^2&#92;)&lt;/span&gt;​
是一个量级的——&lt;strong&gt;稠密图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 稠密图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ≤ n ≤ &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ≤ m ≤ &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 稀疏图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ≤ n,m ≤ &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    <id>https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</id>
    <published>2024-02-25T05:59:27.000Z</published>
    <updated>2024-03-27T01:23:52.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h2><p>​ 给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="除自身以外数组的乘积"><ahref="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h2><p>​ 给你一个整数数组 <code>nums</code>，返回 <em>数组<code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code>中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><ul><li><p>题目数据 <strong>保证</strong> 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32位</strong> 整数范围内。</p></li><li><p>请 <strong>不要使用除法，</strong> 且在 <code>O(*n*)</code>时间复杂度内完成此题。</p></li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析</span></span><br><span class="line"><span class="comment">1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]</span></span><br><span class="line"><span class="comment">2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]  */</span></span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right */</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right = right * nums[i + <span class="number">1</span>];</span><br><span class="line">            v[i] *= right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;例题&quot;&gt;例题&lt;/h1&gt;
&lt;h2 id=&quot;轮转数组&quot;&gt;&lt;a
href=&quot;https://leetcode.cn/problems/rotate-array/&quot;&gt;轮转数组&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;​ 给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，将数组中</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵</title>
    <link href="https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/"/>
    <id>https://cuiluyi.gitee.io/2024/02/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/</id>
    <published>2024-02-24T17:02:27.000Z</published>
    <updated>2024-03-27T01:22:00.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="矩阵置零"><ahref="https://leetcode.cn/problems/set-matrix-zeroes/">矩阵置零</a></h2><p>​ 给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为<strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong>。请使用 <strong><ahref="http://baike.baidu.com/item/原地算法">原地</a></strong> 算法</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403270920185.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403270920199.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>​我们可以用<strong>两个标记数组</strong>分别记录<strong>每一行和每一列是否有零出现</strong>。具体地：</p><ol type="1"><li>我们首先遍历该数组一次，如果某个元素为 0，那么就将该元素所在的行和列所对应标记数组的位置置为<code>true</code></li><li>最后我们再次遍历该数组，用标记数组更新原数组即可</li></ol><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n)</span>, <span class="title">col</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                    row[i] = col[j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j])</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩阵旋转">矩阵旋转</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code>表示一个图像。请你将图像顺时针旋转 90 度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402241658478.png"alt="image-20240224165826279" /><figcaption aria-hidden="true">image-20240224165826279</figcaption></figure><p><strong>分析：</strong></p><p>原地旋转90度：</p><ol type="1"><li><p>沿主对角线所有元素交换</p></li><li><p>沿着垂直中轴线方向所有元素交换</p></li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/* 1.沿主对角线所有元素交换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2.沿着垂直中轴线方向所有元素交换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[i][n - <span class="number">1</span> - j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵">螺旋矩阵</h2><h3 id="螺旋矩阵-pat"><ahref="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805275146436608?type=7&amp;page=0">螺旋矩阵-PAT</a></h3><p>​ 本题要求将给定的 <em>N</em>个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 <em>m</em> 行<em>n</em> 列，满足条件：<em>m</em>×<em>n</em> 等于<em>N</em>；<em>m</em>≥<em>n</em>；且 <em>m</em>−<em>n</em>取所有可能值中的最小值。</p><p><strong>输入格式：</strong></p><p>输入在第 1 行中给出一个正整数 <em>N</em>，第 2 行给出 <em>N</em>个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。</p><p><strong>输出格式：</strong></p><p>输出螺旋矩阵。每行 <em>n</em> 个数字，共 <em>m</em> 行。相邻数字以 1个空格分隔，行末不得有多余空格。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">37 76 20 98 76 42 53 95 60 81 58 93</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">98 95 93</span><br><span class="line">42 37 81</span><br><span class="line">53 20 76</span><br><span class="line">58 60 76</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>填充时按层数填充，一个包裹矩阵的口字型为一层，计算螺旋矩阵的层数<code>level</code></li><li>如果 m 的值为偶数，层数为<code>m / 2</code>，如果 m为奇数，层数为<code>m / 2 + 1</code>，所以<code>level = m / 2 + m % 2</code></li><li>因为是从左上角第 1 个格子开始，按顺时针螺旋方向填充，所以外层 for循环控制层数 i 从 0 到 level，内层 for循环按左上到右上、右上到右下、右下到左下、左下到左上的顺序一层层填充，注意内层for循环中还要控制<code>t &lt;= N – 1</code>，因为如果螺旋矩阵中所有的元素已经都填充完毕，就不能再重复填充～</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402261637178.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">         &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算m、n</span></span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">for</span> (n = (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="built_in">double</span>(N)); n &gt;= <span class="number">1</span>; n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N % n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m = N / n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵赋值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">b</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> level = m / <span class="number">2</span> + m % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; N; j++)</span><br><span class="line">            b[i][j] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; N; j++)</span><br><span class="line">            b[j][n - <span class="number">1</span> - i] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - i - <span class="number">1</span>; j &gt;= i &amp;&amp; t &lt; N; j--)</span><br><span class="line">            b[m - <span class="number">1</span> - i][j] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; N; j--)</span><br><span class="line">            b[j][i] = a[t++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j != n - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-i"><ahref="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵 I</a></h3><p>​ 给你一个 <code>m</code> 行 <code>n</code> 列的矩阵<code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252318668.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252318904.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(m * n)</span></span>;</span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">max</span>(m, n) / <span class="number">2</span> + <span class="built_in">max</span>(m, n) % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                res[t++] = matrix[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                res[t++] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                res[t++] = matrix[m - <span class="number">1</span> - i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                res[t++] = matrix[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-ii"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h3><p>​ 给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的<code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252321434.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>分析：按照⼀个个矩阵的边框输入：<strong>x为矩阵的下界，n为矩阵的上界</strong>，每次输出这个围成的矩阵的<strong>第一行</strong>——<strong>最后一列</strong>——<strong>最后⼀行</strong>——<strong>第一列</strong>，然后将<strong>x⾃增1，m⾃减1</strong>～注意：为了避免重复输出，<strong>当x和n相等的时候，就输入一次第一行就可以，不用重复输入最后一行</strong>～</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402261132564.png" alt="image-20240226113203373" style="zoom:33%;" /></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> level = n / <span class="number">2</span> + n % <span class="number">2</span>, t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt;= n * n; j++)</span><br><span class="line">                res[i][j] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">2</span> - i &amp;&amp; t &lt;= n * n; j++)</span><br><span class="line">                res[j][n - <span class="number">1</span> - i] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt;= n * n; j--)</span><br><span class="line">                res[n - <span class="number">1</span> - i][j] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt;= n * n; j--)</span><br><span class="line">                res[j][i] = t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-iv"><ahref="https://leetcode.cn/problems/spiral-matrix-iv/">螺旋矩阵IV</a></h3><p>给你两个整数：<code>m</code> 和 <code>n</code>，表示矩阵的维数。另给你一个整数链表的头节点 <code>head</code>。请你生成一个大小为 <code>m x n</code>的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵<strong>左上角</strong> 开始、<strong>顺时针</strong> 按<strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用<code>-1</code> 填充。返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262137159.jpeg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]</span><br><span class="line">输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何排布的。</span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262137279.jpeg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 1, n = 4, head = [0,1,2]</span><br><span class="line">输出：[[0,1,2,-1]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。 </span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode* head) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n * m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; k &lt; n * m) &#123;</span><br><span class="line">            nums[k++] = head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">max</span>(m, n) / <span class="number">2</span> + <span class="built_in">max</span>(m, n) % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                matrix[i][j] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                matrix[m - <span class="number">1</span> - i][j] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                matrix[j][i] = nums[t++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;例题&quot;&gt;例题&lt;/h1&gt;
&lt;h2 id=&quot;矩阵置零&quot;&gt;&lt;a
href=&quot;https://leetcode.cn/problems/set-matrix-zeroes/&quot;&gt;矩阵置零&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;​ 给定一个 &lt;code&gt;*m* x *n*&lt;/code</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【线性表】</title>
    <link href="https://cuiluyi.gitee.io/2024/02/22/[object%20Object]/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/02/22/[object%20Object]/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/</id>
    <published>2024-02-22T12:15:21.000Z</published>
    <updated>2024-03-03T07:11:37.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一预备知识">一:预备知识</h1><h2 id="头插法">头插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>头指针</strong>为L，指针<code>t</code>指向待插入的新结点</p><h3 id="若单链表含有头结点">若单链表含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = t;</span><br></pre></td></tr></table></figure><h3 id="若单链表不含有头结点">若单链表不含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head;</span><br><span class="line">head = t;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="尾插法">尾插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>尾指针</strong>为tail，指针<code>t</code>指向待插入的新结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail-&gt;next = t;</span><br><span class="line">tail = t;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>头插法</font></strong>会改变<strong><font color='red'>原先顺序</font></strong>，<strong><font color='blue'>尾插法</font></strong>不会改变<strong><font color='blue'>原先顺序</font></strong></p></blockquote><h2 id="头节点">头节点</h2><p><strong>头节点(head node)</strong> == <strong>哑节点（dummynode）</strong></p><h3 id="头结点的作用">头结点的作用</h3><ol type="1"><li><strong>使插入操作和删除操作统一</strong>，在<strong><font color='blue'>第一个结点之前插入结点</font></strong>或<strong><font color='blue'>删除第一个结点</font></strong>时不必另作判断</li><li>不论链表是否为空，<strong>头指针不变，始终指向头结点</strong></li></ol><h3 id="没有头节点的链表">没有头节点的链表</h3><p>对于不带头结点的链表，要考虑</p><ol type="1"><li><strong><font color='red'>尾插法</font></strong>插入结点时，<strong><font color='blue'>链表是否为空</font></strong>【头插法插入结点时，不必考虑】</li><li>是否在<strong><font color='blue'>第一个结点前插入新结点</font></strong></li><li>是否<strong><font color='blue'>删除</font></strong>结点后<strong><font color='blue'>链表为空</font></strong></li></ol><h2 id="sunny应用sunny">:sunny:应用:sunny:</h2><p>​ 对于没有头节点的链表：</p><ul><li>如果不存在上面我们需要考虑的情况：正常写即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">func</span><span class="params">(ListNode *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果可能存在 3.2节的情况，对于无头节点的链表：我们就先构造一个头节点<code>h</code>，在函数最后返回的时候<code>return h-&gt;next</code>，其余部分按照含有头结点的链表写即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">func</span><span class="params">(ListNode *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以下内容如果没有写2种方案，均按照没有头结点的情况实现，当有头结点时，直接<code>return h</code>即可</p><h1 id="二链表">二:链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;*List;</span><br></pre></td></tr></table></figure><h2 id="链表复制">链表复制</h2><h3 id="带头结点">带头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">copyList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = L-&gt;next, *q = h;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        q-&gt;next = t;</span><br><span class="line">        q = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sunny:2者在第4、12行有所不同</p><h3 id="不带头结点">不带头结点</h3><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">copyList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = L, *q = h;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        q-&gt;next = t;</span><br><span class="line">        q = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sunny:2者在第4、12行有所不同</p><h2 id="链表逆转">链表逆转</h2><h3 id="带头结点-1">带头结点</h3><h4 id="改变链表结构">改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 版本一 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode* &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本二 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不改变链表结构">不改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *reverse_L = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        t-&gt;next = reverse_L-&gt;next;</span><br><span class="line">        reverse_L-&gt;next = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse_L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不带头结点-1">不带头结点</h3><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><h4 id="改变链表结构-1">改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 版本一 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode* &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本二 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不改变链表结构-1">不改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *reverse_L = <span class="literal">NULL</span>, *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        t-&gt;next = reverse_L;</span><br><span class="line">        reverse_L = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse_L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例一">例一</h3><p><strong>1025 反转链表</strong></p><p>给定一个常数 <em>K</em> 以及一个单链表 <em>L</em>，请编写程序将<em>L</em> 中每 <em>K</em> 个结点反转。例如：给定 <em>L</em> 为1→2→3→4→5→6，<em>K</em> 为 3，则输出应该为 3→2→1→6→5→4；如果 <em>K</em>为 4，则输出应该为 4→3→2→1→5→6，即最后不到 <em>K</em> 个元素不反转。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em>(≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code>是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>];             <span class="comment">//地址为5位数,模拟内存存储；     </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t; </span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  注意：不一定所有的输入的结点都是有用的，把链表储存在L数组中</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">    n=L.<span class="built_in">size</span>();             <span class="comment">//符合要求的节点个数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line">res.<span class="built_in">resize</span>(n);                  <span class="comment">//必须设定大小，否则res【i】出错</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-n%k;i++)        <span class="comment">//sum-sum%k是除去了最后不能反转的</span></span><br><span class="line">res[i]=L[k<span class="number">-1</span>-i%k+i/k*k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-n%k;i&lt;n;i++)</span><br><span class="line">        res[i]=L[i];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    输出     </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)   <span class="comment">//最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line">    </span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;    </span><br><span class="line"><span class="comment">//     法二</span></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;n-n%k;i+=k)</span></span><br><span class="line"><span class="comment">//         reverse(L.begin()+i,L.begin()+i+k);    //需要头文件algorithm</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// //    输出     </span></span><br><span class="line"><span class="comment">// for(int i=1;i&lt;n;i++)            //最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d %05d\n&quot;,L[i-1],A[L[i-1]].data,L[i]);</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d -1&quot;,L.back(),A[L.back()].data);    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二">例二</h3><p><strong>1075 链表元素分类</strong></p><p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而[0, K] 区间内的元素都排在大于 K的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为-4→-6→-2→7→0→5→10→18→11。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K(≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址；<code>Data</code>是该结点保存的数据，为 [−105,105] 区间内的整数；<code>Next</code>是下一结点的地址。题目保证给出的链表不为空。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00100 9 10</span><br><span class="line">23333 10 27777</span><br><span class="line">00000 0 99999</span><br><span class="line">00100 18 12309</span><br><span class="line">68237 -6 23333</span><br><span class="line">33218 -4 00000</span><br><span class="line">48652 -2 -1</span><br><span class="line">99999 5 68237</span><br><span class="line">27777 11 48652</span><br><span class="line">12309 7 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">33218 -4 68237</span><br><span class="line">68237 -6 48652</span><br><span class="line">48652 -2 12309</span><br><span class="line">12309 7 00000</span><br><span class="line">00000 0 99999</span><br><span class="line">99999 5 23333</span><br><span class="line">23333 10 00100</span><br><span class="line">00100 18 27777</span><br><span class="line">27777 11 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理多余节点   </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&lt;<span class="number">0</span>)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;=<span class="number">0</span>&amp;&amp;A[L[i]].data&lt;=k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例三">例三</h3><p><strong>区块反转</strong></p><p>给定一个单链表 <em>L</em>，我们将每 <em>K</em>个结点看成一个<strong>区块</strong>（链表最后若不足 <em>K</em>个结点，也看成一个区块），请编写程序将 <em>L</em>中所有区块的链接反转。例如：给定 <em>L</em> 为1→2→3→4→5→6→7→8，<em>K</em> 为 3，则输出应该为 7→8→4→5→6→1→2→3。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em>(≤<em>N</em>)，即区块的大小。结点的地址是 5 位非负整数，NULL 地址用 −1表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code>是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00100 8 3</span><br><span class="line">71120 7 88666</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 71120</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">88666 8 -1</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">71120 7 88666</span><br><span class="line">88666 8 00000</span><br><span class="line">00000 4 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 00100</span><br><span class="line">00100 1 12309</span><br><span class="line">12309 2 33218</span><br><span class="line">33218 3 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100001</span>];</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;L,res,block[<span class="number">100001</span>];<span class="comment">//当n=100000，k=1时区块最多 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vector&lt;int&gt;L,res,block[100001];//放在局部变量会导致溢出，只能放在全局变量</span></span><br><span class="line"><span class="comment">//  故申请大内存时最好放在全局变量里面</span></span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">block[t].<span class="built_in">push_back</span>(L[i]);</span><br><span class="line"><span class="keyword">if</span>(cnt%k==<span class="number">0</span>&amp;&amp;t!=n<span class="number">-1</span>)        <span class="comment">//Attention！if(cnt%k==0) 也对</span></span><br><span class="line">t++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : block[i]) </span><br><span class="line">            res.<span class="built_in">push_back</span>(it);        </span><br><span class="line"><span class="comment">//等价   for(int j=0;j&lt;block[i].size();j++)</span></span><br><span class="line"><span class="comment">// res.push_back(block[i][j]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表合并">链表合并</h2><h3id="两个升序链表合并为一个升序链表">两个升序链表合并为一个升序链表</h3><ul><li>用两个指针p1、p2分别遍历L1和L2，用一个尾指针永远指向新链表的最后一个节点</li><li>比较两个指针指向的节点的大小，将数据域较小的节点用==<strong><font color='red'>尾插法</font></strong>==接在新链表后面</li><li>尾指针后移，p1或者p2后移</li><li>当有一个为空时另一个还会有剩余节点没有加入新链表，将剩下的直接接在新链表后面</li></ul><h4 id="不改变链表结构-2">不改变链表结构</h4><h5 id="带头节点">带头节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode *h = new ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != nullptr &amp;&amp; p2 != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、28行</p><h5 id="不带头节点">不带头节点</h5><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、28行</p><h4 id="改变链表结构-2">改变链表结构</h4><h5 id="带头节点-1">带头节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、26行</p><h5 id="不带头节点-1">不带头节点</h5><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、26行</p><h3id="两个升序链表合并为一个降序链表">两个升序链表合并为一个降序链表</h3><ul><li>用两个指针p1，p2分别遍历L1和L2，用指针s每次指向待插入的节点</li><li>将新链表的头结点的指针域置空</li><li>开始遍历并用==<strong><font color='red'>头插法</font></strong>==开始插入节点</li><li>退出循环后对未遍历完的节点用头插法将剩余节点插入新链表</li></ul><h4 id="不改变链表结构-3">不改变链表结构</h4><h5 id="带头节点-2">带头节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode *h = new ListNode;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != nullptr &amp;&amp; p2 != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            t-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            t-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">        t-&gt;next = h;</span><br><span class="line">        h = t;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h5 id="不带头节点-2">不带头节点</h5><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            t-&gt;next = h;</span><br><span class="line">            h = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            t-&gt;next = h;</span><br><span class="line">            h = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">        t-&gt;next = h;</span><br><span class="line">        h = t;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h4 id="改变链表结构-3">改变链表结构</h4><h5 id="带头节点-3">带头节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = p1;</span><br><span class="line">            p1 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = p2;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = h-&gt;next;</span><br><span class="line">        h-&gt;next = p1;</span><br><span class="line">        p1 = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h5 id="不带头节点-3">不带头节点</h5><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = h;</span><br><span class="line">            h = p1;</span><br><span class="line">            p1 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = h;</span><br><span class="line">            h = p2;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = h;</span><br><span class="line">        h = p1;</span><br><span class="line">        p1 = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h3 id="例一-1">例一</h3><p><strong>List Concatenation</strong></p><p>Concatenation of lists is an operation where the elements of one listare added at the end of another list. For example, if we have a linkedlist <code>L1</code>→1→2→3 and another one <code>L2</code>→4→5→6. Thefunction <code>ListConcat</code> is to return the head pointer of thelist L→4→5→6→1→2→3.</p><p><strong>The list structure is defined as the following:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br></pre></td></tr></table></figure><p><strong>Please fill in the blanks.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">ListConcat</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Tmp = L2;</span><br><span class="line">    <span class="keyword">if</span> ( !L2 ) <span class="keyword">return</span> L1;</span><br><span class="line">    <span class="keyword">while</span> ( Tmp-&gt;Next )</span><br><span class="line">________________;【<span class="number">4</span>分】</span><br><span class="line">______________;【<span class="number">4</span>分】</span><br><span class="line">    <span class="keyword">return</span> __________;【<span class="number">4</span>分】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><p>【1】<code>Tmp=Tmp-&gt;Next</code></p><p>【2】<code>Tmp-&gt;Next=L1</code>//注：<code>Tmp-&gt;Next=L1-&gt;Next</code>错误</p><p>【3】<code>L2</code></p><blockquote><p>该链表是一个不带头结点的单链表，从两个角度判断</p><ol type="1"><li>第4行代码 <code>if ( !L2 ) return L1;</code>//链表L2为空，则返回，说明不带头结点<ul><li>带头结点应写为<code>if ( !L2-&gt;next ) return L1;</code></li></ul></li><li>题干 L1→1→2→3 , L2→4→5→6 和 L→4→5→6→1→2→3.</li></ol></blockquote><h2 id="链表分解">链表分解</h2><h3 id="例一-2">例一</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为<strong><font color='red'>奇数</font></strong>的元素；B链表中含有原链表A中序号为<strong><font color='red'>偶数</font></strong>的元素。<strong><font color='blue'>保持原来的相对顺序。</font></strong></p><blockquote><blockquote><p>因为要保持原来相对位置不变，所以要采用Lb和Lb采用<strong><font color='red'>尾插法</font></strong>,尾指针分别为<strong><code>rear1和rear2</code></strong></p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二-1">例二</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为<strong><font color='red'>偶数</font></strong>的元素；B链表中含有原链表A中序号为<strong><font color='red'>奇数</font></strong>的元素。<strong><font color='blue'>保持原来的相对顺序。</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两两交换链表节点"><ahref="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表节点</a></h2><p>​给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262245395.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281656470.gif"alt="Rec_2024-02-26_0001(2)" /><figcaption aria-hidden="true">Rec_2024-02-26_0001(2)</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281739850.jpg"alt="7236b067d914444ca3a0afe66b74809" /><figcaptionaria-hidden="true">7236b067d914444ca3a0afe66b74809</figcaption></figure><p><strong>代码：</strong></p><p>法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *t = dummyHead, *p = head, *q = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            t-&gt;next = q;</span><br><span class="line">            t = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* t = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (t-&gt;next != <span class="literal">nullptr</span> &amp;&amp; t-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *p = t-&gt;next, *q = t-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            t-&gt;next = q;</span><br><span class="line">            t = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="排序链表"><ahref="https://leetcode.cn/problems/sort-list/">排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong>排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281833020.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281833014.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            num.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            p-&gt;val = num[k++];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="随机链表的复制"><a id="shenkaobei"><ahref="https://leetcode.cn/problems/copy-list-with-random-pointer/">随机链表的复制</a></a></h2><p>给你一个长度为 <code>n</code>的链表，每个节点包含一个额外增加的随机指针 <code>random</code>，该指针可以指向链表中的任何节点或空节点。构造这个链表的 <strong><ahref="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin">深拷贝</a></strong>。深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong>节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code> 指针和 <code>random</code>指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>。</p><p>​ 例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中<code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点<code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code>。</p><p>​ 返回复制链表的头节点。</p><p>用一个由 <code>n</code>个节点组成的链表来表示输入/输出中的链表。每个节点用一个<code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从<code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为<code>null</code> 。</li></ul><p>​ 你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code>作为传入参数。</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942322.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942294.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942306.png"alt="img" /></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>需要<strong>2次遍历链表</strong>：</p><ul><li>首先<strong>对所有节点进行拷贝</strong>：遍历原始链表，每遍历到一个节点，就重新创建一个拷贝节点，然后用Hash表存储原节点与新节点的映射关系</li><li>然后<strong>拷贝点与点之间的关系</strong>：遍历原始链表，每遍历到一个节点，我们都从Hash表中查询到对应的拷贝节点，然后把拷贝节点根据原始节点的关系进行连接就可以了</li></ul><blockquote><p><ahref="https://www.bilibili.com/video/BV1Bv4y1A7Aq/?buvid=XY3CA67352B7F82D3CAB27E191FA025EB4053&amp;from_spmid=main.my-history.0.0&amp;is_story_h5=false&amp;mid=ivlqRrACJE6aj0QtF6a%2FzA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=a1cae467-a3b0-4af5-a2fb-841d5a3ffb7a&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1709393487&amp;unique_k=SMN7Y8h&amp;up_id=320530935&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】138. 复制带随机指针的链表 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p></blockquote><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; h;</span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">            h[p] = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">                h[p]-&gt;next = h[p-&gt;next];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">                h[p]-&gt;random = h[p-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同类型：<ahref="D:\downloads\hexo\blog\source_posts\数据结构【图】.md#kelong">图的深拷贝</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一预备知识&quot;&gt;一:预备知识&lt;/h1&gt;
&lt;h2 id=&quot;头插法&quot;&gt;头插法&lt;/h2&gt;
&lt;p&gt;​
将&lt;strong&gt;结点&lt;/strong&gt;插入&lt;strong&gt;链表表头&lt;/strong&gt;采用&lt;strong&gt;头插法&lt;/strong&gt;，设单链表&lt;strong&gt;头指针&lt;/strong&gt;为L，指针&lt;code&gt;t&lt;/code&gt;指向待插入的新结点&lt;/p&gt;
&lt;h3 id=&quot;若单链表含有头结点&quot;&gt;若单链表含有头结点&lt;/h3&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;t-&amp;gt;next = head-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;head-&amp;gt;next = t;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;若单链表不含有头结点&quot;&gt;若单链表不含有头结点&lt;/h3&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;t-&amp;gt;next = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;head = t;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="https://cuiluyi.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
