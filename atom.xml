<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>弘毅 の blog</title>
  
  
  <link href="https://luyicui.github.io/atom.xml" rel="self"/>
  
  <link href="https://luyicui.github.io/"/>
  <updated>2024-12-24T15:37:38.194Z</updated>
  <id>https://luyicui.github.io/</id>
  
  <author>
    <name>弘毅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"/>
    <id>https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/</id>
    <published>2024-12-24T15:37:37.984Z</published>
    <updated>2024-12-24T15:37:38.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概括">概括</h3><p>Python中面向对象编程有三大特性：<strong>封装、继承和多态。</strong><br /><strong>封装:</strong> 函数是对语句的封装;类是对函数和变量的封装。<br /><strong>继承:</strong>类和类之间可以人为手动的建立父子关系，父类的属性和方法，子类可以使用。<br /><strong>多态:</strong> 是一种编程技巧，提高代码的灵活度。</p><h3 id="封装">1.封装</h3><p>函数是对一个一个语句进行封装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    x = <span class="number">18</span>  <span class="comment"># 赋值语句</span></span><br><span class="line">    x += <span class="number">2</span>  <span class="comment"># 算数运算符表达式语句</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>类是对函数和变量的封装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;人类&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="继承">2.继承</h3><p>继承是面向对象软件设计中的一个概念，描述的是多个类之间的所属关系，可以使子类具有分类的属性和方法，或者重新定义，追加属性和方法等。<br />例如一个A类的属性和方法可以复用，B类继承于A类，那么A类可称为基类，亦可叫做父类，B类则被称为派生类，亦可叫做子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;正在睡觉&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;正在看书&#x27;</span>)</span><br><span class="line"><span class="comment"># 调用 __init__ 方法,Student类没有实现，会自动找 Person 父类</span></span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.name)  <span class="comment">#张三  父类里定义的属性，子类可以直接使用</span></span><br><span class="line">s1.sleep()  <span class="comment">#张三正在睡觉  父类的方法子类实例对象可以直接调用</span></span><br><span class="line">s1.study()  <span class="comment">#张三正在看书  </span></span><br></pre></td></tr></table></figure><p><strong>多继承</strong><br />子类可以有多个父类，继承所有父类的属性和方法。<br />语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">子类名</span>(父类名<span class="number">1</span>,父类名<span class="number">2.</span>..)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是test1&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是A类里的demo方法&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是test2&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是B类里的demo方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.test1()  </span><br><span class="line">c.test2()  </span><br><span class="line"><span class="comment"># 如果两个不同的父类有同名方法,可以使用__mro__属性可以查看方法的调用顺序</span></span><br><span class="line">c.demo()   </span><br><span class="line"><span class="built_in">print</span>(C.__mro__) </span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>我是test1<br />我是test2<br />我是A类里的demo方法<br />(&lt;class ‘<strong>main</strong>.C’&gt;, &lt;class‘<strong>main</strong>.A’&gt;, &lt;class ‘<strong>main</strong>.B’&gt;,&lt;class ‘object’&gt;)</p></blockquote><p><strong>私有属性的继承特点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.__score = <span class="number">90</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;正在睡觉&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Person类里的test方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__demo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Student里的demo方法&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">p = Student(<span class="string">&#x27;源&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.name)</span><br><span class="line">p.sleep()</span><br><span class="line">p._Student__demo()  <span class="comment"># 自己类里定义的私有方法   对象名._类名__私有方法名()</span></span><br><span class="line">p._Person__test()  <span class="comment"># 可以通过 对象名._父类名__私有方法调用()</span></span><br><span class="line"><span class="built_in">print</span>(p._Person__score)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>源<br />源正在睡觉<br />我是Student里的demo方法<br />我是Person类里的test方法<br />90</p></blockquote><blockquote><p>私有属性和方法，子类不会继承<br />所以 p._Student__test() ，print(p._Student__score)，会报错。</p></blockquote><p><strong>新式类与经典类</strong><br />新式类：继承自object的类，我们称之为新式类<br />经典类：不继承自object的类<br />在python2里，如果不手动的指定一个类的父类是object，这个类就是一个经典类<br />在python3里不存在经典类，都是新式类。<br />使用dir函数可以查看object类提供的一些内置属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">s = Student()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(s))</span><br></pre></td></tr></table></figure><p><strong>对象相关的运算符和内置函数</strong><br /><strong>身份运算符</strong>用来比较两个对象的内存地址，查看这两个对象是否是同一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(Person, Teacher):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">p1 = Person(<span class="string">&#x27;源&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">p2 = Person(<span class="string">&#x27;源&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p1 <span class="keyword">is</span> p2)  <span class="comment"># False，两个对象的内存地址不一样</span></span><br></pre></td></tr></table></figure><p><strong>type</strong>内置函数用来获取类对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(Person, Teacher):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">p1 = Person(<span class="string">&#x27;源&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">s = Student(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(p1) == Person)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s) == Person)   <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p><strong>isinstance</strong>内置函数用来判断一个对象是否是由指定的类(或者父类)实例化出来的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(s, (Student, Teacher)))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(s, Person))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(p1, Person))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(p1, Student))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p><strong>issubclass</strong>内置函数用来判断一个类是否是另一个类的子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Student, (Person, Teacher)))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Person, Student))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p><strong>子类重写父类方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;正在吃东西&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):</span><br><span class="line">        <span class="comment"># 子类在父类实现的基础上，又添加了自己新的功能</span></span><br><span class="line">        <span class="comment"># 调用父类方法的两种方式:</span></span><br><span class="line">        <span class="comment"># 1. 父类名.方法名(self,参数列表)</span></span><br><span class="line">        <span class="comment"># Person.__init__(self, name, age)</span></span><br><span class="line">        <span class="comment"># 2. 使用super直接调用父类的方法。推荐使用第二种方式</span></span><br><span class="line">        <span class="built_in">super</span>(Student, self).__init__(name, age)</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;在课间休息时吃东西&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;源&#x27;</span>, <span class="number">18</span>, <span class="number">90</span>)  <span class="comment"># 调用了父类的 __init__ 方法</span></span><br><span class="line">s.eat()  </span><br><span class="line"><span class="built_in">print</span>(Student.__mro__)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>源在课间休息时吃东西<br />(&lt;class ‘<strong>main</strong>.Student’&gt;, &lt;class‘<strong>main</strong>.Person’&gt;, &lt;class ‘object’&gt;)</p></blockquote><blockquote><p>1.子类的实现和父类的实现完全不一样，子类可以选择重写父类的方法。<br />2.子类在父类的基础上又有更多的实现</p></blockquote><h3 id="多态">3.多态</h3><p>多态是基于继承,通过子类重写父类的方法,达到不同的子类对象调用相同的父类方法，得到不同的结果,提高代码的灵活度。<br />不使用多态时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PoliceDog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attack_enemy</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;警犬正在攻击坏人&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlindDog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lead_road</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;导盲犬正在领路&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrugDog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_drug</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;缉毒犬正在搜毒&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.dog = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work_with_pd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.dog <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.dog.attack_enemy()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work_with_bd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.dog <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.dog.lead_road()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work_with_dd</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.dog <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.dog.search_drug()</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;源&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pd = PoliceDog()</span><br><span class="line">p.dog = pd</span><br><span class="line">p.work_with_pd()</span><br><span class="line"></span><br><span class="line">bd = BlindDog()</span><br><span class="line">p.dog = bd</span><br><span class="line">p.work_with_bd()</span><br><span class="line"></span><br><span class="line">dd = DrugDog()</span><br><span class="line">p.dog = dd</span><br><span class="line">p.work_with_dd()</span><br></pre></td></tr></table></figure><blockquote><p>不使用多态时，若不断添加新的功能，每次都需要改动Person类的源码，使得程序的扩展性太差。</p></blockquote><p>使用多态时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>): <span class="comment"># 父类提供统一的方法。</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗正在工作&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoliceDog</span>(<span class="title class_ inherited__">Dog</span>): <span class="comment"># 继承Dog</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):   <span class="comment"># 子类重写方法，并且处理自己的行为</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;警犬正在攻击敌人&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlindDog</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;导盲犬正在领路&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrugDog</span>(<span class="title class_ inherited__">Dog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;缉毒犬正在搜毒&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.dog = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work_with_dog</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.dog <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">isinstance</span>(self.dog, Dog):</span><br><span class="line">            self.dog.work() <span class="comment"># 根据对象的不同而产生不同的运行效果, 保障了代码的稳定性</span></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;源&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pd = PoliceDog()</span><br><span class="line">p.dog = pd</span><br><span class="line">p.work_with_dog()</span><br><span class="line"></span><br><span class="line">bd = BlindDog()</span><br><span class="line">p.dog = bd</span><br><span class="line">p.work_with_dog()</span><br><span class="line"></span><br><span class="line">dd = DrugDog()</span><br><span class="line">p.dog = dd</span><br><span class="line">p.work_with_dog()</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>警犬正在攻击坏人<br />导盲犬正在领路<br />缉毒犬正在搜毒</p></blockquote><blockquote><p>使用多态时，同一个方法，只要是 Dog的子类就可以传递，提供了代码的灵活性，并且传递不同对象，最终work_with_dog 产生了不同的执行效果。</p></blockquote><p>本文转自 <ahref="https://blog.csdn.net/yuanfate/article/details/105026610"class="uri">https://blog.csdn.net/yuanfate/article/details/105026610</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概括&quot;&gt;概括&lt;/h3&gt;
&lt;p&gt;Python中面向对象编程有三大特性：&lt;strong&gt;封装、继承和多态。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;封装:&lt;/strong&gt; 函数是对语句的封装;类是对函数和变量的封装。&lt;br /&gt;
&lt;strong&gt;继承:&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-12-24T12:37:09.275Z</published>
    <updated>2024-12-24T14:09:01.243Z</updated>
    
    <content type="html"><![CDATA[<h1id="类方法和静态方法单例设计模式">类方法和静态方法、单例设计模式</h1><h2 id="类方法和静态方法">类方法和静态方法</h2><h4 id="类方法"><strong>1.类方法</strong></h4><p>需要用装饰器 <span class="citation"data-cites="classmethod">@classmethod</span>来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数。</p><p>其无需实例化，可以调用类属性和类方法，无法取到普通的成员属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Studnet</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;学生&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self, game</span>):  <span class="comment"># 对象方法有一个参数self,指的是实例对象</span></span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;正在玩&#x27;</span> + game)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">cls</span>):  <span class="comment"># 如果这个函数只用到了类属性，我们可以把定义成为一个类方法</span></span><br><span class="line">        <span class="comment"># 类方法会有一个参数 cls,也不需要手动的传参，会自动传参</span></span><br><span class="line">        <span class="comment"># cls 指的是类对象，cls代表Student</span></span><br><span class="line">        <span class="built_in">print</span>(cls.<span class="built_in">type</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;哎呦，不错呦&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">s1 = Studnet(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="comment"># 实例对象在调用方法时，不需要给形参self传参，会自动的把实例对象传递给self</span></span><br><span class="line">s2 = Studnet(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># play_game 对象方法，可以直接使用实例对象.方法名(参数)调用</span></span><br><span class="line"><span class="comment"># 使用对象名.方法名(参数)调用的方式，不需要传递self，会自动将对象名传递给self</span></span><br><span class="line">s1.play_game(<span class="string">&#x27;王者荣耀&#x27;</span>)  <span class="comment"># 直接使用实例对象调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象方法还可以使用 类对象来调用类名.方法名()</span></span><br><span class="line"><span class="comment"># 这种方式，不会自动给self传参，需要手动的指定self</span></span><br><span class="line">Studnet.play_game(s2, <span class="string">&#x27;英雄联盟&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法:可以使用实例对象和类对象调用</span></span><br><span class="line">s1.test()</span><br><span class="line">Studnet.test()</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>张三正在玩王者荣耀<br />李四正在玩英雄联盟<br />学生<br />哎呦，不错呦<br />学生<br />哎呦，不错呦</p></blockquote><p>使用场景：</p><blockquote><p>1.当方法中,需要使用类对象(如访问私有类属性等)时，便可定义类方法<br />2.类方法一般和类属性配合使用</p></blockquote><h4 id="静态方法"><strong>2.静态方法</strong></h4><p>需要通过装饰器 <strong><span class="citation"data-cites="staticmethod">@staticmethod</span></strong>来进行修饰，静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）。<br />其无需实例化，无法到类内部的任何属性和方法，完全独立的一个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Studnet</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;学生&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self, game</span>): </span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;正在玩&#x27;</span> + game)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果一个方法里没有用到实例对象的任何属性，可以将这个方法成static</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(): <span class="comment"># 静态方法不会自动传递实例对象和类对象</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">s1 = Studnet(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">s2 = Studnet(<span class="string">&#x27;李四&#x27;</span>)</span><br><span class="line">s1.play_game(<span class="string">&#x27;王者荣耀&#x27;</span>) </span><br><span class="line">Studnet.play_game(s2, <span class="string">&#x27;英雄联盟&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态方法:没有用到实例对象的任何属性</span></span><br><span class="line">Studnet.test()</span><br><span class="line">s1.test()</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>张三正在玩王者荣耀<br />李四正在玩英雄联盟<br />hello world<br />hello world</p></blockquote><p>使用场景：</p><blockquote><p>1.当方法中,既不需要使用实例对象(如实例对象，实例属性)，也不需要使用类对象(如类属性、类方法、创建实例等)时,便可定义静态方法<br />2.取消不需要的参数传递，有利于减少不必要的内存占用和性能消耗</p></blockquote><h2 id="单例设计模式">单例设计模式</h2><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __instance = <span class="literal">None</span>  <span class="comment"># 类属性</span></span><br><span class="line">    __is_first = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 申请内存，创建一个对象，并把对象的类型设置为cls</span></span><br><span class="line">            cls.__instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__is_first:</span><br><span class="line">            self.a = a</span><br><span class="line">            self.b = b</span><br><span class="line">            self.__is_first = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 __new__ 方法申请内存</span></span><br><span class="line"><span class="comment"># 如果不重写 __new__ 方法，会调用 object 的 __new__ 方法</span></span><br><span class="line"><span class="comment"># object的 __new__ 方法会申请内存</span></span><br><span class="line"><span class="comment"># 如果重写了 __new__ 方法，需要自己手动的申请内存</span></span><br><span class="line">s1 = Singleton(<span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">s2 = Singleton(<span class="string">&#x27;333&#x27;</span>, <span class="string">&#x27;444&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1 <span class="keyword">is</span> s2)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s1.a, s2.b)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>True<br />111 222</p></blockquote><p>本文转自 <ahref="https://blog.csdn.net/yuanfate/article/details/105025849"class="uri">https://blog.csdn.net/yuanfate/article/details/105025849</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1
id=&quot;类方法和静态方法单例设计模式&quot;&gt;类方法和静态方法、单例设计模式&lt;/h1&gt;
&lt;h2 id=&quot;类方法和静态方法&quot;&gt;类方法和静态方法&lt;/h2&gt;
&lt;h4 id=&quot;类方法&quot;&gt;&lt;strong&gt;1.类方法&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;需要用装饰器 &lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2024-12-24T12:29:38.968Z</published>
    <updated>2024-12-24T14:09:22.805Z</updated>
    
    <content type="html"><![CDATA[<p># 面向过程与面向对象、类和对象、面向对象的基本语法</p><h2 id="一.面向过程与面向对象">一.面向过程与面向对象</h2><p><strong>面向过程</strong>：1.根据业务逻辑从上到下写代码。<br />　　　　　2.开发思路是将数据和函数按照执行的逻辑顺序组织在一起<br />　　　　　3.分开考虑数据与函数<br />优点：复杂度的问题简单化、流程化<br />缺点：扩展性差，牵一发而动全身<br />特点：1.注重步骤与过程，不注重职责分工，关注点是怎么做<br />　　　2.如果需求复杂，代码会变得很复杂<br />　　　3.开发复杂项目，没有固定的套路，开发难度很大！<br />　　　<br /><strong>面向对象</strong>：1.将数据与函数绑定到一起<br />　　　　　2.进行封装<br />　　　　　3.更快速高效地开发程序<br />　　　　　4.减少重复代码的重写过程<br />优点：可扩展性高<br />缺点：编程复杂度高，容易出现过度设计问题<br />特点：1.注重对象和职责，不同的对象承担不同的职责，关注点是谁来做。<br />　　　2.更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路。<br />　　　3.需要在面向过程基础上，再学习一些面向对象的语法。</p><h2 id="二.类和对象">二.类和对象</h2><h3 id="类和对象的定义">1.类和对象的定义</h3><p><strong>类</strong>：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法，是抽象的，不能直接使用。<br /><strong>对象</strong>：通过类定义的数据结构实例，可以直接使用。由哪一个类创建出来的对象，就拥有在哪一个类中定义的属性和方法。对象包括两个数据成员（类变量和实例变量）和方法。</p><h3 id="类和对象的关系">2.类和对象的关系</h3><p>1.类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。<br />2.使用同一个类，能够创建出很多对象。<br />3.类中定义了什么属性和方法，对象中就有什么属性和方法。<br />4.不同对象对应的属性值也会不同。</p><h3 id="类的设计">3.类的设计</h3><p>设计一个类，通常需要满足三个要素：<br />1.<strong>类名</strong>：这类事物的名字，按照大驼峰命名法起名。<br />2.<strong>属性</strong>：这类事物具有什么样的特征。<br />3.<strong>方法</strong>：这类事物具有什么样的行为。</p><h3 id="类和对象的简单语法格式">4.类和对象的简单语法格式</h3><p>定义一个只包含方法的类，语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">方法1</span>(<span class="params">self,参数列表</span>):<span class="comment"># 方法里的第一个参数必须是self</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">方法2</span>(<span class="params">self,参数列表</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>创建对象，语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象变量名 = 类名()</span><br></pre></td></tr></table></figure><h2 id="三.面向对象的基本语法">三.面向对象的基本语法</h2><p>先用一个实例来解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># 关注Student类有哪些特征和行为</span></span><br><span class="line">    <span class="comment"># 在 __init__ 方法里，以参数的形式定义特征，我们称之为属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 行为定义为一个个函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在打游戏&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在吃东西&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用 Student 类创建了两个实例对象 s1,s2</span></span><br><span class="line"><span class="comment"># s1和s2都会有name,age属性,同时都有play_game和eat方法</span></span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)  <span class="comment"># Student() ==&gt; 会自动调用 __init__ 方法</span></span><br><span class="line">s2 = Student(<span class="string">&#x27;李四&#x27;</span>, <span class="number">17</span>)</span><br><span class="line"><span class="comment"># 根据业务逻辑，让不同的对象执行不同的行为</span></span><br><span class="line">s1.play_game()</span><br><span class="line">s2.eat()</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>正在打游戏<br />正在吃东西</p></blockquote><h3 id="self语句的使用">1.self语句的使用</h3><p>谁对象调用了方法，方法里的self指的就是谁。通过 self.属性名可以访问到这个对象的属性；通过 self.方法名()可以调用这个对象的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;正在玩游戏&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.name)  <span class="comment">#张三</span></span><br><span class="line">s1.play_game()  <span class="comment">#张三正在玩游戏</span></span><br></pre></td></tr></table></figure><blockquote><p>s1=Student(‘张三’) 这段代码具体做了什么呢？</p><ol type="1"><li>调用 <strong>new</strong> 方法,用来申请内存空间</li><li>调用 <strong>init</strong> 方法传入参数，将 self指向创建好的内存空间，填充数据</li><li>变量 s1 也指向创建好的内存空间</li></ol></blockquote><h3 id="给对象添加属性和修改">2.给对象添加属性和修改</h3><p>Python支持动态属性，当一个对象创建好了以后，可以直接使用 对象.属性名= 属性值 就可以很方便的给对象添加或者修改一个属性。</p><p>直接使用等号给一个属性赋值，如果这个属性以前不存在，会给对象添加一个新的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;正在玩游戏&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">s1.age=<span class="number">18</span>  <span class="comment">#给对象添加一个age属性</span></span><br><span class="line"><span class="built_in">print</span>(s1.age) <span class="comment"># 18 </span></span><br></pre></td></tr></table></figure><p>如果这个属性以前存在，会修改这个属性对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;正在玩游戏&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">s1.name = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">s1.play_game()  <span class="comment">#李四正在玩游戏</span></span><br></pre></td></tr></table></figure><blockquote><p>在日常开发中，不推荐在类的外部直接给对象添加属性这种方式。对象应该具有哪些属性，我们应该封装在类的内部。</p></blockquote><p>本文转自 <ahref="https://blog.csdn.net/yuanfate/article/details/104685030"class="uri">https://blog.csdn.net/yuanfate/article/details/104685030</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;# 面向过程与面向对象、类和对象、面向对象的基本语法&lt;/p&gt;
&lt;h2 id=&quot;一.面向过程与面向对象&quot;&gt;一.面向过程与面向对象&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;面向过程&lt;/strong&gt;：1.根据业务逻辑从上到下写代码。&lt;br /&gt;
　　　　　2.开发思路是将数据和函</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7%E3%80%81%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E3%80%81%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%86%85%E7%BD%AE%E5%B1%9E%E6%80%A7%E3%80%81%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E3%80%81%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2024-12-24T06:52:28.776Z</published>
    <updated>2024-12-24T13:54:42.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性">属性</h1><h2 id="类的内置属性">类的内置属性</h2><p>Python中有很多的内置属性，我们可以通过使用内置函数 dir()来查看一个对象支持的所有属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(s1))</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>[‘<strong>class</strong>’, ‘<strong>delattr</strong>’,‘<strong>dict</strong>’, ‘<strong>dir</strong>’, ‘<strong>doc</strong>’,‘<strong>eq</strong>’, ‘<strong>format</strong>’, ‘<strong>ge</strong>’,‘<strong>getattribute</strong>’, ‘<strong>gt</strong>’,‘<strong>hash</strong>’, ‘<strong>init</strong>’,‘<strong>init_subclass</strong>’, ‘<strong>le</strong>’,‘<strong>lt</strong>’, ‘<strong>module</strong>’, ‘<strong>ne</strong>’,‘<strong>new</strong>’, ‘<strong>reduce</strong>’,‘<strong>reduce_ex</strong>’, ‘<strong>repr</strong>’,‘<strong>setattr</strong>’, ‘<strong>sizeof</strong>’,‘<strong>str</strong>’, ‘<strong>subclasshook</strong>’,‘<strong>weakref</strong>’, ‘name’, ‘score’]</p></blockquote><h3 id="slots__属性">__slots__属性</h3><p>之前我们说过，Python中支持动态属性，可以直接给对象添加属性，但是，在某些情况下，我们想对属性进行管理，此时，就可以使用__slots__方法来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;score&#x27;</span>)  <span class="comment">#控制了属性，只能对name和score属性进行修改，不能再添加属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line">s1.name=<span class="string">&#x27;lisi&#x27;</span>   <span class="comment">#修改name属性</span></span><br><span class="line"><span class="built_in">print</span>(s1.name)   <span class="comment"># lisi</span></span><br><span class="line">s1.gender=<span class="string">&#x27;male&#x27;</span> <span class="comment">#添加一个gender属性</span></span><br><span class="line"><span class="built_in">print</span>(s1.gender) <span class="comment">#报错</span></span><br></pre></td></tr></table></figure><h3 id="doc__属性">__doc__属性</h3><p>可以用来展示类的描述信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Student()：学生类</span></span><br><span class="line"><span class="string">    name：学生姓名</span></span><br><span class="line"><span class="string">    score：学生成绩</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(Student.__doc__)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>Student()：学生类 name：学生姓名 score：学生成绩</p></blockquote><h3 id="module__-属性__class__属性">__module__ 属性、__class__属性</h3><p>调用__module__ 可以查看当前操作的对象在哪个模块中；调用__class__可以查看当前操作的对象的类是什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        </span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)        </span><br><span class="line"><span class="built_in">print</span>(s1.__module__)</span><br><span class="line"><span class="built_in">print</span>(s1.__class__)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p><strong>main</strong><br />&lt;class ‘<strong>main</strong>.Student’&gt;</p></blockquote><h3 id="dict__属性">__dict__属性</h3><h4 id="实例__dict__">实例__dict__</h4><p><strong>实例</strong>的 <code>__dict__</code>仅包括对象的所有<strong>实例属性</strong>（即<strong>非类属性</strong>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">123</span>  <span class="comment"># 实例属性</span></span><br><span class="line">        self.y = <span class="number">456</span>  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.z = <span class="number">789</span>  <span class="comment"># 动态添加实例属性</span></span><br><span class="line"><span class="built_in">print</span>(a.__dict__)  <span class="comment"># &#123;&#x27;x&#x27;: 123, &#x27;y&#x27;: 456, &#x27;z&#x27;: 789&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>a.__dict__</code> 中存储了 <code>x</code>、<code>y</code>和动态添加的 <code>z</code>。</li><li>修改 <code>a.__dict__</code> 中的值，会直接反映到实例属性上。</li></ul><h4 id="类__dict__">类__dict__</h4><p><strong>类</strong>的 <code>__dict__</code>包括<strong>类属性</strong>和<strong>类方法</strong>等</p><blockquote><p>类属性是存储在类对象中的，与实例属性不同，它们共享给所有实例。</p></blockquote><p><strong>猴子补丁</strong>是一种在运行时动态修改类的技术，比如给类添加新的方法。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">12</span><span class="comment"># 类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">123</span>  <span class="comment"># 实例属性</span></span><br><span class="line">        self.y = <span class="number">456</span>  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.x / self.y</span><br><span class="line"></span><br><span class="line">A.z = <span class="number">789</span>  <span class="comment"># 动态添加类属性</span></span><br><span class="line"><span class="built_in">print</span>(A.z)  <span class="comment"># 输出 789</span></span><br><span class="line"></span><br><span class="line">A.bar = bar  <span class="comment"># 动态添加类方法</span></span><br><span class="line"><span class="built_in">print</span>(A.__dict__)  <span class="comment"># 查看类的 __dict__</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">789</span><br><span class="line">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;a&#x27;: 12, &#x27;__init__&#x27;: &lt;function A.__init__ at 0x00000192CABAC820&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__doc__&#x27;: None, &#x27;z&#x27;: 789, &#x27;bar&#x27;: &lt;function bar at 0x00000192CAA5F160&gt;&#125;</span><br></pre></td></tr></table></figure><p>虽然 <code>bar</code>是动态添加的，但它仍然可以通过实例调用，类似普通方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.bar())  <span class="comment"># 输出 123 / 456 的值</span></span><br></pre></td></tr></table></figure><h3id="getitem__属性__setitem__属性__delitem__属性">__getitem__属性、__setitem__属性、__delitem__属性</h3><p>如果想把对象当做字典一样来操作，可以使用这三种方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__dict__[key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">del</span> self.__dict__[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>) </span><br><span class="line"><span class="built_in">print</span>(s1[<span class="string">&#x27;name&#x27;</span>])    <span class="comment"># 会调用 __getitem__ 方法，直接打印属性对应的值</span></span><br><span class="line">s1[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;lisi&#x27;</span>  <span class="comment"># 会调用对象的 __setitem__方法,修改属性对应的值</span></span><br><span class="line">s1[<span class="string">&#x27;score&#x27;</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(s1.name, s1.score)</span><br><span class="line"><span class="keyword">del</span> s1[<span class="string">&#x27;score&#x27;</span>]      <span class="comment"># 会调用 __delitem__ 方法，删除属性及对应的值</span></span><br><span class="line"><span class="built_in">print</span>(s1.__dict__)</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>zhangsan<br />lisi 99<br />{‘name’: ‘lisi’}</p></blockquote><h2 id="类属性和对象属性">类属性和对象属性</h2><ul><li><strong>类属性</strong>是类对象所拥有的属性，定义在类中；类属性可以通过类对象或者实例对象访问；类属性可以被该类的所有实例对象所共有。</li><li>通过类创建出来的对象被称为实例对象，<strong>对象属性</strong>也可以称为实例属性。实例属性要求每个对象为其单独开辟一个内存空间来记录数据，所以不同的对象的同名属性没有关联，互不影响。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;学生&#x27;</span>   <span class="comment">#在类中定义类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        </span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)   <span class="comment"># 通过Student类创建出来的实例对象</span></span><br><span class="line"><span class="comment">#类属性可以通过类对象和实例对象来获取</span></span><br><span class="line"><span class="built_in">print</span>(Student.<span class="built_in">type</span>)  <span class="comment"># 学生   通过类对象获取类属性</span></span><br><span class="line"><span class="built_in">print</span>(s1.<span class="built_in">type</span>)   <span class="comment"># 学生     通过实例对象获取类属性</span></span><br><span class="line">Student.<span class="built_in">type</span>=<span class="string">&#x27;human&#x27;</span>   <span class="comment"># 类属性只能通过类对象来修改，实例对象无法修改类属性</span></span><br><span class="line"><span class="built_in">print</span>(s1.<span class="built_in">type</span>)   <span class="comment"># human    </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：</p><ol type="1"><li>尽量避免类属性和实例对象的属性同名，若同名，实例对象会优先访问实例对象的属性。</li><li>类属性只能通过类对象修改，不能通过实例对象修改。</li><li>类属性可以设置私有属性。</li></ol></blockquote><h2 id="私有属性和方法">私有属性和方法</h2><h3 id="私有属性和私有方法">私有属性和私有方法</h3><p>在实际开发中，对象的某些属性或者方法可能只希望在对象的内部使用，而不希望在外部被访问到，这时就可以定义<strong>私有属性</strong>和<strong>私有方法</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = <span class="number">80</span>  <span class="comment"># 使用 __ 修饰的属性，是私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pass</span>(<span class="params">self, line</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__score &gt;= line:  <span class="comment"># __score只能在对象内部使用</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;该学生成绩合格&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;该学生成绩不合格&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        self.__<span class="keyword">pass</span>(<span class="number">60</span>)  <span class="comment"># __pass方法也只能在对象内部使用</span></span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="comment">#print(s.__score)   会报错，不能直接访问对象内部的私有属性</span></span><br><span class="line">s.test()    <span class="comment"># 该学生成绩合格</span></span><br><span class="line"><span class="comment"># s.__pass()  会报错，不能直接调用pass函数，它是私有方法。</span></span><br></pre></td></tr></table></figure><h3 id="访问私有属性和私有方法">访问私有属性和私有方法</h3><p>私有属性和私有方法都不能直接调用。但是，我们也可以通过一些操作在外部访问一个对象的私有属性和方法。</p><h4 id="直接访问">直接访问</h4><p>语法格式：在私有属性名或者方法名前面添加 <code>__类名</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = <span class="number">80</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pass</span>(<span class="params">self, line</span>):</span><br><span class="line">        <span class="keyword">if</span> self.__score &gt;= line:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;该学生成绩合格&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;该学生成绩不合格&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s._Student__score)   <span class="comment"># 80  </span></span><br><span class="line">s._Student__pass(<span class="number">90</span>)  <span class="comment"># 该学生成绩不合格</span></span><br></pre></td></tr></table></figure><blockquote><p>使用对象名._类名__私有属性名可以直接访问对象的私有属性(在实际开发中，不建议使用此方法来访问私有属性）</p><p>使用对象名._类名__函数名 可以直接调用对象的私有方法</p></blockquote><h4 id="定义方法访问私有变量">定义方法访问私有变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = <span class="number">80</span>  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):  <span class="comment"># 定义了get_score 方法，在这个方法里可以获取 __score的值</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self,new_score</span>):<span class="comment"># 定义了set_score 方法，在这个方法里可以修改 __score的值</span></span><br><span class="line">        self.__score=new_score</span><br><span class="line">        </span><br><span class="line">s = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.get_score())   <span class="comment"># 80</span></span><br><span class="line">s.set_score(<span class="number">90</span>)</span><br><span class="line"><span class="built_in">print</span>(s.get_score())   <span class="comment"># 90</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;属性&quot;&gt;属性&lt;/h1&gt;
&lt;h2 id=&quot;类的内置属性&quot;&gt;类的内置属性&lt;/h2&gt;
&lt;p&gt;Python中有很多的内置属性，我们可以通过使用内置函数 dir()
来查看一个对象支持的所有属性和方法。&lt;/p&gt;
&lt;figure class=&quot;highlight py</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>https://luyicui.github.io/2024/12/24/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</id>
    <published>2024-12-24T06:52:25.436Z</published>
    <updated>2024-12-24T13:17:23.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="魔法方法">魔法方法</h1><p>Python里面有一种特殊的方法，叫做魔法方法。Python的<font color='blue'><strong>类</strong></font>里提供的，是由两个下划线开始，再以两个下划线结束的方法。</p><p>魔法方法不需要手动调用，会在恰当的时候就会被激活，自动执行。</p><p>魔法方法的名字都是系统规定好的，不能乱写，在合适的时候自己调用。</p><h2 id="init__">__init__()</h2><p>__init__()方法，在创建一个对象时默认被调用，不需要手动调用。在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对__init__方法进行改造。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):  <span class="comment"># 重写了___init__魔法方法，设置对象的属性</span></span><br><span class="line">        <span class="comment"># 在创建对象时，会自动调用这个方法。</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__方法被调用了&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;正在玩游戏&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>) <span class="comment">#创建对象时，必须要指定name属性的值</span></span><br><span class="line"><span class="built_in">print</span>(s1.name)  <span class="comment"># 张三</span></span><br><span class="line">s1.play_game()  <span class="comment"># 张三正在玩游戏</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__init__方法被调用了  </span><br><span class="line">张三  </span><br><span class="line">张三正在玩游戏</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol type="1"><li>__init__()方法在创建对象时默认被调用，不需要手动调用。</li><li>__init__()方法里的self参数，在创建对象时不需要传递参数，python解释器会把创建好的对象引用直接赋值给self</li><li>在类的内部，可以使用self来使用属性和调用方法；在类的外部，需要使用对象名来使用属性和调用方法。</li><li>如果有多个对象，每个对象的属性是各自保存的，都有各自独立的地址。</li><li>方法是所有对象共享的，只占用一份内存空间，方法被调用时会通过self来判断是哪个对象调用了实例方法。</li></ol><h2 id="del__">__del__()</h2><p>既然有创建对象时的魔法方法调用，就会有删除对象时的魔法方法调用，__del__()方法就是当对象被销毁时，会自动调用这个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__方法被调用了&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 当对象被销毁时，会自动调用这个方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__del__ 方法被调用了&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;正在玩游戏&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">del</span> s1</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__init__方法被调用了  </span><br><span class="line">__del__ 方法被调用了</span><br></pre></td></tr></table></figure><h2 id="str__">__str__()</h2><p>__str__方法返回对象的描述信息，使用print()函数打印对象时，其实调用的就是这个对象的__str__方法。</p><p>调用对象的__str__方法，默认会打印<strong>类名</strong>和对象的<strong>地址</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)   <span class="comment"># &lt;__main__.Student object at 0x00000298D1161808&gt;</span></span><br></pre></td></tr></table></figure><p>那我们如何得到s1的值呢？其实想要修改对象的输出结果，我们就需要重写__str__方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;姓名:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># 姓名:张三</span></span><br></pre></td></tr></table></figure><h2 id="repr__">__repr__()</h2><p>__repr__方法和__str__方法功能类似，都是用来修改一个对象的默认打印内容。在打印一个对象时，如果没有重写__str__方法，它会自动来查找__repr__方法。如果这两个方法都没有，会直接打印这个对象的内存地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;姓名:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># 姓名:张三</span></span><br></pre></td></tr></table></figure><p>倘若__repr__方法和__str__方法同时出现，会发生什么情况呢？？？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;姓名:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># 姓名:张三</span></span><br></pre></td></tr></table></figure><p>从上面的实例可知，若两种方法同时出现，会选择调用__str__方法。</p><p>如果还想在有__str__方法的情况下，调用__repr__方法，我们可以调用内置函数<code>repr()</code> 或者手动调用__repr__方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;姓名:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name)</span><br><span class="line">s1 = Student(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment">#自动调用__str__方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(s1))  <span class="comment"># 调用内置函数 repr 会触发对象的 __repr__ 方法</span></span><br><span class="line"><span class="built_in">print</span>(s1.__repr__())  <span class="comment"># 手动调用__repr__魔法方法</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">姓名:张三  </span><br><span class="line">hello world  </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol type="1"><li>如果不做任何的修改，直接打印一个对象，<code>$&#123;__name__&#125;.类型 object at 内存地址</code></li><li>当打印一个对象的时候，会调用这个对象的<strong><code>__str__()</code></strong> 或者<strong><code>__repr__()</code></strong> 方法</li><li>如果两个方法都写了，选择<strong><code>__str__()</code></strong></li><li>如果在两个方法都写了的情况下，调用__repr__方法，我们可以调用内置函数<code>repr()</code> 或者手动调用__repr__方法。</li></ol><h2 id="call__">__call__()</h2><p><code>__call__</code>允许<strong>类的实例化对象</strong>像<strong>函数</strong>一样被调用。如果类里没有实现<code>__call__()</code>，此时一个类的实例化对象不是一个可调用的对象，当调用它时会报错：‘XXX’object is not callable.</p><p>先看一个简单的案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello &quot;</span>+self.name)</span><br><span class="line"></span><br><span class="line">a = People(<span class="string">&#x27;无忌！&#x27;</span>)</span><br><span class="line">a.__call__()       <span class="comment"># 调用方法一</span></span><br><span class="line">a()                <span class="comment"># 调用方法二</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello 无忌！</span><br><span class="line">hello 无忌！</span><br></pre></td></tr></table></figure><p>在编写类的时候，如果写了<code>__call__()</code>方法，在实例化的对象进行调用的时候就会有<code>object.__call__()</code>和<code>object()</code>这两种使用方式效果一样的现象，即调用方法一和调用方法二效果一样。</p><h2 id="比较运算符相关的魔法方法">比较运算符相关的魔法方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line">s2 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure><p>s1和s2是否是同一个对象？</p><p>比较两个对象是否是同一个对象，我们需要比较的是<strong>内存地址</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0x%X&#x27;</span> % <span class="built_in">id</span>(s1))  <span class="comment"># 0x16AA83BB408</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0x%X&#x27;</span> % <span class="built_in">id</span>(s2))  <span class="comment"># 0x16AA83BB448</span></span><br></pre></td></tr></table></figure><p>由上可知，它们的内存地址不一样，两个对象不是同一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s1 is s2&#x27;</span>, s1 <span class="keyword">is</span> s2)  <span class="comment"># s1 is s2 False</span></span><br><span class="line"><span class="built_in">print</span>(s1 == s2)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><blockquote><p><code>is</code> 是身份运算符，比较两个对象的内存地址</p></blockquote><p>== 会调用对象的 <strong>__eq__</strong>方法，如果不重写，默认比较依然是内存地址，如果重写方法，便可以获取这个方法的比较结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name == other.name <span class="keyword">and</span> self.score == other.score</span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line">s2 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line"><span class="built_in">print</span>(s1 == s2)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>其它比较运算符，也是如此。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name == other.name <span class="keyword">and</span> self.score == other.score</span><br><span class="line">    <span class="comment">#def __ne__(self, other):# 使用 != 运算符会自动调用这个方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score &lt; other.score</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score &gt; other.score</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>): </span><br><span class="line">        <span class="keyword">return</span> self.score &lt;= other.score</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ge__</span>(<span class="params">self, other</span>): </span><br><span class="line">        <span class="keyword">return</span> self.score &gt;= other.score</span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line">s2 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line">s3 = Student(<span class="string">&#x27;lisi&#x27;</span>, <span class="number">94</span>)</span><br><span class="line">s4 = Student(<span class="string">&#x27;wangwu&#x27;</span>, <span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(s1 == s2)  <span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(s1 != s2)  <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt; s3)   <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt;= s4)  <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(s1 &lt; s4)   <span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(s1 &lt;= s3)  <span class="comment">#True</span></span><br></pre></td></tr></table></figure><h2 id="算数运算符相关的魔法方法">算数运算符相关的魔法方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score + other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score - other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name * other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__truediv__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score / other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mod__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score % other</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__pow__</span>(<span class="params">self, power, modulo=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> self.score ** power</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">95</span>)</span><br><span class="line"><span class="built_in">print</span>(s + <span class="number">1</span>)  <span class="comment"># 96</span></span><br><span class="line"><span class="built_in">print</span>(s - <span class="number">2</span>)  <span class="comment"># 93</span></span><br><span class="line"><span class="built_in">print</span>(s * <span class="number">2</span>)  <span class="comment"># zhangsanzhangsan</span></span><br><span class="line"><span class="built_in">print</span>(s / <span class="number">5</span>)  <span class="comment"># 19.0</span></span><br><span class="line"><span class="built_in">print</span>(s % <span class="number">5</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(s ** <span class="number">2</span>) <span class="comment"># 9025</span></span><br></pre></td></tr></table></figure><h2 id="类型转换相关的魔法方法">类型转换相关的魔法方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__int__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__float__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score * <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.score &gt; <span class="number">60</span></span><br><span class="line">        </span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">90</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(s1))   <span class="comment"># 90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(s1)) <span class="comment"># 90.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(s1))   <span class="comment"># zhangsan</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(s1))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="属性相关的魔法方法">属性相关的魔法方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    z = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.money = <span class="number">10000</span></span><br><span class="line">        self.y = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set %s = %s&#x27;</span> % (name, value))</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;getattribute %s&#x27;</span> % name)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;getattr %s&#x27;</span> % name)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 属性不存在时返回默认值</span></span><br><span class="line"></span><br><span class="line">u = User()  <span class="comment"># 调用 __init__ 和 __setattr__</span></span><br><span class="line"><span class="built_in">print</span>(u.money)  <span class="comment"># 调用 __getattribute__</span></span><br><span class="line"><span class="built_in">print</span>(u.abc)  <span class="comment"># 调用 __getattribute__ 和 __getattr__</span></span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：</p><ol type="1"><li><code>u = User()</code>：<ul><li>调用 <code>__init__()</code>，设置 <code>money</code> 和<code>y</code> 属性。</li><li>每次 <code>self.money = 10000</code> 都会调用<code>__setattr__()</code>。</li></ul></li><li><code>print(u.money)</code>：<ul><li>调用 <code>__getattribute__()</code> 来访问 <code>money</code>属性。</li></ul></li><li><code>print(u.abc)</code>：<ul><li>调用 <code>__getattribute__()</code> 尝试查找属性<code>abc</code>，发现不存在，调用 <code>__getattr__()</code>。</li></ul></li></ol><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set money = 10000</span><br><span class="line">set y = abc</span><br><span class="line">getattribute money</span><br><span class="line">10000</span><br><span class="line">getattribute abc</span><br><span class="line">getattr abc</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="setattr__">__setattr__()</h3><ul><li><p>在给对象设置属性时会自动调用。</p></li><li><p>如果覆盖了 <code>__setattr__</code>，需要显式调用父类方法<code>object.__setattr__</code>，否则会导致递归调用。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;set <span class="subst">&#123;name&#125;</span> = <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">object</span>.__setattr__(self, name, value)  <span class="comment"># 正确的方式</span></span><br></pre></td></tr></table></figure><h3 id="getattribute__">__getattribute__()</h3><ul><li><p>在访问任何属性时都会触发此方法。</p></li><li><p>覆盖此方法需要特别小心，避免无限递归：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;getattribute <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, name)</span><br></pre></td></tr></table></figure><h3 id="getattr__">__getattr__()</h3><ul><li>当访问一个<strong>不存在的属性</strong>时会触发。</li><li>常用于提供默认值或处理动态属性：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;getattr <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 返回默认值</span></span><br></pre></td></tr></table></figure><h2 id="容器方法">容器方法</h2><p>容器方法是 Python 中与<strong>容器对象</strong>（如列表、元组、字典、集合等）交互的魔术方法。这些方法定义了如何使用容器对象进行常见操作，例如计算长度、遍历、索引操作、成员检查等。</p><ol type="1"><li><p><strong><code>__len__</code> 方法</strong></p><ul><li><p><strong>作用</strong>：用于返回容器的长度。</p></li><li><p><strong>触发方式</strong>：通过调用 <code>len()</code>函数触发。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self.items = items</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br><span class="line"></span><br><span class="line">container = MyContainer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(container))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>__iter__</code> 方法</strong></p><ul><li><p><strong>作用</strong>：定义对象是否可以被迭代。</p></li><li><p><strong>触发方式</strong>：通过 <code>for</code>循环或任何需要迭代的上下文触发。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self.items = items</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.items)</span><br><span class="line"></span><br><span class="line">container = MyContainer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> container:</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 输出 1, 2, 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>__contains__</code> 方法</strong></p><ul><li><p><strong>作用</strong>：定义对象是否支持 <code>in</code>操作（成员检查）。</p></li><li><p><strong>触发方式</strong>：通过 <code>in</code> 或<code>not in</code> 运算符触发。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self.items = items</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self.items</span><br><span class="line"></span><br><span class="line">container = MyContainer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">in</span> container)  <span class="comment"># 输出 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> <span class="keyword">in</span> container)  <span class="comment"># 输出 False</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>__getitem__</code> 方法</strong></p><ul><li><p><strong>作用</strong>：定义对象是否支持通过下标或键访问元素。</p></li><li><p><strong>触发方式</strong>：通过 <code>[]</code>访问触发。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self.items = items</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.items[index]</span><br><span class="line"></span><br><span class="line">container = MyContainer([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(container[<span class="number">1</span>])  <span class="comment"># 输出 20</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>__setitem__</code> 方法</strong></p><ul><li><p><strong>作用</strong>：定义对象是否支持通过下标或键设置元素。</p></li><li><p><strong>触发方式</strong>：通过 <code>[]</code>设置值触发。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        self.items = items</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, index, value</span>):</span><br><span class="line">        self.items[index] = value</span><br><span class="line"></span><br><span class="line">container = MyContainer([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line">container[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(container.items)  <span class="comment"># 输出 [10, 99, 30]</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="上下文管理with">上下文管理with</h2><p>__ enter__ 进⼊ with 代码块前的准备操作</p><p>__ exit__ 退出时的善后操作</p><p>⽂件对象、线程锁、socket 对象等都可以使⽤ with 操作。</p><p>为什么要使用with来操作？？？因为使用with可以自动关闭文件，即便是代码程序报错，其也能关闭文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exec enter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, a1, a2, a3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exec exit&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a1:&#x27;</span>, a1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a2:&#x27;</span>, a2)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;a3:&#x27;</span>, a3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> A() <span class="keyword">as</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a = &#x27;</span>, a)</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;errorerror&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202412242110101.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="槽__-slots__">槽（__ slots__）</h2><p>其可以固定类所具有的属性，使实例不会分配__dict__，也无法动态添加属性，但其可以优化内存分配。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202412242109963.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;魔法方法&quot;&gt;魔法方法&lt;/h1&gt;
&lt;p&gt;Python里面有一种特殊的方法，叫做魔法方法。Python的&lt;font color=&#39;blue&#39;&gt;&lt;strong&gt;类&lt;/strong&gt;&lt;/font&gt;里提供的，是由两个下划线开始，再以两个下划线结束的方法。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/16/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/Errors/"/>
    <id>https://luyicui.github.io/2024/12/16/[object%20Object]/%E3%80%90%E5%90%8E%E7%AB%AF%E3%80%91/python/Errors/</id>
    <published>2024-12-16T15:18:24.979Z</published>
    <updated>2024-12-17T12:23:49.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="errors">Errors</h1><h2 id="modulenotfounderror">ModuleNotFoundError</h2><p><a href="./ModuleNotFoundError.md">ModuleNotFoundError</a></p><h2 id="valueerror-not-enough-values-to-unpack">ValueError: not enoughvalues to unpack</h2><p>好的，以下是一个简单的示例，展示了在 <code>for</code>循环中无法正确解包导致出错的情况。</p><h3 id="示例代码">示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们有一个列表，其中包含元组和非元组的元素</span></span><br><span class="line">data = [</span><br><span class="line">    (<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="string">&quot;x&quot;</span>),  <span class="comment"># 正常的元组，能够解包</span></span><br><span class="line">    (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>),       <span class="comment"># 错误的元组，少了一个元素</span></span><br><span class="line">    (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="string">&quot;y&quot;</span>),  <span class="comment"># 正常的元组，能够解包</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,            <span class="comment"># 错误的元素，不是元组</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试在for循环中解包每个元素</span></span><br><span class="line"><span class="keyword">for</span> i, (letter, num, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Index <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;letter&#125;</span>, <span class="subst">&#123;num&#125;</span>, <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面错误的元素通常意味着处理的时候出现了问题</p><h3 id="错误输出">错误输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Index 0: a, 1, x</span><br><span class="line">Index 1: b, 2, Traceback (most recent call last):</span><br><span class="line">  File &quot;example.py&quot;, line 9, in &lt;module&gt;</span><br><span class="line">    for i, (letter, num, value) in enumerate(data):</span><br><span class="line">ValueError: not enough values to unpack (expected 3, got 2)</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><ul><li>第 1 个和第 3 个元素是正常的元组，包含 3 个元素，可以成功解包。</li><li>第 2 个元素是一个只包含 2 个元素的元组 (<code>("b", 2)</code>)，这时<code>for</code> 循环解包时会报错，因为期望解包 3 个元素，但实际上只有 2个。</li><li>第 4 个元素是一个字符串 <code>"d"</code>，它不是元组，也无法解包成<code>letter, num, value</code>，同样会引发错误。</li></ul><h3 id="错误的原因">错误的原因</h3><ul><li><p>当 <code>for</code> 循环尝试解包时，它期望每个元素都包含 3个值，但在某些元素中缺少或不符合这个格式，导致解包失败。</p><p>在这个例子中，代码尝试将每个元素解包为 3 个变量(<code>letter, num, value</code>)，但第二个元素是一个只有 2个值的元组，而第四个元素根本不是一个元组，因此会报错。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;errors&quot;&gt;Errors&lt;/h1&gt;
&lt;h2 id=&quot;modulenotfounderror&quot;&gt;ModuleNotFoundError&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;./ModuleNotFoundError.md&quot;&gt;ModuleNotFoundErro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/vue/6.3%20%E8%AF%BE%E4%B8%8A%E9%A1%B9%E7%9B%AE%E7%9A%84API/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/vue/6.3%20%E8%AF%BE%E4%B8%8A%E9%A1%B9%E7%9B%AE%E7%9A%84API/</id>
    <published>2024-12-06T14:39:44.085Z</published>
    <updated>2024-12-06T14:39:44.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航6.-vue3">导航：<a href="../6.%20Vue3.md">6. Vue3</a></h2><h2 id="获取json-web-tokenjwt">1. 获取Json Web Token（JWT）</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/api/token/</li><li>方法：<code>POST</code></li><li>是否验证jwt：否</li><li>输入参数：<ul><li><code>username</code>: 用户名</li><li><code>password</code>: 密码</li></ul></li><li>返回结果：<ul><li><code>access</code>: 访问令牌，有效期5分钟</li><li><code>refresh</code>: 刷新令牌，有效期14天</li></ul></li></ul><h2 id="刷新jwt令牌">2. 刷新JWT令牌</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/api/token/refresh/</li><li>方法：<code>POST</code></li><li>是否验证jwt：否</li><li>输入参数：<ul><li><code>refresh</code>: 刷新令牌</li></ul></li><li>返回结果：<ul><li><code>access</code>: 访问令牌，有效期5分钟</li></ul></li></ul><h2 id="获取用户列表">3. 获取用户列表</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/myspace/userlist/</li><li>方法：<code>GET</code></li><li>是否验证jwt：否</li><li>输入参数：无</li><li>返回结果：返回10个用户的信息</li></ul><h2 id="获取某个用户的信息">4. 获取某个用户的信息</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/myspace/getinfo/</li><li>方法：<code>GET</code></li><li>是否验证jwt：是</li><li>输入参数：<ul><li><code>user_id</code>：用户的ID</li></ul></li><li>返回结果：该用户的信息</li></ul><h2 id="获取某个用户的所有帖子">5. 获取某个用户的所有帖子</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/myspace/post/</li><li>方法：<code>GET</code></li><li>是否验证jwt：是</li><li>输入参数：<ul><li><code>user_id</code>：用户的ID</li></ul></li><li>返回结果：该用户的所有帖子</li></ul><h2 id="创建一个帖子">6. 创建一个帖子</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/myspace/post/</li><li>方法：<code>POST</code></li><li>是否验证jwt：是</li><li>输入参数：<ul><li><code>content</code>：帖子的内容</li></ul></li><li>返回结果：<code>result: success</code></li></ul><h2 id="删除一个帖子">7. 删除一个帖子</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/myspace/post/</li><li>方法：<code>DELETE</code></li><li>是否验证jwt：是</li><li>输入参数：<ul><li><code>post_id</code>：被删除帖子的ID</li></ul></li><li>返回结果：<code>result: success</code></li></ul><h2 id="更改关注状态">8. 更改关注状态</h2><p>如果未关注，则关注；如果已关注，则取消关注。</p><ul><li>地址：https://app165.acapp.acwing.com.cn/myspace/follow/</li><li>方法：<code>POST</code></li><li>是否验证jwt：是</li><li>输入参数：<ul><li><code>target_id</code>: 被关注的用户ID</li></ul></li><li>返回结果：<code>result: success</code></li></ul><h2 id="注册账号">9. 注册账号</h2><ul><li>地址：https://app165.acapp.acwing.com.cn/myspace/user/</li><li>方法：<code>POST</code></li><li>是否验证jwt：否</li><li>输入参数：<ul><li><code>username</code>: 用户名</li><li><code>password</code>：密码</li><li><code>password_confirm</code>：确认密码</li></ul></li><li>返回结果：<ul><li><code>result: success</code></li><li><code>result: 用户名和密码不能为空</code></li><li><code>result: 两个密码不一致</code></li><li><code>result: 用户名已存在</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航6.-vue3&quot;&gt;导航：&lt;a href=&quot;../6.%20Vue3.md&quot;&gt;6. Vue3&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;获取json-web-tokenjwt&quot;&gt;1. 获取Json Web Token（JWT）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;地址：h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/vue/6.2%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/vue/6.2%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2024-12-06T14:39:44.071Z</published>
    <updated>2024-12-06T14:39:44.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航6.-vue3">导航：<a href="../6.%20Vue3.md">6. Vue3</a></h2><h2 id="script部分">script部分</h2><p><code>export default</code>对象的属性：</p><ul><li><code>name</code>：组件的名称</li><li><code>components</code>：存储<code>&lt;template&gt;</code>中用到的所有组件</li><li><code>props</code>：存储父组件传递给子组件的数据</li><li><code>watch()</code>：当某个数据发生变化时触发</li><li><code>computed</code>：动态计算某个数据</li><li><code>setup(props, context)</code>：初始化变量、函数<ul><li><code>ref</code>定义变量，可以用<code>.value</code>属性重新赋值</li><li><code>reactive</code>定义对象，不可重新赋值</li><li><code>props</code>存储父组件传递过来的数据</li><li><code>context.emit()</code>：触发父组件绑定的函数</li></ul></li></ul><h2 id="template部分">template部分</h2><ul><li><code>&lt;slot&gt;&lt;/slot&gt;</code>：存放父组件传过来的<code>children</code>。</li><li><code>v-on:click</code>或<code>@click</code>属性：绑定事件</li><li><code>v-if</code>、<code>v-else</code>、<code>v-else-if</code>属性：判断</li><li><code>v-for</code>属性：循环，<code>:key</code>循环的每个元素需要有唯一的<code>key</code></li><li><code>v-bind:</code>或<code>:</code>：绑定属性</li></ul><h2 id="style部分">style部分</h2><ul><li><code>&lt;style&gt;</code>标签添加`属性后，不同组件间的css不会相互影响。</li></ul><h2 id="第三方组件">第三方组件</h2><ul><li><code>view-router</code>包：实现路由功能。</li><li><code>vuex</code>：存储全局状态，全局唯一。<ul><li><code>state</code>:存储所有数据，可以用<code>modules</code>属性划分成若干模块</li><li><code>getters</code>：根据<code>state</code>中的值计算新的值</li><li><code>mutations</code>：所有对<code>state</code>的修改操作都需要定义在这里，不支持异步，可以通过<code>$store.commit()</code>触发</li><li><code>actions</code>：定义对<code>state</code>的复杂修改操作，支持异步，可以通过<code>$store.dispatch()</code>触发。注意不能直接修改<code>state</code>，只能通过<code>mutations</code>修改<code>state</code>。</li><li><code>modules</code>：定义<code>state</code>的子模块</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航6.-vue3&quot;&gt;导航：&lt;a href=&quot;../6.%20Vue3.md&quot;&gt;6. Vue3&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;script部分&quot;&gt;script部分&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;export default&lt;/code&gt;对象的属性：&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/vue/6.1%20%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/vue/6.1%20%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</id>
    <published>2024-12-06T14:39:44.059Z</published>
    <updated>2024-12-06T14:39:44.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航6.-vue3">导航：<a href="../6.%20Vue3.md">6. Vue3</a></h2><p><a href="https://vuejs.org/">Vue官网</a></p><h2 id="终端">终端</h2><p><code>Linux</code>和<code>Mac</code>上可以用自带的终端。</p><p><code>Windows</code>上推荐用<code>powershell</code>或者<code>cmd</code>。<code>Git Bash</code>有些指令不兼容。</p><h2 id="安装nodejs">安装<code>Nodejs</code></h2><p><a href="https://nodejs.org/en/">安装地址</a></p><h2 id="安装vuecli">安装<code>@vue/cli</code></h2><p>打开<code>Git Bash</code>，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @vue/cli</span><br></pre></td></tr></table></figure><p>如果执行后面的操作有bug，可能是最新版有问题，可以尝试安装早期版本，比如：<code>npm i -g @vue/cli@4</code></p><h2id="启动vue自带的图形化项目管理界面">启动<code>vue</code>自带的图形化项目管理界面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>常见问题1：Windows上运行<code>vue</code>，提示无法加载文件，表示用户权限不足。</p><p>解决方案：用管理员身份打开终端，输入<code>set-ExecutionPolicy RemoteSigned</code>，然后输入<code>y</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航6.-vue3&quot;&gt;导航：&lt;a href=&quot;../6.%20Vue3.md&quot;&gt;6. Vue3&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://vuejs.org/&quot;&gt;Vue官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;终端&quot;&gt;终端&lt;/h2&gt;
&lt;p&gt;&lt;co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.7%20%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.7%20%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2024-12-06T14:39:32.353Z</published>
    <updated>2024-12-06T14:39:32.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航5.-react">导航：<a href="../5.%20React.md">5. React</a></h2><h2 id="apilogin">API——login</h2><p>登录</p><p><code>https://app165.acapp.acwing.com.cn/calculator/login/</code></p><ul><li>输入参数：<code>username</code>、<code>password</code></li><li>输出参数：<code>result</code><ul><li><code>result = "success"</code>：表示登录成功</li><li><code>result = "用户名或密码不正确"</code>：表示错误信息</li></ul></li></ul><h2 id="apilogout">API——logout</h2><p>退出</p><p><code>https://app165.acapp.acwing.com.cn/calculator/logout/</code></p><ul><li>输入参数：无</li><li>输出参数：<code>result</code><ul><li><code>result = "success"</code>：表示退出成功</li></ul></li></ul><h2 id="apiregister">API——register</h2><p>注册</p><p><code>https://app165.acapp.acwing.com.cn/calculator/register/</code></p><ul><li>输入参数：<code>username</code>、<code>password</code>、<code>password_confirm</code></li><li>输出参数：<code>result</code><ul><li><code>result = "success"</code>：表示注册成功</li><li><code>result = "用户名和密码不能为空"</code>：表示错误信息</li><li><code>result = "两个密码不一致"</code>：表示错误信息</li><li><code>result = "用户名已存在"</code>：表示错误信息</li></ul></li></ul><h2 id="apiget_status">API——get_status</h2><p>查询登录状态，如果已登录，则返回用户名</p><p><code>https://app165.acapp.acwing.com.cn/calculator/get_status/</code></p><ul><li>输入参数：无</li><li>输出参数：<code>result</code>、<code>username</code><ul><li><code>result = "login"</code>，此时有返回值<code>useranme</code>，表示已登录的用户名</li><li><code>result = "logout"</code>，此时<code>username</code>不存在，表示未登录</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航5.-react&quot;&gt;导航：&lt;a href=&quot;../5.%20React.md&quot;&gt;5. React&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;apilogin&quot;&gt;API——login&lt;/h2&gt;
&lt;p&gt;登录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://app165.a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.6%20Redux/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.6%20Redux/</id>
    <published>2024-12-06T14:39:32.341Z</published>
    <updated>2024-12-06T14:39:32.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航5.-react">导航：<a href="../5.%20React.md">5. React</a></h2><p>redux将所有数据存储到树中，且树是唯一的。</p><h2 id="redux基本概念">Redux基本概念</h2><ul><li><code>store</code>：存储树结构。</li><li><code>state</code>：维护的数据，一般维护成树的结构。</li><li><code>reducer</code>：对<code>state</code>进行更新的函数，每个<code>state</code>绑定一个<code>reducer</code>。传入两个参数：当前<code>state</code>和<code>action</code>，返回新<code>state</code>。</li><li><code>action</code>：一个普通对象，存储<code>reducer</code>的传入参数，一般描述对<code>state</code>的更新类型。</li><li><code>dispatch</code>：传入一个参数<code>action</code>，对整棵<code>state</code>树操作一遍。</li></ul><h2 id="react-redux基本概念">React-Redux基本概念</h2><ul><li><code>Provider</code>组件：用来包裹整个项目，其<code>store</code>属性用来存储<code>redux</code>的<code>store</code>对象。</li><li><code>connect(mapStateToProps, mapDispatchToProps)</code>函数：用来将<code>store</code>与组件关联起来。<ul><li><code>mapStateToProps</code>：每次<code>store</code>中的状态更新后调用一次，用来更新组件中的值。</li><li><code>mapDispatchToProps</code>：组件创建时调用一次，用来将<code>store</code>的<code>dispatch</code>函数传入组件。</li></ul></li></ul><h2 id="安装">安装</h2><ul><li><code>npm i redux react-redux @reduxjs/toolkit</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航5.-react&quot;&gt;导航：&lt;a href=&quot;../5.%20React.md&quot;&gt;5. React&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;redux将所有数据存储到树中，且树是唯一的。&lt;/p&gt;
&lt;h2 id=&quot;redux基本概念&quot;&gt;Redux基本概念&lt;/h2&gt;
&lt;ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.5%20%E8%B7%AF%E7%94%B1/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.5%20%E8%B7%AF%E7%94%B1/</id>
    <published>2024-12-06T14:39:30.872Z</published>
    <updated>2024-12-06T14:39:31.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航5.-react">导航：<a href="../5.%20React.md">5. React</a></h2><h2 id="web分类">Web分类</h2><ul><li>静态页面：页面里的数据是写死的</li><li>动态页面：页面里的数据是动态填充的<ul><li>后端渲染：数据在后端填充</li><li>前端渲染：数据在前端填充</li></ul></li></ul><h2 id="安装环境">安装环境</h2><ul><li>VSCODE安装插件：<code>Auto Import - ES6, TS, JSX, TSX</code></li><li>安装<code>Route</code>组件：<code>npm i react-router-dom</code></li></ul><h2 id="route组件介绍">Route组件介绍</h2><ul><li><code>BrowserRouter</code>：所有需要路由的组件，都要包裹在<code>BrowserRouter</code>组件内</li><li><code>Link</code>：跳转到某个链接，<code>to</code>属性表示跳转到的链接</li><li><code>Routes</code>：类似于C++中的<code>switch</code>，匹配第一个路径</li><li><code>Route</code>：路由，<code>path</code>属性表示路径，<code>element</code>属性表示路由到的内容</li></ul><h2 id="url中传递参数">URL中传递参数</h2><p>解析URL：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/linux/:chapter_id/:section_id/&quot;</span> element=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Linux</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>获取参数，类组件写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linux</span> extends Component &#123;</span><br><span class="line">    state = &#123;  &#125; </span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(this.props.params);</span><br><span class="line">        <span class="keyword">return</span> &lt;h1&gt;Linux&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default (props) =&gt; (</span><br><span class="line">    &lt;Linux</span><br><span class="line">        &#123;...props&#125;</span><br><span class="line">        params=&#123;useParams()&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>函数组件写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line">const Linux = () =&gt; &#123;</span><br><span class="line">    console.log(useParams());</span><br><span class="line">    <span class="keyword">return</span> (&lt;h1&gt;Linux&lt;/h1&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Linux;</span><br></pre></td></tr></table></figure><h2 id="search-params传递参数">Search Params传递参数</h2><p>类组件写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSearchParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Django</span> extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        searchParams: this.props.params[<span class="number">0</span>],  // 获取某个参数</span><br><span class="line">        setSearchParams: this.props.params[<span class="number">1</span>],  // 设置链接中的参数，然后重新渲染当前页面</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleClick = () =&gt; &#123;</span><br><span class="line">        this.state.setSearchParams(&#123;</span><br><span class="line">            name: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            age: <span class="number">20</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(this.state.searchParams.get(<span class="string">&#x27;age&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> &lt;h1 onClick=&#123;this.handleClick&#125;&gt;Django&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default (props) =&gt; (</span><br><span class="line">    &lt;Django</span><br><span class="line">        &#123;...props&#125;</span><br><span class="line">        params=&#123;useSearchParams()&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>函数组件写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSearchParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line">const Django = () =&gt; &#123;</span><br><span class="line">    let [searchParams, setSearchParams] = useSearchParams();</span><br><span class="line">    console.log(searchParams.get(<span class="string">&#x27;age&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> (&lt;h1&gt;Django&lt;/h1&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Django;</span><br></pre></td></tr></table></figure><h2 id="重定向">重定向</h2><p>使用<code>Navigate</code>组件可以重定向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;*&quot;</span> element=&#123; &lt;Navigate replace to=<span class="string">&quot;/404&quot;</span> /&gt; &#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="嵌套路由">嵌套路由</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/web&quot;</span> element=&#123;&lt;Web /&gt;&#125;&gt;</span><br><span class="line">    &lt;Route index path=<span class="string">&quot;a&quot;</span> element=&#123;&lt;h1&gt;a&lt;/h1&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route index path=<span class="string">&quot;b&quot;</span> element=&#123;&lt;h1&gt;b&lt;/h1&gt;&#125; /&gt;</span><br><span class="line">    &lt;Route index path=<span class="string">&quot;c&quot;</span> element=&#123;&lt;h1&gt;c&lt;/h1&gt;&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>注意：需要在父组件中添加<code>&lt;Outlet /&gt;</code>组件，用来填充子组件的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航5.-react&quot;&gt;导航：&lt;a href=&quot;../5.%20React.md&quot;&gt;5. React&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;web分类&quot;&gt;Web分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态页面：页面里的数据是写死的&lt;/li&gt;
&lt;li&gt;动态页面：页面里</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.4%20%E7%BB%84%E5%90%88Components/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.4%20%E7%BB%84%E5%90%88Components/</id>
    <published>2024-12-06T14:39:30.858Z</published>
    <updated>2024-12-06T14:39:31.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航5.-react">导航：<a href="../5.%20React.md">5. React</a></h2><h2 id="创建boxes组件">5.4.1 创建<code>Boxes</code>组件</h2><p><code>Boxes</code>组件中包含一系列<code>Box</code>组件。</p><h2 id="从上往下传递数据">5.4.2 从上往下传递数据</h2><p>通过<code>this.props</code>属性可以从上到下传递数据。</p><h2 id="传递子节点">5.4.3 传递子节点</h2><p>通过<code>this.props.children</code>属性传递子节点</p><h2 id="从下往上调用函数">5.4.4 从下往上调用函数</h2><p>注意：每个组件的<code>this.state</code>只能在组件内部修改，不能在其他组件内修改。</p><h2 id="每个维护的数据仅能保存在一个this.state中">5.4.5每个维护的数据仅能保存在一个<code>this.state</code>中</h2><ul><li>不要直接修改<code>this.state</code>的值，因为<code>setState</code>函数可能会将修改覆盖掉。</li></ul><h2 id="创建app组件">5.4.6 创建App组件</h2><p>包含：</p><ul><li>导航栏组件</li><li><code>Boxes</code>组件</li></ul><p>注意：</p><ul><li>要将多个组件共用的数据存放到最近公共祖先的<code>this.state</code>中。</li></ul><h2 id="无状态函数组件">5.4.7 无状态函数组件</h2><ul><li>当组件中没有用到<code>this.state</code>时，可以简写为无状态的函数组件。</li><li>函数的传入参数为<code>props</code>对象</li></ul><h2 id="组件的生命周期">5.4.8 组件的生命周期</h2><ul><li><code>Mount</code>周期，执行顺序：<code>constructor() -&gt; render() -&gt; componentDidMount()</code></li><li><code>Update</code>周期，执行顺序：<code>render() -&gt; componentDidUpdate()</code></li><li><code>Unmount</code>周期，执行顺序：<code>componentWillUnmount()</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航5.-react&quot;&gt;导航：&lt;a href=&quot;../5.%20React.md&quot;&gt;5. React&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;创建boxes组件&quot;&gt;5.4.1 创建&lt;code&gt;Boxes&lt;/code&gt;组件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Boxes&lt;/c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.3%20Components/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.3%20Components/</id>
    <published>2024-12-06T14:39:30.845Z</published>
    <updated>2024-12-06T14:39:31.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航5.-react">导航：<a href="../5.%20React.md">5. React</a></h2><h2 id="创建项目">5.3.1 创建项目</h2><p>创建项目<code>box-app</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create-react-app box-app</span><br><span class="line"><span class="built_in">cd</span> box-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>安装<code>bootstrap</code>库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i bootstrap</span><br></pre></td></tr></table></figure><p><code>bootstrap</code>的引入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;bootstrap/dist/css/bootstrap.css&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="创建component">5.3.2 创建Component</h2><h2 id="创建按钮">5.3.3 创建按钮</h2><p>当子节点数量大于1时，可以用<code>&lt;div&gt;</code>或<code>&lt;React.Fragment&gt;</code>将其括起来。</p><h2 id="内嵌表达式">5.3.4 内嵌表达式</h2><p>JSX中使用<code>&#123;&#125;</code>嵌入表达式。</p><h2 id="设置属性">5.3.5 设置属性</h2><ul><li><code>class -&gt; className</code></li><li>CSS属性：<code>background-color -&gt; backgroundColor</code>，其它属性类似</li></ul><h2 id="数据驱动改变style">5.3.6 数据驱动改变Style</h2><h2 id="渲染列表">5.3.7 渲染列表</h2><ul><li>使用map函数</li><li>每个元素需要具有唯一的<code>key</code>属性，用来帮助React快速找到被修改的DOM元素。</li></ul><h2 id="conditional-rendering">5.3.8 Conditional Rendering</h2><p>利用逻辑表达式的短路原则。</p><ul><li>与表达式中<code>expr1 &amp;&amp; expr2</code>，当<code>expr1</code>为假时返回<code>expr1</code>的值，否则返回<code>expr2</code>的值</li><li>或表达式中<code>expr1 || expr2</code>，当<code>expr1</code>为真时返回<code>expr1</code>的值，否则返回<code>expr2</code>的值</li></ul><h2 id="绑定事件">5.3.9 绑定事件</h2><ul><li>注意妥善处理好绑定事件函数的<code>this</code></li></ul><h2 id="修改state">5.3.10 修改state</h2><ul><li>需要使用<code>this.setState()</code>函数</li><li>每次调用<code>this.setState()</code>函数后，会重新调用<code>this.render()</code>函数，用来修改虚拟DOM树。React只会修改不同步的实际DOM树节点。</li></ul><h2 id="给事件函数添加参数">1.3.11 给事件函数添加参数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航5.-react&quot;&gt;导航：&lt;a href=&quot;../5.%20React.md&quot;&gt;5. React&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;创建项目&quot;&gt;5.3.1 创建项目&lt;/h2&gt;
&lt;p&gt;创建项目&lt;code&gt;box-app&lt;/code&gt;：&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.2%20ES6%E8%AF%AD%E6%B3%95%E8%A1%A5%E5%85%85/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.2%20ES6%E8%AF%AD%E6%B3%95%E8%A1%A5%E5%85%85/</id>
    <published>2024-12-06T14:39:30.830Z</published>
    <updated>2024-12-06T14:39:31.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航5.-react">导航：<a href="../5.%20React.md">5. React</a></h2><h2id="使用bind函数绑定this取值">使用<code>bind()</code>函数绑定<code>this</code>取值</h2><p>在JavaScript中，函数里的<code>this</code>指向的是执行时的调用者，而非定义时所在的对象。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yxc&quot;</span>,</span><br><span class="line">  <span class="attr">talk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">talk</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> talk = person.<span class="property">talk</span>;</span><br><span class="line"><span class="title function_">talk</span>();</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">name</span>: <span class="string">&#x27;yxc&#x27;</span>, <span class="attr">talk</span>: ƒ&#125;</span><br><span class="line"><span class="title class_">Window</span></span><br></pre></td></tr></table></figure><p><code>bind()</code>函数，可以绑定<code>this</code>的取值。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> talk = person.<span class="property">talk</span>.<span class="title function_">bind</span>(person);</span><br></pre></td></tr></table></figure><h2 id="箭头函数的简写方式">箭头函数的简写方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = x =&gt; x * x;</span><br></pre></td></tr></table></figure><p><strong>箭头函数不重新绑定<code>this</code>的取值</strong></p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">talk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">talk</span>();  <span class="comment">// 输出Window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">talk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">talk</span>();  <span class="comment">// 输出 &#123;talk: f&#125;</span></span><br></pre></td></tr></table></figure><h2 id="对象的解构">对象的解构</h2><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yxc&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name : nm, age&#125; = person;  <span class="comment">// nm是name的别名</span></span><br></pre></td></tr></table></figure><h2 id="数组和对象的展开">数组和对象的展开</h2><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [...a];  <span class="comment">// b是a的复制</span></span><br><span class="line"><span class="keyword">let</span> c = [...a, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">name</span>: <span class="string">&quot;yxc&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b, <span class="attr">height</span>: <span class="number">180</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="named-与-default-exports">Named 与 Default exports</h2><ul><li>NamedExport：可以export多个，import的时候需要加大括号，名称需要匹配</li><li>DefaultExport：最多export一个，import的时候不需要加大括号，可以直接定义别名</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航5.-react&quot;&gt;导航：&lt;a href=&quot;../5.%20React.md&quot;&gt;5. React&lt;/a&gt;&lt;/h2&gt;
&lt;h2
id=&quot;使用bind函数绑定this取值&quot;&gt;使用&lt;code&gt;bind()&lt;/code&gt;函数绑定&lt;code&gt;this&lt;/code&gt;取值</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.1%20%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    <id>https://luyicui.github.io/2024/12/06/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/react/5.1%20%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</id>
    <published>2024-12-06T14:39:30.814Z</published>
    <updated>2024-12-06T14:39:32.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导航5.-react">导航：<a href="../5.%20React.md">5. React</a></h2><p><a href="https://zh-hans.reactjs.org/">React官网</a></p><p>安装<code>Git Bash</code>（仅限使用Windows的同学，使用Mac和Linux的同学无需安装）</p><p><a href="https://gitforwindows.org/">安装地址</a></p><h2 id="安装nodejs">安装<code>Nodejs</code></h2><p><a href="https://nodejs.org/en/">安装地址</a></p><h2 id="安装create-react-app">安装<code>create-react-app</code></h2><p>打开<code>Git Bash</code>，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g create-react-app</span><br></pre></td></tr></table></figure><h2 id="安装vscode的插件">安装<code>VSCode</code>的插件</h2><ul><li><code>Simple React Snippets</code></li><li><code>Prettier - Code formatter</code></li></ul><h2 id="创建react-app">创建<code>React App</code></h2><p>在目标目录下打开<code>Git Bash</code>，在终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create-react-app react-app  <span class="comment"># 可以替换为其他app名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> react-app</span><br><span class="line">npm start  <span class="comment"># 启动应用</span></span><br></pre></td></tr></table></figure><h2 id="jsx">JSX</h2><p><code>React</code>中的一种语言，会被<ahref="https://babeljs.io/repl/">Babel</a>编译成标准JavaScript。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导航5.-react&quot;&gt;导航：&lt;a href=&quot;../5.%20React.md&quot;&gt;5. React&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/&quot;&gt;React官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装&lt;code&gt;G</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.10%20canvas/"/>
    <id>https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.10%20canvas/</id>
    <published>2024-12-05T01:59:07.023Z</published>
    <updated>2024-12-06T15:41:45.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="canvas">11.10 canvas</h1><p><ahref="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">canvas教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;canvas&quot;&gt;11.10 canvas&lt;/h1&gt;
&lt;p&gt;&lt;a
href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial&quot;&gt;canvas教程&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.9%20window/"/>
    <id>https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.9%20window/</id>
    <published>2024-12-05T01:59:05.531Z</published>
    <updated>2024-12-06T15:41:38.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="window">11.9 window</h1><ul><li><code>window.open("https://www.acwing.com")</code>在新标签栏中打开页面。</li><li><code>location.reload()</code>刷新页面。</li><li><code>location.href = "https://www.acwing.com"</code>：在当前标签栏中打开页面。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;window&quot;&gt;11.9 window&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;window.open(&quot;https://www.acwing.com&quot;)&lt;/code&gt;在新标签栏中打开页面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location.reload()&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.8%20WebSocket/"/>
    <id>https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.8%20WebSocket/</id>
    <published>2024-12-05T01:59:05.515Z</published>
    <updated>2024-12-06T15:41:30.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="websocket">11.8 WebSocket</h1><p>与服务器建立全双工连接。</p><p>常用API：</p><ul><li><code>new WebSocket('ws://localhost:8080');</code>：建立ws连接。</li><li><code>send()</code>：向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。</li><li><code>onopen</code>：类似于<code>onclick</code>，当连接建立时触发。</li><li><code>onmessage</code>：当从服务器端接收到消息时触发。</li><li><code>close()</code>：关闭连接。</li><li><code>onclose</code>：当连接关闭后触发。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;websocket&quot;&gt;11.8 WebSocket&lt;/h1&gt;
&lt;p&gt;与服务器建立全双工连接。&lt;/p&gt;
&lt;p&gt;常用API：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new WebSocket(&#39;ws://localhost:8080&#39;);&lt;/code&gt;：建立w</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.7%20%E6%97%A5%E6%9C%9F/"/>
    <id>https://luyicui.github.io/2024/12/05/[object%20Object]/%E3%80%90%E5%89%8D%E7%AB%AF%E3%80%91/js/tutorial/11%20%E5%B8%B8%E7%94%A8%E5%BA%93/11.7%20%E6%97%A5%E6%9C%9F/</id>
    <published>2024-12-05T01:59:05.500Z</published>
    <updated>2024-12-06T15:41:22.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期">11.7 日期</h1><p>返回值为整数的API，数值为1970-1-1 00:00:00UTC（世界标准时间）到某个时刻所经过的毫秒数：</p><ul><li><code>Date.now()</code>：返回现在时刻。</li><li><code>Date.parse("2022-04-15T15:30:00.000+08:00")</code>：返回北京时间2022年4月15日15:30:00的时刻。</li></ul><p>与<code>Date</code>对象的实例相关的<code>API</code>：</p><ul><li><code>new Date()</code>：返回现在时刻。</li><li><code>new Date("2022-04-15T15:30:00.000+08:00")</code>：返回北京时间2022年4月15日15:30:00的时刻。</li><li>两个<code>Date</code>对象实例的差值为毫秒数</li><li><code>getDay()</code>：返回星期，0表示星期日，1-6表示星期一至星期六</li><li><code>getDate()</code>：返回日，数值为1-31</li><li><code>getMonth()</code>：返回月，数值为0-11</li><li><code>getFullYear()</code>：返回年份</li><li><code>getHours()</code>：返回小时</li><li><code>getMinutes()</code>：返回分钟</li><li><code>getSeconds()</code>：返回秒</li><li><code>getMilliseconds()</code>：返回毫秒</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;日期&quot;&gt;11.7 日期&lt;/h1&gt;
&lt;p&gt;返回值为整数的API，数值为1970-1-1 00:00:00
UTC（世界标准时间）到某个时刻所经过的毫秒数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Date.now()&lt;/code&gt;：返回现在时刻。&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
