<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/09/30/%5Bobject%20Object%5D/C++/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2024/09/30/%5Bobject%20Object%5D/C++/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量作用域">变量作用域</h1><p>作用域是程序的一个区域，一般来说有三个地方可以定义变量：</p><ul><li>在函数或一个代码块内部声明的变量，称为局部变量；</li><li>在函数参数的定义中声明的变量，称为形式参数；</li><li>在所有函数外部声明的变量，称为全局变量；</li></ul><h2 id="局部变量">局部变量</h2><p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_#include_ &lt;iostream&gt;</span><br><span class="line">_using_ _namespace_ std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_    <span class="comment">// 局部变量声明_</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">_    <span class="comment">// 实际初始化_</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c is &quot;</span> &lt;&lt; c &lt;&lt; endl;_ <span class="comment">// c is 30_</span></span><br><span class="line">    _return_ <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个函数体内可以存在重名的变量，前提是它们的作用域不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量间出现重名的情况下，作用域小的屏蔽作用域大的，所以上面第一个cout 输出 b 的值为1，但由于在块里面申请的变量作用域只限于当前块，所以离开这个块后变量会自动释放，所以第二个cout 输出 b 的值为 2。</p><h2 id="全局变量">全局变量</h2><p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="number">0</span>;  <span class="comment">// 全局变量声明和初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量声明</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    g = a + b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;g is &quot;</span> &lt;&lt; g &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="number">0</span>;  <span class="comment">// 全局变量声明和初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;g is &quot;</span> &lt;&lt; g &lt;&lt; endl;   <span class="comment">// g is 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量和和局部变量同名时，可通过域名在函数中引用到全局变量，不加域名解析则引用局部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; endl;   <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;     <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态局部变量">静态局部变量</h2><p>C++ 中，我们可以在函数体内声明一个静态局部变量( Static Local Variable)。它在函数运行结束后不会消失，并且只有声明它的函数中能够使用它。声明一个静态局部变量的方法是在声明局部变量前加上<code>static</code>，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p>和全局变量类似，如果我们没有对一个静态局部变量做初始化，则编译器会自动将它初始化为对应类型的0。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态局部变量，函数每次被调用后该值会被保存记录下来，下次调用会接着使用上次的值</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> callNum = <span class="number">0</span>;</span><br><span class="line">    callNum += <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;callNum is &quot;</span> &lt;&lt; callNum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">demo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callNum is <span class="number">1</span></span><br><span class="line">callNum is <span class="number">2</span></span><br><span class="line">callNum is <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如果一个函数运行和它以前的运行结果有关，那么一般我们就会使用静态局部变量。</p><h2 id="变量初始化">变量初始化</h2><ul><li>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化，否则在编译阶段会有告警产生；</li><li>定义全局变量时，系统会自动初始化为下列值：</li></ul><p><strong>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【二叉树】</title>
      <link href="/2024/08/23/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
      <url>/2024/08/23/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树">二叉树</h1><h2 id="存储">存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; l, r;<span class="comment">// l[i] 和 r[i] 分别存储节点 i 的左、右孩子编号</span></span><br></pre></td></tr></table></figure><blockquote><p>不定义为 <code>int l[N], r[N]</code>的原因是：二叉树的结点个数最大为N，但是结点权值可以大于N，此时就会导致段错误，而定义成哈希表就避免了很多麻烦</p></blockquote><h2 id="非递归遍历">非递归遍历</h2><h3 id="结论">结论</h3><p>【<strong>结论</strong>】用<strong>栈</strong>模拟实现<strong>中序遍历</strong>，<font color='red'><strong>Push</strong></font>操作的数据过程是<font color='blue'><strong>先序</strong></font>遍历，<font color='red'><strong>Pop</strong></font>操作的数据过程是<font color='blue'><strong>中序</strong></font>遍历</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408232259283.png"alt="树的遍历.png" /><figcaption aria-hidden="true">树的遍历.png</figcaption></figure><p>​如图所示，⊗是先序遍历，☆是中序遍历，△是后序遍历。我们发现：树的<strong>前序、中序、后序</strong>实际上都是将整棵树以<strong>上图所示的路线</strong>跑了<span class="math inline">\(1\)</span> 遍，每个结点都碰到了 <spanclass="math inline">\(3\)</span>次，三者唯一不同之处在于<strong>访问节点的时机不同</strong></p><ul><li><strong>先序</strong>遍历在第 <span class="math inline">\(1\)</span>次碰到结点时访问</li><li><strong>中序</strong>遍历在第 <span class="math inline">\(2\)</span>次碰到结点时访问</li><li><strong>后序</strong>遍历在第 <span class="math inline">\(3\)</span>次碰到结点时访问</li></ul><h3 id="例题">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8792912/">AcWing1576. 再次树遍历 - AcWing</a></li></ul><h2 id="层序遍历">层序遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++ tt] = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(l.count(t))<span class="comment">// 存在左孩子</span></span><br><span class="line">            q[++ tt] = l[t];</span><br><span class="line">        <span class="keyword">if</span>(r.count(t))<span class="comment">// 存在右孩子</span></span><br><span class="line">            q[++ tt] = r[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bfs(root);</span><br><span class="line"><span class="comment">// 输出层序序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br></pre></td></tr></table></figure><h2 id="后序中序建树">后序中序建树</h2><h3 id="模板">模板</h3><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n)\)</span></li></ul><blockquote><p>注意：前提是二叉树中<strong>节点编号或权值互不相同</strong>，我们才能用<strong>哈希表</strong>记录中序序列各节点对应的下标，从而将时间复杂度优化为<spanclass="math inline">\(O(n)\)</span>。如果<strong>二叉树节点编号或权值可能重复</strong>，则只能遍历搜索位置，此时时间复杂度为<span class="math inline">\(O(n^2)\)</span></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> in[N], post[N];<span class="comment">// n 个节点的中序序列、后序序列</span></span><br><span class="line"><span class="type">int</span> pre[N], cnt;<span class="comment">// 建图的同时记录 n 个节点的前序序列</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; l, r, pos;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> il, <span class="type">int</span> ir, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> root = post[pr];</span><br><span class="line">    <span class="type">int</span> k = pos[root];<span class="comment">// 优化时间复杂度 O(1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 记录前序序列 */</span></span><br><span class="line">    <span class="comment">// pre[cnt ++] = root;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(il &lt; k)</span><br><span class="line">        l[root] = build(il, k - <span class="number">1</span>, pl, pl + (k - <span class="number">1</span> - il));</span><br><span class="line">    <span class="keyword">if</span>(k &lt; ir)</span><br><span class="line">        r[root] = build(k + <span class="number">1</span>, ir, pl + (k - <span class="number">1</span> - il) + <span class="number">1</span>, pr - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;post[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">        pos[in[i]] = i;        <span class="comment">// 哈希表记录每个数在中序遍历的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root 为二叉树的根节点</span></span><br><span class="line">    <span class="type">int</span> root = build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-1">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8790598/">AcWing1497. 树的遍历 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8790623/">AcWing1620. Z 字形遍历二叉树 - AcWing</a></li></ul><h2 id="中序建树">中序建树</h2><h3 id="模板-1">模板</h3><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n)\)</span></li></ul><blockquote><p>注意：前提是二叉树中每个节点的权值互不相同，我们才能用哈希表记录中序序列各节点对应的下标</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> in[N], pre[N];<span class="comment">// n 个节点的中序序列、前序序列</span></span><br><span class="line"><span class="type">int</span> post[N], cnt;<span class="comment">// 建图的同时记录 n 个节点的后序序列</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; l, r, pos;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> il, <span class="type">int</span> ir, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> root = pre[pl];</span><br><span class="line">    <span class="type">int</span> k = pos[root];<span class="comment">// 优化时间复杂度 O(1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(il &lt; k)</span><br><span class="line">        l[root] = build(il, k - <span class="number">1</span>, pl + <span class="number">1</span>, pl + <span class="number">1</span> + k - <span class="number">1</span> - il);</span><br><span class="line">    <span class="keyword">if</span>(k &lt; ir)</span><br><span class="line">        r[root] = build(k + <span class="number">1</span>, ir, pl + <span class="number">1</span> + k - <span class="number">1</span> - il + <span class="number">1</span>, pr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录后序序列 */</span></span><br><span class="line">    <span class="comment">// post[cnt ++] = root;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;in[i]);</span><br><span class="line">        pos[in[i]] = i;        <span class="comment">// 哈希表记录每个数在中序遍历的下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// root 为二叉树的根节点</span></span><br><span class="line">    <span class="type">int</span> root = build(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8790607/">AcWing1631. 后序遍历 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/251933/">AcWing2019清华软院T2. 二叉树算权 - AcWing</a></li></ul><h2 id="前序和后序">前序和后序</h2><p>已知二叉树的前序序列和后序序列，<strong>无法唯一确定</strong>这个二叉树，但是我们可以确定每个子树的形状和个数，仅仅是子树的位置不能确定</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8793054/">AcWing1609. 前序和后序遍历 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/251849/">AcWing3486. 前序和后序 - AcWing</a></li></ul><h1 id="完全二叉树">完全二叉树</h1><h2 id="存储-1">存储</h2><p>完全二叉树采用<strong>数组</strong>存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br></pre></td></tr></table></figure><h2 id="性质">性质</h2><p>完全二叉树的性质如下：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408230026116.jpeg"alt="7476a7cbe9d1fbd33df03cf13ab37b4" /><figcaptionaria-hidden="true">7476a7cbe9d1fbd33df03cf13ab37b4</figcaption></figure><ol type="1"><li><strong><font color='red'>从1号单元开始存储树节点</font></strong>（0号单元存节点的个数）</li><li>节点 <span class="math inline">\(i\)</span> 左子树是 <spanclass="math inline">\(2i\)</span>，右子树是 <spanclass="math inline">\(2i+1\)</span>，根节点是 <spanclass="math inline">\(\lfloor i/2 \rfloor\)</span>，左兄弟是 <spanclass="math inline">\(i-1\)</span>，右兄弟 <spanclass="math inline">\(i+1\)</span></li><li>第 <span class="math inline">\(d\)</span> 层最多有 <spanclass="math inline">\(2^{d-1}\)</span>，<strong>起始节点</strong>编号为<span class="math inline">\(2^{d-1}\)</span>（<spanclass="math inline">\(d\)</span> 从 <spanclass="math inline">\(1\)</span> 开始）</li><li>如果完全二叉树一共有 <span class="math inline">\(n\)</span>个节点，则<strong>非</strong>叶子节点为 <spanclass="math inline">\(T[0…n/2]\)</span>，叶节点为 <spanclass="math inline">\(T[n/2+1,…,n]\)</span></li></ol><h2 id="例题-3">例题</h2><ul><li><a href="https://www.acwing.com/solution/content/251776/">AcWing1240. 完全二叉树的权值 - AcWing</a></li></ul><h1 id="二叉搜索树bst">二叉搜索树(BST)</h1><p>==<strong><font color='blue'>二叉搜索树</font></strong> ==<strong><font color='blue'>二叉查找树</font></strong> （Binary SearchTree） == <strong><font color='blue'>二叉排序树</font></strong> （BinarySort Tree）==</p><ul><li>若它的左子树不空，则<strong>左子树</strong>上<strong>所有</strong>结点的值均<font color='red'><strong>小于</strong></font>根结点的值;</li><li>若它的右子树不空，则<strong>右子树</strong>上<strong>所有</strong>结点的值均<font color='red'><strong>大于等于</strong></font>根结点的值;</li><li>它的左、右子树也都分别是<strong>二又搜索树</strong></li></ul><blockquote><p>注意：上述定义在不同题目中，等号的位置可能不一样（即也有可能左子树均小于等于根节点，右子树均大于根节点）</p></blockquote><h2 id="性质-1">性质</h2><ul><li><strong>二叉排序树</strong>的<strong><font color='red'>中序遍历</font></strong>是<strong><font color='gree'>递增</font></strong>序列</li></ul><blockquote><p>在构造二叉排序树时，若关键字序列有序，则二叉排序树的高度最大</p></blockquote><h2 id="例题-4">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8790764/">AcWing1527. 判断二叉搜索树 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adam详解</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/8.Adam%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/8.Adam%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="adam算法详解">Adam算法详解</h1><p>Adam算法在RMSProp算法基础上对<ahref="https://so.csdn.net/so/search?q=%E5%B0%8F%E6%89%B9%E9%87%8F&amp;spm=1001.2101.3001.7020">小批量</a>随机梯度也做了指数加权移动平均[1]。下面我们来介绍这个算法。</p><blockquote><p>所以Adam算法可以看做是RMSProp算法与动量法的结合。adam算法是一种基于“momentum”思想的随机梯度下降优化方法，通过迭代更新之前每次计算梯度的一阶moment和二阶moment，并计算滑动平均值，后用来更新当前的参数。这种思想结合了Adagrad算法的处理稀疏型数据，又结合了RMSProp算法的可以处理非稳态的数据。</p></blockquote><p>小tips：跟我一样基础不太好的看起来比较难以理解，建议搭配视频食用，可参考这个<ahref="https://www.bilibili.com/video/BV1HP4y1g7xN/?spm_id_from=pageDriver&amp;vd_source=12c80a98ec9426002a2f54318421082c">优化算法系列合集</a>，个人觉得比较容易听懂</p><h2 id="算法">算法</h2><p>Adam算法使用了动量变量 <spanclass="math inline">\(\boldsymbol{v}_t\)</span>​和RMSProp算法中小批量随机梯度按元素平方的指数加权移动平均变量 <spanclass="math inline">\(\boldsymbol{s}_t\)</span> ​，并在时间步 <spanclass="math inline">\(0\)</span> 将它们中每个元素初始化为 <spanclass="math inline">\(0\)</span>。给定超参数 <spanclass="math inline">\(0 \leq \beta_1 &lt; 1\)</span> （算法作者建议设为<span class="math inline">\(0.9\)</span>），时间步 <spanclass="math inline">\(t\)</span> 的动量变量 <spanclass="math inline">\(\boldsymbol{v}_t\)</span> ​即小批量随机梯度 <spanclass="math inline">\(\boldsymbol{g}_t\)</span> ​的指数加权移动平均：</p><p><span class="math display">\[\boldsymbol{v}_t \leftarrow \beta_1 \boldsymbol{v}_{t-1} + (1 - \beta_1)\boldsymbol{g}_t\]</span> 和RMSProp算法中一样，给定超参数 <span class="math inline">\(0\leq \beta_2 &lt; 1\)</span> （算法作者建议设为0.999）</p><p>将小批量随机梯度按元素平方后的项 <spanclass="math inline">\(\boldsymbol{g}_t \odot \boldsymbol{g}_t\)</span>​做指数加权移动平均得到 <spanclass="math inline">\(\boldsymbol{s}_t\)</span>​： <spanclass="math display">\[\boldsymbol{s}_t \leftarrow \beta_2 \boldsymbol{s}_{t-1} + (1 - \beta_2)\boldsymbol{g}_t \odot \boldsymbol{g}_t\]</span> 由于我们将 <spanclass="math inline">\(\boldsymbol{v}_0\)</span> 和 <spanclass="math inline">\(\boldsymbol{s}_0\)</span> 中的元素都初始化为 <spanclass="math inline">\(0\)</span></p><p>在时间步 <span class="math inline">\(t\)</span> 我们得到 <spanclass="math inline">\(\boldsymbol{v}_t = (1-\beta_1) \sum_{i=1}^t\beta_1^{t-i}\boldsymbol{g}_i\)</span>。将过去各时间步小批量随机梯度的权值相加，得到<span class="math inline">\((1-\beta_1) \sum_{i=1}^t \beta_1^{t-i} = 1 -\beta_1^t\)</span>。需要注意的是，当 <spanclass="math inline">\(t\)</span>较小时，过去各时间步小批量随机梯度权值之和会较小。例如，当 <spanclass="math inline">\(\beta_1 = 0.9\)</span> 时，<spanclass="math inline">\(\boldsymbol{v}_1 =0.1\boldsymbol{g}_1\)</span>。为了消除这样的影响，对于任意时间步 <spanclass="math inline">\(t\)</span> ，我们可以将 <spanclass="math inline">\(\boldsymbol{v}_t\)</span> 再除以 <spanclass="math inline">\(1 -\beta_1^t\)</span>，从而使过去各时间步小批量随机梯度权值之和为1。这也叫作<strong>偏差修正</strong>。在Adam算法中，我们对变量<span class="math inline">\(\boldsymbol{v}_t\)</span> 和 <spanclass="math inline">\(\boldsymbol{s}_t\)</span> 均作偏差修正： <spanclass="math display">\[\hat{\boldsymbol{v}}_t \leftarrow \frac{\boldsymbol{v}_t}{1 - \beta_1^t}\]</span></p><p><span class="math display">\[\hat{\boldsymbol{s}}_t \leftarrow \frac{\boldsymbol{s}_t}{1 - \beta_2^t}\]</span></p><p>接下来，Adam算法使用以上偏差修正后的变量 $_t $ 和 <spanclass="math inline">\(\hat{\boldsymbol{s}}_t\)</span>，将模型参数中每个元素的学习率通过按元素运算重新调整：</p><p><span class="math display">\[\boldsymbol{g}_t&#39; \leftarrow \frac{\eta\hat{\boldsymbol{v}}_t}{\sqrt{\hat{\boldsymbol{s}}_t} + \epsilon}\]</span> 其中 <span class="math inline">\(\eta\)</span> 是学习率，<spanclass="math inline">\(\epsilon\)</span>是为了维持数值稳定性而添加的常数，如 <spanclass="math inline">\(10^{-8}\)</span>。和AdaGrad算法、RMSProp算法以及AdaDelta算法一样，目标函数自变量中每个元素都分别拥有自己的学习率。最后，使用<span class="math inline">\(\boldsymbol{g}_t&#39;\)</span>​迭代自变量：</p><p><span class="math display">\[\boldsymbol{x}_t \leftarrow \boldsymbol{x}_{t-1} - \boldsymbol{g}_t&#39;\]</span></p><span id="more"></span><h2 id="从零开始实现">从零开始实现</h2><p>我们按照Adam算法中的公式实现该算法。其中时间步 t tt通过<code>hyperparams</code>参数传入<code>adam</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>) </span><br><span class="line"><span class="keyword">import</span> d2lzh_pytorch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">features, labels = d2l.get_data_ch7()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_adam_states</span>():</span><br><span class="line">    v_w, v_b = torch.zeros((features.shape[<span class="number">1</span>], <span class="number">1</span>), dtype=torch.float32), torch.zeros(<span class="number">1</span>, dtype=torch.float32)</span><br><span class="line">    s_w, s_b = torch.zeros((features.shape[<span class="number">1</span>], <span class="number">1</span>), dtype=torch.float32), torch.zeros(<span class="number">1</span>, dtype=torch.float32)</span><br><span class="line">    <span class="keyword">return</span> ((v_w, s_w), (v_b, s_b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adam</span>(<span class="params">params, states, hyperparams</span>):</span><br><span class="line">    beta1, beta2, eps = <span class="number">0.9</span>, <span class="number">0.999</span>, <span class="number">1e-6</span></span><br><span class="line">    <span class="keyword">for</span> p, (v, s) <span class="keyword">in</span> <span class="built_in">zip</span>(params, states):</span><br><span class="line">        v[:] = beta1 * v + (<span class="number">1</span> - beta1) * p.grad.data</span><br><span class="line">        s[:] = beta2 * s + (<span class="number">1</span> - beta2) * p.grad.data**<span class="number">2</span></span><br><span class="line">        v_bias_corr = v / (<span class="number">1</span> - beta1 ** hyperparams[<span class="string">&#x27;t&#x27;</span>])</span><br><span class="line">        s_bias_corr = s / (<span class="number">1</span> - beta2 ** hyperparams[<span class="string">&#x27;t&#x27;</span>])</span><br><span class="line">        p.data -= hyperparams[<span class="string">&#x27;lr&#x27;</span>] * v_bias_corr / (torch.sqrt(s_bias_corr) + eps)</span><br><span class="line">    hyperparams[<span class="string">&#x27;t&#x27;</span>] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用学习率为0.01的Adam算法来训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2l.train_ch7(adam, init_adam_states(), &#123;<span class="string">&#x27;lr&#x27;</span>: <span class="number">0.01</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">1</span>&#125;, features, labels)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss: 0.245370, 0.065155 sec per epoch</span><br></pre></td></tr></table></figure><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/3e40be6e8cf9cc23f28c74f46c87fb79.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="简洁实现">简洁实现</h2><p>通过名称为“Adam”的优化器实例，我们便可使用PyTorch提供的Adam算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2l.train_pytorch_ch7(torch.optim.Adam, &#123;<span class="string">&#x27;lr&#x27;</span>: <span class="number">0.01</span>&#125;, features, labels)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss: 0.242066, 0.056867 sec per epoch</span><br></pre></td></tr></table></figure><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/3d2011d1884097856969211021d1ccff.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="小结">小结</h2><ul><li>Adam算法在RMSProp算法的基础上对小批量随机梯度也做了指数加权移动平均。</li><li>Adam算法使用了偏差修正。</li></ul><h2 id="参考文献">参考文献</h2><p>[1] Kingma, D. P., &amp; Ba, J. (2014). Adam: A method for stochasticoptimization. arXiv preprint arXiv:1412.6980.</p><hr /><blockquote><p>注：除代码外本节与原书此节基本相同，<ahref="https://zh.d2l.ai/chapter_optimization/adam.html">原书传送门</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adam</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/7.Adam/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/7.Adam/</url>
      
        <content type="html"><![CDATA[<h1 id="adam-算法">Adam 算法</h1><p>​接下来，我们将介绍目前常用的梯度下降法中的王者——Adam算法。Adam（AdaptiveMomentEstimation）是目前深度学习中最常用的优化算法之一。Adam算法的核心思想是<strong>利用梯度一阶动量和二阶动量来动态自适应调整学习率</strong>，既保持了<strong>Momentum收敛速度快</strong>的优点，又结合了<strong>RMSProp自适应学习率</strong> 的优点</p><h2 id="基本思想">基本思想</h2><p>Adam算法通过计算梯度的<strong>一阶动量</strong>（即<strong>梯度的指数加权移动平均）</strong>和梯度的<strong>二阶动量</strong>（即<strong>梯度平方的指数加权移动平均</strong>）来<strong>动态调整</strong>每个参数的<strong>学习率</strong>。具体公式如下：</p><ol type="1"><li>梯度的一阶动量：</li></ol><p><span class="math display">\[m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\]</span></p><ol start="2" type="1"><li>梯度的二阶动量：</li></ol><p><span class="math display">\[v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\]</span></p><ol start="3" type="1"><li>偏差修正：</li></ol><p><span class="math display">\[\hat{m}_t = \frac{m_t}{1 - \beta_1^t}  \]</span></p><p><span class="math display">\[\hat{v}_t = \frac{v_t}{1 - \beta_2^t}\]</span></p><ol start="4" type="1"><li>更新参数：</li></ol><p><span class="math display">\[\theta_{t+1} = \theta_t - \frac{\alpha \hat{m}_t}{\sqrt{\hat{v}_t} +\epsilon}\]</span></p><p>其中：<br />- <span class="math inline">\(\beta_1\)</span> 和 <spanclass="math inline">\(\beta_2\)</span>分别是<strong>动量</strong>和<strong>均方根动量</strong>的衰减率，常用值为<span class="math inline">\(\beta_1 = 0.9\)</span> 和 <spanclass="math inline">\(\beta_2 = 0.999\)</span> - <spanclass="math inline">\(\epsilon\)</span>是一个很小的常数，用于防止分母为零，常用值为 <spanclass="math inline">\(10^{-8}\)</span></p><span id="more"></span><h2 id="优缺点">优缺点</h2><p><strong>优点</strong>：</p><ul><li><strong>自适应调整学习率</strong>：根据一阶动量和二阶动量动态调整每个参数的学习率，使得训练过程更加稳定。</li><li><strong>收敛速度快</strong>：结合动量法的<strong>加速特性</strong>和RMSProp的<strong>平稳特性</strong>，能够快速收敛到最优解。</li><li>能处理<strong>稀疏梯度</strong>，适用于大规模数据和参数。</li></ul><p><strong>缺点</strong>：</p><ul><li>对于某些特定问题，Adam 可能会出现不稳定的收敛行为。<br /></li><li>参数较多：Adam 算法需要调整的<strong>超参数较多</strong>（例如 <spanclass="math inline">\(\beta_1\)</span> , <spanclass="math inline">\(\beta_2\)</span> , <spanclass="math inline">\(\epsilon\)</span>），调参复杂度高。</li></ul><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 随机生成数据</span></span><br><span class="line">x = torch.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">3</span> + torch.randn(<span class="number">100</span>, <span class="number">1</span>) * <span class="number">0.5</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w = torch.randn(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义Adam优化器</span></span><br><span class="line">optimizer = torch.optim.Adam([w, b], lr=learning_rate)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 记录损失</span></span><br><span class="line">losses = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    y_pred = x * w + b</span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = torch.mean((y_pred - y) ** <span class="number">2</span>)</span><br><span class="line">    losses.append(loss.item())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清空梯度</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可视化训练过程</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(epochs), losses)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training Loss with Adam&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="adam-与其他算法的比较">Adam 与其他算法的比较</h2><p>Adam算法集成了SGD、动量法、Adagrad、Adadelta等多种优化算法的优点，具有快速收敛和稳定的特点。以下是它与其他算法的对比：</p><ol type="1"><li>SGD：基本的随机梯度下降法，收敛速度较慢，易陷入局部最优。</li><li>动量法：在SGD基础上加入一阶动量，加速收敛，但仍然可能陷入局部最优。</li><li>Adagrad：自适应学习率，但对历史梯度的累积会导致学习率不断减小，后期训练缓慢。</li><li>RMSProp：改进了Adagrad，通过引入衰减系数解决学习率不断减小的问题。</li><li>Adam：结合动量法和RMSProp的优点，具有快速收敛和稳定的特点，是目前最常用的优化算法。</li></ol><h2 id="小结">小结</h2><p>Adam 算法作为一种自适应的梯度下降优化算法，结合了动量法和 RMSProp的优点，能够有效地加速模型的收敛，同时保持稳定性。它通过计算一阶和二阶动量来动态调整学习率，使得模型在训练过程中能够快速收敛，并适应不同的优化问题。尽管Adam需要调整的超参数较多，但其优越的性能使得它成为深度学习中最广泛使用的优化算法之一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AdaGrad</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/5.AdaGrad/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/5.AdaGrad/</url>
      
        <content type="html"><![CDATA[<p># AdaGrad算法</p><p>在前面我们讲解了<ahref="https://so.csdn.net/so/search?q=%E5%8A%A8%E9%87%8F%E6%B3%95&amp;spm=1001.2101.3001.7020">动量法</a>（Momentum），也就是动量随机梯度下降法。它使用了一阶动量。然而，我们同时也提到了二阶动量。使用二阶动量的梯度下降算法的改进版就是本节要讲的AdaGrad算法。二阶动量的出现，才意味着真正的<strong>自适应学习率</strong>优化算法时代的到来。</p><h2 id="adagrad算法的基本思想">AdaGrad算法的基本思想</h2><p>我们先回顾一下传统的<ahref="https://so.csdn.net/so/search?q=%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95&amp;spm=1001.2101.3001.7020">随机梯度下降法</a>（SGD）及其各种变种。它们都是以<strong>同样的学习率</strong>来更新<strong>每一个参数</strong>的。但深度神经网络往往包含大量参数，这些参数并不总是<strong>均匀更新</strong>的。有些参数更新得频繁，有些则很少更新。</p><ul><li>对于<strong>经常更新</strong>的参数，我们已经积累了大量关于它的知识，希望它不被新的单个样本影响太大，也就是说希望对这些参数的<strong>学习率小一些</strong></li><li>对于<strong>偶尔更新</strong>的参数，我们了解的信息较少，希望从每一个样本中多学一些，即<strong>学习率大一些</strong></li></ul><p>要动态度量历史更新的频率，我们引入<strong>二阶动量</strong>。二阶动量通过将每一位各自的历史梯度的<strong>平方</strong>叠加起来来计算。具体公式如下：</p><p><span class="math display">\[v_t = v_{t-1} + g_t^2\]</span></p><p>其中，<span class="math inline">\(g_t\)</span> 是当前的梯度。</p><span id="more"></span><h2 id="算法流程">算法流程</h2><ol type="1"><li><strong>计算当前梯度 <span class="math inline">\(g_t\)</span></strong>：</li></ol><p><span class="math display">\[g_t = \nabla f(w_t)\]</span></p><ol start="2" type="1"><li><strong>更新二阶动量 <span class="math inline">\(v_t\)</span></strong>：</li></ol><p><span class="math display">\[v_t =  v_{t-1} + g_t^2\]</span></p><ol start="3" type="1"><li><strong>计算当前时刻的下降梯度</strong>：</li></ol><p><span class="math display">\[w_{t+1} = w_t - \frac{\alpha}{\sqrt{v_t} + \epsilon} g_t\]</span></p><p>其中，<span class="math inline">\(\alpha\)</span> 是学习率，<spanclass="math inline">\(\epsilon\)</span>是一个小的平滑项，防止分母为0。</p><h2 id="稀疏特征处理">稀疏特征处理</h2><p>AdaGrad算法主要针对<strong>稀疏特征</strong>进行了优化。<strong>稀疏特征</strong>在很多样本中只出现少数几次，在训练模型时，这些稀疏特征的更新很少，但每次更新可能带来较大影响。AdaGrad通过调整每个特征的学习率，针对这种情况进行了优化。</p><h3 id="优缺点">优缺点</h3><p><strong>优点</strong>：</p><ol type="1"><li><strong>有效处理稀疏特征</strong>：自动调整每个参数的学习率，使得稀疏特征的更新更少。<br /></li><li><strong>加速收敛</strong>：在自动调整学习率的同时，使得模型在训练过程中更快收敛。</li></ol><p><strong>缺点</strong>：<br />1.<strong>学习率逐渐减小</strong>：每次迭代中学习率都会减小，导致训练后期学习率变得非常小，从而使收敛速度变慢。<br />2.<strong>固定调整方式</strong>：对于不同参数，学习率调整方式是固定的，无法根据不同任务自动调整。</p><h2 id="代码实现">代码实现</h2><p>下面是一个简单的PyTorch实现AdaGrad算法的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 随机生成一些数据</span></span><br><span class="line">x = torch.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">3</span> + torch.randn(<span class="number">100</span>, <span class="number">1</span>) * <span class="number">0.5</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w = torch.randn(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义AdaGrad优化器</span></span><br><span class="line">optimizer = torch.optim.Adagrad([w, b], lr=learning_rate)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 记录损失</span></span><br><span class="line">losses = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    y_pred = x * w + b</span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = torch.mean((y_pred - y) ** <span class="number">2</span>)</span><br><span class="line">    losses.append(loss.item())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清空梯度</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可视化训练过程</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(epochs), losses)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training Loss&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408112049596.png"alt="image-20240811204910528" /><figcaption aria-hidden="true">image-20240811204910528</figcaption></figure><h2 id="总结">总结</h2><p>本节我们介绍了一种新的梯度下降算法变体——AdaGrad。与动量法相比，它最大的改进在于<strong>使用二阶动量来动态调整学习率</strong>，能够记住历史上的梯度信息，以动态调整学习率。其主要优点是能够处理稀疏特征问题，但也有学习率逐渐减小和调整方式固定的缺点。</p><p>到目前为止，我们一共讲了五种梯度下降算法。AdaGrad是2011年提出的，而动量法在1993年提出，SGD在1951年提出。通过时间轴的对比，我们可以看出人们在不断研究和改进梯度下降算法，从最早的梯度下降法到SGD，再到动量法、小批量梯度下降，最后到2011年的AdaGrad。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMSProp 和 Adadelta</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/6.RMSProp%20%E5%92%8C%20Adadelta/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/6.RMSProp%20%E5%92%8C%20Adadelta/</url>
      
        <content type="html"><![CDATA[<h1 id="rmsprop-和-adadelta-算法">RMSProp 和 Adadelta 算法</h1><p>​ 在<ahref="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&amp;spm=1001.2101.3001.7020">深度学习</a>中，RMSProp和 Adadelta 是两种常见的优化算法。它们都是在 AdaGrad的基础上做了改进，以适应深度学习中的大规模参数优化需求。</p><h2 id="rmsprop-算法">RMSProp 算法</h2><h3 id="基本思想">基本思想</h3><p>RMSProp 对 AdaGrad进行改进，通过引入<strong>衰减率</strong>来调整二阶动量的累积。这样可以<strong>避免</strong>AdaGrad 中<strong>学习率减小过快</strong>的问题。</p><p>AdaGrad 的二阶动量计算公式如下：</p><p><span class="math display">\[v_t = v_{t-1} + g_t^2\]</span> 而 RMSProp 采用了带有衰减率的计算方式：</p><p><span class="math display">\[v_t = \beta v_{t-1} + (1 - \beta) g_t^2\]</span> 其中，<span class="math inline">\(\beta\)</span>是衰减率系数。</p><span id="more"></span><h3 id="优缺点">优缺点</h3><p><strong>优点：</strong></p><ul><li><strong>自动调整学习率</strong>，避免学习率过大或过小的问题</li><li><strong>加速收敛速度</strong></li><li><strong>简单适用</strong>，适用于各种优化问题</li></ul><p><strong>缺点：</strong></p><ul><li>在处理稀疏特征时不够优秀</li><li>需要调整的超参数较多（衰减率 <spanclass="math inline">\(\beta\)</span> i和学习率 <spanclass="math inline">\(\alpha\)</span> ）</li><li>收敛速度可能不如某些更先进的<ahref="https://so.csdn.net/so/search?q=%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">优化算法</a></li></ul><h3 id="代码实现">代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line">beta = <span class="number">0.9</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 随机生成数据</span></span><br><span class="line">x = torch.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">3</span> + torch.randn(<span class="number">100</span>, <span class="number">1</span>) * <span class="number">0.5</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w = torch.randn(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义RMSProp优化器</span></span><br><span class="line">optimizer = torch.optim.RMSprop([w, b], lr=learning_rate, alpha=beta)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 记录损失</span></span><br><span class="line">losses = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    y_pred = x * w + b</span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = torch.mean((y_pred - y) ** <span class="number">2</span>)</span><br><span class="line">    losses.append(loss.item())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清空梯度</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可视化训练过程</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(epochs), losses)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training Loss with RMSProp&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="adadelta-算法">Adadelta 算法</h2><h3 id="基本思想-1">基本思想</h3><p>Adadelta 是对 RMSProp的进一步改进，旨在<strong>自动调整学习率</strong>，避免手动调参。它通过计算梯度和权重更新量的累积值来调整学习率，使得训练过程更加稳定。</p><p>Adadelta 的公式如下：</p><ol type="1"><li>梯度的累积：</li></ol><p><span class="math display">\[E[g^2]_t = \rho E[g^2]_{t-1} + (1 - \rho) g_t^2\]</span></p><ol start="2" type="1"><li>权重更新量的累积：</li></ol><p><span class="math display">\[E[\Delta x^2]_t = \rho E[\Delta x^2]_{t-1} + (1 - \rho) (\Delta x_t)^2\]</span></p><ol start="3" type="1"><li>更新参数：</li></ol><p><span class="math display">\[\Delta x_t = -\frac{\sqrt{E[\Delta x^2]_{t-1} +\epsilon}}{\sqrt{E[g^2]_t + \epsilon}} g_t  \]</span></p><p><span class="math display">\[\theta_{t+1} = \theta_t + \Delta x_t\]</span></p><h3 id="优缺点-1">优缺点</h3><p><strong>优点：</strong><br />- <strong>自动调整学习率</strong>，避免学习率过大或过小的问题 -避免出现学习率饱和现象，使得训练更加稳定</p><p><strong>缺点：</strong></p><ul><li>可能收敛较慢</li><li>需要维护梯度和权重更新量的累积值，增加了空间复杂度</li></ul><h3 id="代码实现-1">代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">learning_rate = <span class="number">1.0</span>  <span class="comment"># Adadelta 不需要传统的学习率</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line">rho = <span class="number">0.9</span></span><br><span class="line">epsilon = <span class="number">1e-6</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 随机生成数据</span></span><br><span class="line">x = torch.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">3</span> + torch.randn(<span class="number">100</span>, <span class="number">1</span>) * <span class="number">0.5</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化参数</span></span><br><span class="line">w = torch.randn(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义Adadelta优化器</span></span><br><span class="line">optimizer = torch.optim.Adadelta([w, b], rho=rho, eps=epsilon)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 记录损失</span></span><br><span class="line">losses = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    y_pred = x * w + b</span><br><span class="line">    <span class="comment"># 计算损失</span></span><br><span class="line">    loss = torch.mean((y_pred - y) ** <span class="number">2</span>)</span><br><span class="line">    losses.append(loss.item())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清空梯度</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    optimizer.step()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可视化训练过程</span></span><br><span class="line">plt.plot(<span class="built_in">range</span>(epochs), losses)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training Loss with Adadelta&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Momentum</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/4.Momentum/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/4.Momentum/</url>
      
        <content type="html"><![CDATA[<h1 id="动量法momentum">动量法（Momentum）</h1><h2 id="背景知识">背景知识</h2><p>在<ahref="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&amp;spm=1001.2101.3001.7020">深度学习</a>的优化过程中，梯度下降法（GradientDescent,GD）是最基本的方法。然而，基本的梯度下降法在实际应用中存在<strong>收敛速度慢</strong>、<strong>容易陷入局部最小值</strong>以及在<strong>高维空间中震荡较大</strong>的问题。为了解决这些问题，人们提出了动量法（Momentum）。</p><h2 id="动量法的概念">动量法的概念</h2><p>动量（Momentum）最初是一个物理学概念，表示物体的质量与速度的乘积。它的方向与速度的方向相同，并遵循动量守恒定律。尽管深度学习中的动量与物理学中的动量并不完全相同，但它们都强调了一个概念：<strong>在运动方向上保持运动的趋势，从而加速收敛</strong>。</p><h2 id="动量法在深度学习中的应用">动量法在深度学习中的应用</h2><p>在深度学习中，动量法通过记录<strong>梯度的增量</strong>并将其与<strong>当前梯度相加</strong>，来<strong>平滑梯度下降</strong>的路径。这意味着在每一步的迭代中，不仅考虑当前的梯度，还考虑之前梯度的累积效果。</p><p>动量法的更新公式如下：</p><p><span class="math display">\[m_t = \beta m_{t-1} + \nabla L(w_t)\]</span> <span class="math display">\[w_{t+1} = w_t - \alpha m_t\]</span></p><p>其中：</p><ul><li><span class="math inline">\(m_t\)</span>是动量项，记录了之前梯度的累积。<br /></li><li><span class="math inline">\(\beta\)</span>是动量参数，控制<strong>动量项的衰减</strong>，一般取值为0.9。<br /></li><li><span class="math inline">\(\nabla L(w_t)\)</span>是当前参数的梯度。</li><li><span class="math inline">\(\alpha\)</span> 是学习率。</li></ul><span id="more"></span><h2 id="动量法的优点">动量法的优点</h2><ol type="1"><li><p><strong>加速收敛</strong>：动量法通过积累之前的梯度信息，使得优化过程更为顺畅，避免了曲折路径，提高了收敛速度。<br /></p></li><li><p><strong>跳过局部最小值</strong>：由于动量的累积作用，可以帮助优化算法跳过一些局部最小值，找到更优的解。<br /></p></li><li><p><strong>减少振荡</strong>：动量法可以有效减小学习过程中梯度震荡的现象，使得模型的训练更加稳定。## 动量法的缺点</p></li><li><p><strong>计算复杂度增加</strong>：由于需要维护动量项，会导致计算复杂度的增加</p></li><li><p><strong>参数调节</strong>：动量法引入了新的超参数（动量系数 <spanclass="math inline">\(\beta\)</span>），需要在实际应用中进行调节</p></li></ol><h2 id="动量法的改进及变种">动量法的改进及变种</h2><p>​ 在动量法的基础上，还有一些改进和变种，如Nesterov加速梯度（NesterovAccelerated <ahref="https://so.csdn.net/so/search?q=Gradient&amp;spm=1001.2101.3001.7020">Gradient</a>,NAG）、RMSprop、Adam等。这些方法在动量法的基础上进一步优化了收敛速度和稳定性。</p><h2 id="实验代码示例">实验代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据生成</span></span><br><span class="line">torch.manual_seed(<span class="number">42</span>)</span><br><span class="line">X = torch.randn(<span class="number">1000</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">3</span> * X.squeeze() + <span class="number">2</span> + torch.randn(<span class="number">1000</span>) * <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LinearModel, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.linear(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同梯度下降方法的比较</span></span><br><span class="line">methods = &#123;</span><br><span class="line">    <span class="string">&#x27;SGD&#x27;</span>: <span class="keyword">lambda</span> params: optim.SGD(params, lr=<span class="number">0.01</span>),</span><br><span class="line">    <span class="string">&#x27;Momentum&#x27;</span>: <span class="keyword">lambda</span> params: optim.SGD(params, lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">losses = &#123;method: [] <span class="keyword">for</span> method <span class="keyword">in</span> methods&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练过程</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> method_name, optimizer_fn <span class="keyword">in</span> methods.items():</span><br><span class="line">    model = LinearModel()</span><br><span class="line">    optimizer = optimizer_fn(model.parameters())</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(X)</span><br><span class="line">        loss = criterion(outputs.squeeze(), y)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        losses[method_name].append(loss.item())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制损失曲线</span></span><br><span class="line"><span class="keyword">for</span> method_name, loss_values <span class="keyword">in</span> losses.items():</span><br><span class="line">    plt.plot(loss_values, label=method_name)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epochs&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;Loss Curve Comparison&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408112029254.png"alt="image-20240811202901191" /><figcaption aria-hidden="true">image-20240811202901191</figcaption></figure><h2 id="结论">结论</h2><p>动量法通过引入动量项，显著提高了<ahref="https://so.csdn.net/so/search?q=%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95&amp;spm=1001.2101.3001.7020">梯度下降法</a>的收敛速度和稳定性。尽管在实际应用中引入了额外的计算开销，但其在许多深度学习任务中的表现优异，已经成为常用的优化方法之一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mini-batch GD</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/3.Mini-batch%20GD/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/3.Mini-batch%20GD/</url>
      
        <content type="html"><![CDATA[<h1id="小批量梯度下降法mini-batch-gradient-descent">小批量梯度下降法（Mini-batchGradient Descent）</h1><p>在<ahref="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B&amp;spm=1001.2101.3001.7020">深度学习模型</a>的训练过程中，梯度下降法是最常用的优化算法之一。我们前面介绍了梯度下降法（BatchGradient Descent）和随机梯度下降法（Stochastic GradientDescent），两者各有优缺点。为了在<strong>计算速度</strong>和<strong>收敛稳定性</strong>之间找到<strong>平衡</strong>，<strong>小批量梯度下降法</strong>（Mini-batchGradientDescent）应运而生。下面我们详细介绍其基本思想、优缺点，并通过代码实现来比较三种梯度下降法。</p><h2 id="小批量梯度下降法的基本思想">小批量梯度下降法的基本思想</h2><p>​小批量梯度下降法在每次迭代中，使用<strong>一小部分随机样本（称为小批量）</strong>来计算梯度，并更新参数值。具体来说，算法步骤如下：</p><ol type="1"><li><p>初始化参数 <span class="math inline">\(w\)</span> 和 <spanclass="math inline">\(b\)</span></p></li><li><p>在每次迭代中，从训练集中随机抽取 <spanclass="math inline">\(m\)</span> 个样本。</p></li><li><p>使用这 <span class="math inline">\(m\)</span>个样本计算损失函数的梯度</p></li><li><p>更新参数 <span class="math inline">\(w\)</span> 和 <spanclass="math inline">\(b\)</span></p></li></ol><p>其梯度计算公式如下：</p><p><span class="math display">\[w_{t+1}=w_{t}-\alpha \cdot \frac{1}{m}\sum_{i=1}^m{\nabla_w}L(w_{t},b_{t},x_i,y_i),\\b_{t+1}=b_{t}-\alpha \cdot \frac{1}{m}\sum_{i=1}^m{\nabla_b}L(w_{t},b_{t},x_i,y_i),\]</span> 其中，<span class="math inline">\(\alpha\)</span> 是学习率，<span class="math inline">\(m\)</span> 是小批量的大小。</p><ul><li>当 <span class="math inline">\(m=1\)</span> 时，Mini-batch GradientDescent 转换为 SGD</li><li>当 <span class="math inline">\(m=n\)</span> 时，Mini-batch GradientDescent 转换为 GD</li></ul><span id="more"></span><h2 id="优缺点">优缺点</h2><h3 id="优点">优点</h3><ol type="1"><li><strong>计算速度快</strong>：与批量梯度下降法相比，每次迭代只需计算小批量样本的梯度，速度更快。<br /></li><li><strong>减少振荡</strong>：与<ahref="https://so.csdn.net/so/search?q=%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95&amp;spm=1001.2101.3001.7020">随机梯度下降法</a>相比，梯度的计算更加稳定，减少了参数更新时的振荡。<br /></li><li><strong>控制灵活</strong>：可以调整小批量的大小，使得训练速度和精度之间达到平衡。</li></ol><h3 id="缺点">缺点</h3><ol type="1"><li><strong>需要调整学习率和小批量大小</strong>：学习率决定每次更新的步长，小批量大小决定每次计算梯度使用的样本数量。<br /></li><li><strong>内存消耗</strong>：小批量大小的选择受限于内存容量，尤其在使用GPU运算时，需要选择合适的小批量大小。</li></ol><h3 id="代码实现">代码实现</h3><p>下面通过代码实现和比较三种梯度下降法的执行效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, TensorDataset</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义数据集</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">X = np.random.rand(<span class="number">1000</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">3</span>*X + <span class="number">2</span> + np.random.randn(<span class="number">1000</span>, <span class="number">1</span>) * <span class="number">0.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 转换为tensor</span></span><br><span class="line">X_tensor = torch.tensor(X, dtype=torch.float32)</span><br><span class="line">y_tensor = torch.tensor(y, dtype=torch.float32)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 封装为数据集</span></span><br><span class="line">dataset = TensorDataset(X_tensor, y_tensor)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearRegressionModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LinearRegressionModel, self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.linear(x)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义梯度下降法的批量大小</span></span><br><span class="line">batch_sizes = [<span class="number">1000</span>, <span class="number">1</span>, <span class="number">128</span>]</span><br><span class="line">batch_labels = [<span class="string">&#x27;Batch Gradient Descent&#x27;</span>, <span class="string">&#x27;Stochastic Gradient Descent&#x27;</span>, <span class="string">&#x27;Mini-batch Gradient Descent&#x27;</span>]</span><br><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">num_epochs = <span class="number">1000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 存储损失值</span></span><br><span class="line">losses = &#123;label: [] <span class="keyword">for</span> label <span class="keyword">in</span> batch_labels&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">for</span> batch_size, label, color <span class="keyword">in</span> <span class="built_in">zip</span>(batch_sizes, batch_labels, colors):</span><br><span class="line">    model = LinearRegressionModel()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=learning_rate)</span><br><span class="line">    </span><br><span class="line">    data_loader = DataLoader(dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(num_epochs), desc=label):</span><br><span class="line">        epoch_loss = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> batch_x, batch_y <span class="keyword">in</span> data_loader:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = model(batch_x)</span><br><span class="line">            loss = criterion(outputs, batch_y)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            epoch_loss += loss.item()</span><br><span class="line">        </span><br><span class="line">        losses[label].append(epoch_loss / <span class="built_in">len</span>(data_loader))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 绘制损失值变化曲线</span></span><br><span class="line"><span class="keyword">for</span> label, color <span class="keyword">in</span> <span class="built_in">zip</span>(batch_labels, colors):</span><br><span class="line">    plt.plot(losses[label], color=color, label=label)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="结果分析">结果分析</h3><p>运行上述代码后，会显示三种梯度下降法在每个迭代周期（epoch）中的损失变化曲线。可以看到：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408112012585.png"alt="image-20240811201255444" /><figcaption aria-hidden="true">image-20240811201255444</figcaption></figure><ol type="1"><li>批量梯度下降法：损失曲线平滑，但训练速度较慢。<br /></li><li>随机梯度下降法：训练速度快，但损失曲线波动较大。<br /></li><li>小批量梯度下降法：在训练速度和损失曲线的稳定性之间达到了平衡，效果较为理想。</li></ol><h2 id="总结">总结</h2><p>​小批量梯度下降法结合了批量梯度下降法和随机梯度下降法的优点，是深度学习中常用的<ahref="https://so.csdn.net/so/search?q=%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">优化算法</a>。通过调整小<strong>批量大小</strong>和<strong>学习率</strong>，可以在<strong>训练速度</strong>和<strong>收敛稳定性</strong>之间找到最佳平衡。在实际应用中，小批量梯度下降法由于其较高的效率和较好的收敛效果，被广泛应用于各类深度学习模型的训练中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGD</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/2.SGD/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/2.SGD/</url>
      
        <content type="html"><![CDATA[<h1 id="随机梯度下降法sgd">随机梯度下降法（SGD）</h1><p>​ 在<ahref="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&amp;spm=1001.2101.3001.7020">深度学习</a>中，梯度下降法（GradientDescent）是最常用的模型参数优化方法。然而，传统的梯度下降法（Full BatchLearning）存在一些缺点，例如训练时间过长和容易陷入局部最小值。为了解决这些问题，随机梯度下降法（StochasticGradient Descent，简称SGD）应运而生。</p><h2 id="传统梯度下降法的问题">传统梯度下降法的问题</h2><ol type="1"><li><strong>训练时间长</strong>：传统梯度下降法需要使用所有训练数据来计算梯度，因此数据量大时耗时严重。<br /></li><li><strong>容易陷入局部最小值</strong>：复杂的损失函数可能会导致算法在局部最小值附近来回震荡，无法快速收敛。<br /></li><li><strong>对初始值敏感</strong>：初始值选择不当可能导致算法被卡在局部最小值。</li></ol><h2 id="随机梯度下降法的基本思想"><ahref="https://so.csdn.net/so/search?q=%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95&amp;spm=1001.2101.3001.7020">随机梯度下降法</a>的基本思想</h2><p>SGD每次迭代仅<strong>使用一个样本</strong>的<strong>损失值</strong>来计算梯度，而不是全数据集损失值的求和平均来计算梯度。</p><span id="more"></span><h2 id="sgd的优缺点">SGD的优缺点</h2><h3 id="优点">优点</h3><ol type="1"><li><strong>速度快</strong>：每次迭代只需计算一个样本的梯度，速度比传统方法快很多。<br /></li><li><strong>避免局部最小值</strong>：因为每次更新参数只使用一个样本，随机性使得算法不容易陷入局部最小值。</li><li><strong>更易实现和调整</strong>：每个样本的梯度可以分别计算，并行处理更加高效。</li></ol><h3 id="缺点">缺点</h3><ol type="1"><li><strong>收敛不稳定</strong>：每次迭代梯度都会有噪声，可能导致收敛不稳定。</li><li><strong>方差较大</strong>：每次更新参数只使用一个样本的梯度，可能导致算法方差较大，难以收敛。</li></ol><h2 id="动态学习率">动态学习率</h2><p>为了提高SGD的收敛性，可以使用动态学习率。常见的动态学习率策略包括：</p><ol type="1"><li><p><strong>反比例学习率</strong>：初始学习率随着迭代次数增加而减小。</p></li><li><p><strong>反比例平方学习率</strong>：类似反比例学习率，但减小速度更快。</p></li></ol><p><span class="math display">\[\alpha_t = \frac{\alpha_0}{1 + k \cdot t^2}\]</span></p><ol start="3" type="1"><li><strong>指数衰减学习率</strong>：学习率以指数形式衰减。</li></ol><p><span class="math display">\[\alpha_t = \alpha_0 \cdot e^{-\lambda t}\]</span></p><h2 id="实现示例">实现示例</h2><p>下面是使用Python实现随机梯度下降法的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stochastic_gradient_descent</span>(<span class="params">X, y, lr=<span class="number">0.01</span>, epochs=<span class="number">1000</span></span>):</span><br><span class="line">    m, n = X.shape</span><br><span class="line">    w = np.zeros(n)</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            random_index = np.random.randint(m)</span><br><span class="line">            xi = X[random_index:random_index+<span class="number">1</span>]</span><br><span class="line">            yi = y[random_index:random_index+<span class="number">1</span>]</span><br><span class="line">            gradient_w = <span class="number">2</span> * xi.T.dot(xi.dot(w) + b - yi)</span><br><span class="line">            gradient_b = <span class="number">2</span> * (xi.dot(w) + b - yi)</span><br><span class="line">            w = w - lr * gradient_w</span><br><span class="line">            b = b - lr * gradient_b</span><br><span class="line">        <span class="comment"># 可选：动态学习率调整</span></span><br><span class="line">        lr = lr / (<span class="number">1</span> + epoch / epochs)</span><br><span class="line">    <span class="keyword">return</span> w, b</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">y = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用SGD函数</span></span><br><span class="line">w, b = stochastic_gradient_descent(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;权重:&quot;</span>, w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;偏置:&quot;</span>, b)</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>SGD通过每次迭代使用一个<strong>随机样本</strong>来计算梯度，从而加快了计算速度并避免陷入局部最小值。动态学习率的使用可以进一步提高SGD的收敛性。在实际应用中，SGD已成为深度学习领域最常用的优化算法之一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/1.GD/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/1.GD/</url>
      
        <content type="html"><![CDATA[<h1 id="梯度下降法gradient-descent">梯度下降法（Gradient Descent）</h1><h2 id="引言">引言</h2><p>​ 在深度学习中，<ahref="https://so.csdn.net/so/search?q=%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">损失函数</a>的求解是一个关键步骤。损失函数通常没有解析解，因此需要通过最优化算法来逼近求解。其中，梯度下降法是最常用的优化算法之一。本文将详细介绍梯度下降法的基本概念、理论基础、及其在深度学习中的应用。</p><h2 id="梯度下降法的基本概念">梯度下降法的基本概念</h2><p>梯度下降法（GradientDescent）是一种基于一阶导数的优化算法，用于最小化目标函数。在深度学习中，目标函数通常是损失函数，其目的是通过调整参数来使损失最小化。</p><h3 id="损失函数的定义">损失函数的定义</h3><p>假设损失函数 <span class="math inline">\(L\)</span> 是参数 <spanclass="math inline">\(W\)</span> 的函数：<spanclass="math inline">\(L(W)\)</span>，我们的目标是找到参数 <spanclass="math inline">\(W\)</span> 使得 <spanclass="math inline">\(L(W)\)</span> 最小化。</p><span id="more"></span><h3 id="梯度的定义">梯度的定义</h3><p>梯度是损失函数的导数，表示函数在某一点处的最陡下降方向。对于参数<span class="math inline">\(W\)</span> 的每个分量 <spanclass="math inline">\(w_i\)</span> ，梯度表示为：</p><p><span class="math display">\[\nabla L(W)=\left[\frac{\partial L}{\partial w_1},\frac{\partialL}{\partial w_2},\ldots,\frac{\partial L}{\partial w_n}\right]\]</span></p><blockquote><p><strong>梯度的维度</strong>=<strong>参数的个数</strong></p></blockquote><h3 id="梯度下降算法">梯度下降算法</h3><p>梯度下降法通过以下步骤更新参数：</p><p><span class="math display">\[w_{t+1}=w_{t}-\alpha \cdot \frac{1}{n}\sum_{i=1}^n{\nabla_w}L(w_{t},b_{t},x_i,y_i),\\b_{t+1}=b_{t}-\alpha \cdot \frac{1}{n}\sum_{i=1}^n{\nabla_b}L(w_{t},b_{t},x_i,y_i),\]</span> 其中，<span class="math inline">\(\alpha\)</span>是学习率（Learning Rate），决定了每次更新的步长；<spanclass="math inline">\(n\)</span> 是样本大小。</p><h2 id="梯度下降法的应用">梯度下降法的应用</h2><h3 id="简单示例二次损失函数">简单示例：二次损失函数</h3><p>为了便于理解，我们假设损失函数是一个简单的二次函数</p><p><span class="math display">\[L(W) = W^2\]</span> 梯度为：</p><p><span class="math display">\[\nabla L(W) = 2W\]</span> 根据梯度下降法的更新规则，参数更新为：</p><p><span class="math display">\[W_{t+1} = W_t - \alpha \cdot 2W_t = W_t(1 - 2\alpha)\]</span></p><h3 id="高维度情况下的梯度下降">高维度情况下的梯度下降</h3><p>​在实际应用中，损失函数往往是高维度的。梯度下降法可以扩展到高维度情况，其中<strong>梯度是一个向量，表示每个参数</strong>的导数。我们将梯度表示为一个向量，并对每个参数进行更新。</p><h3 id="学习率的选择">学习率的选择</h3><p>学习率 <span class="math inline">\(\alpha\)</span>对梯度下降法的收敛速度和稳定性有重大影响。选择合适的学习率非常重要。</p><ul><li>如果学习率过大，算法可能会在最小值附近来回<strong>震荡</strong>；</li><li>如果学习率过小，算法的<strong>收敛速度会非常慢</strong>。</li></ul><h2 id="梯度下降法的变体">梯度下降法的变体</h2><p>在实际应用中，梯度下降法有多种变体，以提高收敛速度和稳定性。常见的变体包括：</p><ul><li><strong>随机梯度下降法（SGD）</strong>：每次迭代使用一个或几个样本来更新参数，而不是使用整个训练集。这种方法可以显著加快计算速度。<br /></li><li><strong>动量法（Momentum）</strong>：在每次更新时，加入之前更新的动量，以加速收敛。<br /></li><li><strong>自适应学习率</strong>方法：例如Adagrad、RMSprop、Adam等，通过<strong>动态调整学习率</strong>来提高收敛效果。</li></ul><h2 id="总结">总结</h2><p>梯度下降法是深度学习中最常用的优化算法之一。通过计算损失函数的梯度，确定参数的更新方向和步长，不断逼近损失函数的最小值。<strong>选择合适的学习率和初始点是梯度下降法（GD）成功的关键。</strong>理解梯度下降法的基本概念和应用，对于深入学习<ahref="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">深度学习算法</a>有重要意义。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习中的优化算法探讨</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E5%92%8C%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E5%92%8C%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习中的优化算法探讨">深度学习中的优化算法探讨</h1><p>​在深度学习的过程中，<strong>优化算法</strong>扮演着至关重要的角色。训练神经网络通常需要投入大量的时间和资源，而优化算法的选择和应用直接影响模型的训练效率和效果。数值优化是一个庞大的数学学科，本篇文章将探讨与深度学习，特别是训练过程密切相关的优化算法。</p><h2id="最优化理论和深度学习优化算法的区别">最优化理论和深度学习优化算法的区别</h2><h3 id="度量和损失函数">度量和损失函数</h3><ul><li><strong>最优化理论</strong>：研究如何找到函数的<strong>最优解</strong>，即最大值或最小值，通常有明确的度量标准。</li><li><strong>深度学习</strong>：使用代理损失函数（如负对数似然或交叉熵）来进行优化，通过<strong>最小化代理损失函数</strong>来最大化原始度量。</li></ul><h3 id="数据关注点">数据关注点</h3><ul><li><strong>最优化理论</strong>：只关心现有数据的最优解。</li><li><strong>深度学习</strong>：关注模型的泛化能力，即模型<strong>在测试集</strong>上的表现，避免过拟合现象。</li></ul><h3 id="研究内容">研究内容</h3><ul><li><strong>最优化理论</strong>：注重算法本身的研究。</li><li><strong>深度学习</strong>：关注实现细节，包括神经网络的结构、参数调整等。</li></ul><h2 id="训练误差与泛化误差">训练误差与泛化误差</h2><ul><li><strong>训练误差</strong>：模型在<strong>训练集</strong>上的误差，只关注<strong>训练过程</strong>中的表现。</li><li><strong>泛化误差</strong>：模型在未见过的数据（<strong>测试集</strong>）上的误差，关注模型的<strong>泛化能力</strong>。</li></ul><p>泛化误差的衡量是深度学习优化的<strong>核心</strong>，理想的模型应该在新数据上也能表现良好。</p><h2 id="经验风险与真实风险">经验风险与真实风险</h2><ul><li><strong>经验风险（EmpiricalRisk）</strong>：<strong>训练集</strong>上的期望<strong>损失</strong>，通过<strong>最小化经验风险</strong>来优化模型。</li><li><strong>真实风险（ExpectedRisk）</strong>：使用<strong>真实数据</strong>计算损失函数的期望值，由于无法直接计算<strong>真实风险</strong>，因此通过<strong>优化经验风险</strong>来尽量减少泛化误差。</li></ul><h2 id="深度学习优化中的挑战">深度学习优化中的挑战</h2><h3 id="病态问题ill-conditioned-problem">病态问题（Ill-conditionedProblem）</h3><ul><li>问题解对条件非常敏感，即使微小的变化也会导致解的大幅变化。</li><li>解决方案：正则化技术、数据预处理等。</li></ul><h3 id="局部最小值问题local-minima">局部最小值问题（Local Minima）</h3><ul><li>优化过程中可能陷入局部最小值，而不是全局最优值。</li><li>解决方案：使用不同的优化算法，如随机梯度下降（SGD）、Adam等。</li></ul><h3 id="鞍点问题saddle-points">鞍点问题（Saddle Points）</h3><ul><li>损失函数在某些点的曲率为零，但不是全局最优点。</li><li>解决方案：减少模型复杂度、增加训练数据、使用随机初始化等。</li></ul><h3 id="悬崖问题cliffs">悬崖问题（Cliffs）</h3><ul><li>多层神经网络中的损失函数可能存在陡峭的区域，导致梯度更新大幅改变参数值。</li><li>解决方案：梯度裁剪（Gradient Clipping）以控制梯度大小。</li></ul><h3id="长期依赖问题long-term-dependency-problem">长期依赖问题（Long-termDependency Problem）</h3><ul><li>深层网络结构使得模型难以学习到先前的信息，导致梯度消失或爆炸。</li><li>解决方案：使用LSTM或GRU等特殊的循环神经网络结构</li></ul><span id="more"></span><h2 id="总结">总结</h2><p>​优化算法是深度学习模型训练中的核心工具，两者有密切的联系但也有显著的区别。最优化理论关注的是<strong>训练误差</strong>，而深度学习关注的是<strong>泛化误差</strong>。深度学习通过<strong>最小化经验风险</strong>来尽量减少<strong>泛化误差</strong>。优化过程中面临的挑战包括病态问题、局部最小值、鞍点、悬崖和长期依赖问题，这些问题需要通过不同的优化算法和策略来解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>损失函数</title>
      <link href="/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2024/08/13/%5Bobject%20Object%5D/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="损失函数">损失函数</h1><p>​ 在<ahref="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&amp;spm=1001.2101.3001.7020">深度学习</a>和机器学习领域，损失函数（LossFunction）是优化问题的核心，决定了模型参数的调整方向和幅度。尽管损失函数种类繁多，但理解其起源和背后的理论有助于我们更好地选择和应用它们。</p><h2 id="损失函数的起源"><ahref="https://so.csdn.net/so/search?q=%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">损失函数</a>的起源</h2><p>所有的优化问题都需要确立一个目标函数，通过最小化（或最大化）该目标函数来求解。在<ahref="https://so.csdn.net/so/search?q=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&amp;spm=1001.2101.3001.7020">机器学习</a>中，损失函数衡量模型预测值与真实值之间的差异，是优化模型参数的重要工具。</p><h2 id="最小二乘法mse">最小二乘法（MSE）</h2><p>损失函数的起源可以追溯到统计学中的最小二乘回归。其基本思想是最小化预测值与真实值之间的差异。假设预测值为<span class="math inline">\(\hat{y}_{i}\)</span>，真实值为 <spanclass="math inline">\(y_i\)</span>，则最小二乘误差为： <spanclass="math display">\[[\mathrm{MSE}=\frac{1}{n}\sum_{i=1}^{n}(y_{i}-\hat{y}_{i})2]\]</span> 通过最小化MSE，可以找到使损失函数最小的参数 <spanclass="math inline">\(\theta\)</span>。</p><span id="more"></span><h2 id="最大似然估计mle">最大似然估计（MLE）</h2><p>​ 最大似然估计（Maximum Likelihood Estimation,MLE）是另一种基础且重要的参数估计方法，从概率分布的角度来理解<strong>目标函数</strong>或<strong>损失函数</strong>。假设我们有一组独立的样本数据集<spanclass="math inline">\(\{x_1, x_2, ...,x_m\}\)</span>，来自于未知的真实数据分布<spanclass="math inline">\(P_{\text{data}}(x)\)</span>。我们假设另一个分布<spanclass="math inline">\(P_{\text{model}}(x|\theta)\)</span>来近似真实分布。</p><p>最大似然估计的目标是找到参数 <spanclass="math inline">\(\theta\)</span>，使得在给定数据的情况下，模型的似然函数最大化。即：<span class="math display">\[[\hat{\theta}=\arg\max_{\theta}\prod_{i=1}^{m}P_{\mathrm{model}}(x_{i}|\theta)]\]</span> 为了简化计算，我们通常使用对数似然： <spanclass="math display">\[[\hat{\theta}=\arg\max_{\theta}\sum_{i=1}^{m}\logP_{\mathrm{model}}(x_{i}|\theta)]\]</span>在假设数据符合<strong>高斯分布</strong>的情况下，MLE与最小化均方误差（MSE）等价。</p><h2 id="交叉熵损失">交叉熵损失</h2><p>​ 交叉熵损失（Cross-EntropyLoss）是<strong>分类</strong>问题中常用的损失函数。假设数据符合伯努利分布或多项式分布，交叉熵损失用于衡量两个概率分布之间的差异。对于二分类问题，交叉熵损失定义为：</p><p><span class="math display">\[[L=-\frac{1}{m}\sum_{i=1}^{m}[y_{i}\log\hat{y}_{i}+(1-y_{i})\log(1-\hat{y}_{i})]]\]</span>交叉熵损失从概率分布角度来看，本质上也是最大似然估计的一种形式。</p><h2 id="正则化与最大后验估计map">正则化与最大后验估计（MAP）</h2><p><strong>正则化</strong>技术是解决<strong>过拟合</strong>问题的重要手段措施。正则化可以理解为在损失函数中加入<strong>惩罚项</strong>，以<strong>限制模型的复杂度</strong>，从而提高模型的<strong>泛化能力</strong>。正则化可以视作最大后验估计（MaximumA Posteriori Estimation, MAP）的特殊情况。</p><h3 id="l2正则化ridge回归">L2正则化（Ridge回归）</h3><p>L2正则化通过在损失函数中加入<strong>参数的平方和项</strong>来惩罚过大的参数。其目标函数为：</p><p><span class="math display">\[[ \text{L2正则化} = \text{MSE} + \lambda \sum_{j=1}^{p} \theta _{j}^{2}]\]</span></p><p>其中，<span class="math inline">\(\lambda\)</span>是正则化参数，用于控制惩罚项的权重。<spanclass="math inline">\(L2\)</span>正则化可以视为假设参数符合高斯分布时的最大后验估计。</p><h3 id="l1正则化lasso回归">L1正则化（Lasso回归）</h3><p>L1正则化通过在损失函数中加入参数的绝对值和项来惩罚过大的参数。其目标函数为：</p><p><span class="math display">\[[ \text{L1正则化} = \text{MSE} + \lambda \sum_{j=1}^{p} |\theta_j| ]\]</span> L1正则化可以视为假设参数符合拉普拉斯分布时的最大后验估计。</p><h3 id="最大后验估计map">最大后验估计（MAP）</h3><p>MAP估计在MLE的基础上，考虑了参数的先验分布。其目标函数为： <spanclass="math display">\[[\hat{\theta}=\arg\max_{\theta}P(\theta|X)]\]</span> 利用贝叶斯定理可以展开为：</p><p><span class="math display">\[[\hat{\theta}=\arg\max_\theta\left[\log P(X|\theta)+\logP(\theta)\right]]\]</span>前者是似然函数，后者是先验分布。通过对数变换和相加的方式，将<strong>最大化后验概率</strong>的问题转化为<strong>最大化对数似然函数</strong>与<strong>对数先验分布之和</strong>的问题。</p><h2 id="贝叶斯估计bayesian-estimation">贝叶斯估计（BayesianEstimation）</h2><p>贝叶斯估计（BayesianEstimation）与频率学派的视角不同。贝叶斯学派认为数据是固定的，但参数是随机的，并且参数的估计应基于其全分布而不是点估计。</p><p>贝叶斯估计的核心在于求解后验分布： <span class="math display">\[[P(\theta|X)=\frac{P(X|\theta)P(\theta)}{P(X)}]\]</span> 其中，<spanclass="math inline">\(P(X)\)</span>是证据（evidence），用于归一化。</p><p>在实际应用中，贝叶斯估计通常也会使用对数形式： <spanclass="math display">\[\log P(\theta|X) = \log P(X|\theta) + \log P(\theta) - \log P(X)\]</span>通过这种方式，我们可以更加灵活地处理不确定性，并且可以自然地引入先验信息。</p><h2 id="统一理解">统一理解</h2><p>​损失函数在深度学习中的应用广泛，虽然种类繁多，但从概率分布和参数估计的角度，我们可以将其统一起来理解。通过最大似然估计（MLE）、最大后验估计（MAP）和贝叶斯估计（BayesianEstimation），我们能够更系统地理解损失函数及其背后的统计学原理。</p><h3 id="回归问题">回归问题</h3><p>​回归问题中常用的是均方误差（MSE），其本质是最大似然估计在假设误差服从高斯分布下的特例。L2和L1正则化则分别对应参数服从高斯分布和拉普拉斯分布的最大后验估计。</p><h3 id="分类问题">分类问题</h3><p>​分类问题中常用的是交叉熵损失，其本质是最大似然估计在假设数据服从伯努利分布或多项分布下的特例。</p><h3 id="正则化">正则化</h3><p>​正则化可以视为在最大似然估计的基础上引入先验分布，从而转化为最大后验估计。L2正则化对应高斯分布的先验，L1正则化对应拉普拉斯分布的先验。</p><h2 id="总结">总结</h2><p>通过从概率分布和参数估计的角度重新梳理损失函数的定义，我们可以更高效地理解和应用各种损失函数及其变体。最大似然估计、最大后验估计和贝叶斯估计提供了统一的框架，使我们能够更系统地看待损失函数及其在机器学习和深度学习中的应用。</p><p>希望这篇文章能帮助大家在学习和应用损失函数时，从更高的角度和更深的层次理解其精髓。随着对这些概念的深入理解，我们可以更灵活地选择和设计适合具体问题的损失函数，从而提升模型的性能和泛化能力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scanf()函数与printf()中的格式说明符</title>
      <link href="/2024/08/11/%5Bobject%20Object%5D/C++/%E3%80%90%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E3%80%91/"/>
      <url>/2024/08/11/%5Bobject%20Object%5D/C++/%E3%80%90%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1id="scanf函数与printf中的格式说明符">scanf()函数与printf()中的格式说明符</h1><h2id="scanf与printf中格式说明符几乎相同的一部分">scanf（）与printf（）中格式说明符几乎相同的一部分</h2><table border="1" cellpadding="1" cellspacing="1" style="width: 600px; text-align: central;"><tbody><tr><td>%d</td><td>用来输入和输出int</td></tr><tr><td>%ld</td><td>用来输入和输出long</td></tr><tr><td>%lld</td><td>用来输入和输出long long</td></tr><tr><td>%hd</td><td>用来输入和输出short</td></tr><tr><td>%i</td><td>用来输入和输出有符号十进制整数</td></tr><tr><td>%u</td><td>用来输入和输出无符号十进制整数</td></tr><tr><td>%lu</td><td>用来输入和输出无符号十进制长整数</td></tr><tr><td>%llu</td><td>用来输入和输出无符号十进制长长整数</td></tr><tr><td>%hu</td><td>用来输入和输出无符号短十进制整数</td></tr><tr><td>%o</td><td>用来输入和输出八进制整数</td></tr><tr><td>%lo</td><td>用来输入和输出长八进制整数</td></tr><tr><td>%ho</td><td>用来输入和输出短八进制整数</td></tr><tr><td>%#o</td><td>用来输出八进制整数，数字前有0</td></tr><tr><td>%x</td><td>用来输入和输出十六制整数，字母小写</td></tr><tr><td>%#x</td><td>用来输出十六制整数，字母小写，数字前有0x</td></tr><tr><td>%lx</td><td>用来输入和输出长十六制整数，字母小写</td></tr><tr><td>%X</td><td>用来输入和输出十六制整数，字母大写 </td></tr><tr><td>%#X</td><td>用来输出十六制整数，字母大写 ，数字前有0X</td></tr><tr><td>%lX</td><td>用来输入和输出长十六制整数，字母大写</td></tr><tr><td>%c</td><td>用来输入和输出单个字符</td></tr><tr><td>%s</td><td><p>用来输入和输出一串字符串</p><p>输入时遇空格，<a            href="https://so.csdn.net/so/search?q=%E5%88%B6%E8%A1%A8%E7%AC%A6&amp;spm=1001.2101.3001.7020"            target="_blank"            class="hl hl-1"            data-report-click='{"spm":"1001.2101.3001.7020","dest":"https://so.csdn.net/so/search?q=%E5%88%B6%E8%A1%A8%E7%AC%A6&amp;spm=1001.2101.3001.7020","extra":"{\"searchword\":\"制表符\"}"}'            data-tit="制表符"            data-pretit="制表符"            >制表符</a          >或换行符结束</p><p>输出时连格式说明符一起输出</p><p>printf（"%s","%d%f",a,b）;输出 %d%f</p></td></tr><tr><td>%f</td><td>用来输入和输出float，输出double</td></tr><tr><td>%lf</td><td>用来输入和输出double（double输出用%f和%lf都可以）</td></tr><tr><td>%Lf</td><td>用来输入和输出long double</td></tr><tr><td>%e</td><td>用来输入和输出指数，字母小写</td></tr><tr><td>%le</td><td>用来输入和输出长指数，字母小写</td></tr><tr><td>%E</td><td>用来输入和输出指数，字母大写</td></tr><tr><td>%lE</td><td>用来输入和输出长指数，字母大写</td></tr><tr><td>%g</td><td>用来输入和输出指数或float（输出最短的一种），字母小写</td></tr><tr><td>%lg</td><td>用来输入和输出长指数或double（输出最短的一种），字母小写</td></tr><tr><td>%G</td><td>用来输入和输出指数或float（输出最短的一种），字母大写</td></tr><tr><td>%lG</td><td>用来输入和输出长指数或double（输出最短的一种），字母大写</td></tr></tbody></table><span id="more"></span><h2 id="scanf独有">scanf()独有</h2><table border="1" cellpadding="1" cellspacing="1" style="width: 600px"><tbody><tr><td>%<em>（所有类型），如%</em>d</td><td><p>用来输入一个数，字符或字符串而不赋值（跳过无关输入）</p><p>如scanf("%d%*c%d",&amp;a,&amp;b);</p><p>这样就可以只将1+2中的1和2赋值给a和b。</p></td></tr><tr><td><p>%m（所有类型），其中m为常数</p></td><td>限定输入范围，如scanf（“%4d”，&amp;a）时输入123456，只把1234赋值给a</td></tr><tr><td>，(逗号）</td><td>无实际用处，仅用于美观。如scanf（“%d,%d,%d”,&amp;a,&amp;b,&amp;c）;</td></tr><tr><td>-（横杠）    ：（冒号）</td><td><p>方便日期等输入，但不赋值</p><p>scanf（“%d-%d-%d”,&amp;a,&amp;b,&amp;c）;需输入2018-11-20</p><p>scanf（“%d：%d：%d”：&amp;a,&amp;b,&amp;c）;需输入2018:11:20</p></td></tr><tr><td><p>所有字符串，符号（包括空格）</p><p>数字（不与输入数相挨）</p></td><td><p>任何所写的东西都必须如横杠一般先输入（不赋值），不然系统报错</p><p>scanf（“%d 456 %d”,&amp;a,&amp;b）;</p><p>需输入  1 456 7（1和7之间有 456 （前后各一个空格））</p><p>结果为a=1  b=7</p></td></tr></tbody></table><h2 id="printf独有">printf()独有</h2><table border="1" cellpadding="1" cellspacing="1" style="width: 600px"><tbody><tr><td><p>%m.nd     %-m.nd</p><p>（m和n为常数）</p></td><td><p>m用于在d位数小于m时补空格（<a            href="https://so.csdn.net/so/search?q=%E5%8F%B3%E5%AF%B9%E9%BD%90&amp;spm=1001.2101.3001.7020"            target="_blank"            class="hl hl-1"            data-report-click='{"spm":"1001.2101.3001.7020","dest":"https://so.csdn.net/so/search?q=%E5%8F%B3%E5%AF%B9%E9%BD%90&amp;spm=1001.2101.3001.7020","extra":"{\"searchword\":\"右对齐\"}"}'            data-tit="右对齐"            data-pretit="右对齐"            >右对齐</a          >）d位数大于m时忽略</p><p>如%5d，输出123，          <u            ><span style="color: #3399ea">  </span></u          >123（123前面两个空格）</p><p></p><p>.n用于在d位数小于n时补0（右对齐）d位数大于n时忽略</p><p>如%.5d，输出123，          00123（123前面两个0）</p><p></p><p>%-m.nd则为左对齐</p></td></tr><tr><td><p>%m.nf  %m.nlf  %m.nLf</p><p>%-m.nf %-m.nlf %-m.nLf</p></td><td><p>m用于在小数位数小于m时补空格（右对齐）</p><p>小数位数大于m时忽略      (小数点算一位）</p><p>如%6f  需输出3.14            结果为<u>  </u>3.14（3.14前面两个空格）</p><p></p><p>.n用于控制小数位数      小数部分长度大于n则四舍五入</p><p>小数部分长度小于于n则补0</p><p>如%.6f  需输出3.14           结果为3.140000</p><p>如%6f  需输出3.1415926  结果为3.141593</p><p></p><p>%-m.nf %-m.nlf %-m.nLf   则为左对齐</p></td></tr><tr><td>%m.ns     %-m.ns</td><td><p>m用于在字符串位数小于m时补空格（右对齐）字符串位数大于m时忽略</p><p>如%5s，输出abc，          <u            ><span style="color: #3399ea">  </span></u          >abc（abc前面两个空格）</p><p></p><p>.n用于控制字符串位数      长度大于n则仅输出前n位</p><p>字符串长度小于于n时忽略</p><p>如%.6s 需输出abcdefg      结果为abcdef</p><p>如%6f  需输出abc              结果为abc</p><p></p><p>%-m.ns则为左对齐</p></td></tr><tr><td>%mc        %-mc</td><td><p>m限制char的输出长度       当m&gt;1时，在左方补m-1个空格</p><p></p><p>%-mc则为左对齐</p></td></tr><tr><td><p>%m.ne     %-m.ne</p><p>%m.nE     %-m.nE</p></td><td><p>m用于控制指数长度，在QT中，指数部分占五位（如 e+001 ）</p><p>位数小于m时左方补空格   位数大于m时忽略</p><p>如printf("%15.5e",a);          设a为123.456789</p><p>结果为 <u>   </u>1.23457e+002（三个空格）</p><p></p><p>.n用于控制小数长度           小数部分长度大于n则四舍五入</p><p>小数部分长度小于于n则补0</p><p>如printf("%15.5e",a);          设a为123.456789</p><p>结果为 <u>   </u>1.23457e+002（三个空格）</p><p></p><p>%-m.ne   %-m.nE则为左对齐</p></td></tr><tr><td><p>%<em>（整型）如%</em>d</p><p>%-*（整型）</p></td><td><p>在输出项中规定整型数据的宽度，少于限制补空格，大于忽略</p><p>如printf（“%*d”,a,b）;</p><p>a=5  b=123</p><p>结果为 <u>  </u>123（前面有两个空格）</p><p></p><p>%-*（整型） 左对齐</p></td></tr><tr><td>%0*（整型）</td><td><p>在输出项中规定整型数据的宽度，少于限制补0，大于忽略</p><p>如printf（“%0*d”,a,b）;</p><p>a=5  b=123</p><p>结果为 00123</p></td></tr><tr><td>注意</td><td><p>printf（）中的运算是从右至左，而输出是从做左至右</p><p>如a=1，printf（“%d %d %d”,a++,a++,a++）;</p><p>结果为3 2 1</p></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/08/09/%5Bobject%20Object%5D/AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%8410%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%EF%BC%88Activation_Function%EF%BC%89%E6%80%BB%E7%BB%93/"/>
      <url>/2024/08/09/%5Bobject%20Object%5D/AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%8410%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%EF%BC%88Activation_Function%EF%BC%89%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="激活函数">激活函数</h1><h2 id="简介">简介</h2><p>激活函数（Activation Function），就是在<ahref="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/382460"title="人工神经网络">人工神经网络</a>的神经元上运行的<ahref="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912"title="函数">函数</a>，负责将神经元的输入映射到输出端，旨在帮助网络学习数据中的复杂模式。</p><p>下图展示了一个神经元是如何输入激活函数以及如何得到该神经元最终的输出：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/34d6b14bf4b79175276eac52abacdf94.png" /></p><h2 id="为什么要用激活函数">为什么要用激活函数</h2><ul><li><p>如果不用激活函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的<ahref="https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581"title="感知机">感知机</a>（Perceptron）</p></li><li><p>使用激活函数能够给神经元引入<strong>非线性因素</strong>，使得神经网络可以任意<strong>逼近</strong>任何<strong>非线性函数</strong>，使深层神经网络表达能力更加强大，这样神经网络就可以应用到众多的非线性模型中</p><ol type="1"><li><p>附加到网络中的每个神经元，并根据每个神经元的输入来确定是否应激活</p></li><li><p>有助于将每个神经元的输出标准化到1到0或-1到1的范围内</p></li></ol></li></ul><span id="more"></span><h2 id="激活函数的分类">激活函数的分类</h2><p>激活函数可以分为<strong>两大类：</strong></p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/e41598583c8b35dcbb907f9fd66d8351.png" /></p><ul><li><strong>饱和激活函数：</strong> sigmoid、 tanh...</li><li><strong>非饱和激活函数:</strong>  ReLU 、Leaky Relu 、ELU、PReLU、RReLU...</li></ul><p>首先，我们先了解一下<strong>什么是饱和</strong>？</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/9a7a78e50434edbcad6939b64efee0e1.png" /></p><p>反之，不满足以上条件的函数则称为非饱和激活函数。</p><p>        <strong>Sigmoid函数</strong>需要一个实值输入压缩至[<strong>0,1]</strong>的范围        <strong>tanh函数</strong>需要讲一个实值输入压缩至<strong>[-1, 1]</strong>的范围</p><p>相对于饱和激活函数，使用<strong>非饱和激活函数</strong>的<strong>优势</strong>在于两点：</p><p>   1.非饱和激活函数能解决深度神经网络（层数非常多）带来的<strong>梯度消失</strong>问题</p><p>    2.使用非饱和激活函数能<strong>加快收敛速度</strong>。</p><h2 id="常见的几种激活函数">常见的几种激活函数</h2><h3 id="sigmoid函数"><ahref="https://so.csdn.net/so/search?q=Sigmoid%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">Sigmoid函数</a></h3><p><strong>Sigmoid</strong>激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/6c9269a456ee0497c9bb0d1383e51cc8.png" /></p><p>导数表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/e646103baf196c690998f97ee5987716.png" /></p><p> 函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/af5f15ef44f1b276c78bec5e140e7082.png" /></p><p> Sigmoid函数在历史上曾非常常用，输出值范围为[0,1]之间的实数。但是现在它已经不太受欢迎，实际中很少使用。</p><p><strong>什么情况下适合使用Sigmoid？</strong></p><ul><li><p>Sigmoid 函数的输出范围是 0 到1。非常适合作为模型的输出函数用于输出一个0~1范围内的概率值，比如用于表示二分类的类别或者用于表示置信度。</p></li><li><p>梯度平滑，便于求导，也防止模型训练过程中出现突变的梯度</p></li></ul><p><strong>Sigmoid有哪些缺点？</strong></p><ul><li><p>容易造成梯度消失。我们从导函数图像中了解到sigmoid的导数都是小于0.25的，那么在进行反向传播的时候，梯度相乘结果会慢慢的趋向于0。这样几乎就没有梯度信号通过神经元传递到前面层的梯度更新中，因此这时前面层的权值几乎没有更新，这就叫梯度消失。除此之外，为了防止饱和，必须对于权重矩阵的初始化特别留意。如果初始化权重过大，可能很多神经元得到一个比较小的梯度，致使神经元不能很好的更新权重提前饱和，神经网络就几乎不学习。</p></li><li><p>函数输出不是以 0为中心的，梯度可能就会向特定方向移动，从而降低权重更新的效率</p></li><li><p>Sigmoid函数执行指数运算，计算机运行得较慢，比较消耗计算资源。</p></li></ul><h3 id="tanh函数">Tanh函数</h3><p><strong>tanh</strong>激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/70ad61d6f8c019d3dee98ad6ef45cb1a.png" /></p><p> 函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/e58d7204fef7f7410e92b4bf82e91938.png" /></p><p> 实际上，Tanh函数是 sigmoid 的变形：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/4d6487fb47aa7a4bd310d1181ef19884.png" /></p><p> 与sigmoid不同的是，tanh是“零为中心”的。因此在实际应用中，tanh会比sigmoid更好一些。但是在饱和神经元的情况下，tanh还是没有解决梯度消失问题。</p><p><strong>什么情况下适合使用Tanh</strong>？</p><ul><li><p>tanh 的输出间隔为 1，并且整个函数以 0 为中心，比 sigmoid函数更好；</p></li><li><p>在 tanh图中，负输入将被强映射为负，而零输入被映射为接近零。</p></li></ul><p><strong>Tanh有哪些缺点？</strong></p><ul><li><p>仍然存在梯度饱和的问题</p></li><li><p>依然进行的是指数运算</p></li></ul><h3 id="relu函数"><ahref="https://so.csdn.net/so/search?q=ReLU%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">ReLU函数</a></h3><p><strong>ReLU</strong>激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/ae65877d14768ad1b6789c6ccdcd6e31.png" /></p><p>函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/a2f4f9f3c522518908e20d7865beb48c.png" /></p><p><strong>什么情况下适合使用ReLU？</strong></p><ul><li><p>ReLU解决了梯度消失的问题，当输入值为正时，神经元不会饱和</p></li><li><p>由于ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p><strong>ReLU有哪些缺点？</strong></p><ul><li><p>与Sigmoid一样，其输出不是以0为中心的</p></li><li><p>Dead ReLU问题。当输入为负时，梯度为0。这个神经元及之后的神经元梯度永远为0，不再对任何数据有所响应，导致相应参数永远不会被更新</p></li></ul><p>训练神经网络的时候，一旦学习率没有设置好，第一次更新权重的时候，输入是负值，那么这个含有ReLU的神经节点就会死亡，再也不会被激活。所以，要设置一个合适的较小的学习率，来降低这种情况的发生</p><h3 id="leaky-relu函数">Leaky Relu函数</h3><p><strong>Leaky Relu</strong>激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/88b3993e5054a035be6962f0b3e2ab0b.png" /></p><p> 函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/f08a4f516132c6965a99f4e4ede084e5.png" /></p><p><strong>什么情况下适合使用Leaky ReLU？</strong></p><ul><li><p>解决了ReLU输入值为负时神经元出现的死亡的问题</p></li><li><p>Leaky ReLU线性、非饱和的性质，在SGD中能够快速收敛</p></li><li><p>计算复杂度低，不需要进行指数运算</p></li></ul><p><strong>Leaky ReLU有哪些缺点？</strong></p><ul><li><p>函数中的α，需要通过先验知识人工赋值（一般设为0.01）</p></li><li><p>有些近似线性，导致在复杂分类中效果不好。</p></li></ul><p><strong>注意：</strong>从理论上讲，Leaky ReLU 具有 ReLU的所有优点，而且 Dead ReLU 不会有任何问题，但在实际操作中，尚未完全证明Leaky ReLU 总是比 ReLU 更好</p><h3 id="prelu函数">PRelu函数</h3><p><strong>PRelu</strong>激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/e139c27fe15b02144158329284c4d81f.png" /></p><p> 函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/fd071b3c80f462bc94a1fff457211c06.png" /></p><p> PRelu激活函数也是用来解决ReLU带来的神经元坏死的问题。与LeakyReLU激活函数不同的是，PRelu激活函数负半轴的斜率参数<strong>α</strong>是通过学习得到的，而不是手动设置的恒定值</p><h3 id="elu函数">ELU函数</h3><p><strong>ELU</strong>激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/b70bac8ea93f96755952563c81c430d6.png" /></p><p> 函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/93bfa8c9fd8447aa8503a2c75f6308ce.png" /></p><p> 与LeakyReLU和PRelu激活函数不同的是，ELU激活函数的负半轴是一个指数函数而不是一条直线</p><p><strong>什么情况下适合使用ELU？</strong></p><ul><li><p>ELU试图将激活函数的输出均值接近于零，使正常梯度更接近于单位自然梯度，从而加快学习速度</p></li><li><p>ELU在较小的输入下会饱和至负值，从而减少前向传播的变异和信息</p></li></ul><p><strong>ELU有哪些缺点？</strong></p><ul><li>计算的时需要计算指数，计算效率低</li></ul><h3 id="selu函数">SELU函数</h3><p><strong>SELU</strong>激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/32a0b0737b9af34efab5dc2b9881cfff.png" /></p><p> 其中λ = 1.0507 , α = 1.6733 </p><p>函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/ac5337b33a267bc0e10e6f7125f3cecb.png" /></p><p> SELU 允许构建一个映射 g，其性质能够实现 SNN（自归一化神经网络）。SNN不能通过ReLU、sigmoid 、tanh 和 Leaky ReLU实现。这个激活函数需要有：（1）负值和正值，以便控制均值；（2）饱和区域（导数趋近于零），以便抑制更低层中较大的方差；（3）大于1的斜率，以便在更低层中的方差过小时增大方差；（4）连续曲线。后者能确保一个固定点，其中方差抑制可通过方差增大来获得均衡。通过乘上指数线性单元（ELU）来满足激活函数的这些性质，而且λ&gt;1 能够确保正值净输入的斜率大于 1</p><p>SELU激活函数是在自归一化网络中定义的，通过调整均值和方差来实现内部的归一化，这种内部归一化比外部归一化更快，这使得网络能够更快得收敛</p><h3 id="swish函数">Swish函数</h3><p>Swish激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/ebfc932dd7e11123ece4d00624a800ac.png" /></p><p> 函数图像如下：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/cd5fbc5ff57d321fae3a88975d3ad19d.png" /></p><p> Swish激活函数<strong>无界性</strong>有助于防止慢速训练期间，梯度逐渐接近0并导致饱和；同时，<strong>有界性</strong>也是有优势的，因为有界激活函数可以具有很强的正则化(防止过拟合，进而增强泛化能力)，并且较大的负输入问题也能解决</p><p>Swish激活函数在<code>x=0</code>附近更为平滑，而非单调的特性增强了输入数据和要学习的权重的表达能力。</p><h3 id="mish函数">Mish函数</h3><p>Mish激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/39c694b4d7bfbea87c7f5bae27eda51f.png" /></p><p> 函数图像如下:</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/b5520519b3392bc1618009ec673c396a.png" /></p><p>Mish激活函数的函数图像与Swish激活函数类似，但要更为平滑一些，缺点是计算复杂度要更高一些</p><h3 id="softmax函数">Softmax函数</h3><p>Softmax激活函数的数学表达式为：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/91781adb7d2a642f3fe2fd132f4dedb0.png" /></p><p> 函数图像如下:</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/05b86dc2a65dfa843851e7d8dbc1b7c9.png" /></p><p> Softmax函数常在神经网络输出层充当激活函数，将输出层的值通过激活函数映射到0-1区间，将神经元输出构造成概率分布，用于多分类问题中，Softmax激活函数映射值越大，则真实类别可能性越大</p><p>下图给出了Softmax作激活函数对输出值映射处理过程，进而形象理解Softmax函数</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/7a38f41623bcda0fa735cad89ee62a8b.png" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目经历</title>
      <link href="/2024/08/09/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
      <url>/2024/08/09/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>基于 <span class="math inline">\(sketch\)</span>的高效通信联邦学习客户端选择算法</p><ul><li><strong>内容：</strong>现有的FL系统中，参与每轮更新的客户端通常数量固定且由服务端随机选择，但这种<strong>随机选择客户端的方式会加剧数据异质性（Non-IID）的不利影响</strong>，降低模型的收敛速度和准确率，导致通信代价大幅增加。因此我们提出了一种新的客户端选择算法：在FetchSGD的基础上，算法根据客户端的数据分布、本地损失、与服务器模型参数的差异程度计算其重要程度，服务端基于客户端重要程度进行选择，在保证随机性的同时算法倾向于选择某些更加重要的客户端；此外我们还基于<spanclass="math inline">\(sketch\)</span>实现了在上行链路与下行链路降低通信开销，同时提出skipcommunication算法并运用周期平均思想减少通信的轮数，实现全面降低联邦学习的通信开销</li><li><strong>贡献</strong>：独立完成，论文在写</li></ul><p>对大模型分布式训练技术（如TP、SP、PP）等有一定研究，曾在北京大学数据科学与工程研究所有一段线上的实习经历；此外本人曾对基于sketch解决联邦学习通信效率有一定的研究，以下为个人想法：</p><ol type="1"><li><p>设计并实现了基于FetchSGD的客户端选择算法，通过综合考量数据分布、本地损失及模型参数差异，有效缓解了数据异质性问题，预期提升模型收敛速度15%，准确率提高3个百分点。</p></li><li><p>引入sketch技术优化通信链路，在上行与下行传输中显著降低通信数据量，预计减少通信成本约40%，增强联邦学习效率。</p></li><li><p>创新提出skipcommunication算法，结合周期平均策略，灵活调整通信轮次，成功减少不必要通信轮数20%，进一步降低总体通信开销。</p></li><li><p>独立承担从算法设计到实验验证的全过程，目前正处于关键验证阶段，致力于全面评估并优化新算法在联邦学习环境下的性能表现。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRC</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CRC/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CRC/</url>
      
        <content type="html"><![CDATA[<h1 id="crc">CRC</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191656975.jpg"alt="258a1611faa096e4f1367a79335fb90" /><figcaptionaria-hidden="true">258a1611faa096e4f1367a79335fb90</figcaption></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191656977.jpg" alt="3b36f8ff943c741c889d81022a745df" style="zoom:67%;" /></p><blockquote><ol type="1"><li>生成多项式==&gt;除数</li><li>除数为n位<ul><li>余数为n-1位<strong><font color='red'>(不够的在前面补0)</font></strong></li><li>被除数后面加上<strong><font color='red'>n-1位‘0’</font></strong></li></ul></li></ol></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191656978.jpg"alt="05c133fba1b7e11497708c5df82366d" /><figcaptionaria-hidden="true">05c133fba1b7e11497708c5df82366d</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP例题</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E4%BE%8B%E9%A2%98/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="http">HTTP</h1><h2 id="http协议">HTTP协议</h2><ul><li><span class="math inline">\(HTTP/1.1\)</span>默认使用<strong><font color='red'>持续</font></strong>、<strong><font color='blue'>非流水线</font></strong>方式</li></ul><h2 id="持续http连接">持续HTTP连接</h2><p>Client向 Server 请求共包含 4 个对象（1 个 HTML 基文件和 3 个 JPEG图片)的页面</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406111656225.jpg"alt="8713353fc94f5ca8948d4f31e81012a" /><figcaptionaria-hidden="true">8713353fc94f5ca8948d4f31e81012a</figcaption></figure><h2 id="非持续连接">非持续连接</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406111659324.png"alt="image-20240611165958239" /><figcaption aria-hidden="true">image-20240611165958239</figcaption></figure><blockquote><p>==<strong>先请求HTML基文件，接收方收到HTML文件之后，才能再请求HTML的内嵌对象</strong>==</p></blockquote><h2 id="例题">例题</h2><h3 id="例1">例1</h3><ol type="1"><li>假设在客户端浏览器中通过点击某个超链接获得另一个Web页面。如果客户端只知道Web页面所在服务器的名字，但不知道该服务器的IP地址。因此，客户端必须使用DNS查询服务器的IP地址。假设，客户端使用DNS获得Web服务器的IP地址共耗时t<sub>dns</sub>。进一步假定，该Web页面共有10个非常小的对象。令RTT<sub>0</sub>表示客户端和Web服务器间数据传输的RTT值，<strong>HTML文档及内嵌对象的<font color='red'>传输时间(发送时间)均忽略不计</font></strong>。在下列情况下，从点击该超链接开始，到接收到完整的页面分别需要多少时间？(注意，比须解释所得结果的理由)</li></ol><p>(1)<font color='blue'><strong>无并行</strong></font>连接的<strong><font color='blue'>非持续</font></strong>HTTP</p><blockquote><p><strong>答:(1)DNS解析所需的tdns；使用串行非持续连接，获得一个对象需要2RTT0。因此，共需20RTT0+tdns</strong>。</p></blockquote><p>(2)<strong><font color='blue'>有流水线</font></strong>的持续HTTP</p><blockquote><p><strong>答:(2) 有流水线的持续HTTP，DNS解析需要tdns。建立TCP连接耗时RTT0；然后，获得页面的html文档耗时RTT0；获得页面其他对象耗时RTT0。综上，共耗时：3RTT0+tdns。</strong></p></blockquote><h3 id="例2">例2</h3><p>​浏览器与WWW服务器之间的网络路径被抽象为一条传输速率为100Mbps的链路。假设浏览器要从服务器下载100Kbits(1K=1000)长的页面，并包含10个嵌入的图像（文件名分别img01.jpg,img02.jpg……img10.jpg），每个图像文件大小都是100Kbits，页面和10个图像存储在同一服务器中。从浏览器到服务器的往返时间（RTT）为300毫秒。由于GET方法的request消息比较小，<strong><font color='red'>忽略客户端发送GETrequest消息需要的时间</font></strong>，但需要考虑在链路上<strong><font color='red'>传输HTML基文件和嵌入对象所需的时间</font></strong>，以及建立TCP连接所需要的时间（假设TCP连接建立时间为1RTT）。</p><ol type="1"><li>使用<strong><font color='blue'>非持续HTTP</font></strong>（假设在浏览器和服务器之间<strong><font color='blue'>没有并行连接</font></strong>），响应时间多长？即从用户请求URL到页面和嵌入的图像都到达浏览器需要多长时间？注意要描述导致延迟的不同部分。</li></ol><blockquote><p><strong>一个RTT时间请求，一个RTT响应并返回请求的文件+文件传数据时间。由于是没有并行链接的非持续HTTP链接，每个对象都需要逐个请求所以是：(2RTT+0.001)*11=6.611s</strong>*</p></blockquote><ol start="2" type="1"><li>仍然使用<strong>非持续连接</strong>，假设浏览器想打开多少到服务器的并行连接都可以。这种情况下，响应时间是多少？</li></ol><blockquote><p><strong><font color='blue'>先请求HTML基文件，2RTT+文件传输时间。</font>现在知道了对象的个数，创建一个TCP链接2RTT，但是由于文件储存在同一服务器中，所以服务器需要逐个发送文件，因此时间是10个文件传输时间，所以总时间是：(2RTT+0.001)+(2RTT+10*0.001)=1s</strong></p></blockquote><ol start="3" type="1"><li>假设使用<strong><font color='blue'>持续</font></strong>HTTP连接，但<strong>没有使用流水线机制</strong>。这种情况下响应时间是多少？</li></ol><blockquote><p><strong>使用无流水的持续HTTP链接，服务器的连续发送基文档和内嵌文件对象，建立连接1个RTT，每个对象是1RTT+文件传输时间所以总时间是：1RTT+11*(1RTT+对象传输时间)=0.3+11(0.3+0.001)=3.611s。</strong></p></blockquote><ol start="4" type="1"><li>假设使用<strong><font color='blue'>流水线的持续</font></strong>HTTP，响应时间是多少？</li></ol><blockquote><p><strong>使用流水线的持续HTTP，首先建立链接1个RTT，然后获取HTML基文档1RTT+文件传输时间，内嵌对象的请求背靠背的从客户端发送1RTT，服务器则一次发送文件对象10个文件传输时间，所以总时间是：3RTT+11*0.001=0.911s</strong></p></blockquote><h3 id="例3">例3</h3><p>​假设在浏览器键入地址(URL)后从某个WWW服务器获取一个Web页面，<strong><font color='blue'>该服务器的IP地址已缓存在本地</font></strong>。用RTT表示从客户机到Web服务器的往返时间（RTT）。假设该Web页面由一个基本的HTML文件和五个小图像组成，<strong><font color='red'>每个对象的发送时间与RTT相比很小，可以忽略不计。</font></strong>在下列情况下，从用户输入地址后按下回车键到接收到完整的Web页面需要多长时间？</p><ol type="1"><li><p>没有并行连接的非持续HTTP——<strong>12RTT</strong></p></li><li><p><strong><font color='blue'>最多有五个并行连接的非持续</font></strong>HTTP——<strong>4RTT</strong></p></li><li><p>使用流水线的持续HTTP——<strong>3RTT</strong></p></li></ol><h3 id="例4">例4</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191658229.png"alt="image-20230129172238917" /><figcaption aria-hidden="true">image-20230129172238917</figcaption></figure><h3 id="例5">例5</h3><p>17.【2022 统考真题】假设主机 H 通过 HTTP/1.1 请求浏览某 Web 服务器S上的 Web页news408.html，news408.html引用了同目录下的1幅图像，news408.html文件大小为1MSS(最大段长)，图像文件大小为3MSS，H访问S的往返时间 RTT=10 ms，忽略HTTP响应报文的首部开销和 TCP段传输时延。若H已完成域名解析,则从H请求与S建立TCP连接时刻起，到接收到全部内容止，所需的时间至少是（）</p><p>A.30ms B. 40ms C.50ms D.60ms</p><ul><li><p><span class="math inline">\(HTTP/1.1\)</span>默认使用<strong><font color='red'>持续</font></strong>、<strong><font color='blue'>非流水线</font></strong>方式</p></li><li><p>要求最少时间，理想的情况是TCP在第3次握手的报文段中捎带了 HTTP请求，以及传输过程中的慢开始阶段不考虑拥塞</p></li><li><p>假设接收方有足够大的缓存空间，即发送窗口等同于拥塞窗口，共需要经过：</p><ul><li>第1个RTT，进行TCP连接建立的前两次握手</li><li>第2个RTT，主机C发送第3次握手报文并捎带了对html文件的HTTP请求，<strong>TCP连接刚建立时服务器S的发送窗口=1MSS</strong>，服务器S发送大小为1MSS的 html文件</li><li>第3个RTT，主机C发送对 html 文件的确认并捎带了对图形文件的HTTP请求，<strong>服务器S收到确认后发送窗口变为2MSS</strong>，然后服务器S发送大小为2MSS的图像文件</li><li>第4个RTT，主机C向服务器S发送对收到的部分图像文件的确认，<strong>服务器S收到确认后发送窗口变为4MSS</strong>，然后服务器S发送剩下的1MSS 图像文件，完成传输，</li></ul><p>共需要4个RTT，即 40ms。整个传输过程如下图所示：</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407071335383.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换机自学习功能</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="交换机自学习功能">交换机自学习功能</h1><h2 id="步骤">步骤</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701401.png"alt="image-20221126151441804" /><figcaption aria-hidden="true">image-20221126151441804</figcaption></figure><h2 id="举例">举例</h2><h3 id="例一一台交换机">例一：一台交换机</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701402.png"alt="image-20221126152111230" /><figcaption aria-hidden="true">image-20221126152111230</figcaption></figure><blockquote><p>总结：MAC帧每<strong><font color='gree'>进入交换机</font></strong></p><ul><li><p>首先，==对<strong><font color='red'>源MAC地址和进入接口</font></strong>进行更新==（没有添加，有则更新时间）</p></li><li><p>然后，查找交换表中是否有<strong><font color='red'>目的MAC地址</font></strong>，</p><ul><li>若无，则对==<strong><font color='red'>除进入接口以外的接口</font></strong>广播==</li><li>若有，则通过 指定接口 转发出去</li></ul></li></ul></blockquote><h3 id="例二两台交换机">例二：两台交换机</h3><h4 id="section">(1)</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701403.png"alt="image-20221126152145618" /><figcaption aria-hidden="true">image-20221126152145618</figcaption></figure><ul><li>注意区别</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701404.png"alt="image-20230129143609233" /><figcaption aria-hidden="true">image-20230129143609233</figcaption></figure><ol start="2" type="1"><li></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701405.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="例三三台交换机">例三：三台交换机</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701406.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h4 id="交换机1">交换机1</h4><table><thead><tr class="header"><th>MAC地址</th><th>接口</th></tr></thead><tbody><tr class="odd"><td>B</td><td>2</td></tr><tr class="even"><td>D</td><td>4</td></tr><tr class="odd"><td>E</td><td>4</td></tr><tr class="even"><td>C</td><td>3</td></tr></tbody></table><h4 id="交换机2">交换机2</h4><table><thead><tr class="header"><th>MAC地址</th><th>接口</th></tr></thead><tbody><tr class="odd"><td>B</td><td>2</td></tr><tr class="even"><td>D</td><td>1</td></tr><tr class="odd"><td>G</td><td>4</td></tr><tr class="even"><td>E</td><td>3</td></tr></tbody></table><h4 id="交换机3">交换机3</h4><table><thead><tr class="header"><th>MAC地址</th><th>接口</th></tr></thead><tbody><tr class="odd"><td>B</td><td>2</td></tr><tr class="even"><td>D</td><td>2</td></tr><tr class="odd"><td>G</td><td>4</td></tr><tr class="even"><td>E</td><td>2</td></tr><tr class="odd"><td>F</td><td>1</td></tr></tbody></table><h3 id="例四">例四</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701407.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>答案：A</p><ul><li><strong><font color='red'>PDU</font></strong>的意思是<strong><font color='red'>协议数据单元</font></strong>，它是计算机网络体系结构中对等实体间逻辑通信的对象。</li><li>以太网交换机工作在数据链路层（也包括物理层），他接受并转发的PDU通常称为帧。</li><li>以太网交换机收到帧后，在帧交换表中查找<strong>帧的目的MAC地址</strong>所对应的接口号，然后通过该接口转发帧。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701408.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="例五">例五</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701409.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong><font color='red'>B</font></strong></p><h3 id="例六">例六</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701410.jpg"alt="bdb2e0db0d76b99f974063fbd19a1d6" /><figcaptionaria-hidden="true">bdb2e0db0d76b99f974063fbd19a1d6</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDU格式</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/PDU%E6%A0%BC%E5%BC%8F&amp;&amp;%E5%B0%81%E8%A3%85%E5%85%B3%E7%B3%BB/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/PDU%E6%A0%BC%E5%BC%8F&amp;&amp;%E5%B0%81%E8%A3%85%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="pdu格式">PDU格式</h1><h2 id="mac帧格式">MAC帧格式</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220011.png"alt="image-20221130213320189" /><figcaption aria-hidden="true">image-20221130213320189</figcaption></figure><blockquote><p>注意：</p><ul><li><p>==<strong><font color='red'>以太网MAC帧的最短长度为64Byte；数据字段的最短长度为46Byte</font></strong>==；<strong><font color='blue'>最大长度MTU为1500Byte</font></strong></p><blockquote><p>以太网帧数据部分的最大长度<strong>为MTU</strong></p></blockquote></li><li><p>==<strong><font color='gree'>当网络层交付的IP数据报 &lt;46Byte时，会自动加入填充字节至 46 Byte，使以太网最短帧长为64Byte</font></strong>==</p></li><li><p><strong>MAC帧首部长度为14 Byte，尾部长度（FCS）为4Byte</strong></p><p><strong><font color='purple'>首部长度 + 尾部长度一共18个字节</font></strong></p></li><li><p>帧检验序列FCS：是对MAC帧<strong><font color='red'>首部和数据部分</font></strong>进行检测</p></li></ul></blockquote><h2 id="ip数据报格式">IP数据报格式</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220013.png"alt="image-20221130213758445" /><figcaption aria-hidden="true">image-20221130213758445</figcaption></figure><blockquote><ul><li><strong><font color='purple'>首部长度</font></strong>：占4位，<strong><font color='red'>单位：4B</font></strong>；首部长度范围：【20，60】；首部长度一定是4 的整数倍</li><li><strong><font color='purple'>总长度（length）</font></strong>：IP数据报的总长度。单位：B</li><li><strong><font color='purple'>标识（ID）：</font></strong>每产生一个IP数据报，标识+1；IP数据报分片，<strong><font color='blue'>标识字段</font></strong>不变</li><li><strong><font color='purple'>标志（flag）</font></strong>：MF、DF（<strong><font color='cyan'>DF=0允许分组</font></strong>）</li><li><strong><font color='purple'>生存时间（TTL）</font></strong>：即<strong><font color='red'>跳数限制</font></strong>，单位：跳数；<ul><li><strong><font color='red'>路由器每次转发分组之前，先将TTL减1</font></strong><ul><li><strong><font color='red'>若TTL=0，则丢弃分组，不再转发</font></strong></li></ul></li><li>TTL含义：IP数据报在Internet中转发所能经过的最大路由器数目</li><li>TTL作用：防止IP数据报在Internet中<strong>无限制地兜圈子</strong></li></ul></li><li><strong><font color='purple'>片偏移（offset）</font></strong><strong><font color='blue'>= 前面数据部分的长度 / 8B</font></strong><ul><li><strong><font color='red'>单位：8B</font></strong>；</li><li>IP数据报分片时，<strong><font color='orange'>除最后一个IP分片外，其余所分片数据部分的长度一定是8的整数倍</font></strong></li></ul></li></ul></blockquote><h2 id="udp格式">UDP格式</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220014.png"alt="image-20221130224323035" /><figcaption aria-hidden="true">image-20221130224323035</figcaption></figure><blockquote><p><strong><font color='purple'>总长度（length）</font></strong>：UDP数据报的<strong><font color='blue'>总长度</font></strong></p></blockquote><h2 id="tcp格式">TCP格式</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220015.png"alt="image-20221130214236946" /><figcaption aria-hidden="true">image-20221130214236946</figcaption></figure><blockquote><ul><li>序号（seq）：对<strong><font color='red'>TCP数据字段（即应用层报文）</font></strong>的<strong><font color='blue'>每个字节</font></strong>都按顺序编号，序号范围【0，2<sup>32</sup>–1】， <strong>单位：B</strong>；<strong><font color='purple'>序号（seq）体现了TCP是面向字节流的</font></strong><ul><li><font color='green'><strong>TCP 报文段序号</strong></font>指<strong>TCP数据字段<font color='blue'>第一个字节的序号</font></strong><ul><li>假定某一TCP报文段的序号为x，<strong>数据字段长度为u</strong>，则下一个报文段的序号为x+u</li></ul></li></ul></li><li>数据偏移：即<strong><font color='blue'>TCP首部长度</font></strong>；<strong><font color='red'>单位4B</font></strong></li><li>窗口：<strong><font color='orange'>发送TCP报文段</font></strong>一方的<strong><font color='orange'>接收窗口大小</font></strong><ul><li>MSS：<strong><font color='red'>TCP报文段数据字段</font></strong>的最大长度，<strong><font color='blue'>单位：B</font></strong><ul><li>特别的：SMSS指<strong><font color='cyan'>发送方的MSS</font></strong></li></ul></li><li><strong><code>rwnd、cwnd</code></strong>均指<strong><font color='red'>TCP数据字段</font></strong>的长度</li></ul></li></ul></blockquote><h2 id="总结">总结</h2><blockquote><ul><li><strong>（总）长度 length单位均为<font color='red'>B</font></strong></li><li><strong>首部长度：单位均为 <font color='red'>4B</font></strong></li><li><strong><font color='purple'>片偏移（offset）</font></strong> 单位<strong><font color='red'>8B</font></strong></li></ul></blockquote><h1 id="封装关系">封装关系</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406012120459.png"alt="image-20240601211957274" /><figcaption aria-hidden="true">image-20240601211957274</figcaption></figure><blockquote><ul><li><p>MSS：<strong><font color='red'>TCP报文段数据部分</font></strong>的最大长度（也是<strong><font color='red'>应用层报文</font></strong>的<strong>最大长度</strong>），<strong><font color='blue'>单位：B</font></strong></p><ul><li>特别的：SMSS指<strong><font color='cyan'>发送方的MSS</font></strong></li></ul></li><li><p>MTU：<strong><font color='red'>MAC帧数据部分/IP数据报</font></strong>的<strong>最大长度</strong>，以太网MTU=1500B，<strong><font color='blue'>单位：B</font></strong></p><p><strong><code>IP数据报长度（byte） % 8==0</code></strong></p></li></ul></blockquote><h1 id="类型1分片">类型1：分片</h1><h2 id="例一">例一</h2><p>一个数据报的总长度为3820字节，其数据部分为3800字节长（使用固定首部），需要分片为长度不超过1420字节的数据报片。首部固定20字节，因此每个数据部分长度不能超过1400字节。于是分为3个数据报片。其数据部分长度分别为1400，1400，1000字节。原始数据报首部被复制为各个数据报片的首部，但必须修改有关字段。</p><hr /><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220017.png"alt="image-20221130223322614" /><figcaption aria-hidden="true">image-20221130223322614</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220018.png"alt="image-20221130223332333" /><figcaption aria-hidden="true">image-20221130223332333</figcaption></figure><h2 id="例二">例二</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220019.png"alt="image-20230129135009477" /><figcaption aria-hidden="true">image-20230129135009477</figcaption></figure><h2 id="例三">例三</h2><p>如图网络，请回答下列问题：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220020.jpg"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>(1)主机在配置IP地址时，其正确的子网掩码和默认网关分别是多少？</p><p>(2)若路由器R在向互联网转发一个由主机192.168.1.5发送、ID=12345、<strong><font color='redfaa'>length=500B</font></strong>、DF=1的IP分组时，则该IP分组首部的哪些字段会被修改？如何修改？</p><p>(3)若主机192.168.1.10向互联网ID=6789、length=1500B、DF=0的IP分组时，路由器需要将该IP分组分为几片（每片尽可能封装为最大片）？给出分片结果，包括每片的ID、DF、MF、length、offset的取值。</p><hr /><hr /><p>（1）子网掩码：255.255.255.240，默认网关：192.168.1.1。（2分）（2）<strong><font color='red'>∵ length &lt; MTU                ∴该IP分组不会分片</font></strong></p><ul><li>该IP分组首部的源IP地址、TTL和首部校验和字段会被修改（3分）<ul><li>源IP地址192.168.1.5会被修改为130.11.22.3；</li><li>TTL减1；</li><li>首部校验和重新计算并更新（3分）</li></ul></li></ul><blockquote><p>改编：<strong><font color='blue'>若IP分组的length &gt; 512B时</font></strong>（需要分片），需要修改的字段：</p><ul><li>源IP地址192.168.1.5会被修改为130.11.22.3</li><li>TTL减1</li><li>总长度length字段</li><li>标志字段（MF，DF）</li><li>片偏移字段</li><li>首部校验和 重新计算并更新</li></ul></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220021.jpg"alt="81cfc4345800e21d46b44ee14f7c427" /><figcaptionaria-hidden="true">81cfc4345800e21d46b44ee14f7c427</figcaption></figure><table><thead><tr class="header"><th></th><th>ID</th><th>MF</th><th>DF</th><th>length</th><th>offset</th></tr></thead><tbody><tr class="odd"><td>分片1</td><td>6789</td><td>1</td><td>0</td><td>488+20=508</td><td>0</td></tr><tr class="even"><td>分片2</td><td>6789</td><td>1</td><td>0</td><td>488+20=508</td><td>488/8=61</td></tr><tr class="odd"><td>分片3</td><td>6789</td><td>1</td><td>0</td><td>488+20=508</td><td>61*2=122</td></tr><tr class="even"><td>分片4</td><td>6789</td><td>0</td><td>0</td><td>16+20=36</td><td>61*3=183</td></tr></tbody></table><blockquote><ul><li><p><strong><code>MF==0</code></strong>有两种情况</p><ul><li><ol type="1"><li>独立IP数据报</li></ol></li><li><ol start="2" type="1"><li>最后一个IP数据报<strong>片</strong></li></ol></li></ul></li><li><p><strong><code>offset==0</code></strong>有两种情况</p><ul><li><ol type="1"><li>独立IP数据报</li></ol></li><li><ol start="2" type="1"><li>第一个IP数据报<strong>片</strong></li></ol></li></ul></li><li><p><strong><code>MF==0 &amp;&amp; offset==0</code></strong>说明此为独立IP数据报片（没有分片）</p></li><li><p><strong><code>MF==0 &amp;&amp; offset！= 0</code></strong>说明此为最后一个IP数据报<strong>片</strong></p></li><li><p><strong><code>MF==1 &amp;&amp; offset== 0</code></strong>说明此为第一个IP数据报<strong>片</strong></p></li><li><p><strong><code>MF==1 &amp;&amp; offset！= 0</code></strong>说明此为<strong>除去第一个和最后一个</strong>IP数据报<strong>片</strong></p></li></ul></blockquote><h2 id="例四">例四</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220022.jpg"alt="47ba4593c8ad93b859927db3045d148" /><figcaptionaria-hidden="true">47ba4593c8ad93b859927db3045d148</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220023.jpg"alt="1c81395af20e2014d54fae2867394a2" /><figcaptionaria-hidden="true">1c81395af20e2014d54fae2867394a2</figcaption></figure><table><thead><tr class="header"><th></th><th>数据字段长度</th><th>offset</th></tr></thead><tbody><tr class="odd"><td>分片1</td><td>1480</td><td>0</td></tr><tr class="even"><td>分片2</td><td>1480</td><td>1480/8=185</td></tr><tr class="odd"><td>分片3</td><td>1480</td><td>185*2=370</td></tr><tr class="even"><td>分片4</td><td>1480</td><td>185*3=555</td></tr><tr class="odd"><td>分片5</td><td>1480</td><td>185*4=740</td></tr><tr class="even"><td>分片6</td><td>800</td><td>185*5=925</td></tr></tbody></table><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220024.jpg"alt="95e1c257391d8712f6f37b98311b0b0" /><figcaptionaria-hidden="true">95e1c257391d8712f6f37b98311b0b0</figcaption></figure><h1id="类型2传输效率有效数据率">类型2：传输效率&amp;&amp;有效数据率</h1><h2 id="定义">定义</h2><p>​ 数据的传输效率 是指发送的==<strong><font color='red'>应用层数据</font></strong>==和<strong><font color='blue'>所发送的总数据</font></strong>（即应用层数据加上各种首部和尾部的额外开销）之间的比值</p><h2 id="计算公式">计算公式</h2><blockquote><p><strong>本层的<font color='purple'>传输效率 = 应用层数据 /本层数据</font></strong></p><p><strong>本层的<font color='blue'>有效</font><font color='red'>数据率= 数据部分 / 总时间</font></strong></p></blockquote><h2 id="例题">例题</h2><h3 id="例一-1">例一</h3><p>某客户<strong>使用UDP将数据</strong>发送给一个服务器，<strong><font color='red'>数据共16字节</font></strong>。</p><p>（1）试计算在运输层的传输效率(有用字节与总字节之比)。</p><p>（2）试计算在网络层的传输效率。假定IP首部无选项。</p><p>（3）试计算在数据链路层的传输效率。假定IP首部无选项，在数据链路层使用以太网。</p><blockquote><p>由题干知：应用层数据为 16 Byte</p></blockquote><p>（1）UDP用户数据报的总长度=8+16=24字节因此,在运输层的传输效率=16/24=0.667。</p><p>（2）IP数据报的总长度=20+24=44字节。因此,在IP层的传输效率=16/44=0.364</p><p>（3）<strong><font color='blue'>以太数据字段的最小长度是46字节，而我们的IP数据报仅有44字节，因此还必须加上2字节的填充</font></strong></p><ul><li>这样，以太网的总长度=14+4+2+44=64字节因此,在数据链路层的传输效率=16/64=0.25</li><li>如果再考虑到发送以太网的帧之前还有8字节的前同步码。把这8字节计入后，在数据链路层的传输效率=16/72=0.222</li></ul><h3 id="例二image-20221203143626470">例二<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220025.png"alt="image-20221203143626470" /></h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202312122220026.jpg"alt="微信图片_20221203144729" /><figcaption aria-hidden="true">微信图片_20221203144729</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层提供的2种服务</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%842%E7%A7%8D%E6%9C%8D%E5%8A%A1/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%842%E7%A7%8D%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p># 网络层提供的2种服务</p><h2 id="虚电路服务">虚电路服务</h2><ul><li><p><strong>传统电信网提供的主要业务是提供电话服务。电信网使用昂贵的程控交换机，用面向连接的通信方式，使电信网络能够向用户(实际上就是电话机)提供可靠传输的服务</strong></p></li><li><p><strong>两个计算机进行通信的步骤：</strong></p><p>（1）应当先建立连接(但在分组交换中是建立一条虚电路VC(VirtualCircuit)，以保证通信双方所需的一切网络资源。</p><p>（2）然后双方就沿着已建立的虚电路发送分组。</p><p>（3）这样的分组的首部就不需要填写完整的目的主机地址，而只需填写这条虚电路的编号(一个不大的整数)，因而减少了分组的开销。</p><p>（4）如果这种通信方式再使用可靠传输的网络协议，就可使所发送的分组无差错按序地到达终点，当然也不丢失、不重复。</p><p>（5）在通信结束后，要释放建立的虚电路</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191749015.png"alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><h2 id="数据报服务">数据报服务</h2><ul><li><p><strong>因特网在设计上就采用了和电信网完全不同的思路。</strong></p></li><li><p>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉(与电信网的交换机相比较)。</p></li><li><p><strong>因特网的设计思路：</strong></p><p>（1）网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络在发送分组时不需要先建立连接。每个分组(也就是IP数据报)独立发送，与其前后的分组无关(不进行编号)</p><p>（2）网络层不提供服务质量的承诺。也就是说所传送的分组，可能出错、丢失、重复或失序，当然也不保证分组交付的时限</p></li><li><p>这种设计思路的好处：</p><p>（1）网络的造价大大降低 （2）运行方式灵活（3）能够适应多种应用</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191753937.png"alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><h2 id="虚电路服务-vs-数据报服务">虚电路服务 vs 数据报服务</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191749010.png"alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><hr /><p><strong>参考文献：</strong><br />[1]《计算机网络(第5版)》谢希仁——第四章 4.1</p><p>本文转自 <ahref="https://blog.csdn.net/cainv89/article/details/50654483"class="uri">https://blog.csdn.net/cainv89/article/details/50654483</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络主观题</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%BB%E8%A7%82%E9%A2%98/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%BB%E8%A7%82%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络主观题">计算机网络主观题</h1><h2id="简述以太网中csmacd协议的工作过程">简述以太网中CSMA/CD协议的工作过程</h2><blockquote><p>CSMA/CD协议：仅适用半双工信道：全双工信道不存在信道争用问题，不使用CSMA/CD</p></blockquote><ol type="1"><li>准备发送：适配器从网络层得到一个数据报，加上首部和尾部，组成以太网帧，并放入适配器的缓存中</li><li>检测信道：如果适配器检测到信道忙，则不断检测信道，直到信道转为空闲为止。<strong><font color='red'>此时若在<span class="math inline">\(96\)</span>比特时间内信道保持空闲，就发送这个帧</font></strong></li><li>适配器在发送过程中，不停地检测信道。<ul><li>如果在<strong>争用期</strong> <spanclass="math inline">\(512\)</span>比特时间内未检测到碰撞，则发送成功，返回步骤1</li><li>如果在争用期内检测到碰撞，则立即停止发送，并发送 <spanclass="math inline">\(48bit\)</span>的人为干扰信号，然后适配器执行二进制指数退避算法，等待 <spanclass="math inline">\(r\)</span> 倍的 <spanclass="math inline">\(512\)</span> 比特时间后，返回步骤 2</li></ul></li></ol><blockquote><p>最短帧长=争用期=512bit，最小帧间隔=96bit</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701248.png"alt="image-20221127101923632" /><figcaption aria-hidden="true">image-20221127101923632</figcaption></figure><h2 id="解释截断二进制指数退避算法">解释截断二进制指数退避算法</h2><ol type="1"><li>从{0,1,2….,2<sup>k</sup>-1}随机选取一个数，记为r。<strong><font color='blue'>其中k=min[重传/冲突次数，10]</font></strong></li><li>重传应推迟/退避的时间为 <span class="math inline">\(r\)</span>倍的<font color='red'><strong><span class="math inline">\(512\)</span>比特时间</strong></font></li><li><strong>当重传 <span class="math inline">\(16\)</span>次仍不能成功时，则丢弃该帧并向上报错</strong></li></ol><h2id="分组交换网络中的时延都有哪些这些时延产生的原因是什么">分组交换网络中的时延都有哪些？这些时延产生的原因是什么？</h2><table><colgroup><col style="width: 50%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>时延</th><th>产生原因</th><th>影响因素</th></tr></thead><tbody><tr class="odd"><td>发送时延</td><td>主机或路由器发送数据帧所需要的时间</td><td>数据帧的长度，发送速率</td></tr><tr class="even"><td>传播时延</td><td>信号在信道中传播一定距离所需要的时间</td><td>信道长度，信号在信道上的传播速率</td></tr><tr class="odd"><td>处理时延</td><td>主机/路由器 对收到的分组进行处理所需的时间<br />(eg：检查分组首部，差错检测，查找转发表等)</td><td>主机/路由器的处理性能</td></tr><tr class="even"><td>排队时延</td><td>分组再路由器缓存输入队列中排队等待处理、<br />输出队列中排队等待转发所需要的时间</td><td>网络通信量</td></tr></tbody></table><blockquote><p><font color='orange'><strong>端到端时延 = 发送时延 + 传播时延 +处理时延 + 排队时延 = <spanclass="math inline">\(\frac{1}{2}RTT\)</span></strong></font></p></blockquote><h2id="对于ip网络说明子网掩码的作用">对于IP网络，说明子网掩码的作用</h2><blockquote><p>子网掩码与二进制IP地址进行<strong><font color='red'>按位AND</font></strong>运算，可以得出网络地址</p></blockquote><p>子网掩码的作用是：</p><ol type="1"><li>确定IP地址中的网络号和主机号，</li><li>将一个大的网络划分为若干小的网络</li></ol><h1 id="cdma码分多址">CDMA码分多址</h1><h2 id="工作原理">工作原理</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701249.png"alt="image-20221125163049940" /><figcaption aria-hidden="true">image-20221125163049940</figcaption></figure><ul><li><p>CDMA中，每个比特时间划分为m个码片</p></li><li><p>CDMA为每个站（假设S站）指派一个<strong>唯一的</strong>mbit码片序列。</p><ul><li>发送比特 1：发送自己的m bit码片序列；</li><li>发送比特0，发送该码片序列的二进制反码。</li></ul></li><li><p>各个站分配的码片序列必须<strong>各不相同、相互正交</strong></p></li><li><p>任意码片向量与该码片向量自己的规格化内积为1，与该码片反码向量的规格化内积为-1</p></li><li><p>当接收站要接收S站发送的信号时，就用S站的码片序列与收到的信号作<strong><font color='red'>规格化内积</font></strong></p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701250.png"alt="举例" /><figcaption aria-hidden="true">举例</figcaption></figure><h2 id="例题">例题</h2><h3id="码分多址cdma为什么可以使所有用户在同样的时间使用同样的频带进行通信而不会相互干扰这种复用方式有何优缺点">码分多址CDMA为什么可以使所有用户在同样的时间使用同样的频带进行通信而不会相互干扰？这种复用方式有何优缺点</h3><ul><li>因为各用户使用<strong><font color='red'>经过特殊挑选的不同码片（各不相同，相互正交）</font></strong>，因此用户在同样的时间使用同样的频带进行通信而不会相互干扰</li><li>优点：抗干扰能力强，频谱类似于白噪声</li></ul><h3 id="习题2"><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701251.png"alt="习题2" /></h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701252.jpg"alt="微信图片_20221127092424" /><figcaption aria-hidden="true">微信图片_20221127092424</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701253.png"alt="考研真题" /><figcaption aria-hidden="true">考研真题</figcaption></figure><h4 id="解">解</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701254.png"alt="题目解析" /><figcaption aria-hidden="true">题目解析</figcaption></figure><h2 id="糊涂窗口综合症">糊涂窗口综合症</h2><h3 id="概念">概念</h3><p>当发送端应用进程产生数据很慢，或接收端应用进程处理<strong>接收缓存</strong>数据很慢时，就会使应用进程间传送的报文段很小，特别是<strong>有效载荷</strong>很小，使有效数据传输率很低的现象</p><hr /><p>eg：极端情况下，有效载荷可能只有1个字节；传输开销有40字节(20字节的IP头+20字节的TCP头)</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701255.png"alt="image-20221125174831069" /><figcaption aria-hidden="true">image-20221125174831069</figcaption></figure><h3 id="条件原因">条件/原因</h3><p>当发送端应用进程产生数据很慢（发送方糊涂窗口综合症）、或接收端应用进程处理<strong>接收缓存</strong>数据很慢（接受方糊涂窗口综合症）</p><h1 id="arp-ip寻址过程">ARP &amp; IP寻址过程</h1><h2 id="知识储备">知识储备</h2><h3 id="路由表转发表">路由表转发表</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701256.png"alt="image-20230129204032996" /><figcaption aria-hidden="true">image-20230129204032996</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701257.png"alt="image-20221012204854948" /><figcaption aria-hidden="true">image-20221012204854948</figcaption></figure><h3 id="host主机">Host主机</h3><p>连接到互联网上的计算机的协议软件需要配置的项目包括：（P304）</p><ul><li>IP地址</li><li>子网掩码</li><li><strong><font color='red'>默认路由器的IP地址</font></strong>（默认网关）</li><li>域名服务器的IP地址</li></ul><h2 id="例一">例一</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701258.png"alt="image-20221124192109928" /><figcaption aria-hidden="true">image-20221124192109928</figcaption></figure><ol type="1"><li><p>主机H1首先构造一个源IP地址为202.99.98.18、目的IP地址为202.99.98.35的 IP数据报，并将H2的IP地址与H1的子网掩码255.255.255.240进行AND运算，运算结果不等于H1的网络地址，说明H1与H2不在同一子网，无法直接交付。</p></li><li><p>主机H1通过ARP得到路由器R1（202.99.98.17）的MAC 地址，</p><ul><li>H1首先在其ARP高速缓存中查看有无路由器R1的IP地址；若有，则直接在ARP高速缓存中查出相应的MAC地址</li><li>否则，H1在Net1中广播发送ARP请求分组（目的MAC地址为FF-FF-FF-FF-FF-FF），Net1内所有主机均收到此ARP请求分组。路由器R1（202.99.98.17）收到该ARP请求分组后，向H1发送含有其MAC地址的ARP响应分组。H1收到此ARP响应分组后，更新其ARP高速缓存。</li></ul><p>将路由器R1的MAC地址作为目的MAC地址，H1的MAC地址作为源MAC地址，并将IP数据报<strong>封装成</strong>MAC帧，发送到Net1中</p></li><li><p>路由器R1收到该MAC帧后，去除MAC帧的首部和尾部，得到IP数据报，然后根据IP数据报中的目的IP地址（202.99.98.35）去逐行查找路由表，得到下一跳为直接相连</p></li><li><p>路由器R1通过ARP得到主机H2（202.99.98.35）的MAC地址，并将其作为目的MAC地址，将R1的MAC地址作为源MAC地址，将IP数据报<strong>封装成</strong>新的MAC帧，然后将该帧发送到子网Net2上。</p></li><li><p>主机H2收到该MAC帧后，去除MAC帧的首部和尾部，最终得到从主机H1发来的IP数据报，并交付到网络层。</p></li></ol><h2 id="例二">例二</h2><p>假定H1要发送分组到H3去，H1只知道自己的IP地址，MAC地址，以及H3的IP地址，问H1发送分组到H3的过程？</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701259.png"alt="image-20221005210557516" /><figcaption aria-hidden="true">image-20221005210557516</figcaption></figure><ul><li><p>主机H1将H3的IP地址128.30.36.12与H1的子网掩码255.255.255.128进行AND运算，运算结果不等于与H1的网络地址，说明H1与H2不在同一子网，无法直接交付。</p></li><li><p>主机H1通过ARP得到路由器R1（128.30.33.1）的MAC地址</p><ul><li>H1首先在其ARP高速缓存中查看有无路由器R1的IP地址；若有，则直接在ARP高速缓存中查出相应的MAC地址</li><li>否则，H1在子网1中广播发送ARP请求分组（目的MAC地址为FF-FF-FF-FF-FF-FF），子网1内所有主机均收到此ARP请求分组。路由器R1（128.30.33.1）收到该ARP请求分组后，向H1发送含有其MAC地址的ARP响应分组。H1收到此ARP响应分组后，更新其ARP高速缓存。</li></ul><p>将路由器R1的MAC地址作为目的MAC地址，H1的MAC地址作为源MAC地址，并将IP数据报<strong>封装成</strong>MAC帧，发送到子网1中</p></li><li><p>路由器R1收到该MAC帧后，去除MAC帧的首部和尾部，得到IP数据报，然后根据IP数据报中的目的IP地址（128.30.33.1）去逐行查找路由表，得到下一跳为R2</p></li><li><p>路由器R1通过ARP得到路由器R2（128.30.33.129）的MAC地址，并将其作为目的MAC地址，路由器R1的MAC地址作为源MAC地址，将IP数据报封装成新的MAC帧，发送到子网2中</p></li><li><p>路由器R2收到分组后，重复步骤3，得到下一跳为接口1（直接相连）</p></li><li><p>路由器R2通过ARP得到主机H3的MAC地址，并将其作为目的MAC地址，R2的MAC地址作为源MAC地址，将IP数据报<strong>封装成</strong>新的MAC帧，并通过路由器R2的接口1转发到子网3上</p></li><li><p>主机H3收到该MAC帧后，去除MAC帧的首部和尾部，最终得到从主机H1发来的IP数据报，并交付给网络层</p></li></ul><h2 id="例三">例三</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701260.jpg"alt="02ddf612fe76910629538b5361aadcb" /><figcaptionaria-hidden="true">02ddf612fe76910629538b5361aadcb</figcaption></figure><ul><li><p>A首先构造一个源IP地址为111.111.111.111、目的IP地址为222.222.222.222的 IP数据报，并将B的IP地址与A的子网掩码进行AND运算，运算结果不等于A的网络地址，说明A与B不在同一个子网，无法直接交付</p></li><li><p>A通过ARP得到路由器R（111.111.111.110）的MAC地址：</p><ul><li>A首先在其ARP高速缓存中查看有无路由器R的IP地址；若有，则直接在ARP高速缓存中查出相应的MAC地址</li><li>否则，A在LAN1中广播发送ARP请求分组（目的MAC地址为FF-FF-FF-FF-FF-FF），LAN1内所有主机均收到此ARP请求分组。路由器R（111.111.111.110）收到该ARP请求分组后，向A发送含有其MAC地址的ARP响应分组。A收到此ARP响应分组后，更新其ARP高速缓存。</li></ul><p>A将路由器R的MAC地址（E8-E9-00-17-BB-4B）作为目的MAC地址，A的MAC地址（74-2B-D2-E8-FF-55）作为源MAC地址，并将IP数据报封装成MAC帧，发送到LAN1中</p></li><li><p>路由器R收到该MAC帧后，去除MAC帧的首部和尾部，得到IP数据报，然后根据IP数据报中的目的IP地址（222.222.222.222）去逐行查找路由表，得到下一跳为直接相连，应从接口222.222.222.220转发</p></li><li><p>路由器R通过ARP得到B（222.222.222.222）的MAC地址88-B2-2F-54-1A-0F（过程同上），并将其作为目的MAC地址，将路由器R的MAC地址作为源MAC地址，将IP数据包封装成新的MAC帧，然后将该帧发送到子网LAN2中</p></li><li><p>B收到该MAC帧后，去除MAC帧的首部和尾部，最终得到从A发来的IP数据报，并交付到网络层。</p></li></ul><h1 id="dhcp-nat-dns-vpn">★DHCP &amp; NAT &amp; DNS &amp; VPN</h1><h2 id="例一-1">例一</h2><p>请根据下图详细描述通过笔记本（原来没有IP、网关、DNS信息、ARP表）如何动态加入到校园网并且通过浏览器访问 mail.163.com电子邮件网站的全过程（请按处理先后顺序涉及的协议栈，从 DHCP 分配IP、外网访问、域名解析、层次路由、HTTP等多角度详细描述通信过程及涉及的通信原理）。(15分)</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701261.jpeg"alt="计网压轴题图像" /><figcaption aria-hidden="true">计网压轴题图像</figcaption></figure><h3 id="ip层">IP层</h3><ul><li>ARP地址解析：ARP根据目的IP地址查找目的MAC地址，将IP数据报封装成MAC帧，并发送到数据链路层</li></ul><blockquote><p>源MAC地址直接转化为设备的MAC地址</p></blockquote><ul><li>出现以下 3 种情况，直接返回MAC地址<ul><li>如果ARP高速缓存中存在目的IP地址对应的MAC地址</li><li>源主机发送广播分组</li><li>源主机和目的主机使用点对点链路</li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406011454504.jpg"alt="3c6b2b03a1cc9a37244094daa76fbec" /><figcaptionaria-hidden="true">3c6b2b03a1cc9a37244094daa76fbec</figcaption></figure><h3 id="动态加入到校园网">动态加入到校园网</h3><ul><li>DHCP动态分配IP</li><li>主机向DHCP服务器以广播方式发送DHCPDISCOVER报文，动态获取<strong>本机</strong>IP地址，<strong>DNS服务器</strong>IP地址，<strong>默认网关</strong>IP地址等，从而加入校园网</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406011459453.png"alt="image-20240601145908378" /><figcaption aria-hidden="true">image-20240601145908378</figcaption></figure><ol type="1"><li><p>DHCP服务器被动打开 UDP 端口 67，等待客户端发来的报文</p></li><li><p>DHCP 客户从 UDP 端口 68 发送 DHCP发现报文 <strong>DHCPDISCOVER</strong></p></li><li><p>凡收到 DHCP 发现报文的 DHCP 服务器都发出DHCP 提供报文<strong>DHCP OFFER</strong>，因此 DHCP 客户可能收到多个 DHCP提供报文</p></li><li><p>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP服务器发送 DHCP 请求报文 <strong>DHCP REQUEST</strong></p></li><li><p>被选择的 DHCP 服务器发送确认报文 <strong>DHCPACK</strong>。从这时起，DHCP客户就可开始使用得到的临时IP地址了，进入<strong>已绑定状态</strong>，因为在DHCP 客户端的 IP 地址和 MAC 地址已经完成绑定，并且可以开始使用得到的临时IP 地址了</p><p>DHCP 客户现在要根据服务器提供的租用期T设置两个计时器 <spanclass="math inline">\(T_1\)</span> 和 <spanclass="math inline">\(T_2\)</span>，它们的超时时间分别是 <spanclass="math inline">\(0.5T\)</span> 和 <spanclass="math inline">\(0.875T\)</span>。当超时时间到时，就要请求更新租用期</p></li><li><p>租用期过了一半（<spanclass="math inline">\(T_1\)</span>时间到），DHCP发送请求报文<strong>DHCP REQUEST</strong>，要求更新租用期</p></li><li><p>DHCP 服务器若同意，则发回确认报文 <strong>DHCP ACK</strong>，DHCP客户得到了新的租用期，重新设置计时器</p></li><li><p>DHCP 服务器若不同意，则发回否认报 <strong>DHCP NACK</strong>.这时DHCP 客户必须<strong>立即</strong>停止使用原来的IP 地址，而必须重新申请IP 地址（回到步骤 2）</p></li></ol><blockquote><p>若 DHCP 服务器不响应步骤 6 的请求报文 <strong>DHCPRREQUEST</strong>，则在租用期过了 87.5% 时（ <spanclass="math inline">\(T_2\)</span> 时间到）， DHCP客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。</p></blockquote><ol start="9" type="1"><li>DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP服务器发送释放报文 <strong>DHCP RELEASE</strong> 即可</li></ol><h3 id="通过浏览器访问-mail.163.com-电子邮件网站">通过浏览器访问mail.163.com 电子邮件网站</h3><ul><li>DNS域名解析：主机向DNS服务器发送域名解析请求，将域名mail.163.com解析为相应的IP地址，作为IP数据报的目的IP地址</li></ul><blockquote><p>详细过程：<ahref="https://j1dwlsm5xld.feishu.cn/wiki/OhlWwuMsUi9aHokE1mzcUv8inqh?fromScene=spaceOverview">DNS- 飞书云文档 (feishu.cn)</a></p></blockquote><ul><li>层次选路：AS内部使用域内路由选择协议（RIP/OSPF），AS之间使用域间路由选择协议BGP</li><li>VPN外网访问：主机通过域内路由，将IP数据报发送到NAT路由器，NAT路由器通过内部的NAT转换表，将IP数据报中的本地IP地址转化为全球IP地址，改写到数据报首部中作为新的源IP地址，并通过域间路由发送到互联网</li><li>TCP连接与HTTP请求：主机与mailserver完成TCP三次握手建立TCP连接，并在第三次握手时发送HTTP请求报文，mailserver发送HTTP响应报文，主句从中提取出HTML，最终显示出Web网页</li></ul><p><ahref="https://blog.csdn.net/qq_43444349/article/details/110954118">计算机网络：详解动态加入校园网并访问网页的全过程_校园网怎么实现web访问-CSDN博客</a></p><h2 id="例二-1">例二</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701262.jpg"alt="59f2ca9a88ca4a3cf2bb08312be20a1" /><figcaptionaria-hidden="true">59f2ca9a88ca4a3cf2bb08312be20a1</figcaption></figure><ul><li>DHCP动态分配IP：主机A向DHCP服务器以广播方式发送DHCPDISCOVER报文，动态获取VPN分配的IP地址，DNS服务器IP地址，默认网关IP地址等，从而加入校园网</li><li>NAT网络地址转换：主机A将IP数据报发送到NAT路由器，NAT路由器通过内部的NAT转换表，将IP数据报中的本地IP地址转化为全球IP地址，改写到数据报首部中作为新的源IP地址，发送到互联网，实现上网问题</li><li>主机B、C、D上网只需通过DHCP动态获取IP地址即可</li></ul><h1 id="tcp">TCP</h1><h2 id="简述tcp拥塞控制算法">简述TCP拥塞控制算法</h2><blockquote><p>cwnd拥塞窗口，<span class="math inline">\(ssthresh\)</span>阈值</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406011313792.png"alt="image-20240601131256686" /><figcaption aria-hidden="true">image-20240601131256686</figcaption></figure><p>（1）慢开始【此阶段 <span class="math inline">\(cwnd \lessthresh\)</span> 】</p><ul><li><p>初始时，cwnd=1 MSS</p></li><li><p>发送方每收到一个ACK，就将cwnd加1</p></li><li><p>每经过一个RTT，cwnd就加倍（<spanclass="math inline">\(cwnd*=2\)</span>）</p></li></ul><blockquote><p>作用：试探网络的拥塞程度，视情况逐渐增加cwnd</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406011315134.png" alt="image-20240601131550056" style="zoom:33%;" /></p><p>（2）拥塞避免，即<strong>加法增大AI算法</strong>【此阶段 <spanclass="math inline">\(cwnd \ge ssthresh\)</span>】</p><ul><li>每经过一个RTT，cwnd就加1（<spanclass="math inline">\(cwnd+=1\)</span>​）</li></ul><blockquote><p>作用：使cwnd按照线性规律缓慢增大，避免网络拥塞</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406011315912.png" alt="image-20240601131435683" style="zoom:33%;" /></p><p>（3）快重传算法：接收方每收到一个报文段，就立即发送确认</p><blockquote><p>作用：使发送方尽早知道个别报文段的丢失，立即重传丢失的报文段</p></blockquote><p>（4）快恢复算法：发送方收到 3个重复ACK，立即重传丢失的报文段，并将<spanclass="math inline">\(ssthresh=cwnd/2,\cwnd=ssthresh\)</span>​，进入拥塞避免阶段</p><blockquote><p>作用：避免网络拥塞</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406011313563.png" alt="image-20240601131346494" style="zoom:33%;" /></p><p>（5）超时处理：若超时计时器到期，仍未收到对某个报文段的确认，即出现超时，表明网络发生拥塞，则将<spanclass="math inline">\(ssthresh=cwnd/2,\cwnd=1\)</span>，进入慢开始阶段</p><blockquote><p>作用：避免网络拥塞</p></blockquote><h2 id="tcp三次握手四次挥手">TCP三次握手四次挥手</h2><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406021539782.png" /></p><h2 id="例题-1">例题</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701263.jpg"alt="92971b94e0613f24c53564d1350ac05" /><figcaptionaria-hidden="true">92971b94e0613f24c53564d1350ac05</figcaption></figure><p><strong>解答</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191701264.png"alt="af3264cccc7e4ca574a7d9238e4f3ff" /><figcaptionaria-hidden="true">af3264cccc7e4ca574a7d9238e4f3ff</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端到端 &amp;&amp; 点到点</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AB%AF%E5%88%B0%E7%AB%AF%20&amp;&amp;%20%E7%82%B9%E5%88%B0%E7%82%B9/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AB%AF%E5%88%B0%E7%AB%AF%20&amp;&amp;%20%E7%82%B9%E5%88%B0%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="端到端-点到点">端到端 &amp;&amp; 点到点</h1><ul><li>数据传输的可靠性是通过<strong>数据链路层和网络层的点对点</strong>和<strong>传输层的端对端</strong>保证的。</li><li>端到端与点到点是针对网络中传输的<strong>两端设备间的关系</strong>而言的。</li><li>在一个网络系统的不同分层中，可能用到端到端传输，也可能用到点到点传输。<ul><li>如Internet网，IP及以下各层采用点到点传输</li><li>4层以上采用端到端传输。</li></ul></li></ul><h2 id="端到端通信">端到端通信</h2><p>端到端通信是针对<strong><font color='red'>传输层</font></strong>来说的，它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据，知道数据发送完毕，接收端确认接收成功。也就是说在数据传输之前，先为数据的传输开辟一条通道，然后在进行传输。从发送端发出数据到接收端接收完毕，结束。</p><h3 id="端到端优点">端到端优点：</h3><p>链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。</p><h3 id="端到端缺点">端到端缺点：</h3><ul><li><p>直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。</p></li><li><p>如果接收设备关机或故障，那么端到端传输不可能实现。</p></li></ul><h2 id="点到点通信">点到点通信</h2><p>点到点通信是针对数据链路层或网络层来说的，点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。</p><h3 id="点到点优点">点到点优点：</h3><ul><li><p>发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。</p></li><li><p>即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。</p></li></ul><h3 id="点到点缺点">点到点缺点：</h3><ul><li>发送端发出数据后，不知道接收端能否收到或何时能收到数据。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由选择协议</title>
      <link href="/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/05/19/%5Bobject%20Object%5D/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="路由选择协议">路由选择协议</h1><blockquote><ol type="1"><li>RIP协议的<strong>距离</strong>称为==<strong><font color='blue'>跳数</font></strong>==<ul><li><p><strong><font color='purple'>路由器某一网络的跳数为所经过路由器的个数</font></strong></p><blockquote><p><strong><font color='purple'>路由器 到直接相连的网络，跳数为1</font></strong> 即<strong><font color='red'>跳数=1 表示直接交付</font></strong></p></blockquote></li></ul></li><li>跳数16表示<strong><font color='red'>不可达</font></strong></li></ol></blockquote><h2 id="例题">例题</h2><h3 id="例一">例一</h3><p>如图所示网络拓扑，所有路由器均采用距离向量路由算法计算到达两个子网的路由（注：到达子网的路由度量采用<strong><font color='red'>跳步数</font></strong>）。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191702599.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>假设路由表结构如下表所示。</p><table><thead><tr class="header"><th style="text-align: center;">目的网络</th><th style="text-align: center;">接口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>请回答下列问题：</p><p>（1）若<strong><font color='red'>所有路由器均已收敛</font></strong>，请给出R1的路由表，要求包括到达图中所有子网的路由，且<strong><font color='blue'>路由表中的路由项尽可能少。</font></strong></p><p>（2）在所有路由器均已收敛的状态下，R3突然检测到子网192.168.1.128/26<strong><font color='blue'>不可到达</font></strong>，若接下来R2和R3==<strong><font color='cyan'>同时</font></strong>==向R1交换距离向量，则R1更新后的路由表是什么？更新后的R1距离向量是什么？</p><blockquote><p>分析：</p><ol type="1"><li>R3突然检测到子网192.168.1.128/26<strong><font color='blue'>不可到达</font></strong>（P163）</li></ol><ul><li>说明R3到子网192.168.1.128/26的链路出现了故障，R3无法到达子网192.168.1.128/26</li><li>R3把到子网192.168.1.128/26的距离改为16</li></ul><ol start="2" type="1"><li>R2和R3==<strong><font color='cyan'>同时</font></strong>==向R1交换距离向量，R1由R3知，192.168.1.128/26<strong><font color='blue'>不可到达</font></strong>；由R2知，到192.168.1.128/26需要3跳，故更新距离为3</li></ol></blockquote><h4 id="答案">答案</h4><p>（1）R1路由表：</p><table><thead><tr class="header"><th style="text-align: center;">目的网络</th><th style="text-align: center;">接口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">192.168.1.192/26</td><td style="text-align: center;">E0</td></tr><tr class="even"><td style="text-align: center;">192.168.2.0/23</td><td style="text-align: center;">S0</td></tr><tr class="odd"><td style="text-align: center;">192.168.1.0/24</td><td style="text-align: center;">S1</td></tr></tbody></table><p>（2）</p><p>R1路由表：</p><table><thead><tr class="header"><th style="text-align: center;">目的网络</th><th style="text-align: center;">接口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">192.168.1.192/26</td><td style="text-align: center;">E0</td></tr><tr class="even"><td style="text-align: center;">192.168.1.0/25</td><td style="text-align: center;">S1</td></tr><tr class="odd"><td style="text-align: center;">192.168.2.0/23</td><td style="text-align: center;">S0</td></tr><tr class="even"><td style="text-align: center;">192.168.1.128/26</td><td style="text-align: center;">S0</td></tr></tbody></table><hr /><p>R1路由向量表：</p><table><thead><tr class="header"><th style="text-align: center;">目的网络</th><th style="text-align: center;">距离向量</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">192.168.1.192/26</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">192.168.1.0/25</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">192.168.2.0/23</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;">192.168.1.128/26</td><td style="text-align: center;">3</td></tr></tbody></table><h3 id="例二">例二</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191702600.png"alt="image-20221127155129164" /><figcaption aria-hidden="true">image-20221127155129164</figcaption></figure><p>#### 答案</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191702601.jpg"alt="172dd008dc019401ce3a3f8e217bb5d" /><figcaptionaria-hidden="true">172dd008dc019401ce3a3f8e217bb5d</figcaption></figure><blockquote><p><strong><font color='red'>不同的下一跳，跳数相同，不更新路由表</font></strong>：这可以避免临时出现的拓扑变动造成的网络震荡</p></blockquote><h3 id="例三">例三</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191702602.png"alt="image-20221128210528811" /><figcaption aria-hidden="true">image-20221128210528811</figcaption></figure><h3 id="例四">例四</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405191702603.png"alt="image-20230125141750284" /><figcaption aria-hidden="true">image-20230125141750284</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scaling_Law</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/LLM/Scaling_Law/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/LLM/Scaling_Law/</url>
      
        <content type="html"><![CDATA[<p># Scaling_Law</p><p>在大模型的研发中，通常会有下面一些需求：</p><ol type="1"><li>计划训练一个10B的模型，想知道至少需要多大的数据？</li><li>收集到了1T的数据，想知道能训练一个多大的模型？</li><li>老板准备1个月后开发布会，给的资源是100张A100，应该用多少数据训多大的模型效果最好？</li><li>老板对现在10B的模型不满意，想知道扩大到100B模型的效果能提升到多少？</li></ol><p>以上这些问题都可以基于Scaling Law的理论进行回答。本文是阅读了一系列Scaling Law的文章后的整理和思考，包括ScalingLaw的概念和推导以及反Scaling Law的场景，不当之处，欢迎指正。</p><h2 id="引言">引言</h2><p>过去几年中，语言模型的发展迅速扩大。如下图所示，语言模型从2018年的BERT-base的1.09亿参数规模，增长到2022年的PaLM的5400亿参数。每个模型不仅在大小上增加（即参数数量），还在训练令牌的数量和训练计算量（以浮点运算或FLOPs计）上都有所增加。</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/fb5ba639e11a907eba934bc92ba9e86d.jpeg" /></p><p>“这三个因素之间有什么关系？”模型大小和训练数据对模型性能（即测试损失）的贡献是否相等？哪一个更重要？如果我想将测试损失降低10%，我应该增加模型大小还是训练数据？需要增加多少？</p><p>这些问题的答案在于大型语言模型（LLMs）的规模化法则行为中。但在深入答案之前，让我们先回顾一下幂律分布。</p><h2 id="幂律分布">幂律分布</h2><p>幂律是两个变量 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 之间的非线性关系，可以通用地建模为：<span class="math display">\[y=ax^k\]</span> 其中 <span class="math inline">\(k\)</span> 和 <spanclass="math inline">\(a\)</span> 是常数。</p><p>如果我在对数-对数图中绘制幂律关系，它将是一条直线，因为 <spanclass="math display">\[\log y=\log a+k\log x\]</span> 让我们为两个不同的 <span class="math inline">\(k\)</span>值绘制幂律图，以观察其不同的行为。如果 <spanclass="math inline">\(k\)</span> 是正的，<spanclass="math inline">\(y\)</span> 和 <spanclass="math inline">\(x\)</span> 之间有增加的关系。然而，如果 <spanclass="math inline">\(k\)</span> 是负的，它们之间则有减少的关系。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021511848.png"alt="image-20241002151152717" /><figcaption aria-hidden="true">image-20241002151152717</figcaption></figure><p>上面的图在 <span class="math inline">\(x\)</span> 轴和 <spanclass="math inline">\(y\)</span>轴上都是线性刻度。如果我们用对数标度表示它们，它们将是一条直线，如公式 2所示。现在，让我们把这些联系在一起，展示幂律是如何与LLM的测试损失联系起来的。</p><h2 id="语言模型中的scaling-law">语言模型中的Scaling Law</h2><p>语言模型中的规模化法则行为（ScalingLaw）指的是模型性能与模型大小、数据集大小和计算资源等多种因素之间观察到的关系。随着模型的扩展，这些关系遵循可预测的模式。规模化法则行为的关键因素如下：</p><ul><li>模型大小：随着模型中参数数量的增加，性能通常会按照幂律改善。</li><li>数据集大小：更大的训练数据集通常带来更好的性能，也遵循幂律关系。</li><li>计算：用于训练的计算资源（浮点运算次数）与性能改善相关。</li></ul><p>下图展示了大型语言模型中的规模化法则。</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/9394c9f8251a827fea7e3bb8249f75d3.jpeg" /></p><p>所有三个图都在对数-对数空间中是线性的，这证明了测试损失与计算、数据集大小和模型参数之间遵循幂律关系。此外这些图表还显示，随着模型大小、数据集大小和用于训练的计算量的增加，语言建模性能得到了提升。</p><p>我们已经看到了这三个因素与测试损失之间的单独关系。但是现在有几个问题：这三个因素本身之间的关系是什么？这些因素如何对测试损失产生贡献？它们的贡献是否相等？还是说其中一个比其他的更重要？</p><h2 id="核心结论">核心结论</h2><p>大模型的Scaling Law是OpenAI在2020年提出的概念[1]，具体如下:</p><ol type="1"><li>对于Decoder-only的模型，计算量<spanclass="math inline">\(C\)</span>(Flops)、模型参数量<spanclass="math inline">\(N\)</span>和数据大小<spanclass="math inline">\(D\)</span>(token数)三者满足：<spanclass="math inline">\(C ≈ 6ND\)</span> 。(推导见本文最后)</li><li>模型的最终性能<strong>主要与</strong>计算量<spanclass="math inline">\(C\)</span>，模型参数量<spanclass="math inline">\(N\)</span>和数据大小<spanclass="math inline">\(D\)</span>三者相关，而与模型的具体结构(层数/深度/宽度)基本无关。</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514304.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>固定模型的总参数量，调整层数/深度/宽度，不同模型的性能差距很小，大部分在2%以内</p></blockquote><ol start="3" type="1"><li>对于计算量<span class="math inline">\(C\)</span>、模型参数量<spanclass="math inline">\(N\)</span>和数据大小<spanclass="math inline">\(D\)</span>，当不受其他两个因素制约时，<strong>模型性能</strong>与每个因素都呈现<strong>幂律关系</strong></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514292.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="4" type="1"><li><p>为了提升模型性能，模型参数量<spanclass="math inline">\(N\)</span>和数据大小<spanclass="math inline">\(D\)</span>需要<strong>同步放大</strong>，但模型参数量<spanclass="math inline">\(N\)</span>和数据大小<spanclass="math inline">\(D\)</span>分别放大的比例还存在争议。</p></li><li><p>ScalingLaw不仅适用于语言模型，还适用于其他模态以及跨模态的任务[4]：</p></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514262.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>这里横轴单位为PF-days: 如果每秒钟可进行<spanclass="math inline">\(10^{15}\)</span>次运算，就是1 petaflops，那么一天的运算就是<span class="math inline">\(10^{15} × 24 × 3600= 8.64 × 10^{19}\)</span>，这个算力消耗被称为1个petaflop/s-day。</p></blockquote><h2 id="核心公式">核心公式</h2><p><span class="math display">\[L(x) = L_{\infty} + (\frac{x_{0}}{x})^{\alpha} \\\]</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514192.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>第一项<spanclass="math inline">\(L_{\infty}\)</span>是指无法通过增加模型规模来减少的损失，可以认为是数据自身的熵（例如数据中的噪音）</li><li>第二项<span class="math inline">\((x_{0} /x)^{\alpha}\)</span>是指能通过增加<strong>计算量</strong>来减少的损失，可以认为是模型拟合的分布与实际分布之间的差。</li></ul><p>根据公式，增大<span class="math inline">\(x\)</span>(例如计算量<spanclass="math inline">\(C\)</span>)，模型整体loss下降，模型性能提升；伴随<spanclass="math inline">\(x\)</span>趋向于无穷大，模型能拟合数据的真实分布，让第二项逼近0，整体趋向于<spanclass="math inline">\(L_{\infty}\)</span></p><h2 id="大模型中的scaling-law">大模型中的Scaling Law</h2><h3 id="gpt4">GPT4</h3><p>下图是GPT4报告[5]中的Scaling Law曲线，计算量<spanclass="math inline">\(C\)</span>和模型性能满足幂律关系</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514182.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li>横轴是归一化之后的计算量，假设GPT4的计算量为1。基于10,000倍小的计算规模，就能预测最终GPT4的性能。</li><li>纵轴是"Bits for words",这也是交叉熵的一个单位。在计算交叉熵时，如果使用以 2为底的对数，交叉熵的单位就是 "bits perword"，与信息论中的比特（bit）概念相符。所以这个值越低，说明模型的性能越好。</li></ul><h3 id="baichuan2">Baichuan2</h3><p>下图是Baichuan2[6]技术报告中的ScalingLaw曲线。基于10M到3B的模型在1T数据上训练的性能，可预测出最后7B模型和13B模型在2.6T数据上的性能</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514279.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="mindllm">MindLLM</h3><p>下图是MindLLM[7]技术报告中的ScalingLaw曲线。基于10M到500M的模型在10B数据上训练的性能，预测出最后3B模型在500B数据上的性能。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514863.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="scaling-law实操-计算效率最优">Scaling Law实操: 计算效率最优</h2><p>根据幂律定律，模型的参数固定，无限堆数据并不能无限提升模型的性能，模型最终性能会慢慢趋向一个固定的值</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514821.webp"alt="img" /> 如图所示，如果模型的参数量为<spanclass="math inline">\(10^3\)</span>（图中紫色的线），在数量达到<spanclass="math inline">\(10^9\)</span>，模型基本收敛。所以在数据量达到<spanclass="math inline">\(10^9\)</span>后，继续增加数据产生的计算量，没有同样计算量下提升模型参数量带来的收益大（<strong>计算效率更优</strong>)。根据<spanclass="math inline">\(C=6ND\)</span>，可以进一步转换成模型参数与计算量的关系，即:模型参数为<span class="math inline">\(10^3\)</span>，在计算量为 <spanclass="math inline">\(6 \times 10^{12}\)</span> Flops，即<spanclass="math inline">\(7 \times 10^{-8}\)</span>PF-days时基本收敛。也就是右图中紫色线的拐点。</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514937.webp"alt="img" /> 根据Baichuan[6]的实验，在中英场景下，7B模型收敛时的算力是<span class="math inline">\(10^{23}\)</span> FLOPS，对应的数据量应该是<span class="math display">\[D = \frac{10^{23}}{6*7*10^{9}} = 2.3T\]</span> 按照上面的思路，下面进行Scaling Law的实操。</p><p>首先准备充足的数据（例如1T），设计不同模型参数量的小模型(例如0.001B -1B)，独立训练每个模型，每个模型都训练到基本收敛（假设数据量充足）。根据训练中不同模型的参数和数据量的组合，收集计算量与模型性能的关系。然后可以进一步获得<strong>计算效率最优</strong>时，即同样计算量下性能最好的模型规模和数据大小的组合，模型大小与计算量的关系，以及数据大小与计算量的关系。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514945.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如图所示，根据左图可以看到计算量与模型性能呈现幂律关系（可以认为数据和模型都不受限制)，根据中图和右图，可以发现<spanclass="math inline">\(N_{opt} \propto C^{a}, D_{opt} \proptoC^{b}\)</span>，即计算效率最优时，模型的参数与计算量的幂次成线性关系，数据量的大小也与计算量的幂次成线性关系。</p><p>根据<span class="math inline">\(C=6ND\)</span>，可以推算出<spanclass="math inline">\(a+b=1\)</span>，但是<spanclass="math inline">\(a,b\)</span>分别是多少存在分歧。</p><p>OpenAI[1]认为模型规模更重要，即<span class="math inline">\(a=0.73,b=0.27\)</span>，而DeepMind在Chinchilla工作[2]和Google在PaLM工作[3]中都验证了<span class="math inline">\(a=b=0.5\)</span>，即模型和数据同等重要。</p><p>所以假定计算量整体放大10倍，OpenAI认为模型参数更重要，模型应放大<spanclass="math inline">\(10^{0.73}\)</span> (5.32)倍，数据放大 <spanclass="math inline">\(10^{0.27}\)</span>(1.86)倍；后来DeepMind和Google认为模型参数量与数据同等重要，两者都应该分别放大<span class="math inline">\(10^{0.5}\)</span> (3.16)倍。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514081.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>例如在PaLM的实验中，计算量从<span class="math inline">\(1 \times10^{21}\)</span>放大10倍到<span class="math inline">\(1 \times10^{22}\)</span>， 模型参数也提升了3.2倍，3.35B-&gt;10.7B。</p><p>具体最好在自己的数据上做实验来获得你场景下的<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>。</p><h2 id="llama-反scaling-law的大模型">LLaMA: 反Scaling Law的大模型</h2><p>假设遵循<strong>计算效率最优</strong>来研发LLM，那么根据ScalingLaw，给定模型大小，可以推算出最优的计算量，进一步根据最优计算量就能推算出需要的token数量，然后训练就行。</p><p>但是<strong>计算效率最优</strong>这个观点是针对<strong>训练阶段</strong>而言的，并不是<strong>推理阶段，</strong>实际应用中推理阶段效率更实用。</p><p>Meta在LLaMA[8]的观点是：给定模型的目标性能，并不需要用最优的计算效率在<strong>最快</strong>时间训练好模型，而应该在更大规模的数据上，训练一个相对<strong>更小</strong>模型，这样的模型在推理阶段的成本更低，尽管训练阶段的效率不是最优的（同样的算力其实能获得更优的模型，但是模型尺寸也会更大）。根据ScalingLaw，10B模型只需要200B的数据，但是作者发现7B的模型性能在1T的数据后还能继续提升。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514063.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以LLaMA工作的重点是训练一系列语言模型，通过使用更多的数据，让模型在<strong>有限推理资源下有最佳的性能</strong>。</p><p>具体而言，确定模型尺寸后，ScalingLaw给到的只是最优的数据量，或者说是一个<strong>至少</strong>的数据量，实际在训练中观察在各个指标上的性能表现，只要还在继续增长，就可以持续增加训练数据。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021514409.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2id="计算量模型和数据大小的关系推导">计算量、模型和数据大小的关系推导</h2><p>对于Decoder-only的模型，计算量<spanclass="math inline">\(C\)</span>(Flops), 模型参数量<spanclass="math inline">\(N\)</span>(除去Embedding部分), 数据大小<spanclass="math inline">\(D\)</span>(token数), 三者的关系为: <spanclass="math inline">\(C ≈ 6ND\)</span></p><p>推导如下，记模型的结构为:</p><p>decoder层数: <span class="math inline">\(l\)</span></p><p>attention 隐层维度: <span class="math inline">\(d\)</span></p><p>attention feedforward层维度: <spanclass="math inline">\(d_{ff}\)</span>， 一般来说 <spanclass="math inline">\(d_{ff} = 4*d\)</span></p><p>首先推导模型的参数量<spanclass="math inline">\(N\)</span>（忽略embedding，norm和bias）计算如下:</p><p>transformer每层包括: self-attetion 和 MLP 两个部分:</p><p>self-attention的参数为<span class="math inline">\(W_{Q}, W_{K},W_{V}, W_{O}\)</span>，每个矩阵的维度均为<spanclass="math inline">\(\mathbb{R}^{d \times d}\)</span>，整体参数量:<span class="math inline">\(4d^{2}\)</span></p><p>MLP的层数的参数为<span class="math inline">\(W_{1} \in \mathbb{R}^{d\times d_{ff}}, W_{2} \in \mathbb{R}^{d_{ff} \timesd}\)</span>，整体参数量: <span class="math inline">\(2 * d * d_{ff} = 2* d * 4d = 8d^2\)</span></p><p>所以每层的参数量为: <span class="math inline">\(4d^2 + 8d^2 =12d^2\)</span>，全部的<spanclass="math inline">\(l\)</span>层的参数量为: <spanclass="math inline">\(12ld^{2}\)</span>，即<spanclass="math inline">\(N=12ld^{2}\)</span></p><p>继续推导模型的前向推理的计算量:</p><blockquote><p>计算量的单位是FLOPs，floating point operations 对于矩阵<spanclass="math inline">\(A \in \mathbb{R}^{m \times n}, B \in \mathbb{R}^{n\times p}\)</span>，<spanclass="math inline">\(AB\)</span>相乘的计算量为<spanclass="math inline">\(2mnp\)</span>，一次加法一次乘法。</p></blockquote><p>假设Decoder层的输入<span class="math inline">\(X \in \mathbb{R}^{b\times s \times d}\)</span>, <spanclass="math inline">\(b\)</span>为batch size，<spanclass="math inline">\(s\)</span>为序列长度, <spanclass="math inline">\(d\)</span>为模型维度。</p><ul><li>self-attention部分的计算:</li></ul><p>输入线性层: <span class="math inline">\(XW_{Q}, XW_{K},XW_{V}\)</span>，计算量为:<span class="math inline">\(3 * b * s * d * d* 2 = 6bsd^2\)</span></p><p>atention计算: <spanclass="math inline">\(QK^{T}\)</span>，计算量为:<spanclass="math inline">\(2 * b * s * s * d = 2bs^2d\)</span></p><p>socre与V的计算: <spanclass="math inline">\(S_{attention}V\)</span>，计算量为: <spanclass="math inline">\(b * 2 * s * s * d = 2bs^2d\)</span></p><p>输出线性层: <spanclass="math inline">\(X^{&#39;}W_{O}\)</span>，计算量为: <spanclass="math inline">\(b * 2 * s * d * d = 2bsd^2\)</span></p><ul><li>MLP部分的计算</li></ul><p>升维: <span class="math inline">\(XW_{1}\)</span>，计算量为: <spanclass="math inline">\(b * 2 * s * d * 4d = 8bsd^2\)</span></p><p>降维: <span class="math inline">\(XW_{2}\)</span>，计算量为: <spanclass="math inline">\(b * 2 * s * 4d * d = 8bsd^2\)</span></p><p>所以整个decoder层的计算量为:<span class="math inline">\(24bsd^2 +4bs^2d\)</span>，全部<span class="math inline">\(l\)</span>层为: <spanclass="math inline">\(C_{forward} = 24lbsd^2 + 4lbs^2d\)</span></p><p>反向传播计算量是正向的2倍，所以全部的计算量为: <spanclass="math inline">\(C = 3*C_{forward} = 72lbsd^2 +12lbs^2d\)</span></p><p>平均每个token的计算量为 <span class="math inline">\(C_{token} =\frac{C}{bs} = 72ld^2 + 12lsd = 6N(1+\frac{s}{6d}) \approx 6N\)</span>(<span class="math inline">\(s \ll 6d\)</span>)</p><p>所以对于全部包含<spanclass="math inline">\(D\)</span>个token的数据集: <spanclass="math inline">\(C = C_{token}D \approx 6ND\)</span></p><h2 id="参考资料">参考资料</h2><ul><li>[1] <ahref="https://arxiv.org/abs/2001.08361">https://arxiv.org/abs/2001.08361</a></li><li>[2] <ahref="https://arxiv.org/abs/2203.15556">https://arxiv.org/abs/2203.15556</a></li><li>[3] <ahref="https://arxiv.org/abs/2305.10403">https://arxiv.org/abs/2305.10403</a></li><li>[4] <ahref="https://arxiv.org/abs/2010.14701">https://arxiv.org/abs/2010.14701</a></li><li>[5] <ahref="https://arxiv.org/abs/2303.08774">https://arxiv.org/abs/2303.08774</a></li><li>[6] <ahref="https://arxiv.org/abs/2309.10305">https://arxiv.org/abs/2309.10305</a></li><li>[7] <ahref="https://arxiv.org/abs/2310.15777">https://arxiv.org/abs/2310.15777</a></li><li>[8] <ahref="https://arxiv.org/abs/2302.13971">https://arxiv.org/abs/2302.13971</a></li><li>[9] <ahref="https://zhuanlan.zhihu.com/p/106406433">https://zhuanlan.zhihu.com/p/106406433</a></li><li>[10] <ahref="https://www.zhihu.com/question/629230332/answer/3278779348">https://www.zhihu.com/question/629230332/answer/3278779348</a></li><li>[11] <ahref="https://zhuanlan.zhihu.com/p/631357320">https://zhuanlan.zhihu.com/p/631357320</a></li><li>[12] <ahref="https://zhuanlan.zhihu.com/p/624740065">https://zhuanlan.zhihu.com/p/624740065</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/LLM/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/LLM/%E5%A4%9A%E6%A8%A1%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多模态">多模态</h1><p>在人工智能的不断发展中，多模态学习逐渐崭露头角，成为了一个重要的研究方向。它不再局限于<strong>单一类型的数据处理</strong>，而是<font color='red'><strong>将文本、图像、视频、音频等多种信息源结合起来</strong></font>，为机器提供了更加丰富和多元的理解视角。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021849147.png"alt="5139a98f8d2858b5b9722638ce88c46f" /><figcaptionaria-hidden="true">5139a98f8d2858b5b9722638ce88c46f</figcaption></figure><p>多模态学习涵盖了计算机视觉（CV）、自然语言处理（NLP）和语音识别等多个应用领域</p><ul><li>什么是计算机视觉？</li></ul><p>CV是多模态学习的一个重要应用领域，它涉及对图像和视频内容的理解和分析。CNN在CV任务中表现出色，被广泛应用于图像分类、目标检测、图像分割、人脸识别等任务中。</p><ul><li>什么是自然语言处理？</li></ul><p>NLP是多模态另一个重要的应用领域，它涉及对文本数据的理解和生成。Transformer及其变体在NLP任务中取得了巨大成功，被广泛应用于文本分类、情感分析、机器翻译、问答系统等任务中。</p><ul><li>什么是语音识别？</li></ul><p>语音识别是另一个融合了多种模态（音频和文本）的应用领域。它旨在将人类语音转换为文本表示，并进一步用于NLP任务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维链COT</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/LLM/%E6%80%9D%E7%BB%B4%E9%93%BECOT/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/LLM/%E6%80%9D%E7%BB%B4%E9%93%BECOT/</url>
      
        <content type="html"><![CDATA[<h1 id="思维连cot">思维连COT</h1><p><strong>思维链（Chain of Thought,CoT）</strong>思维链是大模型复杂问题推理的关键。2022年，Wei等人在数据集中加入一段“逐步推理”的文字，激发大模型的思考能力。这种方法允许模型将<strong>多步推理问题</strong>分解为<strong>中间步骤</strong>，从而提高模型在处理复杂问题时的准确性和可解释性。思维链技术通过模拟人类解决问题时的思考过程，使得大型语言模型能够<strong>逐步分析问题</strong>并生成<strong>中间推理步骤</strong>，最终得出准确答案。这种方法不仅提升了模型在数学、常识和符号推理任务中的表现，而且对模型规模有显著影响，大模型受益更大。此外，思维链提示还使大语言模型更具可解释性，并提供了调试推理路径错误的机会。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021519770.png"alt="image-20241002151926706" /><figcaption aria-hidden="true">image-20241002151926706</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统1与系统2</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/LLM/%E7%B3%BB%E7%BB%9F1%E5%92%8C%E7%B3%BB%E7%BB%9F2/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/LLM/%E7%B3%BB%E7%BB%9F1%E5%92%8C%E7%B3%BB%E7%BB%9F2/</url>
      
        <content type="html"><![CDATA[<h1 id="系统1与系统2">系统1与系统2</h1><p>可以这样理解，<strong>GPT 4o 及之前的模型</strong>进行的是系统 1思维，而 <strong>OpenAI o1</strong>的<strong>思维链</strong>则解锁了系统2 思维。</p><p>众所周知，通过提示模型“逐步思考”可以提升大模型的性能。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021436037.png"alt="image-20241002143649981" /><figcaption aria-hidden="true">image-20241002143649981</figcaption></figure><p>而通过强化学习训练，<strong>逐步拆解问题</strong>并<strong>从头到尾持续试错</strong>，将会进一步大幅提升大模型的性能。正如我们之前在围棋方面的AlphGo以及其它游戏方面的算法模型上所看到的。</p><blockquote><p>系统 1 与系统 2来自诺贝尔经济学奖得主丹尼尔·卡尼曼的《思考，快与慢》，其核心观点包括：</p><ul><li><p>系统 1：快速、直观、自动的思维方式。</p><p>这种思维模式通常是无意识的，依赖于直觉和经验，能迅速做出反应。例如，看到一个熟悉的面孔时，我们几乎无需思考便能认出它。</p></li><li><p>系统 2：慢速、深思熟虑、逻辑性的思维方式。</p><p>这种思维模式需要有意识的努力和思考，用于解决复杂问题或做出深思熟虑的决策。例如，解决数学题或计划长期目标时，我们会调动系统2 的思维。</p></li></ul></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410021417502.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031703471.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Others</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/python/Others/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/python/Others/</url>
      
        <content type="html"><![CDATA[<h1 id="others">Others</h1><ul><li><ahref="https://www.bilibili.com/video/BV1kT4y1u72i/?spm_id_from=333.999.0.0&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">10个Python编程技巧让你的代码更上一层楼_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局变量&amp;局部变量</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/python/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&amp;%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/python/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&amp;%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p># 全局变量&amp;局部变量</p><h2 id="局部变量">局部变量</h2><p><strong>局部变量</strong>就是在函数内部定义的变量，作用范围是这个函数内部，即只能在这个函数中使用，在函数的外部是不能使用的。因为其作用范围只是在自己的函数内部，所以不同的函数可以定义相同名字的局部变量。</p><p>局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储：</p><ul><li>当函数调用时，局部变量被创建</li><li>当函数调用完成后这个变量就不能够使用了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(): </span><br><span class="line">    <span class="comment"># 定义局部变量 </span></span><br><span class="line">    sal = <span class="number">15000</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;薪资:&quot;</span>, sal) </span><br><span class="line">show() </span><br></pre></td></tr></table></figure><p>薪资: 15000</p><h2 id="全局变量">全局变量</h2><p>如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量 </span></span><br><span class="line">money = <span class="number">1200</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(): </span><br><span class="line">    <span class="built_in">print</span>(money) <span class="comment"># 虽然没有定义变量 money 但是可是使用全局变量 money</span></span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure><p>1200</p><span id="more"></span><h2 id="全局变量和局部变量冲突问题">全局变量和局部变量冲突问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量 </span></span><br><span class="line">x = <span class="number">100</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(): </span><br><span class="line">    <span class="comment"># 定义局部变量，与全局变量名字相同 </span></span><br><span class="line">    x = <span class="number">300</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---test1---%d&#x27;</span>%x) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#修改 x = 200 </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;修改后的%d&#x27;</span>%x) </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x = %d&#x27;</span>%x) </span><br><span class="line">    </span><br><span class="line">test1() </span><br><span class="line">test2()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---test1---300</span><br><span class="line">修改后的300</span><br><span class="line">x = 100</span><br></pre></td></tr></table></figure><p>​ 当函数内出现局部变量和全局变量相同名字时，函数内部中的<code>变量名 = 数据</code>此时理解为定义了一个局部变量，而不是修改全局变量的值</p><h2 id="修改全局变量">修改全局变量</h2><p>函数中进行使用全局变量时可否进行修改呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量 </span></span><br><span class="line">x = <span class="number">100</span> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(): </span><br><span class="line">    <span class="comment"># 定义全局变量,使用global函数声明变量x为全局变量</span></span><br><span class="line">    <span class="keyword">global</span> x </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;修改之前：%d&#x27;</span>%x) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#修改 </span></span><br><span class="line">    x = <span class="number">200</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;修改之后：%d&#x27;</span>%x) </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x = %d&#x27;</span>%x) </span><br><span class="line">    </span><br><span class="line">test1() </span><br><span class="line">test2()</span><br></pre></td></tr></table></figure><h2 id="实例">实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u, st, res</span>):</span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    <span class="keyword">if</span> u &gt; k + <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> st == n:</span><br><span class="line">        <span class="keyword">if</span> u == k + <span class="number">1</span>:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, res)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - (k - u) - st + <span class="number">1</span>):</span><br><span class="line">        dfs(u + <span class="number">1</span>, st + <span class="built_in">len</span>, res * <span class="built_in">int</span>(s[st:st + <span class="built_in">len</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><p>​ 在你的代码中，<code>ans</code> 被声明为全局变量，因为你在<code>dfs</code> 函数内部修改了它的值。Python中如果你在函数内部想要修改一个全局变量的值，必须使用 <code>global</code>关键字来显式声明它是全局的，否则 Python会认为这是一个局部变量并报错。</p><p>​ 至于变量 <code>s</code> 和<code>k</code>，它们是函数外部的全局变量，但是在 <code>dfs</code>函数内部只是被读取，而不是修改。所以你不需要用 <code>global</code>声明它们，Python默认允许函数读取全局变量而不需要特殊声明，只有在修改全局变量时才需要使用<code>global</code>。</p><h2 id="总结">总结</h2><ul><li>在函数<strong>内</strong>定义的变量叫做局部变量，在函数<strong>外</strong>定义的变量叫做全局变量</li><li>全局变量能够在<strong>所有的函数</strong>中进行访问，但如果想在函数内<strong>修改</strong>全局变量，必须进行<code>global</code> 声明</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="文件操作">文件操作</h1><h2 id="普通文件操作">普通文件操作</h2><h3 id="读取文件">读取文件</h3><p>以<strong>只读</strong>方式打开文件，文件的指针将会放在文件的开头</p><ol type="1"><li>读取文件内容，保存在<strong>字符串</strong>中</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认读取文件所有内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content: <span class="built_in">str</span> = f.read()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 读取文件前20个字节</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content: <span class="built_in">str</span> = f.read(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>按行方式读取文件内容，保存在<strong>字符串列表</strong>中，其中每一行的数据为一个元素</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件所有内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines: <span class="built_in">list</span> = f.readlines()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 读取文件某1行内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line1: <span class="built_in">str</span> = f.readline()    <span class="comment"># 读取文件第一行内容</span></span><br><span class="line">    line2: <span class="built_in">str</span> = f.readline()    <span class="comment"># 读取文件第二行内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐行处理文件内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="写入文件">写入文件</h3><p>以<strong>可写</strong>方式打开文件</p><ol type="1"><li>如果该文件已存在，则打开文件 并从开头开始编辑，<strong>原有内容会被删除</strong></li><li>如果该文件不存在，则<strong>创建新文件</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="追加文件">追加文件</h3><p>以<strong>追加</strong>方式打开文件</p><ol type="1"><li>如果该文件已存在，<strong>新的内容将会被写入到已有内容之后</strong></li><li>如果该文件不存在，<strong>创建新文件</strong>进行写入</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="序列化与反序列化">序列化与反序列化</h2><h3 id="json-转化为-python-对象">json 转化为 python 对象</h3><ol type="1"><li><code>json.load()</code> <strong>json文件</strong> 转换为<strong>字典列表</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;XXX.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><p><code>json.loads()</code> 将 <strong>json格式的字符串</strong>转换为 python 对象</p><ol type="1"><li>转换为<strong>字典列表</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 JSON 字符串转换为 Python 数据类型[ &#123;k: v, k: v&#125;, &#123;k: v, k: v&#125;]</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;[&#123;&quot;name&quot;: &quot;张大山&quot;, &quot;age&quot;: 11&#125;, &#123;&quot;name&quot;: &quot;王大锤&quot;, &quot;age&quot;: 13&#125;, &#123;&quot;name&quot;: &quot;赵小虎&quot;, &quot;age&quot;: 16&#125;]&#x27;</span></span><br><span class="line">l = json.loads(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(l))</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>转换为<strong>字典</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将JSON字符串转换为Python数据类型&#123;k: v, k: v&#125;</span></span><br><span class="line">s = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;周杰轮&quot;, &quot;addr&quot;: &quot;台北&quot;&#125;&#x27;</span></span><br><span class="line">my_dict:<span class="built_in">dict</span> = json.loads(s)</span><br><span class="line"><span class="comment"># my_dict = dict(s) 错误，dict无法强制转化</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="python-对象转化为-json">python 对象转化为 json</h3><ol type="1"><li><code>json.dump()</code> 将<strong>字典列表</strong>转换为<strong>json 文件</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张大山&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">11</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王大锤&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">13</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;赵小虎&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">16</span>&#125;]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;XXX.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><p><code>json.dumps()</code> 将 python 对象转换为<strong>JSON</strong>**格式的字符串</p><ol type="1"><li>将<strong>字典列表</strong>转换为<strong>JSON格式的字符串</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张大山&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">11</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王大锤&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">13</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;赵小虎&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">16</span>&#125;]</span><br><span class="line">json_str:<span class="built_in">str</span> = json.dumps(data, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将<strong>字典</strong>转换为<strong>JSON格式的字符串</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;周杰轮&quot;</span>, <span class="string">&quot;addr&quot;</span>:<span class="string">&quot;台北&quot;</span>&#125;</span><br><span class="line">json_str:<span class="built_in">str</span> = json.dumps(d, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="获取当前目录">获取当前目录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_import_ os</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 获取当前工作目录_</span></span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 打印当前工作目录_</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前目录：&quot;</span>, current_directory)</span><br></pre></td></tr></table></figure><h2 id="读取当前文件夹下所有以-.bz2-的文件">读取当前文件夹下所有以<code>.bz2</code> 的文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">files = [file _for_ file _in_ os.listdir(<span class="string">&#x27;.&#x27;</span>) _if_ file.endswith(<span class="string">&#x27;.bz2&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依次读取所有文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_content = f.read()</span><br></pre></td></tr></table></figure><h2 id="读取某一目录下所有以-.bz2-的文件">读取某一目录下所有以<code>.bz2</code> 的文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录</span></span><br><span class="line">folder_path = <span class="string">&quot;/home/ycxie/data/cly/hijack/data/features&quot;</span></span><br><span class="line">files = [file <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(folder_path) <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.bz2&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依次读取所有文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="comment"># 将目录与文件名拼接</span></span><br><span class="line">    file_path = os.path.join(folder_path, file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_content = f.read()</span><br></pre></td></tr></table></figure><h2 id="下载大量文件">下载大量文件</h2><ol type="1"><li>首先通过爬虫/其他方式将链接保存在 <code>URL.csv</code>文件中（每一行都是一个文件的链接）</li><li>执行下面的 python 文件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件链接列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;URL.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    links = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用os.system下载每个文件</span></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">    os.system(<span class="string">f&#x27;wget -q <span class="subst">&#123;link&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="解压下载命令">解压下载命令</h2><h3 id="bz2">.bz2</h3><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031531864.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgpdump -m xxx.bz2 -O xxx.json/xxx.txt</span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031531816.png" /></p><hr /><hr /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgpdump -M xxx.bz2 -O xxx.json/xxx.txt</span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031531808.png" /></p><hr /><hr /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgpdump -H xxx.bz2 -O xxx.json/xxx.txt</span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031531853.png" /></p><p><strong>如果要解压当前目录下的所有</strong>.bz2文件，执行以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_import_ os</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 解压当前目录下所有.bz2文件_</span></span><br><span class="line">bzip2_files = [file _for_ file _in_ os.listdir(<span class="string">&#x27;.&#x27;</span>) _if_ file.endswith(<span class="string">&#x27;.bz2&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">_for_ bzip2_file _in_ bzip2_files:</span><br><span class="line">    _<span class="comment"># 构建输出文件的文件名_</span></span><br><span class="line">    output_file = os.path.splitext(bzip2_file)[<span class="number">0</span>] + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 使用bgpdump命令解压文件_</span></span><br><span class="line">    os.system(_f_<span class="string">&#x27;bgpdump -M &#123;bzip2_file&#125; -O &#123;output_file&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 使用rm命令删除bz2文件_</span></span><br><span class="line">    os.system(_f_<span class="string">&#x27;rm -f &#123;bzip2_file&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 输出提示信息_</span></span><br><span class="line">    <span class="built_in">print</span>(_f_<span class="string">&quot;&#123;bzip2_file&#125;解压完成&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>如果要下载URL.csv的所有.bz2</strong>文件，并解压到当前目录下，执行以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件链接列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;URL.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    links = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">    <span class="comment"># 使用wget命令下载文件</span></span><br><span class="line">    os.system(<span class="string">f&#x27;wget -q <span class="subst">&#123;link&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从链接中提取出下载文件名</span></span><br><span class="line">    bzip2_file = link.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    _<span class="comment"># 构建输出文件的文件名_</span></span><br><span class="line">    output_file = os.path.splitext(bzip2_file)[<span class="number">0</span>] + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 使用bgpdump命令解压文件_</span></span><br><span class="line">    os.system(_f_<span class="string">&#x27;bgpdump -M &#123;bzip2_file&#125; -O &#123;output_file&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 使用rm命令删除bz2文件_</span></span><br><span class="line">    os.system(_f_<span class="string">&#x27;rm -f &#123;bzip2_file&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 输出提示信息_</span></span><br><span class="line">    <span class="built_in">print</span>(_f_<span class="string">&quot;&#123;bzip2_file&#125;解压完成&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="txt.bz2">.txt.bz2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d 20220801.as-rel2.txt.bz2</span><br></pre></td></tr></table></figure><p><strong>如果要解压当前目录下的所有.txt.bz2文件，执行以下代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_import_ os</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 解压当前目录下所有.bz2文件_</span></span><br><span class="line">bzip2_files = [file _for_ file _in_ os.listdir(<span class="string">&#x27;.&#x27;</span>) _if_ file.endswith(<span class="string">&#x27;.txt.bz2&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">_for_ bzip2_file _in_ bzip2_files:</span><br><span class="line">    _<span class="comment"># 使用bzip2命令解压文件_</span></span><br><span class="line">    os.system(_f_<span class="string">&#x27;bzip2 -d &#123;bzip2_file&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 输出提示信息_</span></span><br><span class="line">    <span class="built_in">print</span>(_f_<span class="string">&quot;&#123;bzip2_file&#125;解压完成&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>如果要下载</strong>URL.csv的所有.bz2文件，并解压到当前目录下，执行以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件链接列表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;URL.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    links = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">    <span class="comment"># 使用wget命令下载文件</span></span><br><span class="line">    os.system(<span class="string">f&#x27;wget -q <span class="subst">&#123;link&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    _<span class="comment"># 使用bzip2命令解压文件_</span></span><br><span class="line">    os.system(_f_<span class="string">&#x27;bzip2 -d &#123;bzip2_file&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    _<span class="comment"># 输出提示信息_</span></span><br><span class="line">    <span class="built_in">print</span>(_f_<span class="string">&quot;&#123;bzip2_file&#125;解压完成&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="gz">.gz</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d file.gz</span><br></pre></td></tr></table></figure><p>这将解压 <code>file.gz</code>文件，并在当前目录生成一个未压缩的文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learn-regex</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/others/learn-regex/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/others/learn-regex/</url>
      
        <content type="html"><![CDATA[<p align="center"><br/> <a href="https://github.com/ziishaned/learn-regex"><img src="https://i.imgur.com/bYwl7Vf.png" alt="Learn Regex"> </a><br /><br /><p><a href="https://twitter.com/home?status=Learn%20regex%20the%20easy%20way%20by%20%40ziishaned%20http%3A//github.com/ziishaned/learn-regex"><img src="https://img.shields.io/badge/twitter-tweet-blue.svg?style=flat-square"/></a> <a href="https://twitter.com/ziishaned"><img src="https://img.shields.io/badge/feedback-@ziishaned-blue.svg?style=flat-square" /></a></p></p><h1 id="learn-regex">learn-regex</h1><h2 id="什么是正则表达式">什么是正则表达式？</h2><p><a href="https://gum.co/learn-regex"><imgsrc="https://img.shields.io/badge/-Download%20PDF%20-0a0a0a.svg?style=flat&amp;colorA=0a0a0a" /></a></p><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p></blockquote><p>一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regularexpression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p><p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。我们使用以下正则表达式来验证一个用户名：</p><figure><imgsrc="https://github.com/ziishaned/learn-regex/raw/master/img/regexp-cn.png"alt="Regular expression" /><figcaption aria-hidden="true">Regular expression</figcaption></figure><p>以上的正则表达式可以接受<code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p><h2 id="基本匹配">基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式<code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><pre>"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p><p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p><p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/1paXsy/1">在线练习</a></p><h2 id="元字符">元字符</h2><p>正则表达式主要依赖于元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p><table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th style="text-align: center;">元字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr class="even"><td style="text-align: center;">[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr class="odd"><td style="text-align: center;">[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr class="even"><td style="text-align: center;">*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr class="odd"><td style="text-align: center;">+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr class="even"><td style="text-align: center;">?</td><td>标记?之前的字符为可选.</td></tr><tr class="odd"><td style="text-align: center;">{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr class="even"><td style="text-align: center;">(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr class="odd"><td style="text-align: center;">|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr class="even"><td style="text-align: center;">\</td><td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ |</code></td></tr><tr class="odd"><td style="text-align: center;">^</td><td>从开始行开始匹配.</td></tr><tr class="even"><td style="text-align: center;">$</td><td>从末端开始匹配.</td></tr></tbody></table><h3 id="点运算符-.">点运算符 <code>.</code></h3><p><code>.</code>是元字符中最简单的例子。<code>.</code>匹配任意单个字符，但不匹配换行符。例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/xc9GkU/1">在线练习</a></p><h3 id="字符集">字符集</h3><p>字符集也叫做字符类。 方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和<code>The</code>。</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/2ITLQ4/1">在线练习</a></p><p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配<code>ar.</code>字符串</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><p><a href="https://regex101.com/r/wL3xtE/1">在线练习</a></p><h4 id="否定字符集">否定字符集</h4><p>一般来说 <code>^</code>表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。例如，表达式<code>[^c]ar</code>匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/nNNlq3/1">在线练习</a></p><h3 id="重复次数">重复次数</h3><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code>的，用来指定匹配子模式的次数。这些元字符在不同的情况下有着不同的意思。</p><h4 id="号"><code>*</code> 号</h4><p><code>*</code>号匹配在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式<code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code>匹配一个行中所有以小写字母开头的字符串。</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p><a href="https://regex101.com/r/7m8me5/1">在线练习</a></p><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。<code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.</pre><p><a href="https://regex101.com/r/gGrwuz/1">在线练习</a></p><h4 id="号-1"><code>+</code> 号</h4><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。例如表达式<code>c.+t</code>匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><p><a href="https://regex101.com/r/Dzf9Aa/1">在线练习</a></p><h4 id="号-2"><code>?</code> 号</h4><p>在正则表达式中元字符 <code>?</code>标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式<code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/cIg9zm/1">在线练习</a></p><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><p><a href="https://regex101.com/r/kPpO2x/1">在线练习</a></p><h3 id="号-3"><code>&#123;&#125;</code> 号</h3><p>在正则表达式中 <code>&#123;&#125;</code>是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式<code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/juM86s/1">在线练习</a></p><p>我们可以省略第二个参数。 例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位0~9 的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/Gdy4w5/1">在线练习</a></p><p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]&#123;3&#125;</code>匹配3位数字</p><pre>"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.</pre><p><a href="https://regex101.com/r/Sivu30/1">在线练习</a></p><h3 id="特征标群"><code>(...)</code> 特征标群</h3><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code>中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如,表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个<code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式<code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code>。再比如之前说的 <code>&#123;&#125;</code>是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code>前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code>表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或<code>gar</code> 或 <code>par</code>.</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/tUxrBG/1">在线练习</a></p><h3 id="或运算符"><code>|</code> 或运算符</h3><p>或运算符就表示或，用作判断条件。</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或<code>car</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/fBXyX0/1">在线练习</a></p><h3 id="转码特殊字符">转码特殊字符</h3><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定<code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code>这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线<code>\</code>。</p><p>例如 <code>.</code>是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code>则要写成 <code>\.</code> 以下这个例子<code>\.?</code>是选择性匹配<code>.</code></p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/DOc5Nu/1">在线练习</a></p><h3 id="锚点">锚点</h3><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code>指定开头，<code>$</code> 指定结尾。</p><h4 id="号-4"><code>^</code> 号</h4><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果<code>a</code>。但如果使用 <code>^b</code>将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以<code>b</code> 开头。</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或<code>the</code> 开头的字符串。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/5ljjgB/1">在线练习</a></p><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/jXrKne/1">在线练习</a></p><h4 id="号-5"><code>$</code> 号</h4><p>同理于 <code>^</code> 号，<code>$</code>号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/y4Au4D/1">在线练习</a></p><pre>"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/t0AkOd/1">在线练习</a></p><h2 id="简写字符集">简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr class="header"><th style="text-align: center;">简写</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">.</td><td>除换行符外的所有字符</td></tr><tr class="even"><td style="text-align: center;"></td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr class="even"><td style="text-align: center;"> 匹配数字： <code>[0-9]</code></td><td></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配非数字： <code>[^\d]</code></td></tr><tr class="even"><td style="text-align: center;"></td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr class="even"><td style="text-align: center;"> 匹配一个换页符</td><td></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配一个换行符</td></tr><tr class="even"><td style="text-align: center;"> 匹配一个回车符</td><td></td></tr><tr class="odd"><td style="text-align: center;"> 匹配一个制表符</td><td></td></tr><tr class="even"><td style="text-align: center;"> 匹配一个垂直制表符</td><td></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="零宽度断言前后预查">零宽度断言（前后预查）</h2><p>先行断言和后发断言（合称lookaround）都属于<strong>非捕获组</strong>（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p><p>例如，我们希望从下面的输入字符串 <code>$4.44</code> 和<code>$10.88</code> 中获得所有以 <code>$</code>字符开头的数字，我们将使用以下的正则表达式<code>(?&lt;=\$)[0-9\.]*</code>。意思是：获取所有包含 <code>.</code>并且前面是 <code>$</code> 的数字。</p><p>零宽度断言如下：</p><table><thead><tr class="header"><th style="text-align: center;">符号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">?=</td><td>正先行断言-存在</td></tr><tr class="even"><td style="text-align: center;">?!</td><td>负先行断言-排除</td></tr><tr class="odd"><td style="text-align: center;">?&lt;=</td><td>正后发断言-存在</td></tr><tr class="even"><td style="text-align: center;">?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h3 id="正先行断言"><code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着<code>?=...</code>定义的表达式。</p><p>返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用<code>()</code>。在括号内部使用一个问号和等号：<code>(?=...)</code>。</p><p>正先行断言的内容写在括号中的等号后面。 例如，表达式<code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和<code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code>，即 <code>The</code> 和 <code>the</code> 后面紧跟着<code>(空格)fat</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/IDDARt/1">在线练习</a></p><h3 id="负先行断言"><code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为其后不跟随着断言中定义的格式。 <code>正先行断言</code> 定义和<code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成<code>!</code> 也就是 <code>(?!...)</code>。</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和<code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/V32Npg/1">在线练习</a></p><h3 id="正后发断言"><code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code>用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配<code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或<code>the</code>。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><a href="https://regex101.com/r/avH165/1">在线练习</a></p><h3 id="负后发断言"><code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code>用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配<code>cat</code>，且其前不跟着 <code>The</code> 或<code>the</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><p><a href="https://regex101.com/r/8Efx5G/1">在线练习</a></p><h2 id="标志">标志</h2><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr class="header"><th style="text-align: center;">标志</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">i</td><td>忽略大小写。</td></tr><tr class="even"><td style="text-align: center;">g</td><td>全局搜索。</td></tr><tr class="odd"><td style="text-align: center;">m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code>工作范围在每行的起始。</td></tr></tbody></table><h3 id="忽略大小写-case-insensitive">忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写。 例如，表达式<code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的<code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和<code>The</code>，<code>g</code> 表示全局搜索。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/dpQyf9/1">在线练习</a></p><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/ahfiuh/1">在线练习</a></p><h3 id="全局搜索-global-search">全局搜索 (Global search)</h3><p>修饰符 <code>g</code>常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+<code>at</code>，并返回全部结果。</p><pre>"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><p><a href="https://regex101.com/r/jnk6gM/1">在线练习</a></p><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><a href="https://regex101.com/r/dO1nef/1">在线练习</a></p><h3 id="多行修饰符-multiline">多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p><p>像之前介绍的 <code>(^,$)</code>用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符<code>m</code>。</p><p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code>后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据<code>m</code> 修饰符，现在表达式匹配每行的结尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/hoGMkP/1">在线练习</a></p><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/E88WE2/1">在线练习</a></p><h2 id="贪婪匹配与惰性匹配-greedy-vs-lazy-matching">贪婪匹配与惰性匹配(Greedy vs lazy matching)</h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用<code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><pre>"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre><p><a href="https://regex101.com/r/AyAdgJ/1">在线练习</a></p><pre>"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre><p><a href="https://regex101.com/r/AyAdgJ/2">在线练习</a></p><h2 id="参考资料">参考资料</h2><ol type="1"><li>正则表达式30分钟入门教程 作者: deerchaohttps://deerchao.cn/tutorials/regex/regex.htm</li><li>Regex tutorial — A quick cheatsheet by examples (英文) 作者: JonnyFoxhttps://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285</li><li>Regular Expressions Tutorial (英文)https://www.regular-expressions.info/tutorial.html</li><li><ahref="https://www.bilibili.com/video/BV1da4y1p7iZ/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">10分钟快速掌握正则表达式_哔哩哔哩_bilibili</a></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409302030352.png"alt="image-20240930203031011" /><figcaption aria-hidden="true">image-20240930203031011</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh操作</title>
      <link href="/2024/05/05/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/ssh%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/05/05/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/ssh%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh操作">ssh操作</h1><h2 id="mobaxterm">MobaXterm</h2><p><code>139.224.18.199:32122</code> （校内）（64的替代机）</p><ul><li><p>配置：32G+2T</p></li><li><p>功能：大容量或者大批量文件处理机</p></li><li><p>账号：ubuntu</p></li><li><p>密码：nli@hitnslab</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031535211.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><code>10.246.254.228</code>（校内）</p><ul><li><p>配置：4 G+100G</p></li><li><p>功能：数据仓库节点，GPU机器，可以部署路由组常态化程序</p></li><li><p>账号：ycxie</p></li><li><p>密码：Xyc0129</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031536996.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>没有指明ssh端口号的话就默认22</p></blockquote><h2 id="vscode">VScode</h2><p><code>139.224.18.199</code><strong><code>:32122</code></strong>（校内）（64的替代机）</p><ul><li><p>配置：32G+2T</p></li><li><p>功能：大容量或者大批量文件处理机</p></li><li><p>账号：ubuntu</p></li><li><p>密码：nli@hitnslab</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031537256.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh ycxie@10.246.254.228</span><br></pre></td></tr></table></figure><p><code>10.246.254.228</code>（校内）</p><p>配置：4 G+100G</p><p>功能：数据仓库节点，GPU机器，可以部署路由组常态化程序</p><p>账号：ycxie</p><p>密码：Xyc0129</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202410031538791.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 32122 ubuntu@139.224.18.199</span><br></pre></td></tr></table></figure><blockquote><p>没有指明ssh端口号的话就默认22</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【9.算法与数据结构入门】</title>
      <link href="/2024/05/04/%5Bobject%20Object%5D/python/%E3%80%909.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E3%80%91/"/>
      <url>/2024/05/04/%5Bobject%20Object%5D/python/%E3%80%909.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="算法与数据结构入门">【9.算法与数据结构入门】</h1><p>任何程序的本质都是算法 + 数据结构。 ——闫学灿</p><h2 id="枚举">枚举</h2><p>通过枚举的方式求集合的最小值、最大值、元素数量，就是枚举算法。</p><hr /><h2 id="递推">递推</h2><p>逐步通过前面的状态推导出后面的状态，就是递推算法。</p><hr /><h2 id="递归">递归</h2><p>将原问题逐步变成规模更小的子问题，就是递归算法。</p><hr /><span id="more"></span><h2 id="排序">排序</h2><h3 id="选择排序">选择排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(q)):</span><br><span class="line">            <span class="keyword">if</span> q[j] &lt; q[i]:</span><br><span class="line">                q[i], q[j] = q[j], q[i]</span><br></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> q[j] &lt; q[j - <span class="number">1</span>]:</span><br><span class="line">            q[j - <span class="number">1</span>], q[j] = q[j], q[j - <span class="number">1</span>]</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> q[j] &gt; q[j + <span class="number">1</span>]:</span><br><span class="line">                q[j], q[j + <span class="number">1</span>] = q[j + <span class="number">1</span>], q[j]</span><br></pre></td></tr></table></figure><p>冒泡排序可以稍微加个优化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">        not_changed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> q[j] &gt; q[j + <span class="number">1</span>]:</span><br><span class="line">                q[j], q[j + <span class="number">1</span>] = q[j + <span class="number">1</span>], q[j]</span><br><span class="line">                not_changed = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> not_changed:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr /><h2 id="链表">链表</h2><p>链表是一种常用的数据结构，可以存储一列数据。</p><p>例如，下图所示的链表可以用后面的代码存储：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409151534501.png"alt="link.png" /><figcaption aria-hidden="true">link.png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    p = Node(i)</span><br><span class="line">    p.<span class="built_in">next</span> = head</span><br><span class="line">    head = p</span><br><span class="line"></span><br><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    <span class="built_in">print</span>(p.val, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【8.类、异常处理、模块、包的管理、虚拟环境】</title>
      <link href="/2024/05/03/%5Bobject%20Object%5D/python/%E3%80%908.%E7%B1%BB%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E3%80%81%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E3%80%91/"/>
      <url>/2024/05/03/%5Bobject%20Object%5D/python/%E3%80%908.%E7%B1%BB%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E3%80%81%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1id="类异常处理模块包的管理虚拟环境">【8.类、异常处理、模块、包的管理、虚拟环境】</h1><p>本章内容与Python开发项目相关，每个知识点的细节纷繁复杂，大家只要学会核心用法，剩下的细节现用现查即可。——闫学灿</p><h2 id="类">类</h2><p>类可以将变量、函数打包在一起，让代码在逻辑上更加清晰。<br />类名称一般采用驼峰命名法，函数一般采用下划线命名法。</p><p>类中函数的第一个参数都是<code>self</code>，用来调用类本身的变量和函数。<br />当调用类中函数的时候，第一个参数<code>self</code>不需要自己传递，Python会自动传递这个参数。</p><h3 id="类的定义">类的定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line">zeus = Hero(<span class="string">&quot;Zeus&quot;</span>)</span><br><span class="line">athena = Hero(<span class="string">&quot;Athena&quot;</span>, <span class="number">6</span>)</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.move()</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.get_level(), athena.next_level())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), athena)</span><br><span class="line"><span class="built_in">print</span>(Hero.hero_count)</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="类变量和实例变量">类变量和实例变量</h3><p>每个类可以创建任意多实例。例如上面的<code>Hero</code>类，可以创建<code>zeus</code>和<code>athena</code>等实例。</p><p>类变量由所有实例共享，一般通过类名访问，例如<code>Hero.hero_count</code>。</p><p>实例变量与每个具体的实例绑定，一般通过具体实例来访问，例如<code>zeus.name</code>。</p><h3 id="类的继承">类的继承</h3><p>子类可以继承父类的变量和函数。</p><p><code>self</code>可以调用<strong>自身和父类</strong>中的变量和函数，<code>super()</code>可以调用<strong>父类</strong>中的函数。</p><p>如果子类和父类的变量或函数重名，优先使用子类的变量和函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zeus</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Zeus&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Zeus.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Athena</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Athena&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Athena.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line">zeus = Zeus(<span class="number">6</span>)</span><br><span class="line">athena = Athena(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.level, Hero.hero_count)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), <span class="built_in">str</span>(athena))</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.greet()</span><br><span class="line"><span class="built_in">print</span>(zeus.get_level())</span><br></pre></td></tr></table></figure><hr /><h2 id="异常处理">异常处理</h2><p>当某段代码出现异常时，代码会被终止。此时如果不想让代码终止，可以用<code>try ... except ...</code>语句来处理异常。</p><p>例如，将字符串转化成整数时，可能会出现异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished!&quot;</span>)</span><br></pre></td></tr></table></figure><p>当除以0时，也会出现异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    z = x / y</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished!&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果希望输出更多的错误信息，可以使用 <code>traceback</code> 模块中的<code>print_exc()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    z = x / y</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">from</span> traceback <span class="keyword">import</span> print_exc</span><br><span class="line">    print_exc()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished!&quot;</span>)</span><br></pre></td></tr></table></figure><hr /><h2 id="模块">模块</h2><p>当项目的逻辑越来越复杂时，把所有代码写到一个文件中会相当不方便。</p><p>此时就可以将不同代码放到不同的模块中。所有模块通过文件夹和文件组织成树的形式。</p><p>自定义模块的每个文件夹中需要包含一个空<code>__init__.py</code>文件，用来让Python识别出这是一个模块。</p><p>示例：</p><p>文件结构如下所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409151527434.png"alt="微信截图_20231102194835.png" /><figcaption aria-hidden="true">微信截图_20231102194835.png</figcaption></figure><p><code>utils/__init__.py</code> 是空文件。</p><p><code>utils/log.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>), <span class="string">&quot;INFO:&quot;</span>, self.text)</span><br></pre></td></tr></table></figure><p><code>operation/__init__.py</code> 是空文件。</p><p><code>operation/add.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.log <span class="keyword">import</span> Log</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    log = Log(<span class="string">&quot;Operation add&quot;</span>)</span><br><span class="line">    log.info()</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p><code>operation/sub.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils.log</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a, b</span>):</span><br><span class="line">    log = utils.log.Log(<span class="string">&quot;Operation sub&quot;</span>)</span><br><span class="line">    log.info()</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br></pre></td></tr></table></figure><p><code>operation/mul.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.log <span class="keyword">import</span> Log <span class="keyword">as</span> MyLog</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a, b</span>):</span><br><span class="line">    log = MyLog(<span class="string">&quot;Operation mul&quot;</span>)</span><br><span class="line">    log.info()</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br></pre></td></tr></table></figure><p><code>operation/others.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.log <span class="keyword">import</span> Log</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a, b</span>):</span><br><span class="line">    log = Log(<span class="string">&quot;Operation div&quot;</span>)</span><br><span class="line">    log.info()</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">a, b</span>):</span><br><span class="line">    log = Log(<span class="string">&quot;Operation power&quot;</span>)</span><br><span class="line">    log.info()</span><br><span class="line">    <span class="keyword">return</span> a ** b</span><br></pre></td></tr></table></figure><p><code>main.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operation.add <span class="keyword">import</span> add</span><br><span class="line"><span class="keyword">from</span> operation.sub <span class="keyword">import</span> sub</span><br><span class="line"><span class="keyword">from</span> operation.mul <span class="keyword">import</span> mul</span><br><span class="line"><span class="keyword">from</span> operation.others <span class="keyword">import</span> div, power</span><br><span class="line"></span><br><span class="line">op = <span class="built_in">input</span>()</span><br><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(add(a, b))</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(sub(a, b))</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(mul(a, b))</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(div(a, b))</span><br><span class="line"><span class="keyword">elif</span> op == <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(power(a, b))</span><br></pre></td></tr></table></figure><hr /><h2 id="包的管理">包的管理</h2><p>写项目时，不会所有代码都自己实现，会用到很多网络上现成的包（模块）。</p><h3 id="通过命令行管理">通过命令行管理</h3><p>以安装<code>pygame</code>这个包为例：</p><ul><li><p>安装包：<code>pip3 install pygame --user</code></p></li><li><p>升级包：<code>pip3 install pygame --user --upgrade</code></p></li><li><p>删除包：<code>pip3 uninstall pygame</code></p></li></ul><h3 id="通过ide的图形化界面管理">通过IDE的图形化界面管理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409151527500.png"alt="微信截图_20231102175604.png" /><figcaption aria-hidden="true">微信截图_20231102175604.png</figcaption></figure><h3 id="示例">示例</h3><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/10401037/">下一章</a>我们会用<code>pygame</code>包来开发迷宫项目。</p><p>现在我们可以先尝试一下这个包，用它来创建一个可关闭的窗口，名称是“Maze”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line">pygame.init()</span><br><span class="line">screen = pygame.display.set_mode((<span class="number">700</span>, <span class="number">500</span>))  <span class="comment"># 窗口大小 700 * 500</span></span><br><span class="line"></span><br><span class="line">pygame.display.set_caption(<span class="string">&quot;Maze&quot;</span>)  <span class="comment"># 窗口标题是 Maze</span></span><br><span class="line"></span><br><span class="line">done = <span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:  <span class="comment"># 如果检测到窗口被关闭了，就终止程序</span></span><br><span class="line">            done = <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr /><h2 id="虚拟环境">虚拟环境</h2><p>每个虚拟环境主要用来存放一系列不同版本的包。</p><p>在windows或mac下开发时，一台电脑上可能会有多个Python项目，不同项目可能会依赖不同版本的包，为了不让不同项目之间产生冲突，可以将每个项目放到单独的虚拟环境中。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409151527483.png"alt="微信图片_20231102175848.png" /><figcaption aria-hidden="true">微信图片_20231102175848.png</figcaption></figure><p>虚拟环境主要用于本地开发，在云端Linux服务器上部署项目时，一般采用docker来管理环境，不需要使用虚拟环境<code>env</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【thu工程硕博】</title>
      <link href="/2024/05/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E5%B7%A5%E7%A8%8B%E7%A1%95%E5%8D%9A%E3%80%91/"/>
      <url>/2024/05/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E5%B7%A5%E7%A8%8B%E7%A1%95%E5%8D%9A%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="thu工程硕博">thu工程硕博</h1><h2 id="电子工程系">电子工程系</h2><h3 id="硕士">硕士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271521107.png"alt="image-20240827152058967" /><figcaption aria-hidden="true">image-20240827152058967</figcaption></figure><h3 id="博士">博士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271522969.png"alt="image-20240827152205862" /><figcaption aria-hidden="true">image-20240827152205862</figcaption></figure><h2 id="计算机科学与技术系">计算机科学与技术系</h2><h3 id="硕士-1">硕士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271523518.png"alt="image-20240827152341415" /><figcaption aria-hidden="true">image-20240827152341415</figcaption></figure><h3 id="博士-1">博士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271524589.png"alt="image-20240827152417491" /><figcaption aria-hidden="true">image-20240827152417491</figcaption></figure><h2 id="自动化系">自动化系</h2><h3 id="硕士-2">硕士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271526480.png"alt="image-20240827152606392" /><figcaption aria-hidden="true">image-20240827152606392</figcaption></figure><h3 id="博士-2">博士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271525046.png"alt="image-20240827152503946" /><figcaption aria-hidden="true">image-20240827152503946</figcaption></figure><h2 id="软件学院">软件学院</h2><h3 id="硕士-3">硕士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271527245.png"alt="image-20240827152755147" /><figcaption aria-hidden="true">image-20240827152755147</figcaption></figure><h3 id="博士-3">博士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271528443.png"alt="image-20240827152836349" /><figcaption aria-hidden="true">image-20240827152836349</figcaption></figure><h2 id="网络空间安全学院">网络空间安全学院</h2><h3 id="直博">直博</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271529796.png"alt="image-20240827152917720" /><figcaption aria-hidden="true">image-20240827152917720</figcaption></figure><h3 id="硕士-4">硕士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271529294.png"alt="image-20240827152951220" /><figcaption aria-hidden="true">image-20240827152951220</figcaption></figure><h2 id="深研院">深研院</h2><h3 id="博士-4">博士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271608367.png"alt="image-20240827160815315" /><figcaption aria-hidden="true">image-20240827160815315</figcaption></figure><h3 id="硕士-5">硕士</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408271609817.png"alt="image-20240827160923740" /><figcaption aria-hidden="true">image-20240827160923740</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【保研天梯】</title>
      <link href="/2024/05/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90%E4%BF%9D%E7%A0%94%E5%A4%A9%E6%A2%AF%E3%80%91/"/>
      <url>/2024/05/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90%E4%BF%9D%E7%A0%94%E5%A4%A9%E6%A2%AF%E3%80%91/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201341313.jpg"alt="7c64a3f6bf1aee01a1863e690a0484a" /><figcaptionaria-hidden="true">7c64a3f6bf1aee01a1863e690a0484a</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201341136.jpg"alt="c002fed944e0a70de4320ea7378f8ee" /><figcaptionaria-hidden="true">c002fed944e0a70de4320ea7378f8ee</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201341866.jpg"alt="fd8579f11f080d0838b4d187b8860ce" /><figcaptionaria-hidden="true">fd8579f11f080d0838b4d187b8860ce</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201341112.jpg"alt="f577c6cd8448b671c53ce926ed2d4c4" /><figcaptionaria-hidden="true">f577c6cd8448b671c53ce926ed2d4c4</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201341166.jpg"alt="8f283c6de1063b64e012aea5b9ee2e4" /><figcaptionaria-hidden="true">8f283c6de1063b64e012aea5b9ee2e4</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409261933906.jpg"alt="b8f640b54f785376a2ed83b4f989f2e" /><figcaptionaria-hidden="true">b8f640b54f785376a2ed83b4f989f2e</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409261933418.jpg"alt="e93f6f7ef0f8d32cc2c2482c6f96c1b" /><figcaptionaria-hidden="true">e93f6f7ef0f8d32cc2c2482c6f96c1b</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409261933149.jpg"alt="36c915056e9ed7db36a1d603a74f4ac" /><figcaptionaria-hidden="true">36c915056e9ed7db36a1d603a74f4ac</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409261934384.jpg"alt="394406d2470a7146e114fdde40c8403" /><figcaptionaria-hidden="true">394406d2470a7146e114fdde40c8403</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409261936323.jpg"alt="b08b542bb172f7bcdcef2cedf017b80" /><figcaptionaria-hidden="true">b08b542bb172f7bcdcef2cedf017b80</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【报考数量】</title>
      <link href="/2024/05/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90%E6%8A%A5%E8%80%83%E6%95%B0%E9%87%8F%E3%80%91/"/>
      <url>/2024/05/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90%E6%8A%A5%E8%80%83%E6%95%B0%E9%87%8F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201339912.jpeg"alt="1b30d588c93c5675b29a09a480e43365" /><figcaptionaria-hidden="true">1b30d588c93c5675b29a09a480e43365</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【7.元组、集合和字典】</title>
      <link href="/2024/05/02/%5Bobject%20Object%5D/python/%E3%80%907.%E5%85%83%E7%BB%84%E3%80%81%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8%E3%80%91/"/>
      <url>/2024/05/02/%5Bobject%20Object%5D/python/%E3%80%907.%E5%85%83%E7%BB%84%E3%80%81%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="元组集合和字典">【7.元组、集合和字典】</h1><p>列表、集合和字典是Python最常使用的数据结构。——闫学灿</p><h2 id="元组">元组</h2><p>元组跟<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/10015276/">列表</a>类似，只是不支持动态添加、修改、删除元素</p><h3 id="元组的初始化">元组的初始化</h3><p>元组需要用小括号括起来，中间的元素用逗号隔开。</p><blockquote><p>注意，如果初始化只包含一个元素的元组，需要在该元素后添加逗号。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = ()      <span class="comment"># 初始化一个空元组</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 含有2个整数的元组</span></span><br><span class="line">c = <span class="number">6</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">3.14</span>   <span class="comment"># 小括号可以省略，等价于(6, &quot;Python&quot;, 3.14)</span></span><br><span class="line">d = (<span class="number">5</span>,)    <span class="comment"># 注意不能写成(5)，(5)表示整数5，因为这里()被认为是用来改变运算符的优先级</span></span><br><span class="line">e = <span class="number">5</span>,  <span class="comment"># 等价于(5,)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e)</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="元组的解包">元组的解包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&quot;Hello!&quot;</span>  <span class="comment"># 初始化一个元组</span></span><br><span class="line">x, y, z = t  <span class="comment"># 将元组解包，将元组内的三个值按顺序赋值给x、y、z</span></span><br><span class="line"><span class="built_in">print</span>(x, y, z)</span><br></pre></td></tr></table></figure><p>所以，<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/9960888/">2.判断语句</a>中学习的交换操作，本质上是元组的解包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">3</span>, <span class="number">4</span>  <span class="comment"># 将元组(3, 4)解包，分别赋值给a、b</span></span><br><span class="line">a, b = b, a  <span class="comment"># 将元组(b, a)解包，分别赋值给a、b</span></span><br></pre></td></tr></table></figure><p>同样地，<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/10200082/">6.函数</a>中函数返回多个值，本质上也是返回了一个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y, x * y  <span class="comment"># 等价于 return (x + y, x * y)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">s, p = calc(x, y)  <span class="comment"># 将(x + y, x * y)解包，分别赋值给s、p</span></span><br><span class="line"><span class="built_in">print</span>(s, p)</span><br></pre></td></tr></table></figure><h3 id="元组的比较运算">元组的比较运算</h3><p>元组和列表均支持比较运算符：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>等，按字典序进行比较。</p><h3 id="元组的其他操作">元组的其他操作</h3><p>元组的下标访问元素、循环遍历、切片、加法和乘法运算等操作，都与<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/10015276/">列表</a>相同。</p><hr /><h2 id="集合">集合</h2><p>集合是Python中最常用的数据结构之一，用来存储不同元素。</p><p>注意，集合中的元素是无序的。</p><h3 id="集合的初始化">集合的初始化</h3><p>创建集合<code>&#123;&#125;</code>或<code>set()</code>函数。注意：创建空集合只能用<code>set()</code>，不能用<code>&#123;&#125;</code>，因为<code>&#123;&#125;</code>创建的是空字典，会在下一小节里介绍字典。</p><p>集合常见的初始化方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;  <span class="comment"># 会自动去除重复元素</span></span><br><span class="line"><span class="built_in">print</span>(basket)  <span class="comment"># 重复的元素已经去除了</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>()  <span class="comment"># 初始化一个空列表</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">b = <span class="built_in">set</span>(a)<span class="comment"># 将列表转化成集合，一般是为了去重。</span></span><br><span class="line">c = <span class="built_in">list</span>(b)<span class="comment"># 将集合转化回列表</span></span><br><span class="line"><span class="built_in">print</span>(b, c)</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;abracadabra&quot;</span></span><br><span class="line">a = <span class="built_in">set</span>(x)  <span class="comment"># 将字符串中的每个字符存到集合中</span></span><br><span class="line">b = <span class="built_in">str</span>(a)  <span class="comment"># 注意，这里并不能将集合转化回原字符串，而是用格式化表示集合中的内容</span></span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure><h3 id="集合的常用操作">集合的常用操作</h3><p>假设<code>a</code>表示一个集合。</p><ul><li><code>len(a)</code> 返回集合中包含的元素数量。</li><li><code>a.add(x)</code> 在集合中添加一个元素。</li><li><code>a.remove(x)</code>删除集合中的<code>x</code>，如果<code>x</code>不存在，则报异常。</li><li><code>a.discard(x)</code>删除集合中的<code>x</code>，如果<code>x</code>不存在，则不进行任何操作。</li><li><code>x in a</code> 判断<code>x</code>是否在<code>a</code>中。</li><li><code>x not in a</code>判断<code>x</code>是否不在<code>a</code>中。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 输出3</span></span><br><span class="line"></span><br><span class="line">a.add(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;1, 2, 3, 4&#125;，注意集合中的元素是无序的。</span></span><br><span class="line"></span><br><span class="line">a.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;1, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  a.remove(5)  # 因为5不存在，所以会报异常</span></span><br><span class="line">a.discard(<span class="number">5</span>)  <span class="comment"># 因为5不存在，所以不进行任何操作</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># &#123;1, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用for循环遍历集合">使用<code>for</code>循环遍历集合</h3><p>类似于列表，集合也可以用<code>for ... in ...</code>的形式遍历。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:  <span class="comment"># 循环遍历整个集合</span></span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><hr /><h2 id="字典">字典</h2><p>字典是Python中最常用的数据结构之一，用来存储映射关系。<br />注意，字典中的元素是无序的。</p><p>不同于列表，字典是以<code>key</code>进行索引的，可以将每个<code>key</code>映射到某个<code>value</code>。<code>key</code>可以是任何不可变类型，常用可以作为<code>key</code>的类型有数字和字符串。列表因为是可变的，所以不能作为<code>key</code>。<code>value</code>可以是任意类型。</p><h3 id="字典的初始化">字典的初始化</h3><p>创建字典用花括号或<code>dict()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;  <span class="comment"># 创建一个字典</span></span><br><span class="line"><span class="built_in">print</span>(tel)  <span class="comment"># 输出 &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>()  <span class="comment"># 创建一个空字典</span></span><br><span class="line">a[<span class="number">123</span>] = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line">a[<span class="number">456</span>] = <span class="string">&quot;def&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;123: &#x27;abc&#x27;, 456: &#x27;def&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">list</span>(a)  <span class="comment"># 将字典的关键字转化成列表</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出[123, 456]</span></span><br></pre></td></tr></table></figure><h3 id="字典的常用操作">字典的常用操作</h3><p>假设<code>a</code>表示一个字典。</p><ul><li><code>len(a)</code>：返回字典中的元素对数。</li><li><code>a[x]</code>：获取关键字<code>x</code>对应的值，如果<code>x</code>不存在，会报异常。</li><li><code>a.get(x)</code>：获取关键字<code>x</code>对应的值，如果<code>x</code>不存在，会返回<code>None</code>，不会报异常。</li><li><code>a.get(x, y)</code>：获取关键字<code>x</code>对应的值，如果<code>x</code>不存在，会返回默认值<code>y</code>，不会报异常。</li><li><code>a[x] = y</code>：在字典中插入一对元素，如果关键字<code>x</code>已存在，则将它之前映射的值覆盖掉。</li><li><code>del a[x]</code>：删除关键字<code>x</code>对应的元素对，如果<code>x</code>不存在，会报异常。</li><li><code>x in a</code>：检查字典中是否存在关键字<code>x</code>。</li><li><code>x not in a</code>：检查字典中是否不存在关键字<code>x</code>。</li><li><code>a.keys()</code>：返回字典的所有<code>key</code>。</li><li><code>a.values()</code>：返回字典的所有<code>value</code>。</li><li><code>a.items()</code>：返回字典的所有由<code>key</code>和<code>value</code>组成的元组。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;def&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;python&#x27;</span>: <span class="number">3</span>&#125;  <span class="comment"># 初始化一个字典</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))           <span class="comment"># 输出3</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;def&#x27;</span>])         <span class="comment"># 输出2</span></span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;def&#x27;</span>))     <span class="comment"># 输出2</span></span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">5</span>))  <span class="comment"># 因为&#x27;xyz&#x27;不存在，所以输出默认值5</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;hello&#x27;</span>] = <span class="number">4</span>  <span class="comment"># 插入一对元素 &#x27;hello&#x27; -&gt; 4</span></span><br><span class="line"><span class="built_in">print</span>(a)        <span class="comment"># 输出&#123;&#x27;abc&#x27;: 1, &#x27;def&#x27;: 2, &#x27;python&#x27;: 3, &#x27;hello&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;def&#x27;</span>] = <span class="number">5</span>    <span class="comment"># 更新&#x27;def&#x27;映射的值</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;def&#x27;</span>]) <span class="comment"># 输出5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;python&#x27;</span>]  <span class="comment"># 删除关键字&#x27;python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)         <span class="comment"># 输出&#123;&#x27;abc&#x27;: 1, &#x27;def&#x27;: 5, &#x27;hello&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> a)  <span class="comment"># 输出True</span></span><br><span class="line"><span class="built_in">print</span>(a.keys())      <span class="comment"># 输出dict_keys([&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;hello&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(a.values())    <span class="comment"># 输出dict_values([1, 5, 4])</span></span><br><span class="line"><span class="built_in">print</span>(a.items())     <span class="comment"># 输出dict_items([(&#x27;abc&#x27;, 1), (&#x27;def&#x27;, 5), (&#x27;hello&#x27;, 4)])</span></span><br></pre></td></tr></table></figure><h3 id="使用for循环遍历字典">使用<code>for</code>循环遍历字典</h3><p>类似于列表，字典也可以用<code>for ... in ...</code>的形式遍历。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;abc&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;def&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;python&#x27;</span>: <span class="number">3</span>&#125;  <span class="comment"># 初始化一个字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> a:  <span class="comment"># 遍历key</span></span><br><span class="line">    <span class="built_in">print</span>(k, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> a.keys():<span class="comment"># 遍历key</span></span><br><span class="line">    <span class="built_in">print</span>(k, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a.values():  <span class="comment"># 遍历value</span></span><br><span class="line">    <span class="built_in">print</span>(v, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> a.items():  <span class="comment"># 遍历key-value对</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s, %d) &quot;</span> % (k, v), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><hr /><h2 id="作业题扩展内容">作业题扩展内容</h2><ol type="1"><li><code>map()</code>也可以用<code>for ... in ...</code>的形式遍历。例如：<code>for x in map(int, input().split())</code>可以遍历一行内用空格隔开的每个整数。</li><li><code>map()</code>函数的返回值也可以直接转化成<code>set()</code>，例如：<code>set(map(int, input().split()))</code>可以将一行用空格隔开的整数存到<code>set()</code>中。</li><li><code>sorted()</code>函数可以将列表、元组、集合、字典排序，并返回一个新列表。如果对字典排序，则返回字典所有<code>key</code>排序后的列表。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6.函数】</title>
      <link href="/2024/05/01/%5Bobject%20Object%5D/python/%E3%80%906.%E5%87%BD%E6%95%B0%E3%80%91/"/>
      <url>/2024/05/01/%5Bobject%20Object%5D/python/%E3%80%906.%E5%87%BD%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="函数">【6.函数】</h1><p>当代码中需要重复使用相同的逻辑时，可以使用函数来减少代码量。当代码较长时，可以使用函数来将逻辑分割成若干部分，使代码结构更容易让人看懂。</p><p>Python中函数的用法非常多，80%的用法不常用，20%的用法常用。大家不要把精力浪费在背完所有用法上，而要把主要精力放到最常用的20%的用法和代码逻辑上，至于另外80%不常用的用法，边用边查就行。</p><h2 id="函数基础">函数基础</h2><p>Python中一个典型的函数定义包括以下部分：关键字<code>def</code>、函数名称、由<span class="math inline">\(0\)</span>个或多个形参组成的列表以及函数体。</p><h3 id="编写函数">编写函数</h3><p>我们来编写一个求阶乘的函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        res *= i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>函数名称是<code>fact</code>，给它传入一个<code>n</code>，会返回<code>n</code>的阶乘。<code>return</code>语句负责结束函数并返回<code>res</code>的值。</p><span id="more"></span><h3 id="调用函数">调用函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我们要计算5的阶乘，答案是：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fact(<span class="number">5</span>))  <span class="comment"># 输出 120</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算结束啦！&quot;</span>)</span><br></pre></td></tr></table></figure><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用的函数。此时，代码原本的执行顺序被暂时中断，被调函数开始执行。等被调用函数执行完后，再继续执行之前的代码。</p><h3 id="形参和实参">形参和实参</h3><p>实参指调用函数时传入的变量或常量，形参指定义函数时参数列表里的变量。</p><p>形参列表可以为空，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f()  <span class="comment"># 输出 Hello World</span></span><br></pre></td></tr></table></figure></p><h4 id="形参的初始化方式">形参的初始化方式</h4><p>调用函数时会用实参去初始化形参，初始化的顺序有两种：</p><p>第一种是用<font color='blue'><strong>位置实参</strong></font>(positionalargument)来初始化形参。顾名思义，实参会按位置关系来初始化形参，第一个实参初始化第一个形参，第二个实参初始化第二个形参，依此类推。形参和实参的个数必须匹配。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c, d</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d)</span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="literal">True</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">4.2</span>)  <span class="comment"># 输出 a = 1, b = True, c = Python, d = 4.2</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">True</span>, <span class="string">&quot;Python&quot;</span>, <span class="number">4.2</span>, <span class="number">3</span>)  <span class="comment"># 会报错，因为实参个数多于形参</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">True</span>, <span class="string">&quot;Python&quot;</span>)  <span class="comment"># 会报错，因为实参个数少于形参</span></span><br></pre></td></tr></table></figure></p><p>第二种是用<font color='blue'><strong>关键字实参</strong></font>(keywordargument)来初始化形参。此时实参不再按位置关系来初始化形参，而是按变量名初始化。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f()的定义如上所述</span></span><br><span class="line">f(b=<span class="number">1</span>, c=<span class="literal">True</span>, a=<span class="string">&quot;Python&quot;</span>, d=<span class="number">4.2</span>)  <span class="comment"># 输出 a = Python, b = 1, c = True, d = 4.2</span></span><br></pre></td></tr></table></figure><p>两种方式也可以混合使用，但是<strong><font color='blue'>位置实参</font>一定要放到<font color='blue'>关键字实参</font>(defaultargument)<font color='red'>之前</font></strong></p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f()的定义如上所述</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, d=<span class="string">&quot;Python&quot;</span>, c=<span class="number">4.2</span>)  <span class="comment"># 输出 a = 1, b = 2, c = 4.2, d = Python</span></span><br><span class="line">f(<span class="number">1</span>, b=<span class="number">3</span>, <span class="string">&quot;Python&quot;</span>, d=<span class="number">4.2</span>)  <span class="comment"># 会报错，因为位置实参位于关键字实参后面了。</span></span><br></pre></td></tr></table></figure><h4 id="带默认值的形参">带默认值的形参</h4><p>形参也可以设置默认值，当某些形参没有被初始化时，这些形参会<strong>使用默认值</strong>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c=<span class="number">3</span>, d=<span class="string">&quot;Python&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># c和d没有被初始化，采用默认值。输出 a = 1, b = 2, c = 3, d = Python</span></span><br><span class="line">f(<span class="number">1</span>, b=<span class="number">2</span>, d=<span class="string">&quot;AcWing&quot;</span>)  <span class="comment"># c没有被初始化，采用默认值。输出 a = 1, b = 2, c = 3, d = AcWing</span></span><br></pre></td></tr></table></figure><p><strong><font color='blue'>无默认值的形参</font>(non-defaultargument)一定要放到<font color='blue'>带默认值的形参</font>(defaultargument)<font color='red'>之前</font></strong>。例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 会报错，因为无默认值的形参位于带默认值的形参后面了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">c=<span class="number">3</span>, d=<span class="string">&quot;Python&quot;</span>, a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c, end=<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d)</span><br></pre></td></tr></table></figure><h4 id="其它参数写法">其它参数写法</h4><p>其它参数写法用得不多，想了解的同学可以参考<ahref="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#more-on-defining-functions">函数定义详解</a>。</p><h3 id="变量的作用域">变量的作用域</h3><p>函数内定义的变量为局部变量，只能在函数内部使用。</p><p>当需要修改用全局变量时，需要用<code>global</code>关键字在函数内声明全局变量。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">global</span> x  <span class="comment"># 在函数内声明全局变量</span></span><br><span class="line">    x = <span class="number">666</span></span><br><span class="line">    y = <span class="number">777</span></span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f()  <span class="comment"># 输出 666 777</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 会发现全局变量x也被修改了</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 会报错，因为y是局部变量，函数外无法使用</span></span><br></pre></td></tr></table></figure></p><h3 id="嵌套定义函数">嵌套定义函数</h3><p>函数内部也可以定义函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):  <span class="comment"># 定义函数g()</span></span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    g(<span class="number">5</span>)  <span class="comment"># 调用函数g()</span></span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f()  <span class="comment"># 输出6</span></span><br></pre></td></tr></table></figure></p><h3 id="pass语句"><code>pass</code>语句</h3><p>当函数定义完但还不想实现时，可以用<code>pass</code>占位符，来避免出现语法错误。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr /><h2 id="参数传递">参数传递</h2><h3 id="值传递">值传递</h3><p><code>int</code>、<code>float</code>、<code>bool</code>、字符串等采用<font color='red'><strong>值传递</strong></font>。</p><p>将实参的初始值拷贝给形参。此时，对形参的改动不会影响实参的初始值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">y</span>):</span><br><span class="line">    y = <span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">f(x)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 会发现x的值没变</span></span><br></pre></td></tr></table></figure></p><h3 id="引用传递">引用传递</h3><p>列表采用<font color='red'><strong>引用传递</strong></font>。</p><p>将实参的引用传给形参，此时对形参的修改会影响实参的初始值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">        b[i] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">f(a)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 会发现列表a中的每个数加了1</span></span><br></pre></td></tr></table></figure></p><hr /><h2 id="return语句"><code>return</code>语句</h2><p><span class="math inline">\(return\)</span>语句终止当前正在执行的函数并将控制权返回到调用该函数的地方，并返回结果。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 不写返回值时，会返回None</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>  <span class="comment"># 返回一个变量</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>, <span class="number">5</span>  <span class="comment"># 返回多个变量</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = f(<span class="number">1</span>)</span><br><span class="line">b = f(<span class="number">2</span>)</span><br><span class="line">c, d = f(<span class="number">3</span>)</span><br><span class="line">e = f(<span class="number">4</span>)  <span class="comment"># 没写return时，也会返回None</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e)  <span class="comment"># 输出 None 3 4 5 None</span></span><br></pre></td></tr></table></figure><hr /><h2 id="lambda表达式语法糖">lambda表达式（语法糖）</h2><p><code>lambda</code>关键字可以创建<strong>匿名函数</strong>（不占用函数名），目的是为了简化代码。可以对比下面两种写法，会发现<code>lambda</code>表达式的写法更短一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, g</span>):</span><br><span class="line">    g(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m called! %d %d&quot;</span> %(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法一：定义函数</span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">3</span>, <span class="number">4</span>, f))</span><br><span class="line"><span class="comment"># 法二：使用lambda匿名函数</span></span><br><span class="line"><span class="built_in">print</span>(foo(<span class="number">3</span>, <span class="number">4</span>, <span class="keyword">lambda</span> x, y : <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m called! %d %d&quot;</span> %(x, y))))</span><br></pre></td></tr></table></figure><p><code>lambda</code>常与<code>sort()</code>函数配合使用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pairs = [</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&quot;one&quot;</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="string">&quot;four&quot;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])  <span class="comment"># 依据第二个元素从小到大排序，如果希望从大到小排序则return -pair[1]</span></span><br><span class="line"><span class="built_in">print</span>(pairs)  <span class="comment"># 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]]</span></span><br></pre></td></tr></table></figure><p>等价于下面的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pairs = [</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&quot;one&quot;</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="string">&quot;four&quot;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">pair</span>):</span><br><span class="line">    <span class="keyword">return</span> pair[<span class="number">1</span>]<span class="comment"># 如果希望从大到小排序，则return -pair[1]</span></span><br><span class="line"></span><br><span class="line">pairs.sort(key=compare)  <span class="comment"># 每个元素使用第二个变量比较大小</span></span><br><span class="line"><span class="built_in">print</span>(pairs)  <span class="comment"># 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]]   </span></span><br></pre></td></tr></table></figure><hr /><h2 id="函数递归">函数递归</h2><p>在一个函数内部，也可以调用函数自身。这种写法被称为递归。</p><p>写递归函数可以从集合的角度来思考。理解递归函数的执行顺序可以用树的形式来思考。</p><p>例如，求解斐波那契数列第 <span class="math inline">\(n\)</span>项可以采用如下写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>​<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(fib(<span class="number">6</span>))  <span class="comment"># 输出 8</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【5.字符串】</title>
      <link href="/2024/04/30/%5Bobject%20Object%5D/python/%E3%80%905.%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91/"/>
      <url>/2024/04/30/%5Bobject%20Object%5D/python/%E3%80%905.%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串">【5.字符串】</h1><p>字符串是计算机与人类沟通的重要手段。——闫学灿</p><h2 id="字符与整数的联系ascii码">字符与整数的联系——ASCII码</h2><p>每个常用字符都对应一个<code>-128 ~ 127</code>的数字，二者之间可以相互转化。注意：目前负数没有与之对应的字符。</p><ul><li><p><code>ord()</code>函数可以求一个字符的ASCII码。注意输入是一个字符，而不是字符串。</p></li><li><p><code>chr()</code>函数可以将一个ASCII码转化成对应的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(c))</span><br><span class="line"></span><br><span class="line">a = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(a))</span><br></pre></td></tr></table></figure></li></ul><p>常用ASCII值：<code>'A'- 'Z'</code>是<code>65 ~ 90</code>，<code>'a' - 'z'</code>是<code>97 - 122</code>，<code>0 - 9</code>是<code>48 - 57</code></p><p><strong>注意</strong>：虽然字符可以跟整数相互转化，但在Python中，字符不能参与数值运算，这一点跟C++、Java等语言是不同的。</p><span id="more"></span><hr /><h2 id="字符串常量的写法">字符串常量的写法</h2><p>在 <span class="math inline">\(Python\)</span>中，字符串既可以用<strong>单引号</strong>来表示，也可以用<strong>双引号</strong>来表示，二者完全相同。</p><p>这一点跟 <span class="math inline">\(C++\)</span>、<spanclass="math inline">\(Java\)</span>等编程语言是不同的，在这些编程语言中，用单引号来表示字符，用双引号来表示字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;Hello World&quot;</span>  <span class="comment"># 双引号写法</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b = <span class="string">&#x27;Hello World&#x27;</span>  <span class="comment"># 单引号写法</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>两个或多个字符串常量并排写，会被自动合并，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;My &quot;</span> <span class="string">&quot;name &quot;</span> <span class="string">&quot;is yxc.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出：My name is yxc.</span></span><br></pre></td></tr></table></figure><p>一个字符串如果包含多行，可以采用<code>"""..."""</code>或者<code>'''...'''</code>的初始化方式，字符串中将自动包含回车字符，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;&quot;&quot;Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">    -h                        Display this usage message</span></span><br><span class="line"><span class="string">    -H hostname               Hostname to connect to&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>会得到如下输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Usage: <span class="title">thingy</span> [<span class="title">OPTIONS</span>]</span></span><br><span class="line"><span class="function">    -<span class="title">h</span>                        <span class="title">Display</span> <span class="title">this</span> <span class="title">usage</span> <span class="title">message</span></span></span><br><span class="line"><span class="function">    -<span class="title">H</span> <span class="title">hostname</span>               <span class="title">Hostname</span> <span class="title">to</span> <span class="title">connect</span> <span class="title">to</span></span></span><br></pre></td></tr></table></figure><hr /><h2 id="表示特殊字符转义">表示特殊字符——转义</h2><p>当想在字符串中表示特殊字符时，一般可以在字符前加反斜杠<code>\</code>。常见需要转义的字符有：</p><table><thead><tr class="header"><th>转义字符</th><th>含义</th><th>ASCII码（十进制）</th></tr></thead><tbody><tr class="odd"><td><code>\n</code></td><td>回车</td><td>10</td></tr><tr class="even"><td><code>\\</code></td><td>代表一个反斜杠 <code>\</code></td><td>92</td></tr><tr class="odd"><td><code>\"</code></td><td>表示一个双引号</td><td>34</td></tr><tr class="even"><td><code>\'</code></td><td>表示一个单引号</td><td>39</td></tr></tbody></table><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is:\n\&quot;yxc!\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>会得到如下输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span>:</span><br><span class="line"><span class="string">&quot;yxc!&quot;</span></span><br></pre></td></tr></table></figure><p>另外，如果想输出单引号，也可以用双引号来表示，反之亦然。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#x27;yxc!&#x27;&quot;</span>)  <span class="comment"># 输出：My name is &#x27;yxc!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My name is &quot;yxc!&quot;&#x27;</span>)  <span class="comment"># 输出：My name is &quot;yxc!&quot;</span></span><br></pre></td></tr></table></figure><hr /><h2 id="访问字符串中的每个字符">访问字符串中的每个字符</h2><p>可以通过下标读取字符串中的每个字符，下标从<spanclass="math inline">\(0\)</span>开始，也可以是负数，负数下标表示的是除以字符串长度的<font color='red'><strong>余数</strong></font>对应的位置。</p><p>负数下标相当于将字符串首位相接，然后从0往前数。</p><p>如果字符串长度是 <spanclass="math inline">\(n\)</span>，那么下标只能取 <spanclass="math inline">\(-n \sim n - 1\)</span>之间的整数，超出范围会报错。</p><p><strong>注意</strong>：<font color='blue'><strong>字符串中的每个字符不能修改</strong></font>。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], <span class="built_in">ord</span>(a[<span class="number">5</span>]))  <span class="comment"># 输出H 32</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span>  <span class="comment"># 会报错，字符串不能修改</span></span><br></pre></td></tr></table></figure><hr /><h2 id="使用循环语句遍历字符串">使用循环语句遍历字符串</h2><p>可以通过下标访问，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;acwing&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(s[i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><p>可以通过<code>for ... in ...</code>直接遍历，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;python&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(c, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 注意c本身也是字符串类型</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><hr /><h2 id="字符串的切片操作">字符串的切片操作</h2><p>字符串的切片操作会返回一个新字符串。用法：</p><ul><li><code>a[begin:end]</code>会返回包含<code>a[begin], a[begin + 1], ..., a[end - 1]</code>的字符串。</li><li>省略<code>begin</code>时，<code>begin</code>的默认值是0。</li><li>省略<code>end</code>时，<code>end</code>的默认值是字符串长度。</li><li>如果<code>begin</code>或<code>end</code>是负数，表示的是除以字符串长度后的余数。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 输出BCD</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])  <span class="comment"># 输出BCDE</span></span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">4</span>])  <span class="comment"># 输出ABCD</span></span><br><span class="line"><span class="built_in">print</span>(a[:])  <span class="comment"># 输出ABCDE</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">4</span>:-<span class="number">1</span>])  <span class="comment"># 等价于print(a[1:4])</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：字符串的切片<font color='red'><strong>不支持</strong></font>写操作。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = <span class="string">&quot;XY&quot;</span>  <span class="comment"># 会报错，字符串不能修改</span></span><br></pre></td></tr></table></figure><hr /><h2 id="字符串的复制">字符串的复制</h2><p>跟<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/10015276/">列表</a>不同，字符串的每次复制操作，都会得到一个全新的字符串。</p><hr /><h2 id="字符串的运算">字符串的运算</h2><ul><li>字符串的<strong>加法</strong>可以将<strong>两个字符串拼接起来</strong>，得到一个新字符串。</li><li>字符串<strong>乘以一个整数</strong>，可以将<strong>若干个自身拼接起来</strong>，得到一个新字符串。</li><li>字符串<strong>支持比较运算符</strong>，按字典序比较大小。即如果两个字符串相同，则表示相等；否则找到两个字符串从左到右数第一个不一样的字符，哪个字符串的字符的ASCII码小，哪个字符串的字典序就小；另外空字符比任何字符都小。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;Hello &quot;</span></span><br><span class="line">b = <span class="string">&quot;World&quot;</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出Hello World</span></span><br><span class="line"></span><br><span class="line">d = a * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出Hello Hello Hello</span></span><br><span class="line"></span><br><span class="line">e = a * <span class="number">3</span> + <span class="string">&quot;World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(e)  <span class="comment"># 输出Hello Hello Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &lt;= b)  <span class="comment"># 按字典序比较大小，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span> &gt; <span class="string">&quot;22&quot;</span>)  <span class="comment"># 按字典序比较大小，输出False</span></span><br></pre></td></tr></table></figure><hr /><h2 id="字符串的常用操作">字符串的常用操作</h2><p>假设<code>s</code>是一个字符串，则：</p><ul><li><code>len(s)</code>返回字符串长度。</li><li><code>s.split(sep)</code>返回一个字符串列表。如果给出了<code>sep</code>就按<code>sep</code>分隔；如果没给出，则会按空格分隔，但连续的空格会被视为单个分隔符，而且会忽略首尾的空白字符。</li><li><code>s.strip()</code>将首尾的空白字符删除。</li><li><code>s.replace(old, new)</code>将<code>s</code>中所有的<code>old</code>子串都改成<code>new</code>。</li><li><code>s.find("abc")</code>查询某个子串在<code>s</code>中第一次出现的下标；如果不存在，则返回-1。</li><li><code>s.startswith(prefix)</code>判断<code>prefix</code>是否为<code>s</code>的前缀。</li><li><code>s.endswith(suffix)</code>判断<code>suffix</code>是否为<code>s</code>的后缀。</li><li><code>s.lower()</code>将所有大写字母变成小写。</li><li><code>s.upper()</code>将所有小写字母变成大写。</li><li><code>s.join(a)</code>，<code>a</code>是一个字符串列表，这个函数返回将<code>a</code>中的字符用<code>s</code>作为分隔符拼接起来的结果。</li></ul><p><strong>注意</strong>：返回的所有字符串都是新字符串，原字符串不变。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;abc def xyz&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s1))  <span class="comment"># 输出11</span></span><br><span class="line"><span class="built_in">print</span>(s1.split())  <span class="comment"># 输出[&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;xyz&#x27;]</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">&quot;  abc abc  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s2.strip())  <span class="comment"># 输出abc abc</span></span><br><span class="line"><span class="built_in">print</span>(s2.replace(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;*&quot;</span>))  <span class="comment"># 输出  * *</span></span><br><span class="line"><span class="built_in">print</span>(s2.find(<span class="string">&quot;abc&quot;</span>), s2.find(<span class="string">&quot;xyz&quot;</span>))  <span class="comment"># 输出2 -1</span></span><br><span class="line"></span><br><span class="line">s3 = <span class="string">&quot;Abc deF&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s3.startswith(<span class="string">&quot;Ab&quot;</span>))  <span class="comment"># 输出True</span></span><br><span class="line"><span class="built_in">print</span>(s3.endswith(<span class="string">&quot;deF&quot;</span>))  <span class="comment"># 输出True</span></span><br><span class="line"><span class="built_in">print</span>(s3.lower())  <span class="comment"># 输出abc def</span></span><br><span class="line"><span class="built_in">print</span>(s3.upper())  <span class="comment"># 输出ABC DEF</span></span><br><span class="line"></span><br><span class="line">s4 = <span class="string">&quot;, &quot;</span></span><br><span class="line">a = [<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(s4.join(a))  <span class="comment"># 输出aa, bb, cc</span></span><br></pre></td></tr></table></figure><h2 id="更复杂的格式化输出">更复杂的格式化输出</h2><p>当需要用到更复杂的格式化输出时，现查即可。可以参考：</p><ul><li><ahref="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#formatted-string-literals">更复杂的输出格式</a></li><li><ahref="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting">printf风格的字符串格式化</a></li></ul><hr /><h2 id="作业题扩展内容">作业题扩展内容</h2><ol type="1"><li><p>作业的评测器会自动忽略每一行的行末空格，所以行末输出多余空格也视为正确。</p></li><li><p><code>s.isdigit()</code>：当字符串<code>s</code>不是空字符串，且包含的所有字符都是数字时返回True，否则返回False。</p></li><li><p><code>a, b = ["abc", "def"]</code>这种写法可以将<code>"abc"</code>赋值给第一个变量<code>a</code>，将<code>"def"</code>赋值给第二个变量<code>b</code>。</p></li><li><p><code>s.rfind("abc")</code>查询某个子串在<code>s</code>中最后一次出现的下标；如果不存在，则返回-1。</p></li><li><p>当不知道读入的具体行数时，可以采用如下方法一次性读取所有行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdin.readlines():</span><br><span class="line">    <span class="built_in">print</span>(line.strip())  <span class="comment"># strip()是为了去掉行末的回车</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【4.列表】</title>
      <link href="/2024/04/29/%5Bobject%20Object%5D/python/%E3%80%904.%E5%88%97%E8%A1%A8%E3%80%91/"/>
      <url>/2024/04/29/%5Bobject%20Object%5D/python/%E3%80%904.%E5%88%97%E8%A1%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="列表">【4.列表】</h1><p>程序 = 数据 + 算法，列表是存储数据的强而有力的手段。 ——闫学灿</p><p>列表是一种常见的变量类型，可以存储一列元素。元素的类型可以不同，不过大多数情况下类型是相同的。</p><h2 id="列表的初始化">列表的初始化</h2><p>列表需要用方括号 <code>[]</code>括起来，中间的元素用逗号隔开，最后一个元素后可以多加一个逗号。</p><h3 id="直接初始化">直接初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []                    <span class="comment"># 定义一个空列表</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>]                <span class="comment"># 含有2个整数的列表</span></span><br><span class="line">c = [<span class="number">6</span>, <span class="string">&quot;python&quot;</span>, <span class="number">3.14</span>]   <span class="comment"># 含有3个不同类型元素的列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure><h3 id="通过append函数初始化">通过<code>append</code>函数初始化</h3><p><code>append()</code>函数可以在列表末尾添加一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  <span class="comment"># 初始化[0, 0, 0, 0, 0]</span></span><br><span class="line">    a.append(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 初始化[0, 1, 4, 9]</span></span><br><span class="line">    b.append(i * i)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><span id="more"></span><h3id="通过for语句初始化列表长度和每个位置的数值">通过<code>for</code>语句初始化列表长度和每个位置的数值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]  <span class="comment"># 初始化[0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">b = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 初始化[0, 1, 4, 9]</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><hr /><h2 id="访问列表元素">访问列表元素</h2><p>可以通过下标读/写列表中的元素，下标从0开始，也可以是负数，负数下标表示的是除以列表长度的余数对应的位置。</p><p>负数下标相当于将列表首位相接，然后从0往前数。</p><p>如果列表长度是 <span class="math inline">\(n\)</span>，那么下标只能取<span class="math inline">\(-n \sim n - 1\)</span>之间的整数，超出范围会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])  <span class="comment"># 读取列表中每个位置的值</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># 给列表中的某个位置写值</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">1</span>])  <span class="comment"># 由于-1 % 3 = 2，所以表示的是a[2]</span></span><br></pre></td></tr></table></figure><hr /><h2 id="使用循环语句遍历列表">使用循环语句遍历列表</h2><p>可以通过下标访问，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(a[i], end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以通过<code>for ... in ...</code>直接遍历，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>练习题： 假设斐波那契数列的前两项分别是 <spanclass="math inline">\(a\_0 = 0, a\_1 = 1\)</span>, 求 <spanclass="math inline">\(a\_n\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[n])</span><br></pre></td></tr></table></figure><hr /><h2 id="列表的切片操作">列表的切片操作</h2><p>列表的切片操作会返回一个新列表。用法：</p><ul><li><code>a[begin : end]</code>会返回包含<code>a[begin], a[begin + 1], ..., a[end - 1]</code>的列表。</li><li>省略<code>begin</code>时，<code>begin</code>的默认值是0。</li><li>省略<code>end</code>时，<code>end</code>的默认值是列表长度</li></ul><blockquote><p>如果<code>begin</code>或<code>end</code>是负数，表示的是除以列表长度后的<strong>余数</strong></p></blockquote><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">4</span>])   <span class="comment"># 输出[1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])    <span class="comment"># 输出[1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(a[:<span class="number">4</span>])    <span class="comment"># 输出[0, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(a[:])     <span class="comment"># 输出[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">4</span>:-<span class="number">1</span>]) <span class="comment"># 等价于print(a[1:4])</span></span><br></pre></td></tr></table></figure><p>切片也支持写操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出[0, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>联系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片的语法：[起始:结束:步长] 字符串[start: end: step]</span></span><br><span class="line"><span class="comment"># 这三个参数都有默认值，默认截取方向是从左往右的</span></span><br><span class="line"><span class="comment"># start:默认值为0； end : 默认值未字符串结尾元素； step : 默认值为1；</span></span><br><span class="line"><span class="comment"># 如果切片步长是负值，截取方向则是从右往左的</span></span><br><span class="line">name = <span class="string">&#x27;molly&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(name[-<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(name[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==================================================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小练习</span></span><br><span class="line">string = <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(string[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(string[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(string[<span class="number">3</span>:])</span><br><span class="line"><span class="built_in">print</span>(string[<span class="number">8</span>:<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># ERROR</span></span><br><span class="line"><span class="built_in">print</span>(string[<span class="number">2</span>:<span class="number">8</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==================================================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印字符串中的每个字符</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> string:</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==================================================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果字符串以&#x27;p&#x27;结尾，则打印</span></span><br><span class="line">list_string = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana_p&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>,<span class="string">&#x27;cherry_p&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> list_string:</span><br><span class="line">    <span class="keyword">if</span> fruit[-<span class="number">1</span>] == <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(fruit)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==================================================&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果字符串以&#x27;pr&#x27;结尾，则打印</span></span><br><span class="line">list_string = [<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;banana_pr&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>,<span class="string">&#x27;cherry_pr&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> list_string:</span><br><span class="line">    <span class="keyword">if</span> fruit.endswith(<span class="string">&#x27;pr&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(fruit)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">o</span><br><span class="line">o</span><br><span class="line">oll</span><br><span class="line">yllom</span><br><span class="line">==================================================</span><br><span class="line">l</span><br><span class="line">llo</span><br><span class="line">lo world!</span><br><span class="line">row ol</span><br><span class="line"></span><br><span class="line">==================================================</span><br><span class="line">H</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line"> </span><br><span class="line">w</span><br><span class="line">o</span><br><span class="line">r</span><br><span class="line">l</span><br><span class="line">d</span><br><span class="line">!</span><br><span class="line">==================================================</span><br><span class="line">banana_p</span><br><span class="line">cherry_p</span><br><span class="line">==================================================</span><br><span class="line">banana_pr</span><br><span class="line">cherry_pr</span><br></pre></td></tr></table></figure><hr /><h2 id="列表的复制">列表的复制</h2><p>列表跟其他变量类型不同，如果用<strong>等号</strong>复制列表，那么<strong>原列表和新列表是<font color='red'>同一个列表</font></strong>。对新列表修改，会修改原列表的值。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># 会发现a[0]和b[0]都被修改了</span></span><br></pre></td></tr></table></figure><p>使用切片，可以得到一个原列表的<ahref="https://docs.python.org/zh-cn/3/library/copy.html">浅拷贝</a>。此时再修改新列表，原列表就不会发生变化了。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = a[:]</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a, b)  <span class="comment"># 会发现a[0]没有被修改</span></span><br></pre></td></tr></table></figure><hr /><h2 id="列表的运算">列表的运算</h2><ul><li>列表的<strong>加法</strong>可以将<strong>两个列表拼接</strong>起来，得到一个新列表。</li><li>列表<strong>乘以</strong>一个整数，可以将<strong>若干个自身拼接起来</strong>，得到一个新列表。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">c = a + b  <span class="comment"># c相当于a和b的浅拷贝</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出[0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">d = a * <span class="number">3</span>  <span class="comment"># d相当于a的浅拷贝</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出[0, 1, 2, 0, 1, 2, 0, 1, 2]</span></span><br><span class="line"></span><br><span class="line">a += [<span class="number">3</span>]  <span class="comment"># 在a的末尾添加一个新元素3</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出[0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><hr /><h2 id="列表的常用操作">列表的常用操作</h2><p>假设<code>a</code>是一个列表，则：</p><ul><li><code>len(a)</code> 返回列表长度。</li><li><code>a.append(x)</code> 在列表末尾添加一个新元素。</li><li><code>a.pop()</code> 删除列表的最后一个元素。</li><li><code>a.reverse()</code> 将整个列表翻转。</li><li><code>a.sort()</code> 将整个列表从小到大排序。</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 输出3</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出[0, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">a.pop()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 将[0, 1, 2, 3]的最后一个数删掉，所以输出[0, 1, 2]</span></span><br><span class="line"></span><br><span class="line">a.reverse()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出[2, 1, 0]</span></span><br><span class="line"></span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出[0, 1, 2]</span></span><br></pre></td></tr></table></figure><hr /><h2 id="嵌套列表">嵌套列表</h2><p>列表中的元素也可以是列表，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">matrix = [  <span class="comment"># 列表中的元素也可以是列表</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],  <span class="comment"># 最后一个元素后可以添加逗号</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">99</span>  <span class="comment"># 修改嵌套列表中元素的值</span></span><br><span class="line"><span class="built_in">print</span>(matrix[<span class="number">1</span>][<span class="number">0</span>])  <span class="comment"># 读取嵌套列表中元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):  <span class="comment"># 循环打印整个矩阵</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[i])):</span><br><span class="line">        <span class="built_in">print</span>(matrix[i][j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 在行末输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> matrix:  <span class="comment"># 循环打印整个矩阵</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 在行末输出回车</span></span><br></pre></td></tr></table></figure><p>嵌套列表的常用初始化方式有两种。</p><p>采用<code>append()</code>函数初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">matrix = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        row.append(i * <span class="number">3</span> + j)</span><br><span class="line">    matrix.append(row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matrix)</span><br></pre></td></tr></table></figure><p>采用<code>for</code>语句直接初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[i * <span class="number">3</span> + j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="built_in">print</span>(matrix)</span><br></pre></td></tr></table></figure><hr /><h2 id="作业题扩展内容">作业题扩展内容</h2><ol type="1"><li>当需要读入一行整数时，可以用：<code>a = list(map(int, input().split()))</code>。类似地，当需要读入一行浮点数时，可以用<code>a = list(map(float, input().split()))</code>：</li><li><code>min(a, b)</code>可以求两个数的最小值。类似得<code>min(a, b, c)</code>可以求三个数的最小值，以此类推。同样地<code>max()</code>可以求最大值。</li><li><code>a[::-1]</code>可以返回一个逆序的新列表。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【3.循环语句】</title>
      <link href="/2024/04/28/%5Bobject%20Object%5D/python/%E3%80%903.%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%91/"/>
      <url>/2024/04/28/%5Bobject%20Object%5D/python/%E3%80%903.%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="循环语句">【3.循环语句】</h1><h2 id="while循环"><code>while</code>循环</h2><p>可以简单理解为循环版的<code>if</code>语句。<code>if</code>语句是判断一次，如果条件成立，则执行后面的语句；<code>while</code>是每次判断，如果条件成立，则执行循环体中的语句，否则停止。</p><p>注意，类似于<code>if</code>语句，<code>while</code>语句也需要满足：</p><ul><li><p><code>while</code>后需要加上冒号<code>:</code></p></li><li><p><code>while</code>语句的代码块需要缩进统一长度，规范写法是缩进4个空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">  i += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><p>练习：求 <span class="math inline">\(1\sim 100\)</span>中所有数的立方和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    s += i ** <span class="number">3</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>练习：求斐波那契数列的第<code>n</code>项。<code>f(1) = 1</code>,<code>f(2) = 1</code>, <code>f(n) = f(n - 1) + f(n - 2)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a, b, i = <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    a, b = b, a + b<span class="comment"># 等号右侧的 a 表示 f(n - 2)、b 表示 f(n - 1)</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>死循环：循环永久执行，无法结束。我们要避免写出死循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><hr /><h2 id="for循环"><code>for</code>循环</h2><p><code>for</code>循环语句用来按顺序枚举<code>range</code>、字符串等数据类型中的元素。类似于<code>while</code>和<code>if</code>语句，<code>for</code>语句同样需要满足冒号和缩进的要求。</p><p>注意：本节课重在学习<code>for</code>循环，而非学习列表、元组、集合、字典等复杂数据类型，所以<code>for</code>语句与这些数据类型配合的使用技巧会放到下一章中展开。</p><h3 id="遍历字符串">遍历字符串</h3><p><code>for</code>语句可以遍历字符串中的每个字符。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;python&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(c, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 注意c本身也是字符串类型</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;acwing&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(c, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><h3 id="遍历range">遍历<code>range</code></h3><p><code>range()</code>函数可以生成等差数列，可以接收1个、2个或者3个整数参数：</p><ol type="1"><li>接收1个整数参数时：<code>range(x)</code>会按顺序返回 <spanclass="math inline">\(0, 1, 2, 3, … x - 1\)</span> 这个数列。</li><li>接收2个整数参数时：<code>range(x, y)</code>会按顺序返回 <spanclass="math inline">\(x, x + 1, x + 2, …, y - 1\)</span> 这个数列。</li><li>接收3个整数参数时：<code>range(x, y, z)</code>分为两种情况：<ul><li><code>z &gt; 0</code>时，按顺序返回 <span class="math inline">\(x, x+ z, x + 2z, x + 3z, …\)</span> 这个数列中小于 <spanclass="math inline">\(y\)</span> 的所有数。</li><li><code>z &lt; 0</code>时，按顺序返回 <span class="math inline">\(x, x+ z, x + 2z, x + 3z, …\)</span> 这个数列中大于 <spanclass="math inline">\(y\)</span> 的所有数。</li></ul></li></ol><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  <span class="comment"># 输出：0 1 2 3 4 </span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">8</span>):  <span class="comment"># 输出：3 4 5 6 7 </span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):  <span class="comment"># 输出：1 3 5 7 9 </span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">10</span>, -<span class="number">2</span>):  <span class="comment"># 输出：0 -2 -4 -6 -8 </span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><p>练习：求 <span class="math inline">\(1 \sim 100\)</span>中所有数的立方和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    s += i ** <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>练习：求斐波那契数列的第<code>n</code>项。<code>f(1) = 1</code>,<code>f(2) = 1</code>, <code>f(n) = f(n - 1) + f(n - 2)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">    a, b = b, a + b</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><hr /><h2 id="跳转语句">跳转语句</h2><h3 id="break">break</h3><p>可以提前从最近的一层循环中退出，一般与<code>if</code>语句搭配。</p><p>例题：判断一个大于 <span class="math inline">\(1\)</span>的整数是否是质数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">is_prime = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">        is_prime = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_prime:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="continue">continue</h3><p>可以跳过当前这次迭代后面的语句，并继续下一次迭代。作用与<code>if</code>语句类似。</p><p>例题：求 <span class="math inline">\(1 \sim 100\)</span>中所有偶数的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    s += i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><hr /><h2id="循环中的else子句和pass语句">循环中的<code>else</code>子句和<code>pass</code>语句</h2><p>本节内容用得不多，了解即可</p><h3 id="循环中的else子句">循环中的<code>else</code>子句</h3><p><code>for</code>或<code>while</code>循环可以包括<code>else</code>子句，会在<strong>循环结束后执行</strong>。不过<strong>如果循环是被<code>break</code>结束的，那么<code>else</code>子句就不会执行了</strong>。</p><p>例题：判断一个大于1的整数是否是质数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d = %d * %d&quot;</span> % (n, x, n // x))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 注意else是for语句的子句，所以需要与for语句对齐</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d is a prime number&quot;</span> % n)</span><br></pre></td></tr></table></figure><h3 id="pass语句"><code>pass</code>语句</h3><p>类似于<code>if</code>语句，当<code>for</code>或者<code>while</code>循环里不想写任何代码时，可以写上<code>pass</code>语句，这个语句不执行任何动作。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  <span class="comment"># 不进行任何操作</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 死循环</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr /><h2 id="多层循环">多层循环</h2><p><code>while</code>和<code>for</code>循环内的代码块中也可以包含循环语句。</p><p>例题：将 <span class="math inline">\(1\sim 100\)</span> 打印到一个<span class="math inline">\(10 * 10\)</span> 的矩阵中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(k, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 输出回车</span></span><br></pre></td></tr></table></figure><p>练习：打印 <span class="math inline">\(1 \sim 100\)</span>中的所有质数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line">    is_prime = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, i):</span><br><span class="line">        <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">            is_prime = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> is_prime:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><hr /><h2 id="作业题易错点">作业题易错点</h2><ol type="1"><li>注意多层<code>for</code>循环中所使用的循环变量尽量使用不同的变量名，防止相互干扰。</li><li>Python3中求一个数的绝对值，可以使用<code>abs()</code>函数。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2. 判断语句】</title>
      <link href="/2024/04/27/%5Bobject%20Object%5D/python/%E3%80%902.%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E3%80%91/"/>
      <url>/2024/04/27/%5Bobject%20Object%5D/python/%E3%80%902.%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="判断语句">【2. 判断语句】</h1><h2 id="if-语句">if 语句</h2><h3 id="基本if-else语句">基本if-else语句</h3><p>当条件成立时，执行某些语句；否则执行另一些语句。</p><p>注意：</p><ul><li><code>if</code>和<code>else</code>后需要加上冒号<code>:</code></li><li><code>if</code>语句的代码块需要缩进统一长度，规范写法是缩进4个空格。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法：</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d is big!&quot;</span> % a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d + 1 = %d&quot;</span> % (a, a + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d is small!&quot;</span> % a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d - 1 = %d&quot;</span> % (a, a - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误写法：</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;%d is big!&quot;</span> % a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d + 1 = %d&quot;</span> % (a, a + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d is small!&quot;</span> % a)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;%d - 1 = %d&quot;</span> % (a, a - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><span id="more"></span><p><code>else</code>语句可以省略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d is big!&quot;</span> % a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d + 1 = %d&quot;</span> % (a, a + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>当只有一条语句时，可以写在同一行，但这样写不规范，只要了解即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span>: <span class="built_in">print</span>(<span class="string">&quot;%d is big!&quot;</span> % a)</span><br><span class="line"><span class="keyword">else</span>: <span class="built_in">print</span>(<span class="string">&quot;%d is small!&quot;</span> % a)</span><br></pre></td></tr></table></figure><p>练习：输入一个整数，输出这个数的绝对值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(-x)</span><br></pre></td></tr></table></figure><p>练习：输入两个整数，输出两个数中较大的那个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p><code>if-else</code>语句内也可以是<code>if-else</code>语句。</p><p>练习：输入三个整数，输出三个数中最大的那个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    <span class="keyword">if</span> a &gt; c:</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> b &gt; c:</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><h3 id="常用比较运算符">常用比较运算符</h3><ol type="1"><li><p>大于 <code>&gt;</code></p></li><li><p>小于 <code>&lt;</code></p></li><li><p>大于等于 <code>&gt;=</code></p></li><li><p>小于等于 <code>&lt;=</code></p></li><li><p>等于 <code>==</code></p></li><li><p>不等于 <code>!=</code></p></li></ol><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d &gt; %d&quot;</span> % (a, b))</span><br><span class="line"><span class="keyword">if</span> a &gt;= b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d &gt;= %d&quot;</span> % (a, b))</span><br><span class="line"><span class="keyword">if</span> a &lt; b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d &lt; %d&quot;</span> % (a, b))</span><br><span class="line"><span class="keyword">if</span> a &lt;= b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d &lt;= %d&quot;</span> % (a, b))</span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d == %d&quot;</span> % (a, b))</span><br><span class="line"><span class="keyword">if</span> a != b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d != %d&quot;</span> % (a, b))</span><br></pre></td></tr></table></figure><h3 id="if-else连写"><code>if-else</code>连写</h3><p>注意：<code>else if</code>要写成<code>elif</code>。</p><p>练习：</p><p>输入一个0到100之间的分数，如果大于等于85，输出A；如果大于等于70并且小于85，输出B；如果大于等于60并且小于70，输出C；如果小于60，输出D；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s &gt;= <span class="number">85</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> s &gt;= <span class="number">70</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> s &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure><p>练习：</p><p>1.判断闰年。闰年有两种情况：</p><ol type="1"><li><p>能被100整除时，必须能被400整除；</p></li><li><p>不能被100整除时，被4整除即可。</p></li></ol><p>输入一个年份，如果是闰年输出<code>yes</code>，否则输出<code>no</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">year = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> year % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> year % <span class="number">400</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> year % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="pass-语句"><code>pass</code> 语句</h3><p><code>pass</code>语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 先空出来等以后再实现</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><h3 id="变量的作用域">变量的作用域</h3><p><code>if</code>语句内部的变量，可以在语句外访问（但在C/C++报错）。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    max_value = a</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    max_value = b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(max_value)</span><br></pre></td></tr></table></figure><h2 id="条件表达式">条件表达式</h2><ol type="1"><li><p>与 <code>and</code></p></li><li><p>或 <code>or</code></p></li><li><p>非 <code>not</code></p></li></ol><p>注意：运算符优先级：<code>not &gt; and &gt; or</code>。</p><p>练习：用一条<code>if</code>语句，判断闰年。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">year = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="三元运算">三元运算</h2><p>类似于C++、Java中的问号表达式。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">max_value = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"><span class="built_in">print</span>(max_value)</span><br></pre></td></tr></table></figure><h2 id="match语句">match语句</h2><p>python3.10开始新增了<code>match</code>语句。目前作业评测器的Python3采用旧版本，尚未支持<code>match</code>语法。</p><p>注意：</p><ul><li>只有第一个匹配的模式会被执行。且跟C++、Java不同，匹配后只会执行当前模式，不会顺次执行后面的<code>case</code>。</li><li>可以用 <code>|</code> 表示匹配多个模式。</li><li>变量名 <code>_</code> 被作为 通配符 并必定会匹配成功。</li><li>如果没有 <code>case</code> 匹配成功，则不会执行任何分支。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">status = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> status:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bad request&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">418</span> | <span class="number">420</span> | <span class="number">422</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m a teapot&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something&#x27;s wrong with the internet&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="作业题易错点">作业题易错点</h2><ol type="1"><li>注意<code>if</code>和<code>else</code>语句后一定要加冒号。</li><li>判断语句内部的代码一定要记得缩进。</li><li>格式化字符串中想表示<code>%</code>时，需要写<code>%%</code>。</li><li>Python中交换两个变量，可以用：<code>a, b = b, a</code>。</li><li>Python中的比较运算符支持链式操作，这一点跟C++和Java等语言不同。例如，给三个数排序的代码可以这么写：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">x, y, z = a, b, c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt;= b &gt;= c:</span><br><span class="line">    <span class="built_in">print</span>(c, b, a)</span><br><span class="line"><span class="keyword">elif</span> a &gt;= c &gt;= b:</span><br><span class="line">    <span class="built_in">print</span>(b, c, a)</span><br><span class="line"><span class="keyword">elif</span> b &gt;= a &gt;= c:</span><br><span class="line">    <span class="built_in">print</span>(c, a, b)</span><br><span class="line"><span class="keyword">elif</span> b &gt;= c &gt;= a:</span><br><span class="line">    <span class="built_in">print</span>(a, c, b)</span><br><span class="line"><span class="keyword">elif</span> c &gt;= a &gt;= b:</span><br><span class="line">    <span class="built_in">print</span>(b, a, c)</span><br><span class="line"><span class="keyword">elif</span> c &gt;= b &gt;= a:</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++标准库函数】</title>
      <link href="/2024/04/27/%5Bobject%20Object%5D/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/"/>
      <url>/2024/04/27/%5Bobject%20Object%5D/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="c标准库函数">C++标准库函数</h1><h2 id="lower_bound-upper_bound">lower_bound &amp;&amp; upper_bound</h2><h3 id="头文件">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用">作用</h3><ul><li><p>在一个<strong>排好序的数组</strong>中进行<strong>二分查找</strong></p></li><li><p><strong>基于二分查找！数组或容器必须有序！</strong></p></li></ul><h3 id="用法">用法</h3><ul><li><p><code>lower_bound(begin, end, num)</code>：适用于从小到大排序的有序序列，从数组/容器的<code>begin</code>位置起，到 <code>end − 1</code> 位置结束，查找<strong>第一个大于等于<code>num</code></strong> 的数字。</p><ul><li>若找到则返回该数字的地址，通过减去起始地址 begin的技巧可以求得其在数组/容器中的下标，如<code>lower_bound(arr, arr + n, 3) - arr</code> 表示在数组<code>arr</code> 中查找第一个大于等于 3 的元素在数组中的下标</li><li>若找不到，则返回<code>end</code>，即数组/容器最后一个元素的下一个元素</li></ul></li><li><p><code>upper_bound(begin, end, num)</code>：适用于从小到大排序的有序序列，从数组/容器的<code>begin</code> 位置起，到 <code>end − 1</code>位置结束，查找第一个大于 <code>num</code> 的数字。</p><ul><li>若找到则返回该数字的地址，通过减去起始地址 <code>begin</code>的技巧可以求得其在数组/容器中的下标，如<code>upper_bound(arr, arr + n, 3) − arr</code> 表示在数组<code>arr</code> 中查找第一个大于 3 的元素在数组中的下标。</li><li>若找不到，则返回<code>end</code>，即数组/容器最后一个元素的下一个元素。</li></ul></li><li><p><code>lower_bound(begin, end, num, greater())</code>：适用于从大到小排序的有序序列，从数组/容器的<code>begin</code> 位置起，到 <code>end−1</code>位置结束，查找第一个小于等于 <code>num</code> 的数字。</p><ul><li>若找到则返回该数字的地址，通过减去起始地址 <code>begin</code>的技巧可以求得其在数组/容器中的下标，如<code>lower_bound(arr, arr+n,3, greater())−arr</code> 表示在数组<code>arr</code> 中查找第一个小于等于 3 的元素在数组中的下标。</li><li>若找不到，则返回<code>end</code>，即数组/容器最后一个元素的下一个元素。</li></ul></li><li><p><code>upper_bound(begin, end, num, greater())</code>：适用于从大到小排序的有序序列，从数组/容器的<code>begin</code> 位置起，到 end−1 位置结束，查找第一个小于<code>num</code> 的数字。</p></li><li><p>若找到则返回该数字的地址，通过减去起始地址 begin的技巧可以求得其在数组/容器中的下标，如<code>upper_bound(arr, arr + n, 3, greater()) − arr</code> 表示在数组<code>arr</code> 中查找第一个小于 3 的元素在数组中的下标。</p></li><li><p>若找不到，则返回<code>end</code>，即数组/容器最后一个元素的下一个元素。</p></li></ul><span id="more"></span><h3 id="举例">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数组，假设已经从小到大排序</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 最后一个小于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 最后一个小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 没有小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 最后一个小于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p2 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 最后一个小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 没有小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第一个大于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p3 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p3 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 第一个大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 没有大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第一个大于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p4 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p4 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p4 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 没有大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">7</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">7</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">2.</span> 没有小于等于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">10</span> 的元素</span><br><span class="line"><span class="number">4.</span> 没有大于等于 <span class="number">10</span> 的元素</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">1</span> 的元素</span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">1</span> 的元素是: <span class="number">3</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">9</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">9</span> 的元素</span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="nth_element">nth_element</h2><h3 id="头文件-1">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="原型">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序规则采用默认的升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//排序规则为自定义的 comp 排序规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>first</code> 、 <code>last</code>为<strong>迭代器/指针</strong>，用于指定该函数的作用范围<code>[first, last)</code></li><li><code>nth</code>：也为<strong>迭代器/指针</strong>，其功能是令函数查找“<strong>第nth 小</strong>”的元素，并将其移动到 <code>nth</code> 指向的位置</li><li><code>comp</code>：用于<strong>自定义排序规则</strong></li></ul><blockquote><p><code>comp</code> 是可选参数，默认是求第 <spanclass="math inline">\(k\)</span> 小</p></blockquote><p><strong>返回值：</strong></p><ul><li>无</li></ul><h3 id="作用-1">作用</h3><ul><li>将数组中<strong>第 <span class="math inline">\(k\)</span>小</strong>的数 放在 <code>nth</code> 指向的位置</li><li>函数执行后， <code>nth</code>指向的元素将处于正确位置，其他位置元素顺序相较于初始顺序会被<strong>打乱</strong>，但前面的都比它小，后面的都比它大</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li></ul><h3 id="举例-1">举例</h3><h4 id="求第k小">求第k小</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> </span><br></pre></td></tr></table></figure><h4 id="求第k大">求第k大</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n, [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><h2 id="minmax">min、max</h2><h3 id="不加头文件">不加头文件</h3><p>此时<code>min()</code>、<code>max()</code>只支持传入<strong>两</strong>个参数</p><h3id="加上头文件algorithm">加上头文件<code>&lt;algorithm&gt;</code></h3><p>此时<code>min()</code>、<code>max()</code>只支持使用<code>&#123;&#125;</code>传入<strong>多</strong>个参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">min</span>(&#123;a, b, c, d&#125;)</span><br></pre></td></tr></table></figure><ol type="1"><li><code>min()</code>，<code>max()</code>的多个参数均在<code>&#123;&#125;</code>中</li><li>使用 <code>min(&#123;&#125;)</code> 写法必需要加头文件<code>#include &lt;algorithm&gt;</code></li></ol><blockquote><p>如果不加这个头文件会报错，因为此时只能使用<spanclass="math inline">\(min()\)</span> 传入 <spanclass="math inline">\(2\)</span> 个参数</p></blockquote><h3 id="常见错误">常见错误</h3><ul><li><code>max()/min()</code>函数必须传入两个<strong>同类型的参数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">max(<span class="number">0</span>, <span class="number">500</span> - res.size());</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">max(<span class="number">0</span>, <span class="number">500</span> - (<span class="type">int</span>) res.size());</span><br></pre></td></tr></table></figure><p>在使用C++ max函数时，提示如下报错：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">test1.cpp: <span class="title">In</span> <span class="title">function</span> &#x27;<span class="title">int</span> <span class="title">main</span>()&#x27;:</span></span><br><span class="line"><span class="function"><span class="title">test1.cpp</span>:54:47: <span class="title">error</span>: <span class="title">no</span> <span class="title">matching</span> <span class="title">function</span> <span class="title">for</span> <span class="title">call</span> <span class="title">to</span> &#x27;<span class="title">max</span>(<span class="title">int</span>, <span class="title">std</span>::<span class="title">vector</span>&lt;<span class="title">int</span>&gt;::<span class="title">size_type</span>)&#x27;</span></span><br><span class="line"><span class="function">     <span class="title">for</span>(<span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">max</span>(0, 500 - <span class="title">res.size</span>()); <span class="title">i</span> ++)</span></span><br></pre></td></tr></table></figure><ul><li><code>.length()</code> 和 <code>.size()</code>的返回类型都是<code>size_t</code>，使用时要在前面加上<code>(int)</code>强制类型转换</li></ul><h2 id="max_elementmin_element">max_element、min_element</h2><h3 id="头文件-2">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-2">作用</h3><p><strong>1. 求数组的最大值或最小值</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a, a + <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a, a + <span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//获取最大值</span></span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//获取最小值</span></span><br></pre></td></tr></table></figure><!--more--><p><strong>2. 求数组最大值最小值对应的下标</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a, a + <span class="number">8</span>) - a; </span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a, a + <span class="number">8</span>) - a;</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); <span class="comment">//获取最大值对应的下标</span></span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();<span class="comment">//获取最小值对应的下标</span></span><br></pre></td></tr></table></figure><h2 id="fill">fill</h2><h3 id="头文件-3">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-3">作用</h3><p><ahref="https://blog.csdn.net/liu16659/article/details/87152348?ops_request_misc=%7B%22request%5Fid%22%3A%22167715751316800188555444%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167715751316800188555444&amp;biz_id=0&amp;spm=1018.2226.3001.4187">(96条消息)C++ 中 fill() 的使用_LawsonAbs的博客-CSDN博客_c++ fill</a></p><h2 id="memset">memset</h2><h3 id="头文件-4">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型-1">原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, Byte c, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>s：为指针或是数组</li><li>c：是赋给 s 的值</li><li>count：是 s 的长度</li></ul><p><strong>返回值：</strong></p><ul><li>指向存储区 s 的指针。</li></ul><h3 id="作用-4">作用</h3><p>​ memset是按照 c 的值（看作字节），按<strong>字节</strong>将 s赋值，因此我们最常见的就是</p><ul><li>将每一字节赋值全 0 ，整体就是 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br></pre></td></tr></table></figure><ul><li>将每一字节赋值全 1 ，整体就是 -1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">-1</span>, <span class="keyword">sizeof</span> s);</span><br></pre></td></tr></table></figure><blockquote><p>注意：-1 = 0XFF</p></blockquote><ul><li>将每一个字节赋值 <span class="math inline">\(0x3f\)</span>，整体就是<span class="math inline">\(INF =0x3f3f3f3f=1061109567\)</span>【<strong>正无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> s);</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/qq_42386788/article/details/116427457">关于memset函数和赋值0x3f</a></p></blockquote><ul><li>将每一个字节赋值 <span class="math inline">\(-0x3f\)</span> 或者<span class="math inline">\(0xbf\)</span>，整体就是 <spanclass="math inline">\(-INF\)</span>【<strong>负无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0xbf</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> s);</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><p>memset可以方便的==<strong>清空</strong>或<strong>初始化</strong>一个<strong>数组</strong>==</p><h3 id="举例-2">举例</h3><ol type="1"><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/weixin_44162361/article/details/115790452?ops_request_misc=%7B%22request%5Fid%22%3A%22169735623116800180650624%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169735623116800180650624&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115790452-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=memset&amp;spm=1018.2226.3001.4187">memset的用法详解_薛定谔的猫ovo的博客-CSDN博客</a></p></blockquote><h3 id="注意">注意</h3><p>对 <span class="math inline">\(double\)</span>数组初始化的时候需要注意，由于 <spanclass="math inline">\(double\)</span> 是双精度浮点数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始值为 -nan(not a number)</span></span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">-1</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始值为 0</span></span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br></pre></td></tr></table></figure><p><code>-nan</code> 做任何比较运算都会返回 <code>false</code></p><p>以<ahref="https://www.acwing.com/activity/content/code/content/8490430/">AcWing321. 棋盘分割 - AcWing</a>为例</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408061556268.png"alt="image-20240806155642050" /><figcaption aria-hidden="true">image-20240806155642050</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408061556221.png"alt="image-20240806155653993" /><figcaption aria-hidden="true">image-20240806155653993</figcaption></figure><h2 id="memcmp">memcmp</h2><h3 id="头文件-5">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="基本原型">基本原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf1, <span class="type">const</span> <span class="type">void</span> *buf2, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong></p><ul><li><p>当 buf1&lt;buf2 时，返回值&lt;0</p></li><li><p>当 buf1=buf2 时，返回值=0</p></li><li><p>当 buf1&gt;buf2 时，返回值&gt;0</p></li></ul><h3 id="作用-5">作用</h3><p>memcmp 是比较内存区域 buf1 和 buf2 的前 count个字节。该函数是按字节比较的</p><h3 id="举例-3">举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">r = <span class="built_in">memcmp</span>(&amp;s1,&amp;s2,<span class="built_in">strlen</span>(s1));</span><br><span class="line"><span class="keyword">if</span>(!r)<span class="comment">//！r 非零返回的是 1  这个是非运算，计算机是二进制的，不是零就是一了 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 and s2 are identical\n&quot;</span>);<span class="comment">/*s1等于s2*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);<span class="comment">/*s1小于s2*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);<span class="comment">/*s1大于s2*/</span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,!r); //输出是一， </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,r);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明-1">说明</h3><ol type="1"><li>该函数是按字节比较的：当s1,s2为字符串时</li></ol><ul><li><p><code>memcmp(s1,s2,1)</code>就是比较s1和s2的第一个字节的ascII码值；</p></li><li><p><code>memcmp(s1,s2,n)</code>就是比较s1和s2的前n个字节的ascII码值；</p><p>例如:</p></li></ul><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> *s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *s2=<span class="string">&quot;acd&quot;</span>;</span><br><span class="line">&gt;<span class="type">int</span> r=<span class="built_in">memcmp</span>(s1,s2,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>​比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了所以<spanclass="math display">\[r=-1\]</span>.</p></blockquote><ol start="2" type="1"><li><p>对于<code>memcmp()</code>，如果两个字符串相同而且<code>count</code>大于字符串长度的话，<code>memcmp</code>不会在<code>\0</code>处停下来，会继续比较<code>\0</code>后面的内存单元，直到<code>_res</code>不为零或者达到<code>count</code>次数。</p><p>例如：</p></li></ol><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> a1[]=<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">  <span class="type">char</span> a2[]=<span class="string">&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure></p><p>对于<code>memcmp(a1,a2,10)</code>，<code>memcmp</code>在两个字符串的<code>\0</code>之后继续比较。所以，如果想使用memcmp比较字符串，要保证count不能超过最短字符串的长度，否则结果有可能是错误的。</p></blockquote><h2 id="memcpy">memcpy</h2><h3 id="头文件-6">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="声明">声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>str1</strong> --指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li><li><strong>str2</strong> -- 指向要复制的数据源，类型强制转换为 void*指针。</li><li><strong>n</strong> -- 要被复制的字节数。</li></ul><p><strong>返回值：</strong></p><ul><li>该函数返回一个指向目标存储区 str1 的指针。</li></ul><h3 id="作用-6">作用</h3><p>​ 从存储区 <strong>str2</strong> 复制 <strong>n</strong>个字节到存储区 <strong>str1</strong></p><h3 id="实例">实例</h3><ul><li>将字符串复制到数组 dest 中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="keyword">sizeof</span> src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest = http://www.runoob.com</span><br></pre></td></tr></table></figure><ul><li>将 s 中第 11 个字符开始的 6个连续字符复制到 d 中：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(d, s + <span class="number">11</span>, <span class="number">6</span>); <span class="comment">// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob)</span></span><br><span class="line">    <span class="comment">// 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));</span></span><br><span class="line">    d[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob</span><br></pre></td></tr></table></figure><ul><li>覆盖原有部分数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;***&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 前: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 后: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 memcpy 前: abcdefg</span><br><span class="line">使用 memcpy 后: ***defg</span><br></pre></td></tr></table></figure><h2 id="strcmp">strcmp</h2><h3 id="头文件-7">头文件</h3><p><code>#include &lt;cstring&gt;</code></p><h3 id="作用-7">作用</h3><p>​ 比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较</p><h3 id="原型-2">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>第一个字符串大于第二个字符串，则返回大于 0 的数字</li><li>第一个字符串<font color='red'><strong>等于</strong></font>第二个字符串，则返回<font color='red'><strong>0</strong></font></li><li>第一个字符串小于第二个字符串，则返回小于 0 的数字</li></ul><h3 id="举例-4">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> p1[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p2[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p3[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p4[] = <span class="string">&quot;bcdeffasd&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1, p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1, p3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p3, p4));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p3, <span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="new">new</h2><h3 id="作用-8">作用</h3><p><code>new()</code>使计算机开辟一块内存空间，并返回<strong>内存空间的首地址</strong></p><h3 id="格式">格式</h3><ol type="1"><li><p>使用new函数创建变量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType;</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建变量并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> <span class="built_in">ElementType</span>(val);</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size];</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size]&#123;&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="说明-2">说明</h3><ol type="1"><li>new开辟的空间在堆上，而一般声明的变量存放在栈上</li><li><strong><font color='red'>通常用new函数代替malloc函数</font></strong></li><li>new不需要头文件</li><li>使用 new 函数之后要<strong><font color='red'>使用 delete函数释放内存空间</font></strong></li></ol><h3 id="举例-5">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">example1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 可以在new后面直接赋值 */</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以单独赋值 */</span></span><br><span class="line">    <span class="comment">// int *p = new int;</span></span><br><span class="line">    <span class="comment">// *p = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">example2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 用new创建数组 */</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">/* 也可以依次赋值 */</span></span><br><span class="line">    <span class="comment">// int *q = new int[3];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        q[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *st = <span class="keyword">new</span> <span class="built_in">student</span>(&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *stlist = <span class="keyword">new</span> student[<span class="number">3</span>]&#123;&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;bac&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="string">&quot;ccd&quot;</span>, <span class="number">93</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> e1 = <span class="built_in">example1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e1: &quot;</span> &lt;&lt; e1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *e2 = <span class="built_in">example2</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; e2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st1 = <span class="built_in">example3</span>();</span><br><span class="line">    cout &lt;&lt; st1-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st1-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st2 = <span class="built_in">example4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; st2[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st2[i].score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e1: 3</span><br><span class="line">0 1 2</span><br><span class="line">abc 90</span><br><span class="line">abc 90</span><br><span class="line">bac 78</span><br><span class="line">ccd 93</span><br></pre></td></tr></table></figure><h2 id="swap">swap</h2><h3 id="作用-9">作用</h3><p><strong><code>swap(a,b);</code></strong>交换两个变量<strong><code>a,b</code></strong>的值</p><blockquote><p><strong><code>a,b</code></strong>可以是<strong><font color='red'>任何数据类型</font></strong></p></blockquote><h3 id="原型-3">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ElementType &amp;a, ElementType &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="举例-6">举例</h3><h4 id="例一">例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="例二">例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;ABCD&quot;</span>;     string b = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ABCD</span><br></pre></td></tr></table></figure><h2 id="round">round</h2><h3 id="头文件-8">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-4">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">round</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-10">作用</h3><p>对于小数而言，<code>round()</code>函数仅仅<strong>保留到整数位</strong>，即仅仅对<strong>小数点后一位四舍五入</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">1.5</span>) = <span class="number">2.000000</span></span><br><span class="line">round(<span class="number">1.56</span>) = <span class="number">2.000000</span></span><br><span class="line">round(<span class="number">-1.5</span>) = <span class="number">-2.000000</span></span><br><span class="line">round(<span class="number">-1.56</span>) = <span class="number">-2.000000</span></span><br></pre></td></tr></table></figure><h3 id="应用">应用</h3><p>答案要求<strong>四舍五入到整数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minutes = round(sum / <span class="number">1000</span> / <span class="number">20</span> * <span class="number">60</span>);</span><br></pre></td></tr></table></figure><h2 id="pow">pow</h2><h3 id="头文件-9">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-5">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><code>x</code>：基数（底数），一个浮点数</li><li><code>y</code>：指数，一个浮点数</li></ul><p><strong>返回值：</strong></p><ul><li>返回 <code>x</code> 的 <code>y</code> 次幂，即<code>x^y</code>。</li><li>如果计算产生数学错误，例如负数的非整数幂，会返回 NaN，并设置<code>errno</code>。</li></ul><p><strong>错误处理：</strong></p><ul><li>如果 <code>x</code> 为负且 <code>y</code> 不是整数，结果为NaN，<code>errno</code> 设置为 <code>EDOM</code>。</li><li>如果结果太大而导致上溢，返回<code>HUGE_VAL</code>，<code>errno</code> 设置为<code>ERANGE</code>。</li><li>如果结果太小而导致下溢，返回 <code>0.0</code>，<code>errno</code>设置为 <code>ERANGE</code>。</li></ul><h3 id="示例">示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;值 8.0 ^ 3 = %lf\n&quot;</span>, <span class="built_in">pow</span>(<span class="number">8.0</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;值 3.05 ^ 1.98 = %lf&quot;</span>, <span class="built_in">pow</span>(<span class="number">3.05</span>, <span class="number">1.98</span>));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loglog2log10">log、log2、log10</h2><h3 id="头文件-10">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-6">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">log</span><span class="params">(<span class="type">double</span> x)</span></span>;<span class="comment">// 返回以 e 为底数的对数 ln(x)</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">log2</span><span class="params">(<span class="type">double</span> x)</span></span>;<span class="comment">// 返回以 2 为底数的对数 log2(x)</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">log10</span><span class="params">(<span class="type">double</span> x)</span></span>;<span class="comment">// 返回以 10 为底数的对数 log10(x)</span></span><br></pre></td></tr></table></figure><h3 id="应用-1">应用</h3><ul><li>计算 <span class="math inline">\(\log _ab\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> res = <span class="built_in">log</span>(b) / <span class="built_in">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">log</span>(b) / <span class="built_in">log</span>(a);<span class="comment">// C++ 默认是下取整</span></span><br></pre></td></tr></table></figure><h2 id="absfabs">abs/fabs</h2><h3 id="头文件-11">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-7">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span></span><br></pre></td></tr></table></figure><h3 id="作用-11">作用</h3><ul><li><code>abs</code> 是对<strong>整数</strong>取绝对值</li><li><code>fabs</code> 是对<strong>浮点数</strong>取绝对值</li></ul><h2 id="sqrt">sqrt</h2><h3 id="头文件-12">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-8">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-12">作用</h3><p><code>sqrt()</code> 用来求给定值的平方根</p><h3 id="常见错误-1">常见错误</h3><ol type="1"><li><strong>输出 36的开根号</strong></li></ol><ul><li><strong>错误写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152182.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><blockquote><p>忽略了sqrt()函数的返回值是 double型。导致出错</p></blockquote></blockquote><ul><li><strong>正确写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152197.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>常见的使用sqrt()函数的规范写法</strong> 例如:我们要判断一个数是不是质数，只需要判断 2 ~ n开根号之间有没有可以整除的数就可以了</p><ul><li><strong>错误写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，其实并不推荐这样写。虽然我也经常这样写。但是在一次做题的过程中，就因为这样写程序出现了bug。我就改用下面的这种稳妥的写法了</p><ul><li><strong>正确写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.0*n的目的是——隐式转换成浮点数，开根号后再强制转换成整型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span> * n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse">reverse</h2><h3 id="头文件-13">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-13">作用</h3><p>反转在<strong><font color='red'> [ first,last )</font></strong>范围内的顺序（包括first指向的元素，不包括last指向的元素）</p><h3 id="原型-9">原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span> <span class="params">(BidirectionalIterator first,BidirectionalIterator last)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数first：待排区域的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排区域的<strong><font color='blue'>末尾地址</font></strong></li></ul><h3 id="举例-7">举例</h3><ul><li>反转<strong>向量</strong><font color='blue'><strong>vector</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//v的值为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><ul><li>反转数组<strong><code>ElementType A[]</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[]=&#123;<span class="number">12</span>,<span class="number">-5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(A, A+<span class="number">6</span>);<span class="comment">//数组A为19,1,7,0,-5,12</span></span><br></pre></td></tr></table></figure><ul><li>反转<strong>字符串<font color='blue'>string</font></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;www.mathor.top&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//str结果为pot.rohtam.wwww</span></span><br></pre></td></tr></table></figure><h3 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="sort">sort</h2><h3 id="头文件-14">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-14">作用</h3><p>对==<strong><font color='red'>数组排序</font></strong>==</p><blockquote><ul><li>数组可以是<strong><code>ElementType A[]</code></strong>，也可以是<strong><code>vector &lt;ElementType&gt; A</code></strong><ul><li><strong><code>ElementType A[]</code></strong>：<strong><code>A</code></strong>表示<strong><font color='blue'>数组首地址</font></strong>，<strong><code>A+n</code></strong>表示<strong><font color='blue'>数组尾部</font></strong></li><li><strong><code>vector &lt;ElementType&gt; A</code></strong>：<strong><code>A.begin()</code></strong>和<strong><code>A.end()</code></strong>表示<strong><font color='blue'>头尾</font></strong></li></ul></li></ul></blockquote><h3 id="原型-10">原型</h3><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>默认</th><th><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last);</code></strong></th></tr></thead><tbody><tr class="odd"><td><strong>自定义</strong></td><td><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last,Compare comp);</code></strong></td></tr></tbody></table><ul><li>参数first：待排数组的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排数组的<strong><font color='blue'>末尾地址</font></strong></li><li>参数comp：自定义排序方法<ul><li>如果第三个参数不写，则<strong>默认的排序方法</strong>是<strong><font color='red'>从小到大</font></strong>排序。</li></ul></li></ul><h3 id="举例-8">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// cmp函数返回的值是bool类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 从大到⼩排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 因为这里没有传入参数cmp，所以按照默认,v从小到大排列</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, cmp); <span class="comment">// arr从大到小排列，因为cmp函数排序规则设置了从大到小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见cmp函数">常见cmp函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score!=b.score)</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">return</span> a.score!=b.score ? a.score&gt;b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> node a,<span class="keyword">struct</span> node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height!=b.height ? a.height&gt;b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注： <strong><code>sort</code></strong> 函数的<strong><code>cmp</code></strong> 必须按照规定来写，即必须只是<strong><code>&gt;</code></strong> 或者<strong><code>&lt;</code></strong> ，比如：<strong><code>return a &gt; b;</code></strong> 或者<strong><code>return a &lt; b;</code></strong> 而不能是<strong><code>&lt;=</code></strong> 或者<strong><code>&gt;=</code></strong></p></blockquote><h2 id="find">find</h2><h3 id="头文件-15">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-15">作用</h3><p>​可以在<strong>任何容器</strong>中<strong>查找指定元素</strong>，返回一个迭代器指向<strong>第一个匹配</strong>的元素</p><ul><li><p>string、map、set有内置的成员方法find()，所以对于string、map、set的查找通常使用内置的find()方法</p></li><li><p>但是vector、queue没有内置的成员方法find()，他们通常使用<algorithm>头文件下通用的find()函数</p></li></ul><h3 id="参数">参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>first</strong> 和 <strong>last</strong>为输入迭代器，<strong>[first,last)</strong>用于指定该函数的查找范围</li><li><strong>val</strong>为要查找的目标元素</li></ul><h3 id="返回值">返回值</h3><p>​该函数返回一个<strong>迭代器</strong>，指向范围内搜索元素的<strong>第一次</strong>出现。如果没有找到目标元素，则返回<strong>last</strong></p><h3 id="例子">例子</h3><ul><li>在<code>vector</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element found: 3</span><br></pre></td></tr></table></figure><ul><li>在<code>string</code>中查找指定字符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;This is a string&quot;</span>; <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  ^  ^  ^</span></span><br><span class="line"><span class="comment">                  1  2  3           */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>s.rfind()</code><strong>从左往右</strong>寻找、<code>s.lfind()</code><strong>从右往左</strong>寻找</p></blockquote><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从首个位置开始搜索，在下标 2 处找到子串 is</span><br><span class="line">从下标 5 开始搜索，在下标 5 处找到子串 is</span><br><span class="line">从首个位置开始搜索，在下标 3 处找到字符 s</span><br><span class="line">从下标 5 开始搜索，在下标 6 处找到字符 s</span><br></pre></td></tr></table></figure><ul><li>在<code>set</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法1：使用find方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">2</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法2：使用count方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy">copy</h2><h2 id="unique">unique</h2><h3 id="头文件-16">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-16">作用</h3><p>​ <code>unique</code>可以“去除” <strong>vector</strong> 或 数组中<font color='red'><strong>相邻元素</strong></font>之间重复出现的元素（所以一般使用前需要<font color='blue'><strong>排序</strong></font>）</p><blockquote><p>实际上<code>unique()</code>并没有将重复的元素删除，而是把重复的元素放到数组的最后面<strong>藏起来</strong>了</p></blockquote><h3 id="原型-11">原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator unique(vector&lt;int&gt;::iterator first, vector&lt;int&gt;::iterator last);</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li>第一个参数是集合的起始地址</li><li>第二个参数是集合的最后一个元素的下一个元素的地址</li></ul></li><li><p><strong>返回值</strong>：指向去重后<strong>最后一个元素</strong>的迭代器<code>vector&lt;int&gt;::iterator</code></p></li><li><p><strong>底层原理</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) <span class="comment">// 如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前 j 个元素中</span></span><br><span class="line">            a[j ++] = a[i];          <span class="comment">// 每存在一个不同元素，j ++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j; <span class="comment">// 返回的是前 j 个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用-2">应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vecetor&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只去重相邻的重复元素 */</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(a, a + <span class="number">5</span>) - a; <span class="comment">//去重后不相同元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对所有元素进行去重 */</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="next_permutation">next_permutation</h2><h3 id="头文件-17">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-17">作用</h3><p>​<code>next_permutation</code>是求当前排列的下一个排列（按字典序升序的下一个序列），<strong>该函数会直接修改数组为下一个排列</strong></p><blockquote><p>如 <span class="math inline">\(1234\)</span> 的<code>next_permutation</code> 是 <spanclass="math inline">\(1243\)</span>，在<strong>全排列</strong>当中经常会用。</p></blockquote><h3 id="参数-1">参数</h3><p>​ 和 <code>sort</code>的参数一样，一般传两个参数，第一个是排列开始的地址，第二个是排列结束的下一个地址，如实现数组第<span class="math inline">\(1\sim 3\)</span>排列的下一个排列：<code>next_permutation(a, a + 3)</code></p><h3 id="返回值-1">返回值</h3><p>​ 返回值是 <code>Ture</code> 或者 <code>False</code></p><ul><li>若当前排列有下一个排列，则返回 <code>Ture</code></li><li>否则返回 <code>False</code></li></ul><blockquote><p>如 <span class="math inline">\(54321\)</span> 的返回值为<code>False</code></p></blockquote><h3 id="时间复杂度">时间复杂度</h3><p><span class="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span> 为数组的长度</p><h3 id="原理">原理</h3><p><ahref="https://www.acwing.com/activity/content/code/content/8791535/">LeetCode31. 下一个排列 - AcWing</a></p><ul><li>从后往前找原数组中第一个<code>a[i] &lt; a[i + 1]</code>的地方，其后面全是降序，说明已经排好了，所以我们就要将<code>a[i]</code> 的值改大一点</li><li>将 <code>a[i]</code>和其后面所有数中大于他的最小的数交换位置，则a[i]后面的数仍是个降序</li><li>然后将其后面这些降序的元素翻转，就得到了原排列的下一个增序排列了</li></ul><blockquote><blockquote><p>例如：对于排列2431来说</p><p>①我们先找到2和4处</p><p>②然后交换2和3的位置，就得到了3421</p><p>③最后翻转421，就得到了3124，则3124就是2431的下一个排列，如下图。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152332.png"alt="eg" /><figcaption aria-hidden="true">eg</figcaption></figure></blockquote></blockquote><h2 id="int_maxint_min">INT_MAX，INT_MIN</h2><h3 id="头文件-18">头文件</h3><p><strong><code>#include &lt;climits&gt;</code></strong></p><h3 id="介绍">介绍</h3><p>C中<strong>常量</strong><code>INT_MAX</code>和<code>INT_MIN</code>分别表示int类型的最大值和最小值</p><blockquote><ol type="1"><li>``` INT_MAX = 2^31-1 = 2147483647; INT_MIN = -2^31 = -2147483648;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 所有超过该限值的int类型变量，都会出现溢出，出现warning，但是并不会出现error。</span><br><span class="line"></span><br><span class="line">3. 如果想表示的整数超过了该限值，可以使用长整型long long （占8字节64位）表示。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">### 建议</span><br><span class="line"></span><br><span class="line">-   由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对$INT_MAX$和$INT_MIN$的运算应当格外注意，在出现溢出的时候，不遵循数学规则：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">INT_MAX + 1 = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 = INT_MAX</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MAX + 1 &lt; INT_MAX</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 &gt; INT_MIN</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) &lt; 0</span><br></pre></td></tr></table></figure></li></ol></blockquote><ul><li><p>建议在表示正/负无穷时，不要使用<spanclass="math inline">\(INT_MAX\)</span>和<spanclass="math inline">\(INT_MIN\)</span>，否则可能会出现意外的错误</p><ul><li><p>使用 <code>2e9</code> 表示<strong>正无穷</strong></p></li><li><p>使用<code>-2e9</code> 表示<strong>负无穷</strong></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e9</span>;</span><br></pre></td></tr></table></figure><h3 id="实例-1">实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX = %d\n&quot;</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN = %d\n&quot;</span>, INT_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX + 1 = %d\n&quot;</span>, INT_MAX + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN - 1 = %d\n&quot;</span>, INT_MIN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;abs(INT_MIN) = %d\n&quot;</span>, <span class="built_in">abs</span>(INT_MIN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = 2147483647</span><br><span class="line">INT_MIN = -2147483648</span><br><span class="line">INT_MAX + 1 = -2147483648</span><br><span class="line">INT_MIN - 1 = 2147483647</span><br><span class="line">abs(INT_MIN) = -2147483648</span><br></pre></td></tr></table></figure><h2 id="c11特性中的to_string">C++11特性中的to_string</h2><h3 id="头文件-19">头文件</h3><p><code>#include &lt;cstring&gt;</code></p><h3 id="作用-18">作用</h3><p><code>to_string</code> 最常用的就是把一个 <code>int</code>型变量或者一个数字转化为 <code>string</code> 类型的变量，当然也可以转<code>double</code>、<code>float</code>等类型的变量，这在很多PAT字符串处理的题目中很有用处，以下是示例代码</p><h3 id="示例-1">示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = to_string(<span class="number">123</span>); <span class="comment">// 将123这个数字转成字符串</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = to_string(<span class="number">4.5</span>); <span class="comment">// 将4.5这个数字转成字符串</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 + s2 &lt;&lt; <span class="built_in">endl</span>;           <span class="comment">// 将s1和s2两个字符串拼接起来并输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (s1 + s2).c_str()); <span class="comment">// 如果想用printf输出string，得加⼀个.c_str()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c11特性中的stoistod">C++11特性中的stoi、stod</h2><h3 id="头文件-20">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="作用-19">作用</h3><p>使⽤用 <code>stoi</code>、<code>stod</code> 可以将字符串<code>string</code> 或 <code>char *</code> 转化为对应的 <code>int</code>型、 <code>double</code>型变量，这在字符串处理的很多问题中很有帮助～以下是示例代码和⾮法输⼊的处理方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">stoi</span>(str);</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    str = <span class="string">&quot;123.44&quot;</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="built_in">stod</span>(str);</span><br><span class="line">    cout &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>stoi如果遇到的是非法输入（比如stoi("123.4")，123.4不是一个int型变量）：</p><ol type="1"><li>会自动截取最前面的数字，直到遇到不是数字为止(所以说如果是浮点型，会截取前面的整数部分)</li><li>如果最前面不是数字，会运行时发生错误</li></ol><p>stod如果是非法输入：</p><ol type="1"><li>会自动截取最前面的浮点数，直到遇到不满足浮点数为止</li><li>如果最前面不是数字或者小数点，会运行时发生错误</li><li>如果最前面是小数点，会自动转化后在前面补0</li></ol></blockquote><p><strong>不仅有stoi、stod两种，相应的还有：</strong></p><p><code>stof</code> (string to float)</p><p><code>stold</code> (string to long double)</p><p><code>stol</code> (string to long)</p><p><code>stoll</code> (string to long long)</p><p><code>stoul</code> (string to unsigned long)</p><p><code>stoull</code> (string to unsigned long long)</p><h3 id="区分atoi和stoi">区分atoi和stoi</h3><p><strong>总结</strong>：建议使用 <code>stoi</code></p><ul><li>能用 <code>atoi</code> 的地方一定也可以用 <code>stoi</code></li><li>能用 <code>stoi</code> 的地方却未必能用 <code>atoi</code></li></ul><p><strong>相同点</strong></p><ul><li>头文件都是 <code>#include &lt;cstring&gt;</code></li><li>都是C++的字符处理函数，把数字字符串转换成int输出</li></ul><p><strong>不同点</strong></p><ul><li><p><code>atoi()</code> 的参数是<code>const char*</code>，因此对于一个 string 类型的字符串我们必须调用<code>c_str()</code> 方法把这个 string 转换成 <code>const char*</code>类型</p></li><li><p><code>stoi()</code> 的参数是 <code>const string*</code>，对于<code>const char*</code> 类型的参数可直接输入，C++自动进行将其转化为<code>const string*</code> 类型</p></li><li><p>而 <code>atoi()</code>不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界</p></li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;2147482&quot;</span>, s2 = <span class="string">&quot;-214748&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">stoi</span>(s1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">stoi</span>(s2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s3[] = <span class="string">&quot;12332687&quot;</span>, s4[] = <span class="string">&quot;-12332687&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">atoi</span>(s3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">atoi</span>(s4) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">stoi</span>(s3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">stoi</span>(s4) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2147482</span></span><br><span class="line"><span class="number">-214748</span></span><br><span class="line"><span class="number">12332687</span></span><br><span class="line"><span class="number">-12332687</span></span><br><span class="line"><span class="number">12332687</span></span><br><span class="line"><span class="number">-12332687</span></span><br></pre></td></tr></table></figure><h2 id="关于cctype头文件里的一些函数">关于cctype头文件里的一些函数</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408221311511.png"alt="image-20240822131122962" /><figcaption aria-hidden="true">image-20240822131122962</figcaption></figure><h2 id="参考">参考</h2><ul><li><ahref="https://blog.csdn.net/weixin_51635753/article/details/115434999?ops_request_misc=%7B%22request%5Fid%22%3A%22167049370716782414992762%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167049370716782414992762&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-21-115434999-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&amp;utm_term=C%2B%2B自带swap函数&amp;spm=1018.2226.3001.4187">(82条消息)C++ STL 常用函数_Mr.bei的博客-CSDN博客_c++stl常用函数</a></li><li><ahref="https://zh.cppreference.com/w/首页">cppreference.com</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【1.环境搭建与顺序语句】</title>
      <link href="/2024/04/26/%5Bobject%20Object%5D/python/%E3%80%901.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%A1%BA%E5%BA%8F%E8%AF%AD%E5%8F%A5%E3%80%91/"/>
      <url>/2024/04/26/%5Bobject%20Object%5D/python/%E3%80%901.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%A1%BA%E5%BA%8F%E8%AF%AD%E5%8F%A5%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建与顺序语句">【1.环境搭建与顺序语句】</h1><h2 id="语法基础">语法基础</h2><p><ahref="https://docs.python.org/zh-cn/3/tutorial/index.html">Python语法官方文档</a></p><h3 id="变量">变量</h3><table><thead><tr class="header"><th>类型</th><th>描述</th><th>举例</th></tr></thead><tbody><tr class="odd"><td>int</td><td>整数</td><td>123</td></tr><tr class="even"><td>float</td><td>浮点数</td><td>1.23, 1.24e5</td></tr><tr class="odd"><td>str</td><td>字符串</td><td>"python", 'acwing'</td></tr><tr class="even"><td>bool</td><td>布尔值</td><td>True, False</td></tr><tr class="odd"><td>list</td><td>列表</td><td>[1, 2, 3]</td></tr><tr class="even"><td>tuple</td><td>元组</td><td>(1, 2, 3)</td></tr><tr class="odd"><td>set</td><td>集合</td><td>{1, 2, 3}</td></tr><tr class="even"><td>dict</td><td>字典</td><td>{1: "python", "acwing": 2, 3: 4.0}</td></tr></tbody></table><p>注意：<code>int</code><font color='red'><strong>支持高精度，没有大小限制</strong></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">width = <span class="number">20</span></span><br><span class="line">height = <span class="number">12.3</span></span><br><span class="line">name = <span class="string">&quot;yxc&quot;</span></span><br><span class="line">my_name = name</span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3.0</span>  <span class="comment"># 同时给多个变量赋值</span></span><br><span class="line"><span class="comment"># 输出变量类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(width))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name))</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="运算符">运算符</h3><table><colgroup><col style="width: 8%" /><col style="width: 53%" /><col style="width: 38%" /></colgroup><thead><tr class="header"><th>运算符</th><th>描述</th><th>实例<code>(A=10、B=20)</code></th></tr></thead><tbody><tr class="odd"><td><code>+</code></td><td>把两个数相加，或者拼接两个字符串</td><td><code>A + B</code> 将得到 30</td></tr><tr class="even"><td><code>-</code></td><td>从第一个数中减去第二个数</td><td><code>A - B</code> 将得到 -10</td></tr><tr class="odd"><td><code>*</code></td><td>把两个数相乘</td><td><code>A * B</code> 将得到 200</td></tr><tr class="even"><td><code>/</code></td><td>分子除以分母，结果为 float 类型</td><td><code>B / A</code> 将得到 2.0</td></tr><tr class="odd"><td><code>//</code></td><td>整除，结果为 int 类型（向下取整）</td><td><code>B // A</code> 将得到 2</td></tr><tr class="even"><td><code>%</code></td><td>取模运算符，向零整除后的余数，可能为负数</td><td><code>B % A</code> 将得到 0</td></tr><tr class="odd"><td><code>**</code></td><td>乘方</td><td><code>A ** B</code> 将得到 1e20</td></tr><tr class="even"><td><code>+=</code></td><td>第一个数加上第二个数</td><td><code>A = A + B</code> 简写为 <code>A += B</code></td></tr><tr class="odd"><td><code>-=</code></td><td>第一个数减去第二个数</td><td><code>A = A - B</code> 简写为 <code>A -= B</code></td></tr><tr class="even"><td><code>*=</code></td><td>第一个数乘以第二个数</td><td><code>A = A * B</code> 简写为 <code>A *= B</code></td></tr><tr class="odd"><td><code>/=</code></td><td>第一个数除以第二个数</td><td><code>A = A / B</code> 简写为 <code>A /= B</code></td></tr><tr class="even"><td><code>//=</code></td><td>第一个数整除第二个数</td><td><code>A = A // B</code> 简写为 <code>A //= B</code></td></tr><tr class="odd"><td><code>%=</code></td><td>第一个数对第二个数取余</td><td><code>A = A % B</code> 简写为 <code>A %= B</code></td></tr><tr class="even"><td><code>**=</code></td><td>第一个数变成两个数的乘方</td><td><code>A = A ** B</code> 简写为 <code>A **= B</code></td></tr></tbody></table><p>注意：对 <span class="math inline">\(0\)</span>进行<strong>除法</strong>或<strong>取模</strong>会报错</p><h3 id="表达式">表达式</h3><p>小学学的四则运算都是支持的。</p><p>当整数与浮点数共同运算时，整数会被自动转化成浮点数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2</span> + <span class="number">3</span></span><br><span class="line">y = (x + <span class="number">1.0</span>) * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br></pre></td></tr></table></figure><p>也可以运用<code>int()、float()、str()</code>等函数强制转换类型。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;123.0&quot;</span></span><br><span class="line">a = <span class="built_in">float</span>(s)</span><br><span class="line">b = <span class="built_in">int</span>(a)</span><br><span class="line">s2 = <span class="string">&quot;The value is &quot;</span> + <span class="built_in">str</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s, a, b, s2)</span><br></pre></td></tr></table></figure><h3 id="输入">输入</h3><p>使用<code>input()</code>函数，可以输入<strong>一行内容</strong>，返回的类型为<code>str</code>。一般配合<code>split()</code>、<code>map()</code>、<code>int()</code>、<code>float()</code>等函数使用。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 读入以空格分隔的两个整数</span></span><br><span class="line"><span class="built_in">print</span>(a + b)  <span class="comment"># 计算两个数的和</span></span><br></pre></td></tr></table></figure><h3 id="输出">输出</h3><p>使用<code>print()</code>函数可以输出多个变量，默认用<font color='red'><strong>空格</strong></font>隔开，且<strong>行末会默认添加回车</strong>。如果想自定义<font color='blue'><strong>行末字符</strong></font>，可以添加<code>end</code>参数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c, end=<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>部分题目会要求<strong>四舍五入保留</strong>若干位小数，此时可以使用<code>round()</code>函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">12.34567</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x = <span class="subst">&#123;<span class="built_in">round</span>(x, <span class="number">1</span>)&#125;</span>&quot;</span>)  <span class="comment"># 四舍五入保留 1 位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x = <span class="subst">&#123;<span class="built_in">round</span>(x, <span class="number">3</span>)&#125;</span>&quot;</span>)  <span class="comment"># 四舍五入保留 3 位小数</span></span><br></pre></td></tr></table></figure><p>另外可以使用格式化字符串，在后面的章节会详细讲解，本章中大家会使用下面用法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">12.34567</span></span><br><span class="line">y = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x = <span class="subst">&#123;x:<span class="number">.1</span>f&#125;</span>&quot;</span>)       <span class="comment"># 四舍五入保留1位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x = <span class="subst">&#123;(x * y):<span class="number">.3</span>f&#125;</span>&quot;</span>) <span class="comment"># 四舍五入保留3位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span>)  <span class="comment"># 输出整数</span></span><br></pre></td></tr></table></figure><h3 id="其它函数">其它函数</h3><p>本章中部分题目会要求开根号，可以使用如下方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt  <span class="comment"># 引入开根号函数</span></span><br><span class="line">x = <span class="number">2</span></span><br><span class="line">y = sqrt(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><hr /><h2 id="作业题易错点">作业题易错点</h2><ol type="1"><li>变量名可以是任意单词（除了class、def等少数几个关键词以外），由大小写英文字母、下划线和数字构成，首字母不能写数字。</li><li>注意切换输入法，所有字母、操作符、空格都要用英文字符。</li><li>用<code>print()</code>格式化输出时，例如：<code>print("x = %f, y = %d" % (x, y))</code>，当要填充的变量个数大于1，或者变量为表达式时，一定要加括号，另外变量要用逗号隔开。</li><li><code>float</code>类型的数值(浮点数)有精度问题，存储的是近似值。例如<code>print(0.1 + 0.2)</code>会得到<code>0.30000000000000004</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get_dummies</title>
      <link href="/2024/04/26/%5Bobject%20Object%5D/python/%E3%80%90pandas%E3%80%91/get_dummies/"/>
      <url>/2024/04/26/%5Bobject%20Object%5D/python/%E3%80%90pandas%E3%80%91/get_dummies/</url>
      
        <content type="html"><![CDATA[<h1 id="get_dummies">get_dummies</h1><h2 id="pandas.get_dummies使用场景">pandas.get_dummies使用场景</h2><p>​ 在对变量进行<strong>独热编码</strong>（<spanclass="math inline">\(one-hot\encoding\)</span>）时使用，例如：某一列类别型变量是季节，取值为春、夏、秋、冬，当我们对其进行建模时，需要将其进行独热编码，这时<code>pandas.get\_dummies()</code>便派上了用场。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409302047605.png"alt="image-20240930204756529" /><figcaption aria-hidden="true">image-20240930204756529</figcaption></figure><h2 id="参数详解">参数详解</h2><ul><li><strong>data</strong> : array-like, Series, or DataFrame输入的数据</li><li><strong>prefix</strong> : string,get_dummies转换后，列名的前缀，默认为None</li><li><strong>columns</strong> : 指定需要实现类别转换的列名否则转换所有类别性的列</li><li><strong>dummy_na</strong> : bool, default False增加一列表示空缺值，如果False就忽略空缺值</li><li><strong>drop_first</strong> : bool, default False获得k中的k-1个类别值，去除第一个,防止出现多重共线性</li></ul><h2 id="注意陷阱">注意陷阱</h2><p>​若针对训练数据已经做好了独热编码并建立了模型，而<strong>新增的预测数据或分类数据的类别变量未包含完整的类别</strong>。此时直接使用pd.get_dummies，会发现与训练集得到的结果不一样。例如：训练数据中季节列中春、夏、秋、冬都出现过，而在新的测试数据中只出现了春与夏，两者的结果会不一样。如下：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409302050567.png"alt="image-20240930205022485" />为了避免出现这个情况，需要新增以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&quot;季节&quot;</span>] = pd.Categorical(data[<span class="string">&quot;季节&quot;</span>], categories=[<span class="string">&quot;春&quot;</span>, <span class="string">&quot;夏&quot;</span>, <span class="string">&quot;秋&quot;</span>, <span class="string">&quot;冬&quot;</span>])</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409302112372.png"alt="image-20240930211251309" /><figcaption aria-hidden="true">image-20240930211251309</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广播机制（broadcast）</title>
      <link href="/2024/04/26/%5Bobject%20Object%5D/python/%E3%80%90pytorch%E3%80%91/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%88broadcast%EF%BC%89/"/>
      <url>/2024/04/26/%5Bobject%20Object%5D/python/%E3%80%90pytorch%E3%80%91/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%88broadcast%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p># 广播机制（broadcast）</p><h2 id="定义">定义</h2><p>如果一个<code>PyTorch</code>操作支持广播，则其<code>Tensor</code>参数可以自动扩展为相等大小（不需要复制数据）。通常情况下，小一点的数组会被<code>broadcast</code> 到大一点的，这样才能保持大小一致。</p><h2 id="规则">规则</h2><ul><li><p>如果遵守以下规则，则两个<code>tensor</code>是“可广播的”：</p><ul><li>每个<code>tensor</code>至少有一个维度；</li><li>从尾向前遍历<code>tensor</code>的所有维度，两个<code>tensor</code>存在下列情况：<ul><li><code>tensor</code>维数相等</li><li><code>tensor</code>维数不等且<strong>其中一个维数为 1</strong>或<strong>其中一个维数不存在</strong></li></ul></li></ul></li><li><p>如果两个<code>tensor</code>是“可广播的”，则计算过程遵循下列规则：</p><ul><li>如果两个<code>tensor</code>的维度不同，则在维度较小的<code>tensor</code>的前面增加维度，使它们维度相等。</li><li>对于每个维度，计算结果的维数取两个<code>tensor</code>中较大的那个值。</li><li>两个<code>tensor</code>扩展维度的过程是将数值进行复制。</li></ul></li><li><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 和 y 不可以广播，因为 3rd 尾部维度 x 为 2, y 为 3, 不符合“维度不等且其中一个维度为 1 或其中一个维度不存在”</span></span><br><span class="line">x=torch.ones(<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">y=torch.ones(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">(x + y).shape</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409282135346.png"alt="image-20240928213556171" /><figcaption aria-hidden="true">image-20240928213556171</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有维度的维数均相等，一定可以 broadcasting</span></span><br><span class="line">x=torch.ones(<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>)</span><br><span class="line">y=torch.ones(<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>)</span><br><span class="line">(x + y).shape</span><br><span class="line"><span class="comment"># 输出 torch.Size([5, 7, 3])</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 和 y 不能被广播, 因为 x 没有符合“至少有一个维度”, 不可以 broadcasting</span></span><br><span class="line">x=torch.ones((<span class="number">0</span>))</span><br><span class="line">y=torch.ones(5,7)</span><br><span class="line">(x + y).shape</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409282133450.png"alt="image-20240928213350259" /><figcaption aria-hidden="true">image-20240928213350259</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 和 y 可以广播</span></span><br><span class="line">x=torch.ones(<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.ones(  <span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 从尾部维度开始遍历</span></span><br><span class="line"><span class="comment"># 1st 尾部维度: x 和 y 相同，都为 1</span></span><br><span class="line"><span class="comment"># 2nd 尾部维度: y 为 1, x 为 4, 符合维度不等且其中一个维度为 1, 则广播为 4</span></span><br><span class="line"><span class="comment"># 3rd 尾部维度: x 和 y 相同, 都为 3</span></span><br><span class="line"><span class="comment"># 4th 尾部维度: y 维度不存在, x 为 5, 符合维度不等且其中一个维度不存在，则广播为 5</span></span><br><span class="line">(x + y).shape</span><br><span class="line"><span class="comment"># 输出 torch.Size([5, 3, 4, 1])</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 和 y 不可以广播，因为 3rd 尾部维度 x 为 2, y 为 3, 不符合“维度不等且其中一个维度为 1 或其中一个维度不存在”</span></span><br><span class="line">x=torch.ones(5,2,4,1)</span><br><span class="line">y=torch.ones(  3,1,1)</span><br><span class="line">(x + y).shape</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409282139552.png"alt="image-20240928213941401" /><figcaption aria-hidden="true">image-20240928213941401</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 和 y 可以广播，在维度较小y前面增加维度，使它们维度相等。</span></span><br><span class="line">x=torch.ones(5,2,4,1)</span><br><span class="line">y=torch.ones(    1,1)</span><br><span class="line"><span class="built_in">print</span>((x+y).size())</span><br><span class="line"><span class="comment"># 输出 torch.Size([5, 2, 4, 1])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype = torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(A / A.<span class="built_in">sum</span>(axis = <span class="number">0</span>)<span class="comment"># 符合广播机制</span></span><br><span class="line"><span class="built_in">print</span>(A / A.<span class="built_in">sum</span>(axis = <span class="number">1</span>))<span class="comment"># 不符合广播机制</span></span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409282152088.png"alt="image-20240928215213886" /><figcaption aria-hidden="true">image-20240928215213886</figcaption></figure></li></ul><h2 id="in---place-语义">in - place 语义</h2><p><code>in-place operation</code>称为原地操作符，在<code>pytorch</code>中是指改变一个<code>tensor</code>的值的时候，不经过复制操作，而是直接在原来的内存上改变它的值。在<code>pytorch</code>中经常加后缀“<code>_</code>”来代表原地操作符，如<code>.add_()</code> 、 <code>.scatter()</code> 等</p><p><code>in-place</code>操作不允许<code>tensor</code>像广播那样改变形状。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 和 y 可以广播</span></span><br><span class="line">x=torch.empty(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">y=torch.empty(<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">x.add(y).shape</span><br><span class="line"><span class="comment"># 输出 torch.Size([3, 3, 7])</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x 和 y 不可以广播</span></span><br><span class="line">x=torch.empty(1,3,1)</span><br><span class="line">y=torch.empty(3,1,7)</span><br><span class="line">x.add_(y).shape</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409282145868.png"alt="image-20240928214507682" /><figcaption aria-hidden="true">image-20240928214507682</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Tips】</title>
      <link href="/2024/04/25/%5Bobject%20Object%5D/C++/%E3%80%90Tips%E3%80%91/"/>
      <url>/2024/04/25/%5Bobject%20Object%5D/C++/%E3%80%90Tips%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="tips">Tips</h1><h2 id="精度">精度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eps 表示精度，取决于题目对精度的要求，通常比题目精度高 2 位</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-4</span>;<span class="comment">// 假设题目要求保留 2 位小数</span></span><br></pre></td></tr></table></figure><h2 id="i"><code>~i</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i != <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">~i;</span><br></pre></td></tr></table></figure><h2 id="大数组必须定义为全局变量">大数组必须定义为全局变量</h2><ul><li><p>在函数（包含main）内部声明的变量属于局部变量</p></li><li><p>局部变量存放在<strong>栈空间</strong>，栈空间默认为4MB，最多只能存储 <code>1e6</code> 大小的 <code>int</code> 数组</p></li><li><p>全局变量存放在<strong>堆空间</strong>，堆空间很大，如果内存为4GB，堆空间也可以达到 4GB</p></li></ul><p>​ 因此C++ 中若要设置长度大于 <code>1e6</code>的数组，不能在函数内部声明，因为这样属于局部变量，存放在栈空间上，容易造成内存溢出</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291023786.png" alt="image-20240329102329729" style="zoom: 50%;" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291024238.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><span id="more"></span><h2 id="puts">puts</h2><ul><li><strong>作用</strong>：输出一个字符串，然后加上回车</li></ul><blockquote><p>在用puts输出时会将字符串结束标志 <code>\0</code> 转换成<code>\n</code></p></blockquote><ul><li><strong>输出回车</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">// 字符串为空，相当于只输出一个回车</span></span><br></pre></td></tr></table></figure><ul><li><strong>输出字符串</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用puts函数输出的字符串中可以包含转义字符</span></span><br><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&quot;China\nBeijing&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">China</span><br><span class="line">Beijing</span><br></pre></td></tr></table></figure><h2 id="getlinecin">getline、cin</h2><ul><li><code>getline</code> <strong>功能：</strong><ul><li>从当前缓冲区中读取数据</li><li>直到遇到<strong>换行符 <code>\n</code></strong> 停止（<strong>换行符<code>\n</code></strong> 也会被读入指定的 string 中）</li><li>并将换行符 <code>\n</code> 替换成<strong>字符串结束符<code>\0</code></strong></li></ul></li></ul><h2 id="处理输入">处理输入</h2><h3 id="逗号表达式">逗号表达式</h3><p>以为例</p><ul><li><p>逗号表达式的值等于<strong>最后一个表达式的值</strong></p></li><li><p>通常用在处理输入，eg：</p><ul><li>“每个测试用例占一行，包含一个整数 <spanclass="math inline">\(n\)</span>​。当输入用例 <spanclass="math inline">\(n=−1\)</span>​时，表示输入终止，且该用例无需处理。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n, n != <span class="number">-1</span>)<span class="comment">// while(scanf(&quot;%d&quot;, &amp;n), n != -1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>“每个测试用例占一行，包含三个整数 a、b、c。当输入一行 “<spanclass="math inline">\(0\ 0\ 0\)</span>”时，表示输入终止，且该用例无需处理</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c)<span class="comment">// while(scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c), a || b || c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="whilecinwhilescanf--1">while(cin&gt;&gt;)/while(scanf() !=-1)</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8421970/">AcWing1010. 拦截导弹 -AcWing</a>的输入为例，输入数据只有一行，该行数据的个数未知（整数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 法一：使用scanf */</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[n]) != <span class="number">-1</span>)</span><br><span class="line">    n ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 法二：使用cin */</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a[n])</span><br><span class="line">    n ++;</span><br></pre></td></tr></table></figure><p>以<ahref="https://www.acwing.com/activity/content/code/content/8541559/">AcWing1144. 连接格点 -AcWing</a>的输入为例，输入数据行数未知，每行只输入1个数据（整数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 法一：使用scanf */</span></span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2) != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 法二：使用cin */</span></span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<a href="http://bailian.openjudge.cn/practice/1936/">OpenJudge -1936:全在其中</a>的输入为例，多组测试数据，测试样例数量未知，每行只输入2个数据（字符串），以空格分隔</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 法一：使用scanf */</span></span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 法二：使用cin */</span></span><br><span class="line"><span class="built_in">string</span> s, t;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sstream">sstream</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8466405/">AcWing920. 最优乘车 - AcWing</a>的输入为例，有以下特点：</p><ul><li>输入数据有多行</li><li>每行数据的个数未知</li></ul><blockquote><p>sstream 请参考：<ahref="https://njfjnkm.github.io/2024/03/30/%5Bobject%20Object%5D/C++/stringstream/">stringstream| 天道酬勤，厚德载物 (njfjnkm.github.io)</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline(<span class="built_in">cin</span>, line);<span class="comment">// 把第一行末尾的回车过滤掉</span></span><br><span class="line"><span class="keyword">while</span> (m -- )</span><br><span class="line">&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>, line);</span><br><span class="line">    <span class="built_in">stringstream</span> <span class="title function_">ssin</span><span class="params">(line)</span>;<span class="comment">// 使用 stringstream 接收字符串</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, p;</span><br><span class="line">    <span class="keyword">while</span> (ssin &gt;&gt; p)</span><br><span class="line">        stop[cnt ++ ] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; cnt; k ++ )</span><br><span class="line">            g[stop[j]][stop[k]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getlinecin-s">getline(cin, s)</h3><p>以<a href="https://www.acwing.com/solution/content/250172/">AcWing1524. 最长回文子串 -AcWing</a>为例：如果输入是一个<strong>字符串</strong>且含有<strong>空格</strong>，则必须使用<code>string</code> + <code>getline()</code>处理输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure><h3 id="自定义input函数">自定义input函数</h3><p>以<a href="https://www.acwing.com/solution/content/251688/">HDU 1230.火星A+B -AcWing</a>为例：多组测试用例，每个测试用例占一行，包含两个火星正整数A和B，火星整数的<strong>相邻两位数（位数不固定）</strong>用<code>,</code>分隔，A和B之间有一个<strong>空格</strong>间隔。当A或B为0时输入结束，相应的结果不要输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A)</span><span class="comment">// 这里一定要加上 &amp;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            t = t * <span class="number">10</span> + a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            A.push_back(t);</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A.push_back(t);</span><br><span class="line">    reverse(A.begin(), A.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, B, C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b, a != <span class="string">&quot;0&quot;</span> || b != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A.clear(), B.clear(), C.clear();</span><br><span class="line">        input(a, A), input(b, B);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="坐标系">坐标系</h2><p>算法中有 <span class="math inline">\(2\)</span> 种常用的坐标系</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404142247048.png"alt="image-20240414224707942" /><figcaption aria-hidden="true">image-20240414224707942</figcaption></figure><h2 id="二维坐标映射一维坐标">二维坐标映射一维坐标</h2><p>以<ahref="https://www.acwing.com/activity/content/code/content/8368371/">AcWing1250. 格子游戏（算法提高课） - AcWing</a>为例</p><ul><li>需要确保二维坐标 <span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span> 以及一维坐标 <spanclass="math inline">\(p\)</span> 都是从<font color='red'>下标 <spanclass="math inline">\(0\)</span> </font>开始的</li></ul><blockquote><p>如果是从下标 1 开始的，需要先将坐标 <code>--</code>，再进行转化</p></blockquote><ul><li>假设二维数组是 <span class="math inline">\(n\)</span> 行 <spanclass="math inline">\(m\)</span> 列</li></ul><h3 id="二位坐标转一维坐标">二位坐标转一维坐标</h3><ul><li>法一：每次调用 <code>get()</code> 函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 如果二维坐标 x, y 从 1 开始，添加下面一行代码 */</span></span><br><span class="line">    <span class="comment">// x --, y --;</span></span><br><span class="line"><span class="keyword">return</span> x * m + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维坐标转化为二维坐标">一维坐标转化为二维坐标</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果二维坐标 p 从 1 开始，添加下面一行代码 */</span></span><br><span class="line"><span class="comment">// p --;</span></span><br><span class="line"><span class="type">int</span> x = p / m, y = p % m;</span><br></pre></td></tr></table></figure><p>地x 状态y</p><p>0 0</p><p>1 *</p><p>feix feiy = 1</p><h2 id="子串-vs-子序列">子串 vs 子序列</h2><h3 id="子串">子串</h3><ul><li><p><strong>定义：</strong>子串(sub-string)：串中任意个<font color='red'><strong>连续字符</strong></font>组成的子序列称为该串的子串</p></li><li><p><strong>举例：</strong></p><ul><li>ab的子串：a、b、ab、/0(空串）共 4 个即（2+1+1）个</li><li>abc的子串：a、 b、 c、 ab、 bc 、abc、/0(空串）共（3+2+1+1）个</li></ul></li></ul><p>所以若字符串的长度为 <span class="math inline">\(n\)</span>,则子串的个数就是 <span class="math inline">\([n(n+1)/2+1]\)</span>个</p><h3 id="子序列">子序列</h3><ul><li><p><strong>定义：</strong>子序列(sub-sequence)：一个给定的序列的子序列是在该序列中<strong>删除若干元素后</strong>得到的序列</p></li><li><p><strong>举例：</strong></p></li><li><p>ab的子串：/0(空串）、a、b、ab 共 4 个</p></li><li><p>abc的子串：/0(空串）、a、 b、 c、 ab、 ac、bc 、abc 共 8个</p></li></ul><p>所以若字符串的长度为 <span class="math inline">\(n\)</span>,则子串的个数就是 <span class="math inline">\(2^n\)</span> 个</p><h3 id="关系">关系</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404142316263.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2id="using-namespace-stddefinetypedefinclude-先后顺序"><code>using namespace std</code>、<code>#define</code>、<code>typedef</code>、<code>#include</code>先后顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q[N][N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h2 id="c默认向下取整">C++默认向下取整</h2><h2 id="区间长度与端点">区间长度与端点</h2><ul><li><p>如果区间长度为 <spanclass="math inline">\(len\)</span>、区间左端点为 <spanclass="math inline">\(l\)</span>，则区间右端点为 <spanclass="math inline">\(l+len-1\)</span></p></li><li><p>如果区间长度为 <spanclass="math inline">\(len\)</span>、区间右端点为 <spanclass="math inline">\(r\)</span>，则区间左端点为 <spanclass="math inline">\(r-len+1\)</span></p></li><li><p>如果区间左端点为 <spanclass="math inline">\(l\)</span>、区间右端点为 <spanclass="math inline">\(r\)</span>，则区间长度为 <spanclass="math inline">\(r-l+1\)</span></p></li><li><p>如果每连续 <span class="math inline">\(len\)</span> 个元素是 1个区间，那么这些区间对应位置元素模 <spanclass="math inline">\(len\)</span> 的结果相同 <spanclass="math inline">\(0,1,...,n-1\)</span>，根据这个性质可以准确地求出对应的坐标</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404281921995.jpg"alt="cebd9028783c4f471843d3455be20f6" /><figcaptionaria-hidden="true">cebd9028783c4f471843d3455be20f6</figcaption></figure><h2 id="四舍五入">四舍五入</h2><h3 id="四舍五入精确到小数点后i位">四舍五入精确到小数点后i位</h3><ul><li>计算时</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">rounding</span><span class="params">(<span class="type">double</span> x)</span> <span class="comment">// 四舍五入保留 i 位小数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(x * <span class="built_in">pow</span>(<span class="number">10</span>, i)) / <span class="built_in">pow</span>(<span class="number">10</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出时</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.4f&quot;</span>, x);<span class="comment">// 将double类型的变量 x 以【四舍五入】精确到小数点后 4 位的形式输出</span></span><br></pre></td></tr></table></figure><h3 id="四舍五入精确到整数">四舍五入精确到整数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = (<span class="type">int</span>) round(y);<span class="comment">// 将double类型的变量 x 四舍五入保留到整数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API</title>
      <link href="/2024/04/23/%5Bobject%20Object%5D/python/API/"/>
      <url>/2024/04/23/%5Bobject%20Object%5D/python/API/</url>
      
        <content type="html"><![CDATA[<h1 id="api">API</h1><h2 id="range函数">range函数</h2><h3 id="原型">原型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(start, stop[, step])      <span class="comment"># []代表不是必须</span></span><br></pre></td></tr></table></figure><p><strong>输入参数：</strong></p><ul><li><code>start</code> 默认为 <spanclass="math inline">\(0\)</span>，表示起始值</li><li><code>stop</code> 表示终止范围，<strong>必须指定</strong></li><li><code>step</code> 默认为 <spanclass="math inline">\(1\)</span>，表示步长</li></ul><blockquote><p>其中，<code>start</code>表示这一些列数字中的第一个数字；<code>stop - 1</code>表示这一系列数字中的最后一个数字，产生的数字中<strong>不包括</strong><code>stop</code></p></blockquote><span id="more"></span><h3 id="应用">应用</h3><p><code>range()</code>函数产生的这一系列的数字并<font color='red'><strong>不是</strong></font>以<strong>列表（list）</strong>类型存在的，这样做的目的是为了节省代码所占空间</p><h4id="将range产生的数字转换为列表">将<code>range()</code>产生的数字转换为列表</h4><p>使用如下方法可以将range()产生的数字转换为列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 输出：[0,1，2，3，4]</span></span><br></pre></td></tr></table></figure><p>从图 <span class="math inline">\(1\)</span>中可以看出，<code>range(0,5)</code> 产生的数字中不包含 <spanclass="math inline">\(5\)</span></p><h4id="在for语句中使用range产生的数字">在<code>for</code>语句中使用<code>range()</code>产生的数字</h4><p><code>for</code> 语句的主要作用是遍历容器中的元素，也可以在<code>for</code> 语句中使用 <code>range()</code> 产生的数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, stop, step):</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; stop; i += step)</span><br></pre></td></tr></table></figure><h4 id="对range产生的数字求和">对range()产生的数字求和</h4><p><code>range()</code> 产生的数字具有可叠加性（<ahref="https://so.csdn.net/so/search?q=iterable&amp;spm=1001.2101.3001.7020">iterable</a>），可以通过sum()函数对其进行求和处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># 输出：10</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100 numpy exercises</title>
      <link href="/2024/04/22/%5Bobject%20Object%5D/python/%E3%80%90numpy%E3%80%91/100%20numpy%20exercises/"/>
      <url>/2024/04/22/%5Bobject%20Object%5D/python/%E3%80%90numpy%E3%80%91/100%20numpy%20exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy-exercises">100 numpy exercises</h1><p><ahref="https://colab.research.google.com/drive/1I-RFqhrOUz0Vq4aZ-iT_CfTNJdLIGdie#scrollTo=1a84bed8">100_Numpy_exercises.ipynb- Colab (google.com)</a></p><p>This is a collection of exercises that have been collected in thenumpy mailing list, on stack overflow and in the numpy documentation.The goal of this collection is to offer a quick reference for both oldand new users but also to provide a set of exercises for those whoteach.</p><h4 id="import-the-numpy-package-under-the-name-np">1. Import the numpypackage under the name <code>np</code> (★☆☆)</h4><p><code>hint: import … as</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="print-the-numpy-version-and-the-configuration">2. Print thenumpy version and the configuration (★☆☆)</h4><p><code>hint: np.__version__, np.show_config)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.__version__)</span><br><span class="line">np.show_config()</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="create-a-null-vector-of-size-10">3. Create a null vector of size10 (★☆☆)</h4><p><code>hint: np.zeros</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-find-the-memory-size-of-any-array">4. How to find thememory size of any array (★☆☆)</h4><p><code>hint: size, itemsize</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d bytes&quot;</span> % (Z.size * Z.itemsize))</span><br></pre></td></tr></table></figure><h4id="how-to-get-the-documentation-of-the-numpy-add-function-from-the-command-line">5.How to get the documentation of the numpy add function from the commandline? (★☆☆)</h4><p><code>hint: np.info</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%run `python -c <span class="string">&quot;import numpy; numpy.info(numpy.add)&quot;</span>`</span><br></pre></td></tr></table></figure><h4id="create-a-null-vector-of-size-10-but-the-fifth-value-which-is-1">6.Create a null vector of size 10 but the fifth value which is 1(★☆☆)</h4><p><code>hint: array[4]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line">Z[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-vector-with-values-ranging-from-10-to-49">7. Create avector with values ranging from 10 to 49 (★☆☆)</h4><p><code>hint: arange</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="reverse-a-vector-first-element-becomes-last">8. Reverse a vector(first element becomes last) (★☆☆)</h4><p><code>hint: array[::-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">50</span>)</span><br><span class="line">Z = Z[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-3x3-matrix-with-values-ranging-from-0-to-8">9. Create a3x3 matrix with values ranging from 0 to 8 (★☆☆)</h4><p><code>hint: reshape</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="find-indices下标-of-non-zero-elements-from-120040">10. Find<font color = 'blue'>indices(下标)</font> of non-zero elements from[1,2,0,0,4,0] (★☆☆)</h4><p><code>hint: np.nonzero</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nz = np.nonzero([<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(nz)</span><br></pre></td></tr></table></figure><h4 id="create-a-3x3-identity-matrix单位矩阵">11. Create a 3x3<font color = 'blue'> identity matrix(单位矩阵) </font> (★☆☆)</h4><p><code>hint: np.eye</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.eye(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-3x3x3-array-with-random-values">12. Create a 3x3x3array with random values (★☆☆)</h4><p><code>hint: np.random.random</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-10x10-array-with-random-values-and-find-the-minimum-and-maximum-values">13.Create a 10x10 array with random values and find the minimum and maximumvalues (★☆☆)</h4><p><code>hint: min, max</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">Zmin, Zmax = Z.<span class="built_in">min</span>(), Z.<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(Zmin, Zmax)</span><br></pre></td></tr></table></figure><h4 id="create-a-random-vector-of-size-30-and-find-the-mean-value">14.Create a random vector of size 30 and find the mean value (★☆☆)</h4><p><code>hint: mean</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">30</span>)</span><br><span class="line">m = Z.mean()</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><h4 id="create-a-2d-array-with-1-on-the-border-and-0-inside">15. Createa 2d array with 1 on the border and 0 inside (★☆☆)</h4><p><code>hint: array[1:-1, 1:-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.ones((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-add-a-border-filled-with-0s-around-an-existing-array">16.How to add a border (filled with 0's) around an existing array?(★☆☆)</h4><p><code>hint: np.pad</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Z = np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z = np.pad(Z, pad_width=<span class="number">1</span>, mode=<span class="string">&#x27;constant&#x27;</span>, constant_values=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using fancy indexing</span></span><br><span class="line">Z[:, [<span class="number">0</span>, -<span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">Z[[<span class="number">0</span>, -<span class="number">1</span>], :] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="what-is-the-result-of-the-following-expression">17. What is theresult of the following expression? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> * np.nan</span><br><span class="line">np.nan == np.nan</span><br><span class="line">np.inf &gt; np.nan</span><br><span class="line">np.nan - np.nan</span><br><span class="line">np.nan <span class="keyword">in</span> <span class="built_in">set</span>([np.nan])</span><br><span class="line"><span class="number">0.3</span> == <span class="number">3</span> * <span class="number">0.1</span></span><br></pre></td></tr></table></figure><p><code>hint: NaN = not a number, inf = infinity</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0</span> * np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan == np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.inf &gt; np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan - np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan <span class="keyword">in</span> <span class="built_in">set</span>([np.nan]))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.3</span> == <span class="number">3</span> * <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><h4id="create-a-5x5-matrix-with-values-1234-just-below-the-diagonal">18.Create a 5x5 matrix with values 1,2,3,4 just below the diagonal(★☆☆)</h4><p><code>hint: np.diag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.diag(<span class="number">1</span>+np.arange(<span class="number">4</span>),k=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-8x8-matrix-and-fill-it-with-a-checkerboard-pattern">19.Create a 8x8 matrix and fill it with a checkerboard pattern (★☆☆)</h4><p><code>hint: array[::2]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">8</span>,<span class="number">8</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">Z[<span class="number">1</span>::<span class="number">2</span>,::<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Z[::<span class="number">2</span>,<span class="number">1</span>::<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="consider-a-678-shape-array-what-is-the-index-xyz-of-the-100th-element">20.Consider a (6,7,8) shape array, what is the index (x,y,z) of the 100thelement? (★☆☆)</h4><p><code>hint: np.unravel_index</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.unravel_index(<span class="number">99</span>,(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)))</span><br></pre></td></tr></table></figure><h4 id="create-a-checkerboard-8x8-matrix-using-the-tile-function">21.Create a checkerboard 8x8 matrix using the tile function (★☆☆)</h4><p><code>hint: np.tile</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.tile( np.array([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]), (<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="normalize-a-5x5-random-matrix">22. Normalize a 5x5 random matrix(★☆☆)</h4><p><code>hint: (x -mean)/std</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z = (Z - np.mean (Z)) / (np.std (Z))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-custom-dtype-that-describes-a-color-as-four-unsigned-bytes-rgba">23.Create a custom dtype that describes a color as four unsigned bytes(RGBA) (★☆☆)</h4><p><code>hint: np.dtype</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color = np.dtype([(<span class="string">&quot;r&quot;</span>, np.ubyte),</span><br><span class="line">                  (<span class="string">&quot;g&quot;</span>, np.ubyte),</span><br><span class="line">                  (<span class="string">&quot;b&quot;</span>, np.ubyte),</span><br><span class="line">                  (<span class="string">&quot;a&quot;</span>, np.ubyte)])</span><br></pre></td></tr></table></figure><h4 id="multiply-a-5x3-matrix-by-a-3x2-matrix-real-matrix-product">24.Multiply a 5x3 matrix by a 3x2 matrix (real matrix product) (★☆☆)</h4><p><code>hint:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.dot(np.ones((<span class="number">5</span>,<span class="number">3</span>)), np.ones((<span class="number">3</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternative solution, in Python 3.5 and above</span></span><br><span class="line">Z = np.ones((<span class="number">5</span>,<span class="number">3</span>)) @ np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="given-a-1d-array-negate-all-elements-which-are-between-3-and-8-in-place.">25.Given a 1D array, negate all elements which are between 3 and 8, inplace. (★☆☆)</h4><p><code>hint: &gt;, &lt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">11</span>)</span><br><span class="line">Z[(<span class="number">3</span> &lt; Z) &amp; (Z &lt; <span class="number">8</span>)] *= -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="what-is-the-output-of-the-following-script">26. What is theoutput of the following script? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jake VanderPlas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><code>hint: np.sum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jake VanderPlas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4id="consider-an-integer-vector-z-which-of-these-expressions-are-legal">27.Consider an integer vector Z, which of these expressions are legal?(★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z**Z</span><br><span class="line"><span class="number">2</span> &lt;&lt; Z &gt;&gt; <span class="number">2</span></span><br><span class="line">Z &lt;- Z</span><br><span class="line"><span class="number">1j</span>*Z</span><br><span class="line">Z/<span class="number">1</span>/<span class="number">1</span></span><br><span class="line">Z&lt;Z&gt;Z</span><br></pre></td></tr></table></figure><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z**Z</span><br><span class="line"><span class="number">2</span> &lt;&lt; Z &gt;&gt; <span class="number">2</span></span><br><span class="line">Z &lt;- Z</span><br><span class="line"><span class="number">1j</span>*Z</span><br><span class="line">Z/<span class="number">1</span>/<span class="number">1</span></span><br><span class="line">Z&lt;Z&gt;Z</span><br></pre></td></tr></table></figure><h4 id="what-are-the-result-of-the-following-expressions">28. What arethe result of the following expressions? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.array(<span class="number">0</span>) / np.array(<span class="number">0</span>)</span><br><span class="line">np.array(<span class="number">0</span>) // np.array(<span class="number">0</span>)</span><br><span class="line">np.array([np.nan]).astype(<span class="built_in">int</span>).astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.array(<span class="number">0</span>) / np.array(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(np.array(<span class="number">0</span>) // np.array(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(np.array([np.nan]).astype(<span class="built_in">int</span>).astype(<span class="built_in">float</span>))</span><br></pre></td></tr></table></figure><h4 id="how-to-round-away-from-zero-a-float-array">29. How to round awayfrom zero a float array ? (★☆☆)</h4><p><code>hint: np.uniform, np.copysign, np.ceil, np.abs, np.where</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Charles R Harris</span></span><br><span class="line"></span><br><span class="line">Z = np.random.uniform(-<span class="number">10</span>,+<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(np.copysign(np.ceil(np.<span class="built_in">abs</span>(Z)), Z))</span><br><span class="line"></span><br><span class="line"><span class="comment"># More readable but less efficient</span></span><br><span class="line"><span class="built_in">print</span>(np.where(Z&gt;<span class="number">0</span>, np.ceil(Z), np.floor(Z)))</span><br></pre></td></tr></table></figure><h4 id="how-to-find-common-values-between-two-arrays">30. How to findcommon values between two arrays? (★☆☆)</h4><p><code>hint: np.intersect1d</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z1 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">Z2 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(np.intersect1d(Z1,Z2))</span><br></pre></td></tr></table></figure><h4 id="how-to-ignore-all-numpy-warnings-not-recommended">31. How toignore all numpy warnings (not recommended)? (★☆☆)</h4><p><code>hint: np.seterr, np.errstate</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Suicide mode on</span></span><br><span class="line">defaults = np.seterr(<span class="built_in">all</span>=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line">Z = np.ones(<span class="number">1</span>) / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Back to sanity</span></span><br><span class="line">_ = np.seterr(**defaults)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalently with a context manager</span></span><br><span class="line"><span class="keyword">with</span> np.errstate(<span class="built_in">all</span>=<span class="string">&quot;ignore&quot;</span>):</span><br><span class="line">    np.arange(<span class="number">3</span>) / <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="is-the-following-expressions-true">32. Is the followingexpressions true? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(-<span class="number">1</span>) == np.emath.sqrt(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>hint: imaginary number</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(-<span class="number">1</span>) == np.emath.sqrt(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="how-to-get-the-dates-of-yesterday-today-and-tomorrow">33. How toget the dates of yesterday, today and tomorrow? (★☆☆)</h4><p><code>hint: np.datetime64, np.timedelta64</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yesterday = np.datetime64(<span class="string">&#x27;today&#x27;</span>) - np.timedelta64(<span class="number">1</span>)</span><br><span class="line">today     = np.datetime64(<span class="string">&#x27;today&#x27;</span>)</span><br><span class="line">tomorrow  = np.datetime64(<span class="string">&#x27;today&#x27;</span>) + np.timedelta64(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4id="how-to-get-all-the-dates-corresponding-to-the-month-of-july-2016">34.How to get all the dates corresponding to the month of July 2016?(★★☆)</h4><p><code>hint: np.arange(dtype=datetime64['D'])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="string">&#x27;2016-07&#x27;</span>, <span class="string">&#x27;2016-08&#x27;</span>, dtype=<span class="string">&#x27;datetime64[D]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-compute-ab-a2-in-place-without-copy">35. How to compute((A+B)*(-A/2)) in place (without copy)? (★★☆)</h4><p><code>hint: np.add(out=), np.negative(out=), np.multiply(out=), np.divide(out=)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones(<span class="number">3</span>)*<span class="number">1</span></span><br><span class="line">B = np.ones(<span class="number">3</span>)*<span class="number">2</span></span><br><span class="line">np.add(A,B,out=B)</span><br><span class="line">np.divide(A,<span class="number">2</span>,out=A)</span><br><span class="line">np.negative(A,out=A)</span><br><span class="line">np.multiply(A,B,out=A)</span><br></pre></td></tr></table></figure><h4id="extract-the-integer-part-of-a-random-array-of-positive-numbers-using-4-different-methods">36.Extract the integer part of a random array of positive numbers using 4different methods (★★☆)</h4><p><code>hint: %, np.floor, astype, np.trunc</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Z - Z%<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z // <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np.floor(Z))</span><br><span class="line"><span class="built_in">print</span>(Z.astype(<span class="built_in">int</span>))</span><br><span class="line"><span class="built_in">print</span>(np.trunc(Z))</span><br></pre></td></tr></table></figure><h4 id="create-a-5x5-matrix-with-row-values-ranging-from-0-to-4">37.Create a 5x5 matrix with row values ranging from 0 to 4 (★★☆)</h4><p><code>hint: np.arange</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z += np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># without broadcasting</span></span><br><span class="line">Z = np.tile(np.arange(<span class="number">0</span>, <span class="number">5</span>), (<span class="number">5</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="consider-a-generator-function-that-generates-10-integers-and-use-it-to-build-an-array">38.Consider a generator function that generates 10 integers and use it tobuild an array (★☆☆)</h4><p><code>hint: np.fromiter</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">Z = np.fromiter(generate(),dtype=<span class="built_in">float</span>,count=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-vector-of-size-10-with-values-ranging-from-0-to-1-both-excluded">39.Create a vector of size 10 with values ranging from 0 to 1, bothexcluded (★★☆)</h4><p><code>hint: np.linspace</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">11</span>,endpoint=<span class="literal">False</span>)[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-random-vector-of-size-10-and-sort-it">40. Create arandom vector of size 10 and sort it (★★☆)</h4><p><code>hint: sort</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z.sort()</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-sum-a-small-array-faster-than-np.sum">41. How to sum asmall array faster than np.sum? (★★☆)</h4><p><code>hint: np.add.reduce</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">10</span>)</span><br><span class="line">np.add.reduce(Z)</span><br></pre></td></tr></table></figure><h4 id="consider-two-random-array-a-and-b-check-if-they-are-equal">42.Consider two random array A and B, check if they are equal (★★☆)</h4><p><code>hint: np.allclose, np.array_equal</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">B = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assuming identical shape of the arrays and a tolerance for the comparison of values</span></span><br><span class="line">equal = np.allclose(A,B)</span><br><span class="line"><span class="built_in">print</span>(equal)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking both the shape and the element values, no tolerance (values have to be exactly equal)</span></span><br><span class="line">equal = np.array_equal(A,B)</span><br><span class="line"><span class="built_in">print</span>(equal)</span><br></pre></td></tr></table></figure><h4 id="make-an-array-immutable-read-only">43. Make an array immutable(read-only) (★★☆)</h4><p><code>hint: flags.writeable</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line">Z.flags.writeable = <span class="literal">False</span></span><br><span class="line">Z[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4id="consider-a-random-10x2-matrix-representing-cartesian-coordinates-convert-them-to-polar-coordinates">44.Consider a random 10x2 matrix representing cartesian coordinates,convert them to polar coordinates (★★☆)</h4><p><code>hint: np.sqrt, np.arctan2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">X,Y = Z[:,<span class="number">0</span>], Z[:,<span class="number">1</span>]</span><br><span class="line">R = np.sqrt(X**<span class="number">2</span>+Y**<span class="number">2</span>)</span><br><span class="line">T = np.arctan2(Y,X)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br><span class="line"><span class="built_in">print</span>(T)</span><br></pre></td></tr></table></figure><h4id="create-random-vector-of-size-10-and-replace-the-maximum-value-by-0">45.Create random vector of size 10 and replace the maximum value by 0(★★☆)</h4><p><code>hint: argmax</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z[Z.argmax()] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-structured-array-with-x-and-y-coordinates-covering-the-01x01-area">46.Create a structured array with <code>x</code> and <code>y</code>coordinates covering the [0,1]x[0,1] area (★★☆)</h4><p><code>hint: np.meshgrid</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">5</span>,<span class="number">5</span>), [(<span class="string">&#x27;x&#x27;</span>,<span class="built_in">float</span>),(<span class="string">&#x27;y&#x27;</span>,<span class="built_in">float</span>)])</span><br><span class="line">Z[<span class="string">&#x27;x&#x27;</span>], Z[<span class="string">&#x27;y&#x27;</span>] = np.meshgrid(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>),</span><br><span class="line">                             np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="given-two-arrays-x-and-y-construct-the-cauchy-matrix-c-cij-1xi---yj">47.Given two arrays, X and Y, construct the Cauchy matrix C (Cij =1/(xi -yj)) (★★☆)</h4><p><code>hint: np.subtract.outer</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">X = np.arange(<span class="number">8</span>)</span><br><span class="line">Y = X + <span class="number">0.5</span></span><br><span class="line">C = <span class="number">1.0</span> / np.subtract.outer(X, Y)</span><br><span class="line"><span class="built_in">print</span>(np.linalg.det(C))</span><br></pre></td></tr></table></figure><h4id="print-the-minimum-and-maximum-representable-value-for-each-numpy-scalar-type">48.Print the minimum and maximum representable value for each numpy scalartype (★★☆)</h4><p><code>hint: np.iinfo, np.finfo, eps</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dtype <span class="keyword">in</span> [np.int8, np.int32, np.int64]:</span><br><span class="line">   <span class="built_in">print</span>(np.iinfo(dtype).<span class="built_in">min</span>)</span><br><span class="line">   <span class="built_in">print</span>(np.iinfo(dtype).<span class="built_in">max</span>)</span><br><span class="line"><span class="keyword">for</span> dtype <span class="keyword">in</span> [np.float32, np.float64]:</span><br><span class="line">   <span class="built_in">print</span>(np.finfo(dtype).<span class="built_in">min</span>)</span><br><span class="line">   <span class="built_in">print</span>(np.finfo(dtype).<span class="built_in">max</span>)</span><br><span class="line">   <span class="built_in">print</span>(np.finfo(dtype).eps)</span><br></pre></td></tr></table></figure><h4 id="how-to-print-all-the-values-of-an-array">49. How to print allthe values of an array? (★★☆)</h4><p><code>hint: np.set_printoptions</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>))</span><br><span class="line">Z = np.zeros((<span class="number">40</span>,<span class="number">40</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-find-the-closest-value-to-a-given-scalar-in-a-vector">50.How to find the closest value (to a given scalar) in a vector?(★★☆)</h4><p><code>hint: argmin</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">100</span>)</span><br><span class="line">v = np.random.uniform(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">index = (np.<span class="built_in">abs</span>(Z-v)).argmin()</span><br><span class="line"><span class="built_in">print</span>(Z[index])</span><br></pre></td></tr></table></figure><h4id="create-a-structured-array-representing-a-position-xy-and-a-color-rgb">51.Create a structured array representing a position (x,y) and a color(r,g,b) (★★☆)</h4><p><code>hint: dtype</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>, [ (<span class="string">&#x27;position&#x27;</span>, [ (<span class="string">&#x27;x&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),</span><br><span class="line">                                  (<span class="string">&#x27;y&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>)]),</span><br><span class="line">                   (<span class="string">&#x27;color&#x27;</span>,    [ (<span class="string">&#x27;r&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),</span><br><span class="line">                                  (<span class="string">&#x27;g&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),</span><br><span class="line">                                  (<span class="string">&#x27;b&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>)])])</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="consider-a-random-vector-with-shape-1002-representing-coordinates-find-point-by-point-distances">52.Consider a random vector with shape (100,2) representing coordinates,find point by point distances (★★☆)</h4><p><code>hint: np.atleast_2d, T, np.sqrt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">X,Y = np.atleast_2d(Z[:,<span class="number">0</span>], Z[:,<span class="number">1</span>])</span><br><span class="line">D = np.sqrt( (X-X.T)**<span class="number">2</span> + (Y-Y.T)**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Much faster with scipy</span></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="comment"># Thanks Gavin Heverly-Coulson (#issue 1)</span></span><br><span class="line"><span class="keyword">import</span> scipy.spatial</span><br><span class="line"></span><br><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">D = scipy.spatial.distance.cdist(Z,Z)</span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure><h4id="how-to-convert-a-float-32-bits-array-into-an-integer-32-bits-in-place">53.How to convert a float (32 bits) array into an integer (32 bits) inplace?</h4><p><code>hint: view and [:] =</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Thanks Vikas (https://stackoverflow.com/a/10622758/5989906)</span></span><br><span class="line"><span class="comment"># &amp; unutbu (https://stackoverflow.com/a/4396247/5989906)</span></span><br><span class="line">Z = (np.random.rand(<span class="number">10</span>)*<span class="number">100</span>).astype(np.float32)</span><br><span class="line">Y = Z.view(np.int32)</span><br><span class="line">Y[:] = Z</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><h4 id="how-to-read-the-following-file">54. How to read the followingfile? (★★☆)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5</span><br><span class="line">6,  ,  , 7, 8</span><br><span class="line"> ,  , 9,10,11</span><br></pre></td></tr></table></figure><p><code>hint: np.genfromtxt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fake file</span></span><br><span class="line">s = StringIO(<span class="string">&#x27;&#x27;&#x27;1, 2, 3, 4, 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                6,  ,  , 7, 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                 ,  , 9,10,11</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">Z = np.genfromtxt(s, delimiter=<span class="string">&quot;,&quot;</span>, dtype=np.<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="what-is-the-equivalent-of-enumerate-for-numpy-arrays">55. Whatis the equivalent of enumerate for numpy arrays? (★★☆)</h4><p><code>hint: np.ndenumerate, np.ndindex</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> np.ndenumerate(Z):</span><br><span class="line">    <span class="built_in">print</span>(index, value)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> np.ndindex(Z.shape):</span><br><span class="line">    <span class="built_in">print</span>(index, Z[index])</span><br></pre></td></tr></table></figure><h4 id="generate-a-generic-2d-gaussian-like-array">56. Generate ageneric 2D Gaussian-like array (★★☆)</h4><p><code>hint: np.meshgrid, np.exp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X, Y = np.meshgrid(np.linspace(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>), np.linspace(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">D = np.sqrt(X*X+Y*Y)</span><br><span class="line">sigma, mu = <span class="number">1.0</span>, <span class="number">0.0</span></span><br><span class="line">G = np.exp(-( (D-mu)**<span class="number">2</span> / ( <span class="number">2.0</span> * sigma**<span class="number">2</span> ) ) )</span><br><span class="line"><span class="built_in">print</span>(G)</span><br></pre></td></tr></table></figure><h4 id="how-to-randomly-place-p-elements-in-a-2d-array">57. How torandomly place p elements in a 2D array? (★★☆)</h4><p><code>hint: np.put, np.random.choice</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Divakar</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">Z = np.zeros((n,n))</span><br><span class="line">np.put(Z, np.random.choice(<span class="built_in">range</span>(n*n), p, replace=<span class="literal">False</span>),<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="subtract-the-mean-of-each-row-of-a-matrix">58. Subtract the meanof each row of a matrix (★★☆)</h4><p><code>hint: mean(axis=,keepdims=)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line">X = np.random.rand(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recent versions of numpy</span></span><br><span class="line">Y = X - X.mean(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Older versions of numpy</span></span><br><span class="line">Y = X - X.mean(axis=<span class="number">1</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><h4 id="how-to-sort-an-array-by-the-nth-column">59. How to sort an arrayby the nth column? (★★☆)</h4><p><code>hint: argsort</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Steve Tjoa</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="built_in">print</span>(Z[Z[:,<span class="number">1</span>].argsort()])</span><br></pre></td></tr></table></figure><h4 id="how-to-tell-if-a-given-2d-array-has-null-columns">60. How totell if a given 2D array has null columns? (★★☆)</h4><p><code>hint: any, ~</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># null : 0 </span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">3</span>,(<span class="number">3</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>((~Z.<span class="built_in">any</span>(axis=<span class="number">0</span>)).<span class="built_in">any</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># null : np.nan</span></span><br><span class="line">Z=np.array([</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,np.nan],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,np.nan],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">5</span>,np.nan]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">print</span>(np.isnan(Z).<span class="built_in">all</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h4 id="find-the-nearest-value-from-a-given-value-in-an-array">61. Findthe nearest value from a given value in an array (★★☆)</h4><p><code>hint: np.abs, argmin, flat</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">z = <span class="number">0.5</span></span><br><span class="line">m = Z.flat[np.<span class="built_in">abs</span>(Z - z).argmin()]</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><h4id="considering-two-arrays-with-shape-13-and-31-how-to-compute-their-sum-using-an-iterator">62.Considering two arrays with shape (1,3) and (3,1), how to compute theirsum using an iterator? (★★☆)</h4><p><code>hint: np.nditer</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">3</span>).reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">3</span>).reshape(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">it = np.nditer([A,B,<span class="literal">None</span>])</span><br><span class="line"><span class="keyword">for</span> x,y,z <span class="keyword">in</span> it: z[...] = x + y</span><br><span class="line"><span class="built_in">print</span>(it.operands[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h4 id="create-an-array-class-that-has-a-name-attribute">63. Create anarray class that has a name attribute (★★☆)</h4><p><code>hint: class method</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NamedArray</span>(np.ndarray):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, array, name=<span class="string">&quot;no name&quot;</span></span>):</span><br><span class="line">        obj = np.asarray(array).view(cls)</span><br><span class="line">        obj.name = name</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__array_finalize__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        self.name = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;no name&quot;</span>)</span><br><span class="line"></span><br><span class="line">Z = NamedArray(np.arange(<span class="number">10</span>), <span class="string">&quot;range_10&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (Z.name)</span><br></pre></td></tr></table></figure><h4id="consider-a-given-vector-how-to-add-1-to-each-element-indexed-by-a-second-vector-be-careful-with-repeated-indices">64.Consider a given vector, how to add 1 to each element indexed by asecond vector (be careful with repeated indices)? (★★★)</h4><p><code>hint: np.bincount | np.add.at</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Brett Olsen</span></span><br><span class="line"></span><br><span class="line">Z = np.ones(<span class="number">10</span>)</span><br><span class="line">I = np.random.randint(<span class="number">0</span>,<span class="built_in">len</span>(Z),<span class="number">20</span>)</span><br><span class="line">Z += np.bincount(I, minlength=<span class="built_in">len</span>(Z))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Another solution</span></span><br><span class="line"><span class="comment"># Author: Bartosz Telenczuk</span></span><br><span class="line">np.add.at(Z, I, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="how-to-accumulate-elements-of-a-vector-x-to-an-array-f-based-on-an-index-list-i">65.How to accumulate elements of a vector (X) to an array (F) based on anindex list (I)? (★★★)</h4><p><code>hint: np.bincount</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Alan G Isaac</span></span><br><span class="line"></span><br><span class="line">X = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">I = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">F = np.bincount(I,X)</span><br><span class="line"><span class="built_in">print</span>(F)</span><br></pre></td></tr></table></figure><h4id="considering-a-wh3-image-of-dtypeubyte-compute-the-number-of-unique-colors">66.Considering a (w,h,3) image of (dtype=ubyte), compute the number ofunique colors (★★☆)</h4><p><code>hint: np.unique</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Fisher Wang</span></span><br><span class="line"></span><br><span class="line">w, h = <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">I = np.random.randint(<span class="number">0</span>, <span class="number">4</span>, (h, w, <span class="number">3</span>)).astype(np.ubyte)</span><br><span class="line">colors = np.unique(I.reshape(-<span class="number">1</span>, <span class="number">3</span>), axis=<span class="number">0</span>)</span><br><span class="line">n = <span class="built_in">len</span>(colors)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Faster version</span></span><br><span class="line"><span class="comment"># Author: Mark Setchell</span></span><br><span class="line"><span class="comment"># https://stackoverflow.com/a/59671950/2836621</span></span><br><span class="line"></span><br><span class="line">w, h = <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">I = np.random.randint(<span class="number">0</span>,<span class="number">4</span>,(h,w,<span class="number">3</span>), dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># View each pixel as a single 24-bit integer, rather than three 8-bit bytes</span></span><br><span class="line">I24 = np.dot(I.astype(np.uint32),[<span class="number">1</span>,<span class="number">256</span>,<span class="number">65536</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count unique colours</span></span><br><span class="line">n = <span class="built_in">len</span>(np.unique(I24))</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><h4id="considering-a-four-dimensions-array-how-to-get-sum-over-the-last-two-axis-at-once">67.Considering a four dimensions array, how to get sum over the last twoaxis at once? (★★★)</h4><p><code>hint: sum(axis=(-2,-1))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># solution by passing a tuple of axes (introduced in numpy 1.7.0)</span></span><br><span class="line"><span class="built_in">sum</span> = A.<span class="built_in">sum</span>(axis=(-<span class="number">2</span>,-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line"><span class="comment"># solution by flattening the last two dimensions into one</span></span><br><span class="line"><span class="comment"># (useful for functions that don&#x27;t accept tuples for axis argument)</span></span><br><span class="line"><span class="built_in">sum</span> = A.reshape(A.shape[:-<span class="number">2</span>] + (-<span class="number">1</span>,)).<span class="built_in">sum</span>(axis=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><h4id="considering-a-one-dimensional-vector-d-how-to-compute-means-of-subsets-of-d-using-a-vector-s-of-same-size-describing-subset-indices">68.Considering a one-dimensional vector D, how to compute means of subsetsof D using a vector S of same size describing subset indices? (★★★)</h4><p><code>hint: np.bincount</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line">D = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">S = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">D_sums = np.bincount(S, weights=D)</span><br><span class="line">D_counts = np.bincount(S)</span><br><span class="line">D_means = D_sums / D_counts</span><br><span class="line"><span class="built_in">print</span>(D_means)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pandas solution as a reference due to more intuitive code</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="built_in">print</span>(pd.Series(D).groupby(S).mean())</span><br></pre></td></tr></table></figure><h4 id="how-to-get-the-diagonal-of-a-dot-product">69. How to get thediagonal of a dot product? (★★★)</h4><p><code>hint: np.diag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Mathieu Blondel</span></span><br><span class="line"></span><br><span class="line">A = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">B = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slow version</span></span><br><span class="line">np.diag(np.dot(A, B))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fast version</span></span><br><span class="line">np.<span class="built_in">sum</span>(A * B.T, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Faster version</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij,ji-&gt;i&quot;</span>, A, B)</span><br></pre></td></tr></table></figure><h4id="consider-the-vector-1-2-3-4-5-how-to-build-a-new-vector-with-3-consecutive-zeros-interleaved-between-each-value">70.Consider the vector [1, 2, 3, 4, 5], how to build a new vector with 3consecutive zeros interleaved between each value? (★★★)</h4><p><code>hint: array[::4]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line">Z = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">nz = <span class="number">3</span></span><br><span class="line">Z0 = np.zeros(<span class="built_in">len</span>(Z) + (<span class="built_in">len</span>(Z)-<span class="number">1</span>)*(nz))</span><br><span class="line">Z0[::nz+<span class="number">1</span>] = Z</span><br><span class="line"><span class="built_in">print</span>(Z0)</span><br></pre></td></tr></table></figure><h4id="consider-an-array-of-dimension-553-how-to-mulitply-it-by-an-array-with-dimensions-55">71.Consider an array of dimension (5,5,3), how to mulitply it by an arraywith dimensions (5,5)? (★★★)</h4><p><code>hint: array[:, :, None]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones((<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line">B = <span class="number">2</span>*np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(A * B[:,:,<span class="literal">None</span>])</span><br></pre></td></tr></table></figure><h4 id="how-to-swap-two-rows-of-an-array">72. How to swap two rows of anarray? (★★★)</h4><p><code>hint: array[[]] = array[[]]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Eelco Hoogendoorn</span></span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">25</span>).reshape(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">A[[<span class="number">0</span>,<span class="number">1</span>]] = A[[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><h4id="consider-a-set-of-10-triplets-describing-10-triangles-with-shared-vertices-find-the-set-of-unique-line-segments-composing-all-the-triangles">73.Consider a set of 10 triplets describing 10 triangles (with sharedvertices), find the set of unique line segments composing all thetriangles (★★★)</h4><p><code>hint: repeat, np.roll, np.sort, view, np.unique</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nicolas P. Rougier</span></span><br><span class="line"></span><br><span class="line">faces = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line">F = np.roll(faces.repeat(<span class="number">2</span>,axis=<span class="number">1</span>),-<span class="number">1</span>,axis=<span class="number">1</span>)</span><br><span class="line">F = F.reshape(<span class="built_in">len</span>(F)*<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">F = np.sort(F,axis=<span class="number">1</span>)</span><br><span class="line">G = F.view( dtype=[(<span class="string">&#x27;p0&#x27;</span>,F.dtype),(<span class="string">&#x27;p1&#x27;</span>,F.dtype)] )</span><br><span class="line">G = np.unique(G)</span><br><span class="line"><span class="built_in">print</span>(G)</span><br></pre></td></tr></table></figure><h4id="given-a-sorted-array-c-that-corresponds-to-a-bincount-how-to-produce-an-array-a-such-that-np.bincounta-c">74.Given a sorted array C that corresponds to a bincount, how to produce anarray A such that np.bincount(A) == C? (★★★)</h4><p><code>hint: np.repeat</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line">C = np.bincount([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line">A = np.repeat(np.arange(<span class="built_in">len</span>(C)), C)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><h4id="how-to-compute-averages-using-a-sliding-window-over-an-array">75.How to compute averages using a sliding window over an array? (★★★)</h4><p><code>hint: np.cumsum, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">moving_average</span>(<span class="params">a, n=<span class="number">3</span></span>) :</span><br><span class="line">    ret = np.cumsum(a, dtype=<span class="built_in">float</span>)</span><br><span class="line">    ret[n:] = ret[n:] - ret[:-n]</span><br><span class="line">    <span class="keyword">return</span> ret[n - <span class="number">1</span>:] / n</span><br><span class="line">Z = np.arange(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(moving_average(Z, n=<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"><span class="comment"># make sure your NumPy &gt;= 1.20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy.lib.stride_tricks <span class="keyword">import</span> sliding_window_view</span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=<span class="number">3</span>).mean(axis=-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4id="consider-a-one-dimensional-array-z-build-a-two-dimensional-array-whose-first-row-is-z0z1z2-and-each-subsequent-row-is-shifted-by-1-last-row-should-be-z-3z-2z-1">76.Consider a one-dimensional array Z, build a two-dimensional array whosefirst row is (Z[0],Z[1],Z[2]) and each subsequent row is shifted by 1(last row should be (Z[-3],Z[-2],Z[-1]) (★★★)</h4><p><code>hint: from numpy.lib import stride_tricks, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Joe Kington / Erik Rigtorp</span></span><br><span class="line"><span class="keyword">from</span> numpy.lib <span class="keyword">import</span> stride_tricks</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rolling</span>(<span class="params">a, window</span>):</span><br><span class="line">    shape = (a.size - window + <span class="number">1</span>, window)</span><br><span class="line">    strides = (a.strides[<span class="number">0</span>], a.strides[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> stride_tricks.as_strided(a, shape=shape, strides=strides)</span><br><span class="line">Z = rolling(np.arange(<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4id="how-to-negate-a-boolean-or-to-change-the-sign-of-a-float-inplace">77.How to negate a boolean, or to change the sign of a float inplace?(★★★)</h4><p><code>hint: np.logical_not, np.negative</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nathaniel J. Smith</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">100</span>)</span><br><span class="line">np.logical_not(Z, out=Z)</span><br><span class="line"></span><br><span class="line">Z = np.random.uniform(-<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">100</span>)</span><br><span class="line">np.negative(Z, out=Z)</span><br></pre></td></tr></table></figure><h4id="consider-2-sets-of-points-p0p1-describing-lines-2d-and-a-point-p-how-to-compute-distance-from-p-to-each-line-i-p0ip1i">78.Consider 2 sets of points P0,P1 describing lines (2d) and a point p, howto compute distance from p to each line i (P0[i],P1[i])? (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">P0, P1, p</span>):</span><br><span class="line">    T = P1 - P0</span><br><span class="line">    L = (T**<span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">    U = -((P0[:,<span class="number">0</span>]-p[...,<span class="number">0</span>])*T[:,<span class="number">0</span>] + (P0[:,<span class="number">1</span>]-p[...,<span class="number">1</span>])*T[:,<span class="number">1</span>]) / L</span><br><span class="line">    U = U.reshape(<span class="built_in">len</span>(U),<span class="number">1</span>)</span><br><span class="line">    D = P0 + U*T - p</span><br><span class="line">    <span class="keyword">return</span> np.sqrt((D**<span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">P0 = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">P1 = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">p  = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,( <span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(distance(P0, P1, p))</span><br></pre></td></tr></table></figure><h4id="consider-2-sets-of-points-p0p1-describing-lines-2d-and-a-set-of-points-p-how-to-compute-distance-from-each-point-j-pj-to-each-line-i-p0ip1i">79.Consider 2 sets of points P0,P1 describing lines (2d) and a set ofpoints P, how to compute distance from each point j (P[j]) to each linei (P0[i],P1[i])? (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Italmassov Kuanysh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># based on distance function from previous question</span></span><br><span class="line">P0 = np.random.uniform(-<span class="number">10</span>, <span class="number">10</span>, (<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">P1 = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">p = np.random.uniform(-<span class="number">10</span>, <span class="number">10</span>, (<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(np.array([distance(P0,P1,p_i) <span class="keyword">for</span> p_i <span class="keyword">in</span> p]))</span><br></pre></td></tr></table></figure><h4id="consider-an-arbitrary-array-write-a-function-that-extract-a-subpart-with-a-fixed-shape-and-centered-on-a-given-element-pad-with-a-fill-value-when-necessary">80.Consider an arbitrary array, write a function that extract a subpartwith a fixed shape and centered on a given element (pad with a<code>fill</code> value when necessary) (★★★)</h4><p><code>hint: minimum maximum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nicolas Rougier</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">shape = (<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">fill  = <span class="number">0</span></span><br><span class="line">position = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">R = np.ones(shape, dtype=Z.dtype)*fill</span><br><span class="line">P  = np.array(<span class="built_in">list</span>(position)).astype(<span class="built_in">int</span>)</span><br><span class="line">Rs = np.array(<span class="built_in">list</span>(R.shape)).astype(<span class="built_in">int</span>)</span><br><span class="line">Zs = np.array(<span class="built_in">list</span>(Z.shape)).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">R_start = np.zeros((<span class="built_in">len</span>(shape),)).astype(<span class="built_in">int</span>)</span><br><span class="line">R_stop  = np.array(<span class="built_in">list</span>(shape)).astype(<span class="built_in">int</span>)</span><br><span class="line">Z_start = (P-Rs//<span class="number">2</span>)</span><br><span class="line">Z_stop  = (P+Rs//<span class="number">2</span>)+Rs%<span class="number">2</span></span><br><span class="line"></span><br><span class="line">R_start = (R_start - np.minimum(Z_start,<span class="number">0</span>)).tolist()</span><br><span class="line">Z_start = (np.maximum(Z_start,<span class="number">0</span>)).tolist()</span><br><span class="line">R_stop = np.maximum(R_start, (R_stop - np.maximum(Z_stop-Zs,<span class="number">0</span>))).tolist()</span><br><span class="line">Z_stop = (np.minimum(Z_stop,Zs)).tolist()</span><br><span class="line"></span><br><span class="line">r = [<span class="built_in">slice</span>(start,stop) <span class="keyword">for</span> start,stop <span class="keyword">in</span> <span class="built_in">zip</span>(R_start,R_stop)]</span><br><span class="line">z = [<span class="built_in">slice</span>(start,stop) <span class="keyword">for</span> start,stop <span class="keyword">in</span> <span class="built_in">zip</span>(Z_start,Z_stop)]</span><br><span class="line">R[r] = Z[z]</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br></pre></td></tr></table></figure><h4id="consider-an-array-z-1234567891011121314-how-to-generate-an-array-r-1234-2345-3456-...-11121314">81.Consider an array Z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14], how togenerate an array R = [[1,2,3,4], [2,3,4,5], [3,4,5,6], ...,[11,12,13,14]]? (★★★)</h4><p><code>hint: stride_tricks.as_strided, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan van der Walt</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">1</span>,<span class="number">15</span>,dtype=np.uint32)</span><br><span class="line">R = stride_tricks.as_strided(Z,(<span class="number">11</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(R)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">1</span>, <span class="number">15</span>, dtype=np.uint32)</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=<span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="compute-a-matrix-rank">82. Compute a matrix rank (★★★)</h4><p><code>hint: np.linalg.svd, np.linalg.matrix_rank</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan van der Walt</span></span><br><span class="line"></span><br><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">U, S, V = np.linalg.svd(Z) <span class="comment"># Singular Value Decomposition</span></span><br><span class="line">rank = np.<span class="built_in">sum</span>(S &gt; <span class="number">1e-10</span>)</span><br><span class="line"><span class="built_in">print</span>(rank)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternative solution:</span></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">rank = np.linalg.matrix_rank(Z)</span><br><span class="line"><span class="built_in">print</span>(rank)</span><br></pre></td></tr></table></figure><h4 id="how-to-find-the-most-frequent-value-in-an-array">83. How to findthe most frequent value in an array?</h4><p><code>hint: np.bincount, argmax</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(np.bincount(Z).argmax())</span><br></pre></td></tr></table></figure><h4id="extract-all-the-contiguous-3x3-blocks-from-a-random-10x10-matrix">84.Extract all the contiguous 3x3 blocks from a random 10x10 matrix(★★★)</h4><p><code>hint: stride_tricks.as_strided, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Chris Barker</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span> + (Z.shape[<span class="number">0</span>]-<span class="number">3</span>)</span><br><span class="line">j = <span class="number">1</span> + (Z.shape[<span class="number">1</span>]-<span class="number">3</span>)</span><br><span class="line">C = stride_tricks.as_strided(Z, shape=(i, j, n, n), strides=Z.strides + Z.strides)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=(<span class="number">3</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure><h4 id="create-a-2d-array-subclass-such-that-zij-zji">85. Create a 2Darray subclass such that Z[i,j] == Z[j,i] (★★★)</h4><p><code>hint: class method</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Eric O. Lebigot</span></span><br><span class="line"><span class="comment"># Note: only works for 2d array and value setting using indices</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Symetric</span>(np.ndarray):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, index, value</span>):</span><br><span class="line">        i,j = index</span><br><span class="line">        <span class="built_in">super</span>(Symetric, self).__setitem__((i,j), value)</span><br><span class="line">        <span class="built_in">super</span>(Symetric, self).__setitem__((j,i), value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">symetric</span>(<span class="params">Z</span>):</span><br><span class="line">    <span class="keyword">return</span> np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric)</span><br><span class="line"></span><br><span class="line">S = symetric(np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">5</span>,<span class="number">5</span>)))</span><br><span class="line">S[<span class="number">2</span>,<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><h4id="consider-a-set-of-p-matrices-with-shape-nn-and-a-set-of-p-vectors-with-shape-n1.-how-to-compute-the-sum-of-of-the-p-matrix-products-at-once-result-has-shape-n1">86.Consider a set of p matrices with shape (n,n) and a set of p vectorswith shape (n,1). How to compute the sum of of the p matrix products atonce? (result has shape (n,1)) (★★★)</h4><p><code>hint: np.tensordot</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan van der Walt</span></span><br><span class="line"></span><br><span class="line">p, n = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">M = np.ones((p,n,n))</span><br><span class="line">V = np.ones((p,n,<span class="number">1</span>))</span><br><span class="line">S = np.tensordot(M, V, axes=[[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># It works, because:</span></span><br><span class="line"><span class="comment"># M is (p,n,n)</span></span><br><span class="line"><span class="comment"># V is (p,n,1)</span></span><br><span class="line"><span class="comment"># Thus, summing over the paired axes 0 and 0 (of M and V independently),</span></span><br><span class="line"><span class="comment"># and 2 and 1, to remain with a (n,1) vector.</span></span><br></pre></td></tr></table></figure><h4id="consider-a-16x16-array-how-to-get-the-block-sum-block-size-is-4x4">87.Consider a 16x16 array, how to get the block-sum (block size is 4x4)?(★★★)</h4><p><code>hint: np.add.reduceat, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Robert Kern</span></span><br><span class="line"></span><br><span class="line">Z = np.ones((<span class="number">16</span>,<span class="number">16</span>))</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">S = np.add.reduceat(np.add.reduceat(Z, np.arange(<span class="number">0</span>, Z.shape[<span class="number">0</span>], k), axis=<span class="number">0</span>),</span><br><span class="line">                                       np.arange(<span class="number">0</span>, Z.shape[<span class="number">1</span>], k), axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternative solution:</span></span><br><span class="line"><span class="comment"># Author: Sebastian Wallkötter (@FirefoxMetzger)</span></span><br><span class="line"></span><br><span class="line">Z = np.ones((<span class="number">16</span>,<span class="number">16</span>))</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">windows = np.lib.stride_tricks.sliding_window_view(Z, (k, k))</span><br><span class="line">S = windows[::k, ::k, ...].<span class="built_in">sum</span>(axis=(-<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.ones((<span class="number">16</span>, <span class="number">16</span>))</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=(k, k))[::k, ::k].<span class="built_in">sum</span>(axis=(-<span class="number">2</span>, -<span class="number">1</span>)))</span><br></pre></td></tr></table></figure><h4 id="how-to-implement-the-game-of-life-using-numpy-arrays">88. How toimplement the Game of Life using numpy arrays? (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nicolas Rougier</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">Z</span>):</span><br><span class="line">    <span class="comment"># Count neighbours</span></span><br><span class="line">    N = (Z[<span class="number">0</span>:-<span class="number">2</span>,<span class="number">0</span>:-<span class="number">2</span>] + Z[<span class="number">0</span>:-<span class="number">2</span>,<span class="number">1</span>:-<span class="number">1</span>] + Z[<span class="number">0</span>:-<span class="number">2</span>,<span class="number">2</span>:] +</span><br><span class="line">         Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">0</span>:-<span class="number">2</span>]                + Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">2</span>:] +</span><br><span class="line">         Z[<span class="number">2</span>:  ,<span class="number">0</span>:-<span class="number">2</span>] + Z[<span class="number">2</span>:  ,<span class="number">1</span>:-<span class="number">1</span>] + Z[<span class="number">2</span>:  ,<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Apply rules</span></span><br><span class="line">    birth = (N==<span class="number">3</span>) &amp; (Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">    survive = ((N==<span class="number">2</span>) | (N==<span class="number">3</span>)) &amp; (Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">    Z[...] = <span class="number">0</span></span><br><span class="line">    Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>][birth | survive] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,(<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>): Z = iterate(Z)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-get-the-n-largest-values-of-an-array">89. How to get then largest values of an array (★★★)</h4><p><code>hint: np.argsort | np.argpartition</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">10000</span>)</span><br><span class="line">np.random.shuffle(Z)</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Slow</span></span><br><span class="line"><span class="built_in">print</span> (Z[np.argsort(Z)[-n:]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fast</span></span><br><span class="line"><span class="built_in">print</span> (Z[np.argpartition(-Z,n)[:n]])</span><br></pre></td></tr></table></figure><h4id="given-an-arbitrary-number-of-vectors-build-the-cartesian-product-every-combinations-of-every-item">90.Given an arbitrary number of vectors, build the cartesian product (everycombinations of every item) (★★★)</h4><p><code>hint: np.indices</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan Van der Walt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cartesian</span>(<span class="params">arrays</span>):</span><br><span class="line">    arrays = [np.asarray(a) <span class="keyword">for</span> a <span class="keyword">in</span> arrays]</span><br><span class="line">    shape = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> arrays)</span><br><span class="line"></span><br><span class="line">    ix = np.indices(shape, dtype=<span class="built_in">int</span>)</span><br><span class="line">    ix = ix.reshape(<span class="built_in">len</span>(arrays), -<span class="number">1</span>).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n, arr <span class="keyword">in</span> <span class="built_in">enumerate</span>(arrays):</span><br><span class="line">        ix[:, n] = arrays[n][ix[:, n]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ix</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (cartesian(([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>])))</span><br></pre></td></tr></table></figure><h4 id="how-to-create-a-record-array-from-a-regular-array">91. How tocreate a record array from a regular array? (★★★)</h4><p><code>hint: np.core.records.fromarrays</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.array([(<span class="string">&quot;Hello&quot;</span>, <span class="number">2.5</span>, <span class="number">3</span>),</span><br><span class="line">              (<span class="string">&quot;World&quot;</span>, <span class="number">3.6</span>, <span class="number">2</span>)])</span><br><span class="line">R = np.core.records.fromarrays(Z.T,</span><br><span class="line">                               names=<span class="string">&#x27;col1, col2, col3&#x27;</span>,</span><br><span class="line">                               formats = <span class="string">&#x27;S8, f8, i8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br></pre></td></tr></table></figure><h4id="consider-a-large-vector-z-compute-z-to-the-power-of-3-using-3-different-methods">92.Consider a large vector Z, compute Z to the power of 3 using 3 differentmethods (★★★)</h4><p><code>hint: np.power, *, np.einsum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Ryan G.</span></span><br><span class="line"></span><br><span class="line">x = np.random.rand(<span class="built_in">int</span>(<span class="number">5e7</span>))</span><br><span class="line"></span><br><span class="line">%timeit np.power(x,<span class="number">3</span>)</span><br><span class="line">%timeit x*x*x</span><br><span class="line">%timeit np.einsum(<span class="string">&#x27;i,i,i-&gt;i&#x27;</span>,x,x,x)</span><br></pre></td></tr></table></figure><h4id="consider-two-arrays-a-and-b-of-shape-83-and-22.-how-to-find-rows-of-a-that-contain-elements-of-each-row-of-b-regardless-of-the-order-of-the-elements-in-b">93.Consider two arrays A and B of shape (8,3) and (2,2). How to find rowsof A that contain elements of each row of B regardless of the order ofthe elements in B? (★★★)</h4><p><code>hint: np.where</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Gabe Schwartz</span></span><br><span class="line"></span><br><span class="line">A = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">8</span>,<span class="number">3</span>))</span><br><span class="line">B = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">C = (A[..., np.newaxis, np.newaxis] == B)</span><br><span class="line">rows = np.where(C.<span class="built_in">any</span>((<span class="number">3</span>,<span class="number">1</span>)).<span class="built_in">all</span>(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(rows)</span><br></pre></td></tr></table></figure><h4id="considering-a-10x3-matrix-extract-rows-with-unequal-values-e.g.-223">94.Considering a 10x3 matrix, extract rows with unequal values (e.g.[2,2,3]) (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Robert Kern</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="comment"># solution for arrays of all dtypes (including string arrays and record arrays)</span></span><br><span class="line">E = np.<span class="built_in">all</span>(Z[:,<span class="number">1</span>:] == Z[:,:-<span class="number">1</span>], axis=<span class="number">1</span>)</span><br><span class="line">U = Z[~E]</span><br><span class="line"><span class="built_in">print</span>(U)</span><br><span class="line"><span class="comment"># soluiton for numerical arrays only, will work for any number of columns in Z</span></span><br><span class="line">U = Z[Z.<span class="built_in">max</span>(axis=<span class="number">1</span>) != Z.<span class="built_in">min</span>(axis=<span class="number">1</span>),:]</span><br><span class="line"><span class="built_in">print</span>(U)</span><br></pre></td></tr></table></figure><h4id="convert-a-vector-of-ints-into-a-matrix-binary-representation">95.Convert a vector of ints into a matrix binary representation (★★★)</h4><p><code>hint: np.unpackbits</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line">I = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>])</span><br><span class="line">B = ((I.reshape(-<span class="number">1</span>,<span class="number">1</span>) &amp; (<span class="number">2</span>**np.arange(<span class="number">8</span>))) != <span class="number">0</span>).astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(B[:,::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Daniel T. McDonald</span></span><br><span class="line"></span><br><span class="line">I = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>], dtype=np.uint8)</span><br><span class="line"><span class="built_in">print</span>(np.unpackbits(I[:, np.newaxis], axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="given-a-two-dimensional-array-how-to-extract-unique-rows">96.Given a two dimensional array, how to extract unique rows? (★★★)</h4><p><code>hint: np.ascontiguousarray | np.unique</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,(<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[<span class="number">1</span>])))</span><br><span class="line">_, idx = np.unique(T, return_index=<span class="literal">True</span>)</span><br><span class="line">uZ = Z[idx]</span><br><span class="line"><span class="built_in">print</span>(uZ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Andreas Kouzelis</span></span><br><span class="line"><span class="comment"># NumPy &gt;= 1.13</span></span><br><span class="line">uZ = np.unique(Z, axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(uZ)</span><br></pre></td></tr></table></figure><h4id="considering-2-vectors-a-b-write-the-einsum-equivalent-of-inner-outer-sum-and-mul-function">97.Considering 2 vectors A &amp; B, write the einsum equivalent of inner,outer, sum, and mul function (★★★)</h4><p><code>hint: np.einsum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Alex Riley</span></span><br><span class="line"><span class="comment"># Make sure to read: http://ajcr.net/Basic-guide-to-einsum/</span></span><br><span class="line"></span><br><span class="line">A = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">B = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">np.einsum(<span class="string">&#x27;i-&gt;&#x27;</span>, A)       <span class="comment"># np.sum(A)</span></span><br><span class="line">np.einsum(<span class="string">&#x27;i,i-&gt;i&#x27;</span>, A, B) <span class="comment"># A * B</span></span><br><span class="line">np.einsum(<span class="string">&#x27;i,i&#x27;</span>, A, B)    <span class="comment"># np.inner(A, B)</span></span><br><span class="line">np.einsum(<span class="string">&#x27;i,j-&gt;ij&#x27;</span>, A, B)    <span class="comment"># np.outer(A, B)</span></span><br></pre></td></tr></table></figure><h4id="considering-a-path-described-by-two-vectors-xy-how-to-sample-it-using-equidistant-samples">98.Considering a path described by two vectors (X,Y), how to sample itusing equidistant samples (★★★)?</h4><p><code>hint: np.cumsum, np.interp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Bas Swinckels</span></span><br><span class="line"></span><br><span class="line">phi = np.arange(<span class="number">0</span>, <span class="number">10</span>*np.pi, <span class="number">0.1</span>)</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">x = a*phi*np.cos(phi)</span><br><span class="line">y = a*phi*np.sin(phi)</span><br><span class="line"></span><br><span class="line">dr = (np.diff(x)**<span class="number">2</span> + np.diff(y)**<span class="number">2</span>)**<span class="number">.5</span> <span class="comment"># segment lengths</span></span><br><span class="line">r = np.zeros_like(x)</span><br><span class="line">r[<span class="number">1</span>:] = np.cumsum(dr)                <span class="comment"># integrate path</span></span><br><span class="line">r_int = np.linspace(<span class="number">0</span>, r.<span class="built_in">max</span>(), <span class="number">200</span>) <span class="comment"># regular spaced path</span></span><br><span class="line">x_int = np.interp(r_int, r, x)       <span class="comment"># integrate path</span></span><br><span class="line">y_int = np.interp(r_int, r, y)</span><br></pre></td></tr></table></figure><h4id="given-an-integer-n-and-a-2d-array-x-select-from-x-the-rows-which-can-be-interpreted-as-draws-from-a-multinomial-distribution-with-n-degrees-i.e.-the-rows-which-only-contain-integers-and-which-sum-to-n.">99.Given an integer n and a 2D array X, select from X the rows which can beinterpreted as draws from a multinomial distribution with n degrees,i.e., the rows which only contain integers and which sum to n.(★★★)</h4><p><code>hint: np.logical_and.reduce, np.mod</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">X = np.asarray([[<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">3.0</span>, <span class="number">8.0</span>],</span><br><span class="line">                [<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">                [<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">M = np.logical_and.reduce(np.mod(X, <span class="number">1</span>) == <span class="number">0</span>, axis=-<span class="number">1</span>)</span><br><span class="line">M &amp;= (X.<span class="built_in">sum</span>(axis=-<span class="number">1</span>) == n)</span><br><span class="line"><span class="built_in">print</span>(X[M])</span><br></pre></td></tr></table></figure><h4id="compute-bootstrapped-95-confidence-intervals-for-the-mean-of-a-1d-array-x-i.e.-resample-the-elements-of-an-array-with-replacement-n-times-compute-the-mean-of-each-sample-and-then-compute-percentiles-over-the-means.">100.Compute bootstrapped 95% confidence intervals for the mean of a 1D arrayX (i.e., resample the elements of an array with replacement N times,compute the mean of each sample, and then compute percentiles over themeans). (★★★)</h4><p><code>hint: np.percentile</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jessica B. Hamrick</span></span><br><span class="line"></span><br><span class="line">X = np.random.randn(<span class="number">100</span>) <span class="comment"># random 1D array</span></span><br><span class="line">N = <span class="number">1000</span> <span class="comment"># number of bootstrap samples</span></span><br><span class="line">idx = np.random.randint(<span class="number">0</span>, X.size, (N, X.size))</span><br><span class="line">means = X[idx].mean(axis=<span class="number">1</span>)</span><br><span class="line">confint = np.percentile(means, [<span class="number">2.5</span>, <span class="number">97.5</span>])</span><br><span class="line"><span class="built_in">print</span>(confint)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】</title>
      <link href="/2024/04/13/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/"/>
      <url>/2024/04/13/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/</url>
      
        <content type="html"><![CDATA[<ul><li>以下<strong>数据结构</strong>都是采用<strong>数组</strong>模拟实现（而非 C++ STL容器），效率更高、支持更多操作</li></ul><h1 id="链表">链表</h1><h2 id="单向链表">单(向)链表</h2><ul><li><font color='red'><strong>空指针用 -1 表示</strong></font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7966770/">AcWing826. 单链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点 i 的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点 i 的 next 指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数 x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 x 插到下标是 k 的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是 k 的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="双向链表">双(向)链表</h2><ul><li>双链表实现中：0 号节点表示头节点，1 号节点表示尾节点</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7968200/">AcWing827. 双链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// l[i] 表示节点i的左指针</span></span><br><span class="line"><span class="comment">// r[i] 表示节点i的右指针是多少</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除节点 k */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在节点 k 的右边插入一个数 x */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在节点 k 的左边插入一个数 x，则调用insert(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表的最左端插入数 𝑥</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="number">0</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表的最右端插入数 𝑥</span></span><br><span class="line"><span class="built_in">insert</span>(l[<span class="number">1</span>], x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第 𝑘 个插入的数删除</span></span><br><span class="line"><span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第 𝑘 个插入的数左侧插入一个数</span></span><br><span class="line"><span class="built_in">insert</span>(l[k + <span class="number">1</span>], x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第 𝑘 个插入的数右侧插入一个数</span></span><br><span class="line"><span class="built_in">insert</span>(k + <span class="number">1</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整个链表从左到右输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i])</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整个链表从右到左输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l[<span class="number">1</span>]; i != <span class="number">0</span>; i = l[i])</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br></pre></td></tr></table></figure><p>:apple:<span class="math inline">\(0\)</span> 号是左端点，<spanclass="math inline">\(1\)</span> 号是右端点，第 <spanclass="math inline">\(k\)</span> 个插入数的编号 <spanclass="math inline">\(idx=k+1\)</span></p><h1 id="栈">栈</h1><h2 id="模板">模板</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7970372/">AcWing828. 模拟栈 - AcWing</a>】</li></ul><h3 id="模板1">模板1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶元素下标</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"><span class="keyword">auto</span> t = stk[tt --];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt == -1，则表示栈为空</span></span><br><span class="line"><span class="keyword">if</span> (tt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 栈为空 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板2">模板2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N], tt;<span class="comment">// tt 的值表示栈中元素的个数，tt == 0 说明单调栈为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"><span class="keyword">auto</span> t = stk[tt --];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果元素个数 tt == 0，则表示栈为空</span></span><br><span class="line"><span class="keyword">if</span> (!tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 栈为空 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8210610/">AcWing3302. 表达式求值 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8756228/">LeetCode394. 字符串解码 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8756250/">LeetCode20. 有效的括号 - AcWing</a></li></ul><h1 id="队列">队列</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405010825313.png"alt="image-20240501082529059" /><figcaption aria-hidden="true">image-20240501082529059</figcaption></figure><h2 id="普通队列">普通队列</h2><ul><li><p>缺点：如果元素多次进队出队，我们就需要将 <code>q[N]</code> 的大小<code>N</code> 设置的非常大，因此有可能出现 <spanclass="math inline">\(MLE\)</span></p></li><li><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7971050/">AcWing829. 模拟队列 - AcWing</a>】</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt 表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><p><strong>优点</strong>：</p><ul><li><p>假设在使用过程中，<strong>队列的最大长度为 <spanclass="math inline">\(N\)</span></strong>，则<code>int q[N + 1]</code>，这样不会因为 <spanclass="math inline">\(N\)</span> 太大而 <spanclass="math inline">\(MLE\)</span>，节省空间</p></li><li><p><span class="math inline">\(C++ \ STL\)</span> 中的<code>queue&lt;&gt;</code> 就是循环队列</p></li><li><p>某些算法（如 SPFA算法）必须使用<strong>循环队列</strong>，不能使用普通队列</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 循环队列中最多有 N - 1 个元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;<span class="comment">// Attention!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:star: <code>int q[N], hh = 0, tt = 0;</code> 循环队列中最多只能有<code>N - 1</code> 个元素</p><h1 id="单调栈">单调栈</h1><h2 id="模板-1">模板</h2><ul><li>找出每个数左边离它最近的比它<strong>小</strong>的数——维护（严格）递<strong>增</strong>栈</li><li>找出每个数左边离它最近的比它<strong>大</strong>的数——维护（严格）递<strong>减</strong>栈</li><li>单调栈既可以存储这个<strong>数本身</strong>，也可以存储这个<strong>数对应的下标</strong>【更常用，建议从<strong>下标1</strong>开始存储数据，此时下标<span class="math inline">\(0/n + 1\)</span> 就是哨兵】</li><li>单调栈对应的题目，可以先将<strong>哨兵</strong>入栈，这样就不需要判断单调栈是否为空<ul><li><strong>哨兵（下标为 <spanclass="math inline">\(0/n+1\)</span>）</strong>需要确保单调栈一定<strong>不可能为空</strong>，因此哨兵对应的值<code>a[0]</code> / <code>a[n + 1]</code><ul><li>为<code>-INF</code>（递增栈）</li><li>为<code>INF</code>（递减栈）</li></ul></li><li><strong>哨兵</strong>在初始化单调队列后<strong>压入</strong></li></ul></li></ul><h3 id="模板1-1">模板1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> q[N], tt = <span class="number">-1</span>;<span class="comment">// tt == -1 说明单调栈空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(q[tt], i))</span><br><span class="line">        tt--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">    <span class="keyword">if</span>(~tt)<span class="comment">// 即 tt != -1</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    q[++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板2-1">模板2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> q[N], tt;<span class="comment">// tt 的值表示栈中元素的个数，tt == 0 说明单调栈为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; check(q[tt], i))</span><br><span class="line">        tt--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">    <span class="keyword">if</span>(!tt)<span class="comment">// 即 tt != 0</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    q[++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7971357/">AcWing830. 单调栈 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/230459/">AcWing1574. 接雨水 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8360904/">AcWing131. 直方图中最大的矩形 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8377166/">AcWing1413. 矩形牛棚（每日一题） - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8528586/">LeetCode85. 最大矩形 - AcWing</a></li></ul><blockquote><p>参考：<ahref="https://www.acwing.com/solution/content/244823/">AcWing 1612.最大正方形 - AcWing</a></p></blockquote><ul><li><ahref="https://leetcode.cn/problems/daily-temperatures/description/">739.每日温度 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/min-stack/description/">155.最小栈 - 力扣（LeetCode）</a></li></ul><h1 id="单调队列"><a id="dandiaoduilie">单调队列</a></h1><p>​ <strong>单调队列</strong>实际上是<strong>双端队列</strong></p><h2 id="模板-2">模板</h2><ul><li>常见模型：找出<strong>固定长度窗口</strong>中的<strong>最大值/最小值</strong></li><li>单调队列中通常存储<font color='blue'><strong>下标</strong></font>，方便判断队头是否滑出窗口</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409250939034.png"alt="image-20240925093920776" /><figcaption aria-hidden="true">image-20240925093920776</figcaption></figure><ul><li><p>求解固定区间 <span class="math inline">\([(i - m) - k + 1,\ i -m]\)</span> 的最小值，其中 <span class="math inline">\(k\)</span>为区间长度，有效下标范围为 <spanclass="math inline">\([0,n]\)</span>，<spanclass="math inline">\(m\)</span> 为偏移量，通常情况下等于 <spanclass="math inline">\(0/1\)</span></p><ul><li>单调<strong>递增</strong>队列</li><li>最小值为 <code>q[hh]</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt;= n; i ++)<span class="comment">// 从区间 [(i - m) - k + 1, i - m] 不空对应的下标开始</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - m - k + <span class="number">1</span>) <span class="comment">// 判断队头是否滑出窗口，当前维护区间的左端点下标为 i - m - k + 1</span></span><br><span class="line">        hh ++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i - m]) <span class="comment">// 维持单调队列</span></span><br><span class="line">        tt --;</span><br><span class="line">    q[++ tt] = i - m; <span class="comment">// 将数据加入队尾</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 题目的具体逻辑，此时单调队列维持的就是区间 [(i - m) - k + 1, i - m] 的最小值 a[q[hh]] */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>求解固定区间 <span class="math inline">\([(i - m) - k + 1,\ i -m]\)</span> 的最大值，其中 <span class="math inline">\(k\)</span>为区间长度，有效下标范围为 <span class="math inline">\([0,n -1]\)</span>，<span class="math inline">\(m\)</span>为偏移量，通常情况下等于 <span class="math inline">\(0/1\)</span></p><ul><li>单调<strong>递减</strong>队列</li><li>最大值为 <code>q[hh]</code></li></ul></li></ul><blockquote><p>以求区间最大值只需要将上述第 9 行的符号修改一下：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[hh]] &lt;= a[i - m])</span><br></pre></td></tr></table></figure></p></blockquote><p><font color ='red'><strong>单调栈/单调队列总结</strong></font></p><ul><li>先考虑用普通 栈/队列 暴力模拟</li><li>再将普通 栈/队列中没有用的元素删除，看一下<strong>剩下的元素是否有单调性</strong>——单调栈/单调队列</li><li>考虑优化（队头最小/队尾最大/二分查找…）</li></ul><h2 id="例题-2">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7971364/">AcWing154. 滑动窗口 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/254189/">AcWing4936. 子序列 - AcWing</a></li><li><ahref="D:\downloads\hexo\blog\source_posts\算法【动态规划】.md#DP">【动态规划】单调队列优化DP</a></li></ul><h1 id="kmp">KMP</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849900.png"alt="image-20240307143945027" /><figcaption aria-hidden="true">image-20240307143945027</figcaption></figure><blockquote><p><code>s</code>：表示 <strong>string</strong>，即字符串</p><p><code>p</code>：表示 <strong>pattern</strong>，即模式串</p></blockquote><ol type="1"><li>若匹配成功，返回<strong>模式串T</strong>在<strong>目标串S</strong>中<strong><font color='red'>首次出现的有效位移</font></strong></li><li>若匹配失败，返回 <span class="math inline">\(1\)</span></li></ol><!--more--><p>注意：</p><ul><li>主串 <code>S[]</code> 、模式串 <code>P[]</code>、<code>next[]</code> 均<font color='blue'><strong>从下标 1开始存储</strong></font></li><li>每次 <code>S[i]</code> 与 <code>P[j + 1]</code> 比较<ul><li>当 <code>S[i] == P[j + 1]</code> 时，<code>i ++, j ++;</code></li><li>当 <code>S[i] != P[j + 1]</code> 时，<code>j = next[j];</code></li></ul></li><li><code>i</code>一直往前走，不会后退</li><li>当 <code>S[i]</code> 与 <code>P[j + 1]</code>不匹配时，<code>j</code> 会向后退到 <code>next[j]</code> 处</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849828.png"alt="a8e37396968a427a0efaffde2c68e78" /><figcaptionaria-hidden="true">a8e37396968a427a0efaffde2c68e78</figcaption></figure><ul><li><code>next[i]</code> 表示 <code>P[1, ..., i]</code>最大<strong>前缀与后缀相等</strong>的长度（一定小于<code>i</code>，不能自己与自己相等~）</li><li><code>next[]</code>是通过模板串<strong>自己与自己匹配</strong>操作得出来的（代码和匹配操作几乎一样）<ul><li><code>next[0] = next[1] = 0</code></li><li>由于是从 <code>i = 2</code> 开始求 <code>next[]</code>，所以：<ul><li>不可能匹配成功（不需要 <code>j == m</code> 的判断）</li><li><code>j &lt; i</code>，回退时 <code>next[j]</code> 一定存在</li></ul></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849565.jpeg"alt="3ff244326727713da33759bd2784289" /><figcaptionaria-hidden="true">3ff244326727713da33759bd2784289</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7973749/">AcWing831. KMP字符串 - AcWing</a>】</li><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n)\)</span>，<spanclass="math inline">\(n\)</span>为长文本<strong>主串</strong>的长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本</span></span><br><span class="line"><span class="comment">// p[]是模式串</span></span><br><span class="line"><span class="comment">// n 是 s 的长度</span></span><br><span class="line"><span class="comment">// m 是 p 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求模式串的Next数组：*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到 0 处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j ++;</span><br><span class="line">    <span class="comment">// 此时 j 的长度即为 next[i] 最大前缀与后缀相等的长度</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配过程 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到 0 处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 j 移动到下一次比较的位置</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j ++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">/* 匹配成功后的逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="trie树">Trie树</h1><h2 id="模板-3">模板</h2><p>​<strong>Trie</strong>：高效地<strong>存储</strong>和<strong>查找</strong>字符串/二进制数 集合的数据结构</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403071732565.png"alt="image-20240307173227428" /><figcaption aria-hidden="true">image-20240307173227428</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[i][j]存储树中每个节点的子节点下标</span></span><br><span class="line"><span class="comment">// cnt[i]存储以 i 号节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入一个字符串 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++ idx;<span class="comment">// 不能是 idx ++，因为son[0][]存放的是根节点，从下标 1 开始存储</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询字符串出现的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br></pre></td></tr></table></figure><ul><li><p><code>son[i][]</code> 存储 <span class="math inline">\(i\)</span>号节点的所有出边；<code>cnt[i]</code> 存储以 <spanclass="math inline">\(i\)</span> 号节点结尾的单词数量</p></li><li><p><code>N</code>为 Trie树中的<strong>节点总数</strong>，每个节点存储一个字符；<spanclass="math inline">\(26\)</span> 为字符集大小，每个节点最多有 <spanclass="math inline">\(26\)</span> 个<strong>子</strong>节点</p></li></ul><blockquote><p><code>N</code> 为Trie树的节点总数，通常设置为<strong>字符串总长度（字符串个数 *每个字符串的最大长度）</strong>，尽管实际用到的并没有这么大</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405030901945.jpg"alt="39a1de1f1123e8398c88060337b97c8" /><figcaptionaria-hidden="true">39a1de1f1123e8398c88060337b97c8</figcaption></figure><h2 id="例题-3">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7975276/">AcWing835. Trie字符串统计 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8469979/">AcWing142. 前缀统计 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8217089/">AcWing143. 最大异或对 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8470950/">AcWing144. 最长异或值路径 - AcWing</a></li></ul><h1 id="并查集">并查集</h1><ul><li><strong>核心操作</strong></li></ul><ol type="1"><li>合并两个集合</li><li>查询某个元素的祖宗节点</li></ol><ul><li><strong>基本原理：</strong></li></ul><p>​每个集合用一棵树来表示。<strong>树根</strong>的编号就是整个集合的编号，也叫做<strong>祖宗节点</strong>。每个节点存储它的父节点，<code>p[x]</code>表示 <code>x</code> 的父节点</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081538288.png"alt="image-20240308153805104" /><figcaption aria-hidden="true">image-20240308153805104</figcaption></figure><h2 id="朴素并查集">朴素并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集是可以用来维护很多额外信息的，如集合大小sz，到祖宗节点距离 d等等</p></blockquote><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7986586/">AcWing836. 合并集合 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8359238/">AcWing528. 奶酪（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8368371/">AcWing1250. 格子游戏（算法提高课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8405592/">AcWing1252. 搭配购买 - AcWing</a></p></li></ul><h2 id="维护大小-sz-的并查集">维护大小 sz 的并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// sz[]只对祖宗节点有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"><span class="type">int</span> p[N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    sz[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">sz[<span class="built_in">find</span>(b)] += sz[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7986712/">AcWing837. 连通块中点的数量 - AcWing</a></li></ul><h2 id="维护到祖宗节点距离-d-的并查集">维护到祖宗节点距离 d的并查集</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407291855557.jpg"alt="a5504fa33dbb270b72233fd5e947eec" /><figcaptionaria-hidden="true">a5504fa33dbb270b72233fd5e947eec</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// d[x] 存储 x 到 p[x] 的距离</span></span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 x 的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];<span class="comment">// d[x] 存储 x 到 p[x] 的距离，</span></span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1 ~ n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    p[i] = i, d[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并 a 和 b 所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7987057/">AcWing240. 食物链 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8407527/">AcWing238. 银河英雄传说 - AcWing</a></p></li></ul><h1 id="堆">堆</h1><p>堆是满足以下2个特性的数据结构</p><ul><li><p><strong>结构性</strong>：是==<strong><font color='blue'>数组存储</font></strong>==的==<strong><font color='red'>完全二叉树</font></strong>==</p><ul><li>从<font color='red'><code>h[1]</code>开始存储数据</font>，<code>h[0]</code>用来存放==<strong>哨兵</strong>==</li></ul><blockquote><p>因为如果从0开始存储，根节点0按照公式计算得到的左右节点都是0，显然不成了，需要特判，麻烦</p></blockquote><ul><li><code>i</code> 的左儿子 <code>2 * i</code>，右儿子<code>2 * i + 1</code></li></ul></li><li><p><strong>有序性</strong>：任一结点的关键字是其子树所有结点的最大值(或最小值)</p><ul><li>“<strong>最大堆(MaxHeap)</strong>”，也称“<strong>大顶堆</strong>”：任一结点的<code>data</code>大于其所有子树结点的<code>data</code></li><li>“<strong>最小堆(MinHeap)</strong>”，也称“<strong>小顶堆</strong>”：任一结点的<code>data</code>小于其所有子树结点的<code>data</code></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121621986.png"alt="image-20240812162114739" /><figcaption aria-hidden="true">image-20240812162114739</figcaption></figure><p>所有关于堆的操作均建立在堆的 <code>down()</code> 和 <code>up()</code>函数基础上</p><h2 id="模板1-2">模板1</h2><p>​ 如果只希望实现与C++ STL堆中相同的功能1、2、3，则堆的下滤和上滤操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N] 存储堆中的值, h[1] 是堆顶，x 的左儿子是 2x, 右儿子是 2x + 1</span></span><br><span class="line"><span class="comment">// sz 是堆中元素的个数</span></span><br><span class="line"><span class="type">int</span> h[N], sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= sz &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= sz &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>down() 注意：</p><ul><li>down() 操作需要保证左右儿子均是堆</li><li>t 是根节点 <code>h[u]</code>, 左儿子 <code>h[2 * u]</code>, 右儿子<code>h[2 * u + 1]</code>中最小值的下标</li><li><code>2 * u &lt;= sz</code>说明存在左儿子，<code>2 * u + 1 &lt;= sz</code> 说明存在右儿子</li></ul><p>up() 注意：</p><ul><li><code>u / 2 != 0</code> 说明存在父节点</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[++sz] = x;</span><br><span class="line"><span class="built_in">up</span>(sz);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>] = h[sz--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">sz = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="模板2-2">模板2</h2><p>​ 如果希望实现在 C++ STL堆中功能的基础上，添加在任意位置修改/删除的功能，需要存储映射：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036897.png" alt="image-20240308101556244" style="zoom:15%;" /></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036983.jpeg" alt="b9b669b4a3a28e34e104b0c5bda7d7c" style="zoom:13%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N] 存储堆中的值, h[1] 是堆顶，x 的左儿子是 2x, 右儿子是 2x + 1</span></span><br><span class="line"><span class="comment">// ph[k] 存储第 k 个插入的点在堆中的下标p:pointer</span></span><br><span class="line"><span class="comment">// hp[k] 存储堆中下标是 k 的点是第几个插入的h:heap</span></span><br><span class="line"><span class="comment">// sz 是堆中元素的个数</span></span><br><span class="line"><span class="comment">// m 是当前堆中插入操作的次数</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], sz, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换 h[] 中的两个点，及其映射关系 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= sz &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= sz &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>p:pointer</li><li>h:heap</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sz++, m++;</span><br><span class="line">h[sz] = x, hp[sz] = m, ph[m] = sz;</span><br><span class="line"><span class="built_in">up</span>(sz);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">heap_swap</span>(<span class="number">1</span>, sz--);</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除第 k 个插入的数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line"><span class="built_in">heap_swap</span>(k, sz--);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改第 k 个插入的数,将其变为 x</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><blockquote><p>修改后的值与原来值相比，有3种情况</p><ul><li>相等：不需要调整堆</li><li>小于：up(k)</li><li>大于：down(k)</li></ul><p>把上面 3 种情况综合考虑，不管是相等/大于/小于，为了简单起见:</p><ul><li>如果修改h[1]：down(1)</li><li>在最后插入数据：up(++size)</li><li>如果修改其他： up(k); down(k)</li></ul><p>【实际运行时要么都不执行，要么只 up(k) ，要么只 down(k) 】</p></blockquote><ol start="6" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">sz = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="例题-4">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7979479/">AcWing838. 堆排序 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7983190/">AcWing839. 模拟堆 - AcWing</a></li></ul><h1 id="哈希表">哈希表</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081905012.png" alt="image-20240308190529753" style="zoom: 25%;" /></p><ul><li>离散化是一种<strong>极其特殊</strong>的哈希方式（数据有序排列）</li><li>在算法题中，通常在哈希表 查找/添加 元素，而不会 删除 元素</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081918152.png"alt="image-20240308191829923" /><figcaption aria-hidden="true">image-20240308191829923</figcaption></figure><h2 id="一般哈希">一般哈希</h2><h3 id="c-stl哈希表">C++ STL哈希表★</h3><p>使用 <span class="math inline">\(C++\)</span> STL哈希表<code>unordered_set</code>/<code>unorderd_map</code> 进行存储</p><blockquote><p><ahref="https://www.acwing.com/activity/content/code/content/8740059/">LeetCode1345. 跳跃游戏 IV -AcWing</a>就使用了<code>unorderd_map&lt;int, vector&lt;int&gt;</code>作为哈希表</p></blockquote><h3 id="拉链法">拉链法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x,ne[idx] = h[k],h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这里的 N 通常取质数eg：100003</li></ul></blockquote><h3 id="开放寻址法">开放寻址法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span> (t == N)</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意">注意</h3><p>​ <code>unordered_set</code> 无法对 <code>pair&lt;&gt;</code>进行哈希，例如对边 <span class="math inline">\((a,b)\)</span> 进行哈希<ahref="https://www.acwing.com/activity/content/code/content/8707496/">AcWing1175. 最大半连通子图 - AcWing</a>，我们需要手动构造一个哈希函数，假设<span class="math inline">\(0 \le a \le 10^3-1,0 \le b \le10^5-1\)</span>，则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;LL&gt; hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将(a, b)插入哈希表中 */</span></span><br><span class="line">hash.insert((ll)a * <span class="number">1e5</span> + b)<span class="comment">// a保存在前3位，b保存在后5位</span></span><br><span class="line">hash.insert((ll)b * <span class="number">1e3</span> + a)<span class="comment">// b保存在前5位，a保存在后3位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在哈希表中查询(a, b) */</span></span><br><span class="line"><span class="keyword">if</span>(hash.count((ll)a * <span class="number">1e5</span> + b))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// (a, b)在哈希表中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(hash.count((ll)b * <span class="number">1e3</span> + a))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// (a, b)在哈希表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希">字符串哈希</h2><p>​ 字符串哈希非常有用的利器，是KMP的劲敌，字符串哈希除了循环节不能处理，其他均可代替KMP</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403082108366.png" alt="image-20240308210833057" style="zoom: 50%;" /></p><p><strong>核心思想</strong>：</p><ul><li><p>将字符串看成 P 进制数，每个字符的 ASCII 码对应数的一位</p></li><li><p>P 的经验值是 131 或 13331，取这两个值的冲突概率低（ASCII 范围 0 -127，最少 128 进制）</p></li><li><p>字符串很长，对应的数太大，通过模 <spanclass="math inline">\(2^{64}\)</span> 把它映射到 <spanclass="math inline">\([0, 2^{64} - 1]\)</span></p></li></ul><p><strong>小技巧</strong>：</p><ul><li>用 <code>unsigned long long</code> 存储哈希值，溢出相当于对 <spanclass="math inline">\(2^{64}\)</span> 自动取模，省略了手动运算</li><li>可以利用前缀哈希直接求出子串哈希（减去高位）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(DEF) = <span class="built_in">hash</span>(ABCDEF) - <span class="built_in">hash</span>(ABC) x P^<span class="number">3</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">    A       B       C       D       E       F  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">5</span> + <span class="number">2</span>xP^<span class="number">4</span> + <span class="number">3</span>xP^<span class="number">3</span> + <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                            D       E       F</span><br><span class="line">                          <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    A       B       C  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">2</span> + <span class="number">2</span>xP^<span class="number">1</span> + <span class="number">3</span>xP^<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><code>str[]</code> 、<code>h[]</code> 、<code>p[]</code> 必须从下标<span class="math inline">\(1\)</span> 开始存储</li><li><strong>不能把某个字符映射成 P 进制 0</strong>，否则 A 如果是 0，则AA 也是 0，就会出现冲突</li><li><code>\0</code> 的 ASCII 是 0，本题不出现该字符，不用担心上一点</li><li>使用这种方法就假定了出题人的人品足够好，不出现冲突</li></ul><h3 id="单一字符串哈希">单一字符串哈希</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, P = <span class="number">131</span>;<span class="comment">// N 为字符串最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h[k]存储字符串前k个字母 str[1 ~ k] 的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 h[ ], p[ ]</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串哈希表">字符串哈希表</h3><p>【推荐】使用 <code>unordered_set&lt;string&gt; hash</code>作为字符串哈希表</p><ul><li><strong>优点</strong>：方便，不需要自己写字符串哈希</li><li><strong>缺点</strong>：<strong>插入、查找</strong>操作的平均时间复杂度为<spanclass="math inline">\(O(1)\)</span>，最坏情况下时间复杂度为<spanclass="math inline">\(O(n)\)</span>，<spanclass="math inline">\(n\)</span> 为字符串长度，如果操作次数过多可能导致<span class="math inline">\(TLE\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串哈希表</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将string str 插入哈希表中 */</span></span><br><span class="line">hash.insert(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找string str 是否在哈希表中 */</span></span><br><span class="line"><span class="keyword">if</span>(hash.count(str))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 字符串str在哈希表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<strong>字符串</strong>映射为<strong>数字</strong>，然后使用<code>unordered_set&lt;int&gt; hash</code> 作为字符串哈希表</p><ul><li><strong>优点</strong>：<strong>查找</strong>操作的时间复杂度为<spanclass="math inline">\(O(1)\)</span></li></ul><blockquote><p>注意：<strong>插入</strong>操作的时间复杂度仍为 <spanclass="math inline">\(O(n)\)</span></p></blockquote><ul><li><strong>缺点</strong>：麻烦，需要自己写字符串哈希</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串哈希表，将字符串映射为数字存储</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;ULL&gt; hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将字符串 str 哈希为 数字h */</span></span><br><span class="line">ULL <span class="title function_">get</span><span class="params">(<span class="built_in">string</span> str)</span></span><br><span class="line">&#123;</span><br><span class="line">    ULL h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)</span><br><span class="line">        h = h * P + c;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将字符串 str 插入哈希表中 */</span></span><br><span class="line">ULL h = get(str);</span><br><span class="line">hash.insert(h);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找字符串 str 是否在哈希表中 */</span></span><br><span class="line">ULL h = get(str);</span><br><span class="line"><span class="keyword">if</span>(hash.count(h))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 字符串str在哈希表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-5">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7988981/">AcWing840. 模拟散列表 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7992616/">AcWing841. 字符串哈希 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8741637/">LeetCode139. 单词拆分 - AcWing</a></p></li></ul><h1 id="树状数组">树状数组</h1><ul><li>作用：动态维护前缀和</li><li>基本操作：<ul><li><strong>单点修改</strong>：给某个位置上的数加上一个数——<spanclass="math inline">\(O(logn)\)</span></li><li><strong>区间查询</strong>：求某一个前缀和——<spanclass="math inline">\(O(logn)\)</span>​</li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404141335555.png"alt="image-20240414133510262" /><figcaption aria-hidden="true">image-20240414133510262</figcaption></figure><ul><li>树状数组 vs 前缀和</li></ul><table><thead><tr class="header"><th></th><th>单点修改</th><th>区间查询</th></tr></thead><tbody><tr class="odd"><td>树状数组</td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="even"><td>前缀和</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td></tr></tbody></table><h1 id="线段树">线段树</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联邦学习</title>
      <link href="/2024/04/08/%5Bobject%20Object%5D/AI/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/08/%5Bobject%20Object%5D/AI/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="联邦学习">联邦学习</h1><p>​ 联邦学习（Federated Learning, a.k.a. Federated MachineLearning）可以分为三类：横向联邦学习（Horizontal FederatedLearning），纵向联邦学习（Vertical FederatedLearning），联邦迁移学习（Federated Transfer Learning）[1, 2]。</p><p>​有不少读者说，横向联邦学习和纵向联邦学习容易混淆，不太清楚为什么这么分类。我在这里再解释一下横向联邦学习和纵向联邦学习。</p><h2 id="横向联邦学习"><strong>横向联邦学习</strong></h2><p>​数据矩阵（也可以是表格，例如，Excel表格）的横向的一行表示一条训练样本，纵向的一列表示一个数据特征（或者标签）。通常用表格查看数据（例如，病例数据），用一行表示一条训练样本比较好，因为可能有很多条数据。</p><p>​横向联邦学习，适用于参与者的<font color = 'red'><strong>数据特征重叠较多，而样本ID重叠较少</strong></font>的情况，例如，两家<strong>不同地区</strong>的银行的客户数据[1, 2]。“横向”二字来源于数据的“<strong>横向划分（horizontalpartitioning, a.k.a.sharding）</strong>”。如图1所示例，联合多个参与者的具有<strong>相同特征</strong>的多行样本进行联邦学习，即各个参与者的训练数据是<strong>横向划分</strong>的，称为<strong>横向联邦学习</strong>。图2给出了一个<strong>横向划分</strong>表格的示例。横向联邦使训练样本的<strong>总数量增加</strong>。</p><p>​横向联邦学习也称为<strong>特征对齐的联邦学习</strong>（Feature-AlignedFederatedLearning），即横向联邦学习的参与者的数据特征是对齐的，如图3所示例。“特征对齐的联邦学习”这个名字有点长，还是用“横向联邦学习”比较好。</p><span id="more"></span><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922927.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图1 横向联邦学习示例，横向联邦使训练样本量增大    &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922833.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图2 横向（按行）划分数据示例 &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922372.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图3 横向联邦学习，也称为特征对齐的联邦学习，横向联邦使训练样本量增大 &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="纵向联邦学习">纵向联邦学习</h2><p>​纵向联邦学习，适用于参与者<font color = 'red'><strong>训练样本ID重叠较多，而数据特征重叠较少</strong></font>的情况，例如，<strong>同一地区</strong>的银行和电商的共同的客户数据[1, 2]。“纵向”二字来源于数据的“<strong>纵向划分（verticalpartitioning）</strong>”。如图4所示例，联合多个参与者的共同样本的不同数据特征进行联邦学习，即各个参与者的训练数据是<strong>纵向划分</strong>的，称为<strong>纵向联邦学习</strong>。图5给出了一个<strong>纵向划分</strong>表格的示例。纵向联邦学习需要先做样本对齐，即找出参与者拥有的<strong>共同样本</strong>，也就叫“数据库撞库（entityresolution, a.k.a. entityalignment）”。只有联合多个参与者的共同样本的不同特征进行纵向联邦学习，才有意义。纵向联邦使训练样本的<strong>特征维度增多</strong>。</p><p>​纵向联邦学习也称为<strong>样本对齐的联邦学习</strong>（Sample-AlignedFederatedLearning），即纵向联邦学习的参与者的训练样本是对齐的，如图6所示例。“样本对齐的联邦学习”这个名字有点长，还是用“纵向联邦学习”比较好。</p><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-9bccacdd69689d782c0e9d896df3e3c4_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图4 纵向联邦学习示例，纵向联邦使训练数据特征维度增加&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-6a71c9b0697c4afb7bfc17569442ffc6_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图5 纵向（按列）划分数据示例&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-cfb91e1c746ea4343f4b3ac27ba204ca_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图6 纵向联邦学习，也称为样本对齐的联邦学习，纵向联邦使训练数据特征维度增加&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="小节">小节</h2><p>​<strong>横向联邦学习</strong>的名称来源于训练数据的“<strong>横向划分</strong>”，也就是数据矩阵或者表格的按行（横向）划分。不同行的数据有相同的数据特征，即数据特征是对齐的。</p><p>​<strong>纵向联邦学习</strong>的名称来源于训练数据的“<strong>纵向划分</strong>”，也就是数据矩阵或者表格的按列（纵向）划分。不同列的数据有相同的样本ID，即训练样本是对齐的。</p><p>[1] Qiang Yang, Yang Liu, Tianjian Chen, and Yongxin Tong, "FederatedMachine Learning: Concept and Applications," Feb. 2019. Available: <ahref="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1902.04885">https://arxiv.org/abs/1902.04885</a></p><p>[2] 杨强，刘洋，陈天健，童咏昕，“联邦学习”，Nov. 2018. Available: <ahref="https://link.zhihu.com/?target=https%3A//dl.ccf.org.cn/institude/institudeDetail%3Fid%3D4150944238307328%26from%3Dgroupmessage%26isappinstalled%3D0%26_ack%3D1">https://dl.ccf.org.cn/institude/institudeDetail?id=4150944238307328&amp;from=groupmessage&amp;isappinstalled=0&amp;_ack=1</a>,or <ahref="https://link.zhihu.com/?target=https%3A//wemp.app/posts/a3771dc7-6722-4690-bf25-23ba36f7b78c%3Futm_source%3Dlatest-posts">https://wemp.app/posts/a3771dc7-6722-4690-bf25-23ba36f7b78c?utm_source=latest-posts</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI 集群基础设施&amp;&amp;InfiniBand</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/AI%20%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD&amp;&amp;InfiniBand/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/AI%20%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD&amp;&amp;InfiniBand/</url>
      
        <content type="html"><![CDATA[<h1 id="ai-集群基础设施infiniband">AI集群基础设施&amp;&amp;InfiniBand</h1><p>GPU在高性能计算和深度学习加速中扮演着非常重要的角色，GPU的强大的并行计算能力，大大提升了运算性能。随着运算数据量的不断攀升，GPU间需要大量的交换数据，因此，GPU通信性能成为了非常重要的指标。</p><p>在 AI集群中进行分布式训练时，通信是必要环节，同时也是相比于单机训练而言多出来的系统开销。通信与计算的时间比例往往决定了分布式机器学习系统加速比的上限。</p><p>因此，分布式机器学习的关键是设计通信机制，从而降低通信与计算的时间比例，更加高效地训练出高精度模型。</p><p>下面给大家介绍AI集群通信的软硬件、NCLL集合通信库、InfiniBand网络通信技术协议、AI集群和AI框架中对于InfiniBand的应用。</p><blockquote><p>文章较长，建议先点赞收藏，后续再慢慢观看。另外，我撰写的<strong>大模型相关的博客及配套代码</strong>均整理放置在Github：<strong><ahref="https://link.zhihu.com/?target=https%3A//github.com/liguodongiot/llm-action/tree/main">llm-action</a></strong>，有需要的朋友自取。</p></blockquote><span id="more"></span><h2 id="通信硬件"><strong>通信硬件</strong></h2><h3 id="通信硬件的实现方式"><strong>通信硬件的实现方式</strong></h3><p>通信的实现方式分为两种类型：机器内通信与机器间通信。</p><ul><li><p>机器内通信：</p><ul><li><p>共享内存（QPI/UPI），比如：CPU与CPU之间的通信可以通过共享内存。</p></li><li><p>PCIe，通常是CPU与GPU之间的通信。</p></li><li><p>NVLink，通常是GPU与GPU之间的通信，也可以用于CPU与GPU之间的通信。</p></li></ul></li><li><p>机器间通信：</p><ul><li><p>TCP/IP 网络协议。</p></li><li><p>RDMA (Remote Direct Memory Access) 网络协议。</p><ul><li>InfiniBand</li><li>iWARP</li><li>RoCE</li></ul></li></ul></li></ul><h3 id="pcie"><strong>PCIe</strong></h3><p>PCI-Express（peripheral component interconnectexpress），简称PCIe，是一种高速串行计算机扩展总线标准，主要用于扩充计算机系统总线数据吞吐量以及提高设备通信速度。</p><p>PCIE本质上是一种全双工的的连接总线，传输数据量的大小由通道数（lane，信道）决定的。</p><p>通常，1个连接通道lane称为X1，<strong>每个通道lane由两对数据线组成，一对发送，一对接收，每对数据线包含两根差分线。即X1只有1个lane，4根数据线</strong>，每个时钟每个方向1bit数据传输。依此类推，X2就有2个lane，由8根数据线组成，每个时钟传输2bit。类似的还有X12、X16、X32。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444411.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>2003 年 PCIe 1.0 正式发布，可支持每通道传输速率为250MB/s，总传输速率为 2.5 GT/s。</p><p>2007 年推出 PCIe 2.0 规范。在 PCIe 1.0的基础上将总传输速率提高了一倍，达到 5 GT/s，每通道传输速率从 250 MB/s上升至 500 MB/s。</p><p>2022 年 PCIe 6.0 规范正式发布，总传输速率提高至 64 GT/s。</p><p>2022年6月，PCI-SIG 联盟宣布 PCIe 7.0版规范，单条通道（x1）单向可实现128 GT/s传输速率，计划于2025年推出最终版本。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444467.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>PCIe吞吐量(可用带宽)计算方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量=传输速率*编码方案</span><br></pre></td></tr></table></figure><p>传输速率为每秒传输量（GT/s），而不是每秒位数（Gbps），是因为传输量包括<strong>不提供额外吞吐量的开销位</strong>，比如：PCIe1x和PCIe 2x使用8b/10b编码方案，导致占用了20%(=2/10)的原始信道带宽。</p><ul><li>GT/s，Giga transtion per second(千兆传输/秒)，即每一秒内传输的次数，重点在于描述物理层通信协议的速率属性，可以不和链路宽度等关联。</li><li>Gbps，Giga Bits per second(千兆位/秒)。GT/s和Gbps之间不存在成比例的换算关系。</li></ul><p>PCIe2.0协议支持5.0GT/s，即每一条Lane上支持每秒钟传输5G个Bit，但这并不意味着PCIe2.0协议的每一条Lane支持5Gbps的速率。为什么这么说呢，因为PCIe2.0的物理层协议中使用的是8b/10b编码方案，即每传输8个Bit，需要发送10个Bit，这多出来的2Bit并不是对上层有意义的信息。那么，PCIe2.0协议的每一条Lane支持<code>5*8/10=4Gbps=500MB/s</code>的速率。以一个PCIe2.0 x8的通道为例，x8的可用带宽为<code>4*8=32Gbps=4GB/s</code>。</p><p>同理，PCIe3.0协议支持8.0GT/s，即每一条Lane上支持每秒钟传输8G个Bit。而PCIe3.0的物理层协议中使用的是128b/130b编码方案，即每传输128个Bit，需要发送130个Bit，那么，PCIe3.0协议的每一条Lane支持<code>8*128/130=7.877GB/s=984.6MB/s</code>的速率。以一个PCIe3.0x16的通道为例，x16的可用带宽为<code>7.877*16=126.032 Gbps=15.754GB/s</code>。</p><p><strong>PCIE体系架构</strong>：</p><p>PCIE体系架构一般包含根组件RC（root-complex），交换器switch，终端设备EP（endpoint）等类型的PCIE设备组成。RC在总线架构中只有一个，用于处理器和内存子系统与I/O设备之间的连接，而switch的功能通常是以软件形式提供的，它包括两个或更多的逻辑PCI到PCI的连接桥（PCI-PCIBridge），以保持与现有PCI兼容。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444428.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvlink"><strong>NVLink</strong></h3><p><strong>背景</strong>：</p><p>算力的提升不仅依靠单张 GPU 卡的性能提升，往往还需要多 GPU卡组合。在多 GPU 系统内部，GPU间通信的带宽通常在数百GB/s以上，PCIe总线的数据传输速率容易成为瓶颈，且PCIe链路接口的串并转换会产生较大延时，影响GPU并行计算的效率和性能。</p><p>GPU发出的信号需要先传递到PCIe Switch, PCIeSwitch中涉及到数据的处理，CPU会对数据进行分发调度，这些都会引入额外的网络延迟，限制了系统性能。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444403.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>为此，NVIDIA推出了能够提升GPU通信性能的技术——GPUDirectP2P技术，使GPU可以通过 PCI Express直接访问目标GPU的显存，避免了通过拷贝到CPU hostmemory作为中转，大大降低了数据交换的延迟，但受限于PCIExpress总线协议以及拓扑结构的一些限制，无法做到更高的带宽。此后，NVIDIA提出了 NVLink 总线协议。</p><p><strong>NVLink简介</strong>：</p><p>NVLink 是一种高速互连技术，旨在加快 CPU 与 GPU、GPU 与 GPU之间的数据传输速度，提高系统性能。NVLink通过GPU之间的直接互联，可扩展服务器内的多GPUI/O，相较于传统PCIe总线可提供更高效、低延迟的互联解决方案。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444911.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>NVLink的首个版本于2014年发布，首次引入了高速GPU互连。2016年发布的P100搭载了第一代NVLink，提供160GB/s 的带宽，相当于当时 PCIe 3.0 x16 带宽（双向）的 5倍。之后陆续发布了很多新版本，V100搭载的 NVLink2 将带宽提升到300GB/s，A100搭载了NVLink3带宽为600GB/s。H100中包含18条第四代NVLink链路，总带宽（双向）达到900 GB/s，是PCIe 5.0 x16带宽（双向）的7倍。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444966.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444983.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>NVLink高速互联主要有两种：</p><ul><li>第一种是以桥接器的形式实现。</li><li>另一种是在主板上集成 <code>NVLink</code> 接口。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444035.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvswitch"><strong>NVSwitch</strong></h3><p>为了解决GPU之间通讯不均衡问题，NVIDIA引入NVSwitch。NVSwitch芯片是一种类似交换机的物理芯片（ASIC），通过NVLink接口可以将多个GPU高速互联到一起，可创建无缝、高带宽的多节点GPU集群，实现所有GPU在一个具有全带宽连接的集群中协同工作，从而提升服务器内部多个GPU之间的通讯效率和带宽。NVLink和NVSwitch的结合使NVIDIA得以高效地将AI性能扩展到多个GPU。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444026.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>第一代 NVSwitch于2018年发布，采用台积电 12nm FinFET 工艺制造，共有 18个 NVLink 2.0 接口。目前 NVSwitch 已经迭代至第三代。第三代 NVSwitch采用台积电 4N 工艺（台积电 4N工艺专为NVIDIA定制设计，并进行了一系列优化，它与普通台积电5nm节点相比，可实现更好的电源效率与性能，并且密度有所提升）构建，每个NVSwitch 芯片上拥有 64 个 NVLink 4.0 端口，GPU 间通信速率可达900GB/s。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444101.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvidia-gpu-服务器-pcie-版-和-sxm-版的区别"><strong>Nvidia GPU服务器 PCIe 版 和 SXM 版的区别</strong></h3><p>英伟达GPU卡间互连的内存插槽有2种，一种是PCIe口，一种是SXM口。</p><p>PCIe口是一个相对通用的协议，PCIe口相对慢一些，SXM是专门用来做卡间互连的，SXM协议是铺在电路板上，SXM协议做卡间互连会更快，对NVLink原生支持更好，显存带宽比PCIe高一些。PCIe和SXM都可以用NVLink，但是SXM是更好使用NVLink的方法。</p><p>SXM 架构是一种高带宽插座式解决方案，用于将 GPU 连接到 NVIDIA 专有的DGX 和 HGX 系统。SXM 版 GPU 通过主板上集成的 NVSwitch 实现 NVLink的连接，不需要通过主板上的PCIe进行通信，它能支持8块GPU卡的互联互通，实现了GPU之间的高带宽。未阉割的A100是600GB/s、H100是900GB/s，阉割过的A800、H800为400GB/s。</p><p>把 PCIe 版 GPU 卡插到 PCIe插槽上，就可以和CPU、同一个服务器上其他的GPU卡进行通信，也可以通过网卡与其他的服务器节点上的设备进行通信，这种就是PCIe的通信方式，但是这种传输速度不快。如果想要和SXM一样，有很快的传输速度，可以使用NVlink桥接器实现GPU和CPU之间的通信，但是和SXM不一样的地方就是它只能实现2块GPU卡之间的通信。即PCIe 版只有成对的 GPU 通过 NVLink Bridge 连接，通过 PCIe通道进行数据通信。同时，最新的PCIe网络带宽有128GB/s的限制。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444612.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="tcpip"><strong>TCP/IP</strong></h3><p>TCP/TP （或传输控制协议/Internet 协议）用于通过 Internet互连网络设备。它确定了数据应该如何被打包、寻址、传输、路由和接收。TCP/IP非常重视两台计算机之间的准确数据传输。如果系统在一次发送消息时遇到问题，则必须重新发送整个消息。</p><p>此外，TCP/IP的功能分为四个不同的层：<strong>数据链路层、互联网层、传输层和应用层</strong>。数据在被另一端接收之前必须经过这四层。然后，TCP/IP将通过以相反顺序传递层来重组数据并将其呈现给接收器。这样，您可以通过升级某些层而不是整个系统来提高数据中心的性能或安全性。</p><h3 id="rdma"><strong>RDMA</strong></h3><p>RDMA(远程直接数据存取)就是为了解决网络传输中服务器端数据处理的延迟而产生的，<strong>无需使用CPU，就可以从一个主机或服务器的内存直接访问另一主机或服务器的内存</strong>。它释放了CPU去执行其应做的工作，比如：运行应用程序和处理大量数据。这既提高了带宽又降低了延迟、抖动和CPU 消耗。</p><p>对比传统的网络传输机制，RDMA无需操作系统和TCP/IP协议栈的介入。<strong>RDMA的内核旁路机制，允许应用与网卡之间的直接数据读写</strong>，将服务器内的数据传输时延降低到1us以下。同时，RDMA的内存零拷贝机制，允许接收端直接从发送端的内存读取数据，极大的减少了CPU的负担，提升CPU的效率。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444661.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>大致有三类RDMA网络，分别是Infiniband、RoCE、iWARP。其中，Infiniband是一种专为RDMA设计的网络，从硬件级别保证可靠传输，而RoCE 和 iWARP都是基于以太网的RDMA技术，支持相应的verbs接口。</p><p>RDMA最早在Infiniband传输网络上实现，技术先进，但是价格高昂(<strong>只有Mellanox（现已被英伟达收购）和Intel（2012年，英特尔公司出资收购了QLogic的InfiniBand技术）供应商提供全套网络解决方案</strong>)，后来业界厂家把RDMA移植到传统Ethernet以太网上，降低了RDMA的使用成本，推动了RDMA技术普及。在Ethernet以太网上，根据协议栈融合度的差异，分为iWARP和RoCE两种技术，而RoCE又包括<strong>RoCEv1和RoCEv2两个</strong>版本(RoCEv2的最大改进是支持IP路由)。各RDMA网络协议栈的对比，如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444703.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>IB（InfiniBand）：</strong> 基于 InfiniBand 架构的 RDMA技术，由 IBTA（InfiniBand Trade Association）提出。搭建基于 IB 技术的RDMA 网络需要专用的 IB 网卡和 IB 交换机。</p><p><strong>iWARP（Internet Wide Area RDMA Protocal）：</strong> 基于TCP/IP 协议的 RDMA 技术，由 IETF 标 准定义。iWARP支持在标准以太网基础设施上使用 RDMA 技术，但服务器需要使用支持iWARP的网卡。</p><p><strong>RoCE（RDMA over Converged Ethernet）：</strong> 基于以太网的RDMA 技术，也是由 IBTA 提出。RoCE支持在标准以太网基础设施上使用RDMA技术，但是需要交换机支持无损以太网传输，需要服务器使用RoCE 网卡。</p><p>在三种主流的RDMA技术中，可以划分为两大阵营。一个是IB技术，另一个是支持RDMA的以太网技术(RoCE和iWARP)。其中,IBTA力挺的技术自然是IB和RoCE,Mellanox公司是这方面的急先锋。而iWARP则是IEEE/IETF力挺的技术，主要是Chelsio公司在推进。</p><p>在存储领域，支持RDMA的技术早就存在，比如：SRP(SCSI RDMAProtocol)和iSER(iSCSI Extensions for RDMA)。如今兴起的NVMe overFabrics如果使用的不是FC网络的话，本质上就是 NVMe over RDMA。换句话说，NVMe over InfiniBand, NVMe over RoCE 和 NVMe over iWARP 都是NVMe over RDMA。</p><h2 id="infiniband"><strong>InfiniBand</strong></h2><p>InfiniBand（直译为 “无限带宽”技术，缩写为IB）是一个为大规模、易扩展机群而设计的<strong>网络通信技术协议</strong>。可用于计算机内部或外部的数据互连，服务器与存储系统之间直接或交换互连，以及存储系统之间的互连。</p><p>InfiniBand最重要的一个特点就是<strong>高带宽</strong>、<strong>低延迟</strong>，因此在高性能计算项目中广泛的应用。主要用于高性能计算（HPC）、高性能集群应用服务器和高性能存储。</p><h3 id="infiniband-链路速率"><strong>InfiniBand 链路速率</strong></h3><p>InfiniBand在物理层定义了多种链路速度，例如：1X，4X，12X。每个单独的链路是四线串行差分连接（每个方向两根线）。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444802.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>以早期的SDR（单数据速率）规范为例，1X链路的原始信号带宽为2.5Gbps，4X链路是10Gbps，12X链路是30Gbps。1X链路的实际数据带宽为2.0Gbps（因为采用8b/10b编码）。由于链路是双向的，因此相对于总线的总带宽是4Gbps。</p><p>随着时间的推移，InfiniBand的网络带宽不断升级，下图展示了 InfiniBand从SDR、DDR、QDR、FDR、EDR发展到HDR、NDR的网络带宽，其速度是基于 4x链路速度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444850.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li>SDR（Single Data Rate）：2.5Gb/s (10Gb/s for 4x)。</li><li>DDR（Double Data Rate）：5 Gb/s (20Gb/s for 4x)。</li><li>QDR（Quad Data Rate）：10 Gb/s (40Gb/s for 4x)。</li><li>FDR（Fourteen Data Rate）：14Gb/s (56Gb/s for 4x)。</li><li>EDR（Enhanced Data Rate）：25 Gb/s (100Gb/s for 4x)。</li><li>HDR（High Data Rate）：50 Gb/s (200Gb/s for 4x)。</li><li>NDR（Next Data Rate）：100 Gb/s (400Gb/s for 4x)。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444956.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-网络互连产品"><strong>InfiniBand网络互连产品</strong></h3><p>InfiniBand网络中，使用的线缆区别于传统的以太网线缆和光纤线缆。针对不同的连接场景，需使用专用的InfiniBand线缆。</p><p>InfiniBand网络互连产品包括：<strong>DAC高速铜缆</strong>、<strong>AOC有源线缆</strong>以及<strong>光模块</strong>。</p><p>DAC高速线缆和AOC有源光缆都是用于数据中心、高性能计算机等大容量储存器设备间的传输设备。</p><p><strong>DAC高速线缆</strong>，也叫直连铜缆（Direct Attach Coppercable）,它的线材是铜缆，是低压脉冲传输信号；因为材料的不同导致功耗、传输距离和价格的不同，DAC高速线缆的功耗比较低，但传输距离相对比较短，低于10米。价格方面相对便宜一些。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444144.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>AOC有源光缆</strong>（Active OptialCable），它的线材是光缆，为光信号传输，通过电-光-电的转换；功耗相对比较大些但传输的距离可达到100米，价格方面相对高些。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444200.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>光模块</strong>的作用也是光电信号之间的转换，主要用于交换机与设备之间传输的载体，和光纤收发器的原理相同，只是光模块相比收发器更具效率性、安全性。光模块按照封装形式分类，常见的有SFP，SFP+，XFP，SFP28,QSFP+,QSFP28 等。</p><p><strong>光纤收发器</strong>是将短距离的电信号和长距离的光信号进行转换的设备，一般应用在远距离传输中，通过光纤进行传输，将电信号转换成光信号发送出去，同时，在接收端将接收到的光信号转换成电信号。在很多地方也被称之为光电转换器(FiberConverter)。光纤收发器为需要将系统从铜线升级到光纤，为缺少资金、人力或时间的用户提供了一种廉价的方案。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444278.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>光模块与光纤收发器如何配对使用？</strong></p><ol type="1"><li>波长和传输距离必须一致，比如：采用1310nm波长，传输距离应该是10KM/20KM。</li><li>光纤跳线尾纤接口选择需注意，一般光纤收发器采用的SC口，光模块采用的是LC口。</li><li>速率必须一样，比如：千兆收发器对应 1.25G光模块，百兆连百兆，千兆连千兆。4、光模块类型需要采用相同类型，单纤对单纤，双纤对双纤。</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444281.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-的网络架构"><strong>InfiniBand的网络架构</strong></h3><p>InfiniBand 是一种基于通道的结构，组成单元主要分为四类：</p><ul><li>HCA（Host Channel Adapter，主机通道适配器）</li><li>TCA（Target Channel Adapter，目标通道适配器）</li><li>InfiniBand link（连接通道，可以是电缆或光纤，也可以是板上链路）</li><li>InfiniBand交换机和路由器（组网用的）</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444357.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>通道适配器就是搭建InfiniBand通道用的。所有传输均以通道适配器开始或结束，以确保安全或在给定的QoS（服务质量）级别下工作。</p><p>使用 InfiniBand 的系统可以由多个子网（Subnet）组成，每个子网最大可由6 万多个节点组成。</p><ul><li>子网内部，InfiniBand 交换机进行二级处理。</li><li>子网之间，使用路由器或网桥进行连接。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444436.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>InfiniBand 的二级处理过程非常简单，每个 InfiniBand子网都会设一个子网管理器，生成16位的 LID（本地标识符）。InfiniBand交换机包含多个 InfiniBand端口，并根据第二级本地路由标头中包含的LID，将数据包从其中一个端口转发到另一个端口。<strong>除管理数据包外，交换机不会消耗或生成数据包</strong>。</p><p>简单的处理过程，加上自有的Cut-Through技术，InfiniBand将转发时延大幅降低至 100ns 以下，明显快于传统以太网交换机。</p><p>在 InfiniBand网络中，数据同样以数据包（最大4KB）的形式传输，采用的是串行方式。</p><h3 id="infiniband-的协议栈"><strong>InfiniBand 的协议栈</strong></h3><p>InfiniBand协议同样采用了分层结构，各层相互独立，下层为上层提供服务，如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444628.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li><strong>物理层</strong>定义了在线路上如何将比特信号组成符号，然后再组成帧、数据符号以及包之间的数据填充等，详细说明了<strong>构建有效包的信令协议</strong>等。</li><li><strong>链路层</strong>定义了数据包的格式以及数据包操作的协议，如：流控、路由选择、编码、解码等。</li><li><strong>网络层</strong>通过在数据包上添加一个40字节的全局的路由报头（GlobalRoute Header,GRH）来进行路由的选择，对数据进行转发。<strong>在转发的过程中，路由器仅仅进行可变的CRC校验，这样就保证了端到端的数据传输的完整性</strong>。Infiniband报文封装格式如下图所示：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444690.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li><strong>传输层</strong>再将数据包传送到某个指定的队列偶（Queue Pair,QP）中，并指示 QP 如何处理该数据包。</li></ul><p>可以看出，InfiniBand 拥有自己定义的 1-4层格式，是一个完整的网络协议。端到端流量控制，是 InfiniBand网络数据包发送和接收的基础，可以实现无损网络。</p><blockquote><p>QP（队列偶）说明：QP是RDMA技术中通信的基本单元。队列偶就是一对队列，SQ（SendQueue，发送工作队列）和 RQ（ReceiveQueue，接收工作队列）。用户调用API发送接收数据的时候，实际上是将数据放入QP当中，然后以轮询的方式，将QP中的请求一条条的处理。</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444761.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="mellanox-ofed-软件栈"><strong>Mellanox OFED 软件栈</strong></h3><p>Mellanox OFED是一个单一的软件堆栈，包括驱动、中间件、用户接口，以及一系列的标准协议IPoIB、SDP、SRP、iSER、RDS、DAPL(Direct Access ProgrammingLibrary)，支持 MPI、Lustre/NFS over RDMA 等协议，并提供 Verbs编程接口；Mellanox OFED 由开源 OpenFabrics 组织维护。</p><p>Mellanox OFED 软件堆栈是承载在 InfiniBand硬件和协议之上的，软件通过协议和硬件进行有效的数据传输。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444831.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="opensm-子网管理器"><strong>OpenSM 子网管理器</strong></h3><p>OpenSM 软件是符合InfiniBand的子网管理器(SM)，运行在MellanoxOFED软件堆栈进行 IB网络管理，管理控制流走业务通道，属于带内管理方式。</p><p>OpenSM包括<strong>子网管理器、背板管理器和性能管理器</strong>三个组件，绑定在交换机内部的必备部件。提供非常完备的管理和监控能力，如：<strong>设备自动发现、设备管理、Fabric可视化、智能分析、健康监测</strong>等等。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444856.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-组网"><strong>InfiniBand 组网</strong></h3><p>InfiniBand 组网跟普通的交换机不太一样，InfiniBand的组网成本很高。如果希望这个网络中任何两个计算节点的网卡之间互相无损地通信，需要使用一种叫做胖树（FatTree）的网络拓扑，大概是如下一种拓扑结构，方块是交换机，椭圆是计算节点。</p><p>胖树主要有两层，上面一层是核心层，不连任何计算节点，它的功能就是转发流量；下面一层是接入层，接入各类计算节点。</p><p>胖树拓扑成本高的主要原因是：某一个汇聚交换机上，假如有36个口，那如果为了达到无损速率，一半的口，也就是18个口可以给计算节点连，剩下一半要连到上层的核心交换机上。要知道，任何一根线，就是1万多块钱呢，如果达到无损，就要冗余地做这些连接。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444939.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvidia-infiniband-商用产品"><strong>NVIDIA InfiniBand商用产品</strong></h3><p>Mellanox 在全球 InfiniBand 市场的占有率基本上无敌的存在，在英伟达收购Mellanox 之后，也于2021年推出了自己的第七代 NVIDIA InfiniBand架构：NVIDIA Quantum-2。</p><p>NVIDIA Quantum-2 平台包括：NVIDIA Quantum-2 系列交换机、NVIDIAConnectX-7 InfiniBand 适配器、BlueField-3 InfiniBand DPU以及电缆。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444126.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>NVIDIA Quantum-2系列交换机</strong>采用紧凑型1U设计，包括风冷和液冷版本。交换机的芯片制程工艺为7nm，单芯片拥有570亿个晶体管（比A100GPU还多）。单个交换机采用64个400Gb/s端口或128个200Gb/s端口的灵活搭配，提供总计51.2Tb/s的双向吞吐量。NVIDIA NDR 400Gb/s InfiniBand交换机如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444198.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>NVIDIA ConnectX-7 InfiniBand 适配器</strong>支持PCIeGen4和Gen5，具有多种外形规格，可提供 400Gb/s 吞吐量。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444299.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-常用命令"><strong>InfiniBand 常用命令</strong></h3><ul><li><code>ibv_asyncwatch</code>：监视 InfiniBand 异步事件</li><li><code>ibv_devices</code> 或 <code>ibv_devinfo</code>： 列举InfiniBand 设备或设备信息 - <code>ibstatus</code>：查询 IB设备的基本状态</li><li><code>ibping</code>： 验证 IB 节点之间的连通性</li><li><code>ibtracert</code>：跟踪 IB 路径</li><li><code>iblinkinfo</code>：查看IB交换模块的所有端口的连接状态。此命令会将集群内所有的IB交换模块都进行列举。</li></ul><h2 id="通信软件"><strong>通信软件</strong></h2><p>通信软件指用于分布式训练时，多个计算设备之间的集合通信。在分布式系统中，各个节点间往往存在大量的集合通信需求，而我们可以用消息传递接口(Message Passing Interface，MPI，一套集合通信相关的接口标准)来定义一些比较底层的消息通信行为。譬如Reduce、AllReduce、Scatter、Gather、AllGather 等。</p><p>常见的集合通信库（如：Open MPI、Gloo、NCCL等）都在 MPI的基础上，对各种集合通信的模式和算法作了各自的实现。</p><p><strong>Open MPI</strong>：</p><p>Open MPI 是一个开源 MPI（消息传递接口）的实现，由学术，研究和行业合作伙伴联盟开发和维护。因此，Open MPI可以整合高性能计算社区中所有专家，技术和资源，以构建可用的最佳 MPI库。</p><p><strong>Gloo</strong>：</p><p>Gloo 是 Facebook开源的一套集体通信库，提供了对机器学习中有用的一些集合通信算法。如：Barrier，Broadcast，AllReduce。</p><p><strong>NCCL</strong>：</p><p>NCCL（Nvidia Collective multi-GPU Communication Library）是英伟达基于NVIDIA GPU 的一套开源的集合通信库，如其官网描述：NVIDIA集合通信库（NCCL）实现了针对 NVIDIA GPU 性能优化的多 GPU和多节点集合通信原语。NCCL 提供了诸如 All Gather，AllReduce，Broadcast，Reduce，Reduce-Scatter 等实现，这些实现优化后可以通过PCIe、 NVLink、InfiniBand 等高速互联，从而实现高带宽和低延迟。</p><p>因为 NCCL 是 NVIDIA基于自身硬件定制的，能做到更有针对性且更方便优化，故在英伟达硬件上，NCCL的效果往往比其它的通信库更好。</p><p>NCCL主要做几件事：<strong>探测计算节点的网络设备和拓扑结构</strong>，使用算法自动调优选择一个最优的通信方式。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444373.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="nccl-集合通信库"><strong>NCCL 集合通信库</strong></h2><h3 id="通信原语"><strong>通信原语</strong></h3><p>并行任务的通信一般可以分为 Point-to-point communication 和 Collectivecommunication 。</p><p>P2P 通信这种模式只有一个sender和一个receiver，实现起来比较简单。</p><p>集合通信包含多个sender多个receiver，一般的通信原语包括broadcast，gather，all-gather，scatter，reduce，all-reduce，reduce-scatter，all-to-all等。</p><p>简单介绍几个常用的操作：</p><p><strong>Reduce</strong>：从多个sender那里接收数据，最终combine到一个节点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444484.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>All-reduce</strong>：从多个sender那里接收数据，最终combine到每一个节点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444737.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nccl-实现"><strong>NCCL 实现</strong></h3><p>NCCL 实现成 CUDA C++ kernels，包含3种 primitive operations：Copy，Reduce，ReduceAndCopy。</p><ul><li>NCCL 1.0 版本只支持单机多卡，卡之间通过 PCIe、NVlink、GPUDirect P2P来通信。</li><li>NCCL 2.0 支持多机多卡，多机间通过 Sockets (Ethernet) 或者 InfiniBandwith GPUDirect RDMA 通信。</li></ul><p>单机内多卡通过PCIe以及CPU socket通信。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444882.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>多机通过InfiniBand通信，在多机多卡内部，也要构成一个通信环。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444963.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="对比-nccl-在不同硬件架构下网络带宽"><strong>对比 NCCL在不同硬件架构下网络带宽</strong></h3><p>下图是 Allreduce 在单机不同架构下的速度比较：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444081.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>前面三个是单机多卡典型的三种连接方式：</p><ul><li>第一种是两个GPU通过CPU然后通过QPI和另一个CPU上的两块卡相连，因此速度最慢，但也能达到&gt;5GB/s。</li><li>第二种是两个GPU通过PCIeswitch相连后再经过CPU连接，速度会稍微低一点。</li><li>第三种是四张卡都在一个PCIe switch上，所以带宽较高，能达到&gt;10GB/sPCIe的带宽大小。</li></ul><p>第四种是DGX-1架构，这是Nvidia推出的深度学习平台，带宽能达到60GB/s。</p><p>下图是 Allreduce多机下的速度表现。其中，左图2机8卡，机内PCIe，机间InfiniBand能达到&gt;10GB/s的速度，InfiniBand基本上能达到机内的通信速度；右图4机32卡，机内NVLink，机间InfiniBand，带宽能达到&gt;40GB/s。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444202.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>下图是 NCCL 在 CNTK ResNet50 上的可扩展性（scalability），32卡基本能达到线性加速比。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444295.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nccl-常见的环境变量设置"><strong>NCCL常见的环境变量设置</strong></h3><p><strong>NCCL_P2P_DISABLE</strong></p><p>该变量禁用 P2P 传输，该传输使用 NVLink 或 PCI在GPU之间使用CUDA直接访问。</p><p>设定为 1 相当于设置 <code>NCCL_P2P_LEVEL=0</code>，并且会被NCCL_P2P_LEVEL 的值所覆盖。</p><p><strong>NCCL_P2P_LEVEL</strong>：</p><p>该变量允许用户精细地控制何时在GPU之间使用 P2P传输。该级别定义了NCCL将使用P2P传输的GPU之间的最大距离。</p><p>如果未指定，NCCL将尝试根据其运行的体系结构和环境来最佳选择一个值。</p><p>可选值：</p><ul><li>LOC：从不使用P2P（始终禁用）</li><li>NVL ：当 GPU 通过 NVLink 连接时使用 P2P</li><li>PIX ：当 GPU 位于同一 PCI 交换机上时使用 P2P。</li><li>PXB：当 GPU 通过 PCI 交换机（可能是多跳）连接时使用 P2P。</li><li>PHB ：当 GPU 位于同一 NUMA 节点上时使用 P2P。 流量将通过 CPU。</li><li>SYS ：在 NUMA 节点之间使用 P2P，可能跨越 SMP互连（例如：QPI/UPI）。</li></ul><p><strong>NCCL_NET_GDR_LEVEL</strong>：</p><p>该变量允许用户精细控制何时在NIC和GPU之间使用GPUDirectRDMA。该级别定义NIC和GPU之间的最大距离。</p><p>如果未指定，NCCL将尝试根据其运行的体系结构和环境来最佳选择一个值。</p><p>可选值：</p><ul><li>LOC：从不使用 GPU Direct RDMA。（始终禁用）</li><li>PIX：当 GPU 和 NIC 位于同一 PCI 交换机上时，使用 GPU DirectRDMA。</li><li>PXB：当 GPU 和 NIC 通过 PCI 交换机（可能是多跳）连接时，使用 GPUDirect RDMA。</li><li>PHB ：当 GPU 和 NIC 位于同一 NUMA 节点上时，使用 GPU Direct RDMA。流量将通过 CPU。</li><li>SYS ：即使跨 NUMA 节点之间的 SMP 互连（例如 QPI/UPI）也使用 GPUDirect RDMA。 （始终启用）</li></ul><p><strong>NCCL_NET_GDR_READ</strong>：</p><p>只要 GPU-NIC 距离在 NCCL_NET_GDR_LEVEL指定的距离内，NCCL_NET_GDR_READ 变量就会在发送数据时启用 GPU DirectRDMA。</p><ul><li>2.4.2之前，默认情况下禁用GDR读取，即发送数据时，数据先存储在 CPU内存中，然后再发送到 InfiniBand 卡。</li><li>自 2.4.2 起，基于 NVLink 的平台默认启用 GDR 读取。</li></ul><p>注意：已知在某些平台（例如：PCI-E）上，发送数据时直接从 GPU内存读取比从 CPU 内存读取稍慢。</p><p>可选值为0或1。定义并设置为1以使用GPU DirectRDMA直接将数据发送到NIC（绕过CPU）。</p><p>在 2.4.2 之前，所有平台的默认值都是 0。 自 2.4.2 起，基于 NVLink的平台的默认值为 1，否则为 0。</p><p><strong>NCCL_IB_DISABLE</strong>：</p><p>该变量将禁用 NCCL 要使用的IB传输。NCCL 将使用IP sockets 。</p><p>定义并设置为1以强制使用IP sockets 。</p><p><strong>NCCL_SOCKET_IFNAME</strong>：</p><p>指定NCCL使用的SOCKET网卡。如：<code>NCCL_SOCKET_IFNAME=bond0,eth0</code>。</p><p><strong>NCCL_IB_HCA</strong>：</p><p>该变量指定要用于通信的 RDMA接口。使用IB通信必须要设置的（指定NCCL使用的IB网卡）。 可以通过 ibstat查看IB网卡名。</p><p>用法：</p><p>定义一个前缀列表来过滤要由 NCCL 使用的接口。使用 ^ 符号，NCCL将排除以列表中任何前缀开头的接口。还可以使用 :符号来指定特定的端口。要匹配（或不匹配）确切的接口名称而不是前缀，在字符串前面加上= 字符。</p><p>示例：</p><ul><li><code>mlx5</code>：使用以 mlx5 开头的所有卡的所有端口。</li><li><code>=mlx5_0:1,mlx5_1:1</code>：使用卡 mlx5_0 和 mlx5_1 的端口1。</li><li><code>^=mlx5_1</code>：不使用卡 mlx5_1。</li></ul><p>比如： NCCL_IB_HCA=mlx5_2,mlx5_3,mlx5_4,mlx5_5</p><blockquote><p>注意： 如果不加前缀 =，使用 mlx5_1 将同时选择 mlx5_1 和 mlx5_10 到mlx5_19（如果存在）。因此，始终建议添加前缀 = 以确保精确匹配。</p></blockquote><p>使用建议：</p><p>通过这个环境变量可以调整NIC（Network Interface Controller）数量，NIC通常是一块插入计算机主板上的扩展卡，更多NIC，节点带宽更大。通过控制NIC数量可以控制节点间通信带宽。</p><p><strong>NCCL_IB_TIMEOUT</strong>：</p><p>该变量用于控制InfiniBand Verbs超时。取值范围1-22。</p><p>超时时间的计算公式为4.096微秒 * 2 ^timeout，正确的值取决于网络的大小。增加该值可以在非常大的网络上提供帮助，例如，如果NCCL在调用ibv_poll_cq时出现错误12。</p><p>使用建议：</p><p>在大模型训练任务中设置成最大值22，可以减少不少nccl timeout异常。</p><p><strong>NCCL_IB_RETRY_CNT</strong></p><p>该变量控制 InfiniBand 的重试次数。</p><p>使用建议：</p><p>在大模型训练任务中设置成13，尽可能多重试。</p><p><strong>NCCL_PXN_DISABLE</strong>：</p><p>禁止使用非本地 NIC 的进行节点间通信，使用 NVLink 和一个中间 GPU。</p><p>使用建议：</p><p>设置成1。在PyTorch中进行跨节点all-to-all通信时，如果该环境变量是0会出现异常。</p><p><strong>NCCL_DEBUG_FILE</strong>：</p><p>设置一个文件地址，变量用于将NCCL的调试日志输出到文件中，有助于调试NCCL。</p><p><strong>NCCL_IB_PCI_RELAXED_ORDERING</strong>：</p><p>启用 IB Verbs 传输的 Relaxed Ordering。RelaxedOrdering可以极大地提高虚拟化环境下 InfiniBand 网络的性能。</p><p>传统的顺序执行（StrictOrdering）要求数据在发送和接收之间按照严格的顺序进行传输和处理。这种机制可以确保数据的顺序性，但可能会导致性能瓶颈，特别是在高负载和复杂通信模式下。</p><p>而RelaxedOrdering允许数据在发送和接收之间进行乱序传输和处理。这意味着系统可以更灵活地调度和处理数据，提高并行性和吞吐量。RelaxedOrdering机制在虚拟化环境中尤其有益，因为它可以减少虚拟机之间的争用和延迟，提高整体性能。</p><p>接受的取值：</p><ul><li>设置为 2，如果可用，自动使用Relaxed Ordering。</li><li>设置为 1，强制使用Relaxed Ordering，如果不可用，则失败。</li><li>设置为 0，禁用使用Relaxed Ordering。</li></ul><p>默认值为 2。建议设置成 1。</p><p><strong>NCCL_SHM_DISABLE</strong>：</p><p>该变量禁用共享内存（SHM）传输。</p><p>在P2P不能生效的情况下，是否使用CPU的共享内存来传输数据。 当 SHM禁用时，NCCL 使用网络（ InfiniBand 或 IP sockets）在 CPU sockets之间进行通信。</p><h2 id="infiniband-在-ai-集群中的应用"><strong>InfiniBand 在 AI集群中的应用</strong></h2><h3 id="gpudirect-简介"><strong>GPUDirect 简介</strong></h3><p>GPUDirect 是 NVIDIA 开发的一项技术，可实现 GPU与其他设备（例如网络接口卡 (NIC)和存储设备）之间的直接通信和数据传输，而不涉及 CPU。</p><p>传统上，当数据需要在 GPU 和另一个设备之间传输时，数据必须通过CPU，从而导致潜在的瓶颈并增加延迟。使用GPUDirect，网络适配器和存储驱动器可以直接读写 GPU内存，减少不必要的内存消耗，减少 CPU开销并降低延迟，从而显著提高性能。GPU Direct 技术包括 GPUDirectStorage、GPUDirect RDMA、GPUDirect P2P 和 GPUDirect Video。</p><h3 id="gpudirect-发展简史"><strong>GPUDirect 发展简史</strong></h3><ul><li>GPUDirect Shared Memory (2012) ：Nvidia在PCIe上实现了单机上的GPUDirect Shared Memory 技术；</li><li>GPUDirect P2P (2014)： Nvidia在PCIe上实现了单机上的GPUDirectP2P技术；</li><li>NVLink（2014） ：解决了单机多卡通信时PCIe瓶颈问题；</li><li>GPUDirect RDMA（2014）：提升多机多卡通信性能；</li></ul><h3 id="gpudirect-peer-to-peerp2p简介"><strong>GPUDirect Peer toPeer（P2P）简介</strong></h3><p>GPUDirect Peer-to-Peer(P2P)技术主要用于单机GPU间的高速通信，它使得<strong>GPU可以通过PCIExpress直接访问目标GPU的显存</strong>，避免了通过拷贝到CPU hostmemory作为中转，大大降低了数据交换的延迟。</p><p>以深度学习应用为例，主流的开源深度学习框架（如：TensorFlow、MXNet）都提供了对GPUDirectP2P的支持，NVIDIA开发的NCCL(NVIDIA Collective CommunicationsLibrary)也提供了针对GPUDirect P2P的特别优化。</p><p>通过使用GPUDirectP2P技术可以大大提升深度学习应用单机多卡的扩展性，使得深度学习框架可以获得接近线性的训练性能加速比。</p><h3 id="gpudirect-rdma-简介"><strong>GPUDirect RDMA 简介</strong></h3><p>所谓 GPUDirectRDMA，就是计算机1的GPU可以直接访问计算机2的GPU内存。而在没有这项技术之前，GPU需要先将数据从GPU内存搬移到系统内存，然后再利用RDMA传输到计算机2，计算机2的GPU还要做一次数据从系统内存到GPU内存的搬移动作。GPUDirectRDMA技术使得进一步减少了GPU通信的数据复制次数，通信延迟进一步降低。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444358.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>使用 GPUDirect RDMA 两个 GPU 设备必须共享相同的上游 PCI Express rootcomplex。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444350.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="infiniband-在-nvidia-dgx-集群中应用"><strong>InfiniBand 在NVIDIA DGX 集群中应用</strong></h2><p><strong>DGX-1 集群中应用 InfiniBand</strong>：</p><p>下图展示了 DGX-1 配有四个 EDR InfiniBand 卡（每个 100 Gb/s）和两个10Gb/s 以太网卡（铜质）。 这些网络接口可用于将 DGX-1连接到网络以进行通信和存储。</p><p>每两个 GPU 都连接到系统板上的一个 PCIe 交换机。 该交换机还连接到InfiniBand (IB) 网卡。 为了减少延迟并提高吞吐量，来自这两个 GPU的网络流量应流向关联的 IB 卡。 这就是 DGX-1 设备中有四张 IB卡的原因。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444419.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>如果您想使用InfiniBand（IB）网络连接DGX设备，理论上，您只需使用其中一张IB卡即可。然而，这些数据流量将强行通过 CPU 之间的 QPI 链路，这对于 GPU流量来说是一个非常慢的链路（即，它成为瓶颈）。更好的解决方案是使用两张IB 卡，一张连接到每个 CPU。这可以是 IB0 和 IB2，或者 IB1 和 IB3，或者IB0 和 IB3，或者 IB1 和 IB2。 这将大大减少必须穿越 QPI 链路的流量。最佳性能始终是使用 IB 交换机的所有四个 IB 链路。</p><p>使用 IB 链路是将所有四个 IB 卡连接到 IB 结构的最佳方法。如果您使用多个 DGX设备进行训练，这将带来最佳性能（完全的平分带宽和最低延迟）。</p><p>通常，最小的 IB 交换机配有 36 个端口。 这意味着单个 IB交换机可容纳使用全部四张 IB 卡的九个 DGX-1 设备。 这允许从 DGX-1到交换机的带宽为 400 Gb/s。</p><p>如果您的应用程序不需要 DGX-1 设备之间的带宽，则可以如前所述为每个DGX-1 使用两个 IB 连接。 这允许您将最多 18 个 DGX-1 设备连接到单个 36端口 IB 交换机。</p><p>注意：<strong>不建议仅使用单个 IB卡</strong>，但如果由于某种原因采用这种配置，则您最多可以将 36 个 DGX-1设备连接到单个交换机。</p><p>对于大量 DGX-1 设备，您可能必须使用两级交换网络。 经典的 HPC配置是在第一级使用 36 端口 IB交换机（有时称为叶子（Leaf）交换机），并将它们连接到单个大型核心交换机，有时称为导向器级（directorclass）交换机。最大的导向器级InfiniBand交换机有648个端口。当然您也可以使用多个核心交换机，但配置会变得相当复杂。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444513.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>对于两级交换网络，如果每个 DGX-1 设备的全部 4 个 IB 卡都用于连接到 36端口交换机，并且没有过度订阅，则每个交换机的 DGX-1 设备的最大数量为4。这时每个 DGX-1 有 4 个端口进入交换机，总共 16个端口。然后，从叶子交换机到核心交换机（导向器级交换机）有 16个上行链路。总共 40 台 36 端口叶子交换机可连接到 648 端口核心交换机(648/16)。 这导致 160（40 * 4） 个 DGX-1设备（共640卡）以全对分带宽连接。</p><p>当然您还可以在设计 IB网络时使用所谓的过度订阅。过度订阅意味着来自<strong>上行链路的带宽小于进入设备的带宽</strong>（换句话说，带宽性能较差）。如果我们使用从DGX-1 设备到第一级交换机（36 端口叶交换机）的 2:1 超额订阅，则每个 DGX-1设备仅使用两个 IB卡连接到交换机。与使用所有四张卡相比，这会导致带宽更少，并且延迟也会更高。</p><p>如果我们保持从叶子交换机到核心交换机的网络带宽为1:1（换句话说，没有过度订阅，全对分带宽），那么我们可以将九个 DGX-1设备放入一个单叶子交换机（从 DGX 设备到叶子交换机的总共 18个端口以及到核心交换机的 18个上行链路端口）。结果是总共36（648/18）台叶子交换机可以连接到核心交换机。这使得总共 324（36 * 9） 个 DGX-1 设备可以连接在一起。</p><p>您还可以通过使用从叶子交换机到核心交换机的超额订阅来进一步定制 IB网络。 这可以通过<strong>使用每个 DGX 设备到叶子交换机的四个 IB连接</strong>，然后对核心交换机进行 2:1超额订阅，甚至使用到叶子交换机的两个 IB 连接，然后对核心交换机进行 2:1超额订阅来完成。</p><p>InfiniBand 网络的另一个重要方面是子网管理器 (SM)。 SM仅管理IB网络。任何时候都有一个 SM 管理 IB 结构，但您可以让其他 SM 运行并准备好在第一个SM 崩溃时接管。 选择运行多少个 SM以及在何处运行它们会对集群的设计产生重大影响。</p><p>首先要做的决定是<strong>在哪里运行 SM</strong>。</p><p>如果您愿意，它们可以在 IB 交换机上运行。 这称为硬件SM，因为它在交换机硬件上运行。 这样做的优点是您不需要任何其他也可以运行SM 的服务器。</p><p>在节点上运行 SM 称为软件 SM。 运行硬件 SM 的一个缺点是，如果 IB流量很大，SM 可能会遇到困难。 对于大量 IB流量和较大的网络，最佳实践是在专用服务器上使用软件 SM。</p><p>要做的第二个决定是您<strong>想要运行多少个 SM</strong>。您至少必须运行一个 SM。 最便宜的解决方案是运行单个硬件 SM。 这对于 DGX-1设备的小集群（可能是 2-4 个）来说效果很好。随着单元数量的增加，您将需要考虑同时运行两个 SM 以获得HA（高可用性）功能。 您需要 HA的原因是集群上有更多用户，并且集群故障比少量设备故障产生的影响更大。</p><p>随着设备数量的增长，请考虑在专用服务器（软件 SM）上运行 SM。您还需要为集群运行至少两个 SM。 理想情况下，这意味着 SM有两台专用服务器。</p><p><strong>DGX SuperPOD 中广泛应用InfiniBand</strong>：</p><p>下图为 DGX A100/H100 256 SuperPOD 网络拓扑图：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444669.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>下图为 DGX A100/H100 1K POD 网络拓扑图：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444765.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="infiniband-在-ai-框架中的应用"><strong>InfiniBand 在 AI框架中的应用</strong></h2><p>在之前文章（<strong><ahref="https://link.zhihu.com/?target=https%3A//juejin.cn/post/7311604023184162835">AI集群基础设施 NVMe SSD 详解</a></strong>）中谈到了 NVMe 在 DeepSpeed中的应用。DeepSpeed 通过 ZeRO-Infinity 技术尝试<strong>利用 NVMe的空间进一步打破内存墙的限制训练超大模型</strong>。除此之外，该方法也充分利用了InfiniBand网络进行多机通信，具体如下图所示。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444828.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>另外，像NCCL、Gloo等集合通信库都继承了InfiniBand，Pytorch框架也能够通过通信库轻松应用InfiniBand进行分布式训练。</p><h2 id="总结"><strong>总结</strong></h2><p>本文讲述了AI集群通信的软硬件；同时，针对NCLL集合通信库以及InfiniBand网络通信技术协议进行了更为详细的介绍；另外，也讲述了AI集群以及AI框架中对于InfiniBand的应用。</p><p>码字不易，如果觉得有帮助，欢迎点赞收藏加关注。</p><h2 id="参考文档"><strong>参考文档</strong></h2><ul><li><strong><ahref="https://zhuanlan.zhihu.com/p/454282470">带你了解PCIE通信原理</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/662904805">电脑硬件冷知识：主板北桥芯片为何消失了，南桥也有同样的命运？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/FlRc2q8r0fUOzxJFWulGfw">必看:原来PCIe技术原理这么简单</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.sdnlab.com/26316.html">AI网络互联，PCIe还是NVLink？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.sohu.com/a/229080366_632967">RDMA技术原理分析、主流实现对比和解析</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/FgKjDjZsPlweVJ03OVr3SA">详谈RDMA技术原理和三种实现方式</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/u013253075/article/details/119843611">RDMA技术详解——RDMA的三种实现方式</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.nvidia.cn/networking/interconnect/">【英伟达官网】线缆和收发器</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=http%3A//www.rhopto.com/articles/dacgsx.html">DAC高速线缆和AOC有源光缆有什么区别呢？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.etulink.com/blog/-_b268">你会区分光模块和光纤收发器吗？</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/139294038">都是光电转换作用，光模块和光纤收发器有什么区别？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//baijiahao.baidu.com/s%3Fid%3D1760941961023057651%26wfr%3Dspider%26for%3Dpc">态路小课堂丨关于InfiniBand网络相关内容简介！</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.51cto.com/u_14408894/8031135">态路小课堂丨InfiniBandAOC有源光缆简介</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NTA0MDUyMA%3D%3D%26mid%3D2456692454%26idx%3D1%26sn%3D031a11b931edee5504b15045cd863d37%26chksm%3Dfda68b81cad10297e4dd53bc97f63e0c47c26a27cdbb3c584cce6fc49fc6b4367b1531cbfcb6%26scene%3D0%26xtrack%3D1%23rd">InfiniBand，到底是个啥？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/networking/display/mlnxofedv583070101/introduction">NVIDIAMLNX_OFED Documentation v5.8-3.0.7.0.101 for DGX H100Systems</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/deeplearning/nccl/user-guide/docs/env.html">NCCL环境变量</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/653001915">大模型训练场景下NCCL环境变量设置</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//github.com/FelixFu520/README/blob/main/envs/pytorch/cuda_gpu.md">【GitHub】CUDA_GPU详细介绍</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/e40059d5c832">GPU卡的底层通信原理</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.nvidia.cn/networking/infiniband-adapters/">NVIDIAConnectX InfiniBand 网卡</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.h3c.com/cn/d_202007/1317229_30005_0.htm%23_Toc46935211">H3CIB网卡常用命令</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_42319496/article/details/125942763">IB常用命令</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/591403">浅析GPU通信技术（上）-GPUDirectP2P</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/603617">浅析GPU通信技术（下）-GPUDirectRDMA</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/cuda/gpudirect-rdma/index.html">GPUDirectRDMA 12.3 文档</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/622853211">【大模型训练】RDMA高速网络与集合通讯</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//cloud.baidu.com/doc/GPU/s/Yl3mr0ren">百度智能云-NCCL环境搭建</a></strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>throughput</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/throughput/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/throughput/</url>
      
        <content type="html"><![CDATA[<h1 id="throughput">throughput</h1><p>哟哟哟！！看图了。大模型性能比较指标中，到处都是throughput！到处都是！！！</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061752165.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>真的是到处都是呢！！</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061752217.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><hr /><p>​ <ahref="https://www.zhihu.com/search?q=神经网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">神经网络</a>的吞吐量（Throughput）定义为网络模型在<strong>单位时间内</strong>（例如，1s）<strong>可以处理的最大输入的训练样本数据</strong>。</p><p>​ 与涉及单个样本数据处理的延迟 Latency 不同，为了实现最大吞吐量Throughput，希望在集群训练的过程中并行处理尽可能多的样本数据。有效的并行性显然依赖于数据、模型和设备规模。</p><p>​ 因此，为了正确测量吞吐量，可以执行以下两个步骤：</p><ol type="1"><li>估计允许最大<ahref="https://www.zhihu.com/search?q=并行度&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">并行度</a>的最佳训练样本数据批量大小，即Batch Size</li><li>在AI训练集群中给定这个最佳批量大小，<ahref="https://www.zhihu.com/search?q=测量网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">测量网络</a>在1秒钟内可以处理的训练样本数据。</li></ol><p>​ 要找到最佳批量大小，一个好的经验法则是达到 Ascend <ahref="https://www.zhihu.com/search?q=昇腾处理器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">昇腾处理器</a>对给定数据类型的内存限制，即BatchSize塞满内存。这个大小当然取决于硬件类型和网络的大小。</p><p>​ 找到这个最大批量大小 Batch Size的最快方法是执行二进制搜索。当时间不重要时，简单的<ahref="https://www.zhihu.com/search?q=顺序搜索&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">顺序搜索</a>就足够了。不过在大模型训练的过程中，因为BatchSize比较重要，设计到重计算、Pipeline并行、Tensor并行等不同并行模式的配比，还有包括microBatch Size的数据配比。因此默认Batch Size会为16的倍数增长比较合理。</p><p>​ 这确定了 AI加速卡上可以处理的最大批量大小，用于训练大模型及其处理的输入训练样本数据。在找到最佳批量大小后，可以计算实际吞吐量，然后使用以下公式：<span class="math display">\[sample_{throughput}=BS*N/step_{time}\]</span> 其中，BS 为 Batch Size，N 为集群中AI加速卡的数量，steptime为在分布式集群中，执行完一个BatchSize的时间（单位为s）。大模型训练的<ahref="https://www.zhihu.com/search?q=吞吐率&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">吞吐率</a>的单位在CV和部分NLP任务重为Samples/s，在固定 Shape 的 NLP任务有seqlen，因此单位为tokens/s，计算公式为： <span class="math display">\[tokens_{throughout}=sample_{throughput}*seq_{len}\]</span> ​ 假设GLM10B<ahref="https://www.zhihu.com/search?q=网络模型&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">网络模型</a>的吞吐为25Samples/s，max seq_len 为1024，那么按照tokens来计算吞吐率为 25 * 1024 =25600 tokens/s。也就是每秒能处理2万多个tokens啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FLOPs&amp;&amp;FLOPS</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/FLOPs&amp;&amp;FLOPS/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/FLOPs&amp;&amp;FLOPS/</url>
      
        <content type="html"><![CDATA[<h1 id="flopsflops">FLOPs&amp;&amp;FLOPS</h1><h2 id="什么是flops">什么是flops</h2><p>对flops有疑惑，首先得先捋清这个概念：</p><ul><li><strong>FLOPS</strong>：注意全大写，是floating point operations per<strong>second</strong>的缩写，意指<strong>每秒浮点运算次数</strong>，理解为<strong>计算速度</strong>。是一个<strong>衡量硬件性能</strong>的指标。</li><li><strong>FLOPs</strong>：注意s小写，是floating pointoperations的缩写（<strong>s表复数</strong>），意指<strong>浮点运算数</strong>，理解为<strong>计算量</strong>。可以用来<strong>衡量算法/模型的复杂度</strong>。</li></ul><p>网上打字很容易全小写，造成混淆，本问题针对模型，应指的是FLOPs。</p><p>我们知道，通常我们去<strong>评价一个模型时，首先看的应该是它的精确度</strong>，当你精确度不行的时候，你和别人说我的模型预测的多么多么的快，部署的时候占的内存多么多么的小，都是白搭。但当你模型达到一定的精确度之后，就需要更<strong>进一步的评价指标来评价你模型</strong>：1）<strong>前向传播时所需的计算力</strong>，它反应了对硬件如GPU性能要求的高低；2）<strong>参数个数</strong>，它反应所占内存大小。为什么要加上这两个指标呢？因为这事关你模型算法的落地。比如你要在手机和汽车上部署深度学习模型，对模型大小和计算力就有严格要求。模型参数想必大家都知道是什么怎么算了，而前向传播时所需的计算力可能还会带有一点点疑问。所以这里总计一下前向传播时所需的计算力。它正是由<strong>FLOPs</strong>体现，那么<strong>FLOPs</strong>该怎么计算呢？</p><span id="more"></span><h2 id="如何计算flops">如何计算flops</h2><p>我们知道，在一个模型进行前向传播的时候，会进行卷积、池化、BatchNorm、Relu、Upsample等操作。这些操作的进行都会有其对应的计算力消耗产生，其中，卷积所对应的计算力消耗是所占比重最高的。所以，我们这里主要讲一下卷积操作所对应的计算力。</p><p>我们以下图为例进行讲解：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421083.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>先说结论：卷积层 计算力消耗 等于上图中两个立方体 (绿色和橙色)体积的乘积。即flops =</p><p><strong>推导过程：</strong>卷积层 wx + b需要计算两部分，首先考虑前半部分 wx 的计算量：</p><p>令 :</p><ul><li>k 表示卷积核大小;</li><li>c 表示输入 feature map 的数量;</li></ul><p>则对于输出 feature map 上的<strong>单个</strong> Unit 有：</p><p><strong><code>k \* k \* c 次乘法，以及 k \* k \* c - 1 次加法</code></strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421090.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>用上图形象化解释就是：</p><p>Image大小为 5x5，卷积核大小为3x3，那么一次3x3的卷积（求右图矩阵一个元素的值）所需运算量：(3x3)个乘法+(3x3-1)个加法= 17。要得到右图convolved feature （3x3的大小）：17x9 = 153</p><p>如果输出 feature map 的分辨率是 H * W ，且输出 o 个 featuremap，则输出 feature map 包含 Unit的总数就是 H * W * o。</p><p>因此，该卷积层在计算 wx 时有:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k * k * c * H * W * o 次乘法          --（1）</span><br><span class="line">(k * k * c - 1) * H * W * o 次加法    --（2）</span><br></pre></td></tr></table></figure><p>再考虑偏置项 b 包含的计算量：</p><p>由于 b 只存在加法运算，输出 feature map 上的每个 Unit做一次偏置项加法。因此，该卷积层在计算偏置项时总共包含：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H * W * o 次加法      --（3）</span><br></pre></td></tr></table></figure><p>将该卷积层的 wx 和 b 两部分的计算次数累计起来就有：</p><p><strong>式(1) 次乘法:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k * k * c * H * W * o 次乘法</span><br></pre></td></tr></table></figure><p><strong>式(2) + 式(3) 次加法:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(k * k * c - 1) * H * W * o  + H * W * o  = k * k * c * H * W * o</span><br></pre></td></tr></table></figure><p><strong>可见，式(2) + 式(3) = 式 (1)</strong></p><p>对于带偏置项的卷积层，乘法运算和加法运算的次数相等，刚好配对。定义一次加法和乘法表示一个flop，该层的计算力消耗为：</p><p><strong><code>k \* k \* c \* H \* W \* o</code></strong></p><p>刚好等于图中两个立方体（绿色和橙色）体积的乘积。全连接层的算法也是一样。</p><h2 id="计算flops的开源库">计算flops的开源库</h2><blockquote><p>作者：留德华叫兽@知乎</p></blockquote><p>示例代码如下，它求出了VGG16的flops和参数量：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421109.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以看到，算上import 和print（）也仅仅6行代码！不仅输出了整个框架的复杂度，还能输出每一层的复杂度以及 该层占整个网络的比重</p><p>最后贴出常见backbone的flops：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421115.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵乘法复杂度分析</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p># 矩阵乘法复杂度分析</p><h2 id="前言">前言</h2><p><strong>矩阵乘法</strong>：<strong>矩阵乘法（英语：matrixmultiplication）</strong>是一种根据两个矩阵得到<strong>第三个矩阵</strong>的<strong>二元运算</strong>（需要2个对象参与，这里指2个矩阵），第三个矩阵即前两者的乘积，称为<strong>矩阵积</strong></p><p><strong>条件：</strong>它只有在第一个矩阵的<strong>列数（column）</strong>和第二个矩阵的<strong>行数（row）</strong>相同时才有意义</p><h2 id="矩阵乘法">矩阵乘法</h2><h3 id="个矩阵相乘">2个矩阵相乘</h3><p>对于矩阵 <span class="math inline">\(A_{a*b}\)</span>、<spanclass="math inline">\(B_{b*c}\)</span>，那么 <spanclass="math inline">\(A*B\)</span> 的复杂度为 <spanclass="math inline">\(O(a*b*c)\)</span>，准确是 <spanclass="math inline">\(2abc\)</span></p><ul><li>加法计算了 <span class="math inline">\(abc\)</span> 次</li><li>乘法计算了 <span class="math inline">\(abc\)</span> 次</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)         <span class="comment">// A矩阵中的n 行</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)     <span class="comment">// B矩阵中的n  列</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; m; k++) <span class="comment">// A矩阵中的m 或者B矩阵中的m ,一样的</span></span><br><span class="line">            C[i][j] = C[i][j] + A[i][k] * B[k][j];</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="个矩阵相乘-1">3个矩阵相乘</h3><p>对于矩阵 <span class="math inline">\(A_{a*b}\)</span>、<spanclass="math inline">\(B_{b*c}\)</span>、<spanclass="math inline">\(C_{c*d}\)</span>，那么 <spanclass="math inline">\(A*B*C\)</span> 的复杂度为 <spanclass="math inline">\(O(abc + acd)\)</span></p><ul><li><span class="math inline">\(A*B\)</span> 的复杂度为 <spanclass="math inline">\(O(a*b*c)\)</span>，得到 <spanclass="math inline">\(a*c\)</span> 的矩阵</li><li><span class="math inline">\((A*B)_{a*c}*C\)</span> 的复杂度为 <spanclass="math inline">\(O(abc + acd)\)</span></li></ul><h3 id="推广">推广</h3><p>对于矩阵 <spanclass="math inline">\({A_1}_{_{a_1*a_2}}\)</span>、<spanclass="math inline">\({A_2}_{_{a_2*a_3}}\)</span>、… 、<spanclass="math inline">\({A_n}_{_{a_n*a_{n+1}}}\)</span>，那么 <spanclass="math inline">\(A*B*C\)</span> 的复杂度为 $a_1*(a_2a_3+a_3a_4++a_na_{n+1} ) $</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模拟】</title>
      <link href="/2024/03/31/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%A8%A1%E6%8B%9F%E3%80%91/"/>
      <url>/2024/03/31/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%A8%A1%E6%8B%9F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="模拟">模拟</h1><h2 id="字符串模拟">字符串模拟</h2><ul><li><a href="https://www.acwing.com/solution/content/251846/">AcWing3528. 字符串匹配 - AcWing</a></li></ul><h2 id="简单">简单</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8472379/">AcWing1324. 五子棋 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8779050/">AcWing3283. 回收站选址 - AcWing</a></p></li></ul><h2 id="中等">中等</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8774356/">AcWing4510. 寻宝！大冒险！ - AcWing</a></li></ul><h2 id="困难">困难</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8774021/">AcWing4008. 脉冲神经网络 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8775036/">AcWing3413. DHCP服务器 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8776873/">AcWing3294. 点亮数字人生 - AcWing</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssize_t&amp;&amp;size_t</title>
      <link href="/2024/03/30/%5Bobject%20Object%5D/C++/ssize_t&amp;&amp;size_t/"/>
      <url>/2024/03/30/%5Bobject%20Object%5D/C++/ssize_t&amp;&amp;size_t/</url>
      
        <content type="html"><![CDATA[<h1 id="ssize_tsize_t">ssize_t&amp;&amp;size_t</h1><h2 id="size_t">size_t</h2><p>​ <strong><code>size_t</code></strong> 是一些C/C++标准在<code>stddef.h</code> 中定义的，<code>size_t</code> 类型表示 C中任何对象所能达到的最大长度，它是无符号整数。</p><p>​ 它是为了方便系统之间的移植而定义的，不同的系统上，定义<code>size_t</code> 可能不一样。<code>size_t</code> 在 32 位系统上定义为<code>unsigned int</code>，也就是 32 位无符号整型。在64位系统上定义为<code>unsigned long</code> ，也就是 64 位无符号整形。<code>size_t</code>的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。</p><p>​ <code>size_t</code>在数组下标和内存管理函数之类的地方广泛使用。例如，<code>size_t</code>用做 <code>sizeof</code>操作符的返回值类型，同时也是很多函数的参数类型，包括 <code>malloc</code>和 <code>strlen</code>。</p><p>​ 在声明诸如字符数或者数组索引这样的长度变量时用 <code>size_t</code>是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。<code>size_t</code>的声明是实现相关的。它出现在一个或多个标准头文件中，比如<code>stdio.h</code> 和 <code>stblib.h</code>，典型的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZE_T</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><p>​ <code>define</code>指令确保它只被定义一次。实际的长度取决于实现。通常在 32位系统上它的长度是 32 位，而在 64 位系统上则是 64位。一般来说，<code>size_t</code> 可能的最大值是<code>SIZE_MAX</code></p><p>​ 打印 <code>size_t</code>类型的值时要小心。这是无符号值，如果选错格式说明符，可能会得到不可靠的结果。推荐的格式说明符是<code>%zu</code>。不过，某些情况下不能用这个说明符， 作为替代，可以考虑<code>%u</code> 或 <code>%lu</code>。下面这个例子将一个变量定义为<code>size_t</code>，然后用两种不同的格式说明符来打印：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sizet = <span class="number">-5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet);</span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code>本来是用于表示正整数的，如果用来表示负数就会出问题。如果为其赋一个负数，然后用<code>%d</code> 和 <code>%zu</code> 格式说明符打印，就得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-5</span><br><span class="line">4294967291</span><br></pre></td></tr></table></figure><p>​ <code>%d</code> 把 <code>size_t</code> 当做有符号整数，它打印出-5。因为变量中存放的就是 -5。<code>%zu</code> 把 <code>size_t</code>当做无符号整数。当 -5 被解析为有符号数时，高位置为1，表示这个数是负数。当它被解析为无符号数时，高位的 1 被当做 2的乘幂。所以在用 <code>%zu</code> 格式说明符时才会看到那个大整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizet = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code> 是无符号的，一定要给这种类型的变量赋正数。</p><h2 id="ssize_t">ssize_t</h2><p><strong><code>ssize_t</code></strong> 和 <code>size_t</code>类似，但必需是<strong>signed</strong>（表示 <code>signed size_t</code>类型）， 用来表示可以被执行读写操作的数据块的大小。</p><h2 id="size_t-和-int-比较">size_t 和 int 比较</h2><ul><li><code>size_t</code>在32位架构中定义为：<code>typedef  unsigned int size_t</code></li><li><code>size_t</code>在64位架构中被定义为：<code>typedef  unsigned long size_t</code></li><li><code>size_t</code> 是无符号的，并且是平台无关的，表示 0 ~MAXINT的范围；<code>int</code> 为是有符号的；</li><li><code>int</code> 在不同架构上都是4字节，<code>size_t</code>在32位和64位架构上分别是 4 字节和 8字节，在不同架构上进行编译时需要注意这个问题。</li><li><strong><code>ssize_t</code></strong>是<strong>有符号</strong>整型，在32 位机器上等同与 <code>int</code>，在 64 位机器上等同与<code>long int</code>.</li></ul><h2id="c语言编程需要注意的64位和32机器的区别">C语言编程需要注意的64位和32机器的区别</h2><table><thead><tr class="header"><th></th><th>char</th><th>short</th><th>int</th><th>long</th><th>long long</th><th>指针</th></tr></thead><tbody><tr class="odd"><td>16 位 平台</td><td>1Byte</td><td>2Byte</td><td>2Byte</td><td>4Byte</td><td></td><td>2 Byte</td></tr><tr class="even"><td>32 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>4Byte</td><td>8Byte</td><td>4 Byte</td></tr><tr class="odd"><td>64 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>8Byte</td><td>8Byte</td><td>8Byte</td></tr></tbody></table><h2 id="编程注意事项">编程注意事项</h2><p>​ 为了保证平台的通用性，程序中尽量不要使用 <code>long</code>数据库型。可以使用固定大小的数据类型宏定义，这些宏定义需要引用<code>stdint.h</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __extension__</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="intptr_t">intptr_t</h2><p>​ 使用 <code>int</code> 时也可以使用 <code>intptr_t</code>来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台字长，比如64 位机器它的长度就是 8 字节，32位机器它的长度是4字节，使用它可以安全地进行整数与指针的转换运算，也就是说当需要将指针作为整数运算时，将它转换成<code>intptr_t</code> 进行运算才是安全的。<code>intptr_t</code>需要引用<code>stddef.h</code> 头文件，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​ 编程中要尽量使用 <code>sizeof</code>来计算数据类型的大小。以上类型定义都有相应的无符号类型。</p><h2 id="使用ssize_t和size_t">使用ssize_t和size_t</h2><p>​ 它们分别是 <code>unsigned</code> 和 <code>signed</code> size ofcomputer word size。它们也是表示<strong>计算机的字长</strong>，在 32位机器上是 <code>int</code>型，在64位机器上 <code>long</code>型。使用它们对于增加平台的通用性有很大好处，从某种意义上来说它们等同于<code>intptr_t</code> 和 <code>uintptr_t</code>。使用它们也需要引用<code>stddef.h</code> 头文件。</p><p>​ socket 的 <code>accept</code> 函数在有些操作系统上使用<code>size_t</code> 是不正确的，因为 <code>accept</code> 接收的<code>int</code> 类型，而size_t的长度可能会超过 <code>int*</code>的长度限制，导致错误。后来BSD使用 <code>sock_t</code> 来替代它。</p><blockquote><p>参考：</p><ul><li>https://blog.csdn.net/bzhxuexi/article/details/19899803</li><li>https://blog.csdn.net/qq_30866297/article/details/51465473</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string和char[]的相互转换</title>
      <link href="/2024/03/30/%5Bobject%20Object%5D/C++/string%E5%92%8Cchar%5B%5D%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
      <url>/2024/03/30/%5Bobject%20Object%5D/C++/string%E5%92%8Cchar%5B%5D%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="string和char的相互转换">string和char[]的相互转换</h1><h2 id="char转string">char*转string</h2><p><code>char*</code> 类型字符串能够<strong>自动</strong>转换成<code>string</code> 对象，因此 直接赋值即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> pc[] = <span class="string">&quot;a character array&quot;</span>; <span class="comment">//加不加const都行</span></span><br><span class="line">s1 = pc; <span class="comment">// ok </span></span><br></pre></td></tr></table></figure><h2 id="string转char">string转char*</h2><p><code>string</code> 类型必须通过 <code>c_str()</code> 方法转化为<code>char*</code> 类型字符串， 需常量修饰符 const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c_str()返回了一个指向常量数组的指针， 需常量修饰符 const</span></span><br><span class="line"><span class="comment">//str 被定义为常量指针 </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s1.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stringstream</title>
      <link href="/2024/03/30/%5Bobject%20Object%5D/STL/stringstream%E7%B1%BB/"/>
      <url>/2024/03/30/%5Bobject%20Object%5D/STL/stringstream%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p># stringstream类</p><h2 id="概述">概述</h2><p><strong><sstream></strong>定义了三个<strong>类</strong>：<strong>istringstream</strong>、<strong>ostringstream</strong>和<strong>stringstream</strong>，分别用来进行流的输入、输出和输入输出操作。本文以stringstream 为主，介绍流的输入和输出操作。</p><p><sstream> 主要用来进行数据类型转换，由于 <sstream> 使用<strong>string 对象</strong>来代替字符数组（snprintf方式），避免了缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符号的问题。简单说，相比C 编程语言库的数据类型转换，<sstream> 更加安全、自动和直接。</p><span id="more"></span><h2 id="示例代码">示例代码</h2><h3 id="数据类型转换">数据类型转换</h3><p>这里展示一份示例代码，介绍将 int 类型转换为 string 类型的过程。</p><p>示例代码（stringstream_test1.cpp）的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    string strResult;</span><br><span class="line">    <span class="type">int</span> nValue = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将int类型的值放入输入流中</span></span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    <span class="comment">// 从sstream中抽取前面插入的int类型的值，赋给string类型</span></span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[cout]strResult is: &quot;</span> &lt;&lt; strResult &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[printf]strResult is: %s\n&quot;</span>, strResult.<span class="built_in">c_str</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上述代码，结果如下：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351103.png" /></p><h3 id="多个字符串拼接">多个字符串拼接</h3><p>本示例介绍在 stringstream中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 string类实现），同时，介绍 stringstream 类的清空方法。</p><p>示例代码（stringstream_test2.cpp）的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;string,&quot;</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot; second string&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 清空 sstream</span></span><br><span class="line">    sstream.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;third string&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After clear, strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上述代码，结果如下：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351129.png" /></p><p>从上述代码执行结果能够知道：</p><ul><li>可以使用 str() 方法，将 stringstream 类型转换为 string 类型；</li><li>可以将多个字符串放入 stringstream 中，实现字符串的拼接目的；</li><li>如果想清空 stringstream，必须使用 sstream.str(""); 方式；clear()方法适用于进行多次数据类型转换的场景。详见示例 2.3。</li></ul><h3 id="stringstream的清空">stringstream的清空</h3><p>清空 stringstream 有两种方法：clear() 方法以及 str("")方法，这两种方法对应不同的使用场景。str("")方法的使用场景，在上面的示例中已经介绍过了，这里介绍 clear()方法的使用场景。</p><p>示例代码（stringstream_test3.cpp）的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    <span class="type">int</span> first, second;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在进行多次类型转换前，必须先运行clear()</span></span><br><span class="line">    sstream.<span class="built_in">clear</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入bool值</span></span><br><span class="line">    sstream &lt;&lt; <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    cout &lt;&lt; second &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上述代码，结果如下：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351190.png" /></p><p>注意：在本示例涉及的场景下（多次数据类型转换），必须使用 clear()方法清空 stringstream，不使用 clear() 方法或使用 str("")方法，都不能得到数据类型转换的正确结果。下图分别是未使用 clear()方法、使用 str("") 方法代替 clear() 方法时的运行结果：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351119.png" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算几何中的精度问题》</title>
      <link href="/2024/03/29/%5Bobject%20Object%5D/C++/%E3%80%8A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E3%80%8B/"/>
      <url>/2024/03/29/%5Bobject%20Object%5D/C++/%E3%80%8A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何中的精度问题">《计算几何中的精度问题》</h1><p>​计算几何头疼的地方一般在于代码量大和精度问题，代码量问题只要平时注意积累模板一般就不成问题了。精度问题则不好说，有时候一个<ahref="https://www.zhihu.com/search?q=精度问题&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">精度问题</a>就可能成为一道题的瓶颈，简直“画龙点睛”。这些年的题目基本是朝着越来越不卡精度的方向发展了，但是也不乏一些%^&amp;%题#<spanclass="math inline">\(%\)</span>^，另外有些常识不管题目卡不卡，都是应该知道的。今天我就开膛回顾下见过且还有印象的精度问题。</p><p>​ 计算几何的精度问题说到底其实是<ahref="https://www.zhihu.com/search?q=浮点数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">浮点数</a>的精度问题，但我觉得“<ahref="https://www.zhihu.com/search?q=计算几何&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">计算几何</a>”比“浮点数”更能吸引眼球，所以选了这个标题。</p><h2 id="浮点数为啥会有精度问题">浮点数为啥会有精度问题？</h2><p>​浮点数(以C/C++为准)，一般用的较多的是<code>float</code>、<code>double</code></p><table><colgroup><col style="width: 8%" /><col style="width: 8%" /><col style="width: 19%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th></th><th>占字节数</th><th>数值范围</th><th><ahref="https://www.zhihu.com/search?q=十进制精度位数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">十进制精度位数</a></th></tr></thead><tbody><tr class="odd"><td><code>float</code></td><td>4</td><td>-3.4e-38～3.4e38</td><td>6~7</td></tr><tr class="even"><td><code>double</code></td><td>8</td><td>-1.7e-308～1.7e308</td><td>14~15</td></tr></tbody></table><p>​如果内存不是很紧张或者精度要求不是很低，一般选用<code>double</code>。14位的精度(是有效数字位，不是小数点后的位数)通常够用了。注意，问题来了，数据精度位数达到了14位，但有些<ahref="https://www.zhihu.com/search?q=浮点运算&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">浮点运算</a>的结果精度并达不到这么高，可能准确的结果只有10~12位左右。那低几位呢？自然就是不可预料的数字了。这给我们带来这样的问题：即使是理论上相同的值，由于是经过不同的运算过程得到的，他们在低几位有可能(一般来说都是)是不同的。这种现象看似没太大的影响，却会一种运算产生致命的影响：==。恩，就是判断相等。注意，C/C++中浮点数的==需要完全一样才能返回true。来看下面这个例子：</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="number">2.0</span>) / <span class="number">2</span>) * <span class="number">4.0</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; a = %.20lf\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; b = %.20lf\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; a - b = %.20lf\n&quot;</span>, a - b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a == b = %d\n&quot;</span>, a == b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a = 3.14159265358979360000</span><br><span class="line"> b = 3.14159265358979310000</span><br><span class="line"> a - b = 0.00000000000000044409</span><br><span class="line">a == b = 0</span><br></pre></td></tr></table></figure><p>​ 我们解决的办法是引进<code>eps</code>，来辅助判断浮点数的相等。</p><!--more--><h2 id="eps">eps</h2><p>​ <span class="math inline">\(eps\)</span> 缩写自 <spanclass="math inline">\(epsilon\)</span>，表示一个小量，但这个小量又要确保远大于浮点运算结果的不确定量。<spanclass="math inline">\(eps\)</span>最常见的取值是<code>1e-8</code>左右。引入 <spanclass="math inline">\(eps\)</span> 后，我们判断两浮点数 <spanclass="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>相等的方式如下:</p><p>​ 定义<ahref="https://www.zhihu.com/search?q=三出口函数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">三出口函数</a>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sgn</span><span class="params">(<span class="type">double</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; -eps ? <span class="number">-1</span> : a &lt; eps ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 则各种判断大小的运算都应做如下修正：</p><table><thead><tr class="header"><th>传统意义</th><th>修正写法1</th><th>修正写法2</th></tr></thead><tbody><tr class="odd"><td><code>a == b</code></td><td><code>sgn(a - b) == 0</code></td><td><code>fabs(a – b) &lt; eps</code></td></tr><tr class="even"><td><code>a != b</code></td><td><code>sgn(a - b) != 0</code></td><td><code>fabs(a – b) &gt; eps</code></td></tr><tr class="odd"><td><code>a &lt; b</code></td><td><code>sgn(a - b) &lt; 0</code></td><td><code>a – b &lt; -eps</code></td></tr><tr class="even"><td><code>a &lt;= b</code></td><td><code>sgn(a - b) &lt;= 0</code></td><td><code>a – b &lt; eps</code></td></tr><tr class="odd"><td><code>a &gt; b</code></td><td><code>sgn(a - b) &gt; 0</code></td><td><code>a – b &gt; eps</code></td></tr><tr class="even"><td><code>a &gt;= b</code></td><td><code>sgn(a - b) &gt;= 0</code></td><td><code>a – b &gt; -eps</code></td></tr></tbody></table><p>​这样，我们才能把相差非常近的浮点数判为相等；同时把确实相差较大(差值大于<span class="math inline">\(eps\)</span> )的数判为不相等。</p><p>PS: 养成好习惯，尽量不要再对浮点数做==判断。例如，我的修正写法<spanclass="math inline">\(2\)</span>里就没有出现==。</p><h2 id="eps带来的函数越界">eps带来的函数越界</h2><p>​ 如果<code>sqrt(a)</code>、<code>asin(a)</code>、<code>acos(a)</code>中的a是你自己算出来并传进来的，那就得小心了。</p><p>​ 如果 <span class="math inline">\(a\)</span> 本来应该是 <spanclass="math inline">\(0\)</span>的，由于浮点误差，可能实际是一个绝对值很小的负数（比如<code>1e-12</code>），这样<code>sqrt(a)</code> 应得 <span class="math inline">\(0\)</span>的，直接因 <span class="math inline">\(a\)</span> 不在定义域而出错。</p><p>​ 类似地，如果 <span class="math inline">\(a\)</span> 本来应该是±1，则<code>asin(a)</code>、<code>acos(a)</code> 也有可能出错。</p><p>​ 因此，对于此种函数，必需事先对 <spanclass="math inline">\(a\)</span> 进行校正。</p><h2 id="输出陷阱i">输出陷阱I</h2><p>​这一节和下一节一样，都是因为题目要求输出浮点数，导致的问题。而且都和四舍五入有关。</p><p>​ 说到四舍五入，就再扯一下相关内容,据我所知有三种常见的方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“% <span class="number">.3</span>lf”, a); <span class="comment">// 保留a的三位小数，按照第四位四舍五入</span></span><br><span class="line">(<span class="type">int</span>)a;              <span class="comment">// 将a靠进0取整</span></span><br><span class="line"><span class="built_in">ceil</span>(a);<span class="built_in">floor</span>(a);    <span class="comment">// 顾名思义，向上取证、向下取整。需要注意的是，这两个函数都返回double，而非int</span></span><br></pre></td></tr></table></figure><p>​ 其中第一种很常见于输出(nonsense…)。</p><p>​现在考虑一种情况,题目要求输出保留两位小数。有个case的正确答案的精确值是<span class="math inline">\(0.005\)</span> ,按理应该输出 <spanclass="math inline">\(0.01\)</span>，但你的结果可能是 <spanclass="math inline">\(0.005000000001\)</span>(恭喜)，也有可能是 <spanclass="math inline">\(0.004999999999\)</span>(悲剧),如果按照<code>printf(“%.2lf”, a);</code>输出，那你的遭遇将和括号里的字相同。</p><p>​ 解决办法是，如果 <span class="math inline">\(a\)</span> 为正，则输出<code>a+eps</code>，否则输出<ahref="https://www.zhihu.com/search?q=a-eps&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">a-eps</a></p><blockquote><p>典型案例：<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/POJ-2826">POJ-2826</a></p></blockquote><h2 id="输出陷阱ii">输出陷阱II</h2><p>​ ICPC题目输出有个不成文的规定(有时也成文)，不要输出: <spanclass="math inline">\(-0.000\)</span></p><p>那我们首先要弄清，什么时候按 <code>printf(“%.3lf\n”, a);</code>输出会出现这个结果。</p><p>​ 直接给出结果好了：<span class="math inline">\(a∈(-0.000499999……,-0.000……1)\)</span></p><p>​ 所以，如果你发现a落在这个范围内，请直接输出0.000。更保险的做法是用<ahref="https://www.zhihu.com/search?q=sprintf&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">sprintf</a>直接判断输出结果是不是-0.000再予处理。</p><blockquote><p>典型案例：<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/UVA-746">UVA-746</a></p></blockquote><p><strong>6. 范围越界</strong></p><p>​ 这个严格来说不属于精度范畴了，不过凑数还是可以的。请注意，虽然<code>double</code>可以表示的数的范围很大，却不是不穷大，上面说过最大是<code>1e308</code>。所以有些时候你得小心了，比如做连乘的时候，必要的时候要换成对数的和。</p><blockquote><p>典型案例:<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/HDU-3558">HDU-3558</a></p></blockquote><h2 id="关于sett">关于<code>set&lt;T&gt;</code></h2><p>​ 有时候我们可能会有这种需求，对浮点数进行 插入、查询是否插入过的操作。手写 <span class="math inline">\(hash\)</span> 表是一个方法（<ahref="https://www.zhihu.com/search?q=hash函数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">hash函数</a>一样要小心设计），但<code>set</code> 不是更方便吗。但 <code>set</code>好像是按==来判重的呀？貌似行不通呢。经观察，set不是通过==来判断相等的，是通过<span class="math inline">\(&lt;\)</span> 来进行的，具体说来，只要<spanclass="math inline">\(a&lt;b\)</span> 和 <spanclass="math inline">\(b&lt;a\)</span> 都不成立，就认为 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 相等，可以发现，</p><p>​如果将小于定义成：<code>bool operator &lt; (const Dat dat)const&#123;return val &lt; dat.val - eps;&#125;</code>就可以解决问题了。 (基本类型不能重载运算符，所以封装了下)</p><h2 id="输入值波动过大">输入值波动过大</h2><p>​ 这种情况不常见，不过可以帮助你更熟悉 <spanclass="math inline">\(eps\)</span>。假如一道题输入说，给一个浮点数 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(1e-20 &lt;a &lt; 1e20\)</span>。那你还敢用 <spanclass="math inline">\(1e-8\)</span> 做 <spanclass="math inline">\(eps\)</span> 么？合理的做法是把 <spanclass="math inline">\(eps\)</span> 按照输入规模缩放到合适大小。</p><blockquote><p>典型案例：<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/HUST-1361">HUST-1361</a></p></blockquote><h2 id="一些建议">一些建议</h2><p>​ 容易产生较大浮点误差的函数有<code>asin</code>、<code>acos</code>。欢迎尽量使用<code>atan2</code></p><p>​ 另外，如果数据明确说明是整数，而且范围不大的话，使用<code>int</code> 或者 <code>long long</code> 代替 <code>double</code>都是极佳选择，因为就不存在浮点误差了(尽管我几乎从来都只用<code>double</code> !)</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】</title>
      <link href="/2024/03/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/"/>
      <url>/2024/03/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><h2 id="概念了解">概念【了解】</h2><ol type="1"><li><p><strong>动态规划：</strong>将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解</p><ul><li>动态规划会将每个求解过的子问题的解记录下来，这样下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算</li><li>采用<strong>递归</strong>（又叫<strong>记忆化搜索</strong>）实现</li></ul></li><li><p><strong>重叠子问题：</strong>如果<strong>一个问题可以被分解成若干个子问题</strong>，且这些子问题会重复出现，就称这个问题拥有重叠子问题。一个问题必须拥有重叠子问题，才能用动态规划去解决。</p></li><li><p><strong>最优子结构：</strong>如果<strong>一个问题的最优解可以由其子问题的最优解有效地构造出来</strong>，那么称为这个问题拥有的最优子结构。最优子结构保证了动态规划中的原问题的最优解可以由子问题的最优解推导而来</p></li><li><p><strong>动态规划</strong> vs<strong>分治：</strong>都是分解为子问题然后合并子问题得到解，但是：</p><ul><li>动态规划分解出的子问题是重叠的</li><li>分治分解出的子问题是不重叠的</li></ul></li><li><p><strong>动态规划 vs 贪心：</strong>都有最优子结构，但是：</p><ul><li>贪心直接选择一个子问题去求解，会抛弃一些子问题，这种选择的正确性需要用归纳法证明</li><li>而动态规划会考虑所有的子问题，所以这种选择一定是正确的</li></ul></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png"alt="Snipaste_2019-09-13_17-06-58.png" /><figcaptionaria-hidden="true">Snipaste_2019-09-13_17-06-58.png</figcaption></figure><h2 id="闫式dp分析法">闫式DP分析法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403231407219.jpeg"alt="闫式dp.jpg" /><figcaption aria-hidden="true">闫式dp.jpg</figcaption></figure><ol type="1"><li><strong>状态函数</strong>定义</li></ol><ul><li><strong>第一维</strong>通常用于集合划分</li><li>明确题目<strong>约束条件</strong>：每个<strong>约束条件</strong>对于状态函数中剩下的<strong>每维</strong></li></ul><ol start="2" type="1"><li><strong>集合划分</strong>原则</li></ol><ul><li><p>不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】</p></li><li><p>如何将现有的集合划分为更小的子集，使得<strong>所有子集</strong>都可以计算出来</p></li></ul><ol start="3" type="1"><li>所有数组的<strong>下标</strong>从 <spanclass="math inline">\(0\)</span> 开始递归还是下标从 <spanclass="math inline">\(1\)</span> 开始递归？</li></ol><ul><li>如果涉及到 <code>f[i-1]</code>，建议下标从 1开始递归，<code>f[0]</code>存储初始值</li><li>否则下标从 0 开始递归</li></ul><ol start="4" type="1"><li>考虑状态函数<strong>初始化</strong></li></ol><ul><li><p>只需要对<strong>递归入口/起点</strong>进行初始化，之后的会通过迭代进行更新，不需要初始化</p><blockquote><p>递归入口要从状态转移方程考虑，通常是 <code>f[][]</code> 各个维度的<span class="math inline">\(0\)</span> 下标</p></blockquote><ul><li>若状态函数的递归入口/起点<strong>有意义</strong>，则初始化为实际含义的状态属性值</li><li>若状态函数的递归入口/起点<strong>无意义</strong>，则初始化为<code>INF</code>（求最小值）、<code>-INF</code>（求最大值）</li></ul></li><li><p>迭代从递归入口/起点的下一个位置开始</p></li></ul><ol start="5" type="1"><li>考虑<strong>状态计算顺序</strong>——必须按照<font color='red'><strong>拓扑序</strong></font>计算所有状态</li></ol><blockquote><p>因为按照<strong>拓扑序</strong>进行递推的话，能够保证在计算 <spanclass="math inline">\(f(i)\)</span> 的时候其依赖的所有状态 <spanclass="math inline">\(f(j)\)</span> 都已经计算过了</p></blockquote><span id="more"></span><h2 id="背包问题">背包问题</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404191746465.png"alt="image-20240419174617174" /><figcaption aria-hidden="true">image-20240419174617174</figcaption></figure><ul><li>0/1 背包：每种物品只有 1 个</li><li>完全背包：每种物品有无限个</li><li>多重背包：每种物品有 <span class="math inline">\(S_i\)</span>个</li><li>分组背包：有 N组物品，每组物品有若干个，同一组内的物品最多只能选一个</li><li>混合背包：第一类物品只能用1次（01背包），第二类物品可以用无限次（完全背包），第三类物品最多只能用<span class="math inline">\(s_i\)</span> 次（多重背包）</li></ul><p>标记(<span class="math inline">\(Notations\)</span>)</p><ul><li>N：物品种数</li><li>V：背包容量</li><li>S：物品数量</li></ul><p>:smile:<strong><ahref="https://www.acwing.com/blog/content/46542/">背包问题中体积至多/恰好/至少是 j 的初始化问题的研究 - AcWing</a></strong></p><!--more--><h3 id="背包">0/1 背包</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404182045086.png"alt="image-20240418204511783" /><figcaption aria-hidden="true">image-20240418204511783</figcaption></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8133547/">AcWing2. 01背包问题 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&amp;envId=top-100-liked">279.完全平方数 - 力扣（LeetCode）</a></p></li><li><p><a href="https://www.acwing.com/solution/content/241925/">AcWing1047. 糖果 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8420088/">AcWing423. 采药 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8420167/">AcWing1024. 装箱问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8426205/">AcWing278. 数字组合 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8440400/">AcWing426. 开心的金明 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8802847/">AcWing734. 能量石 - AcWing</a></p></li></ul><h3 id="完全背包问题">完全背包问题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8134352/">AcWing3. 完全背包问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8229758/">AcWing4700. 何以包邮？ - AcWing</a></li><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11788635/">AcWing1371. 货币系统（每日一题） - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/242408/">LeetCode322. 零钱兑换 - AcWing</a></li></ul><h3 id="多重背包">多重背包</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8140913/">AcWing4. 多重背包问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8430914/">AcWing1019. 庆功会 - AcWing</a></p></li></ul><h3 id="分组背包">分组背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8144220/">AcWing9. 分组背包问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8436618/">AcWing1013. 机器分配 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8440415/">AcWing487. 金明的预算方案 - AcWing</a></li></ul><h3 id="混合背包">混合背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8442455/">AcWing7. 混合背包问题 - AcWing</a></li></ul><h3 id="二维费用背包">二维费用背包</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8426248/">AcWing8. 二维费用的背包问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8420612/">AcWing1022. 宠物小精灵之收服 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8429100/">AcWing1020. 潜水员 - AcWing</a></p></li></ul><h3 id="背包问题求具体方案">背包问题求具体方案</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8436139/">AcWing12. 背包问题求具体方案 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8436618/">AcWing1013. 机器分配 - AcWing</a></li></ul><h3 id="背包问题求方案数">背包问题求方案数</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8426205/">AcWing278. 数字组合 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8430848/">AcWing1023. 买书 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8430971/">AcWing1021. 货币系统 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8442259/">AcWing532. 货币系统 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8449881/">AcWing11. 背包问题求方案数 - AcWing</a></li></ul><h2 id="状态机dp">状态机DP</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8190672/">AcWing285. 没有上司的舞会 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8449405/">AcWing1049. 大盗阿福 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8770276/">LeetCode213. 大盗阿福 II - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/250074/">AcWing1055. 股票买卖 II - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8532860/">AcWing1057. 股票买卖 IV - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8534682/">AcWing1058. 股票买卖 V - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/250097/">AcWing1059. 股票买卖 VI - AcWing</a></p></li></ul><h2 id="线性dp">线性DP</h2><p>线性DP指的是<strong>状态转移方程</strong>存在某种线性关系</p><h3 id="数字三角形">数字三角形</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404172005650.png"alt="image-20240417200506233" /><figcaption aria-hidden="true">image-20240417200506233</figcaption></figure><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8147866/">AcWing898. 数字三角形 - AcWing</a>、<ahref="https://leetcode.cn/problems/pascals-triangle/description/">118.杨辉三角 - 力扣（LeetCode）</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8411489/">AcWing1015. 摘花生 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8411972/">AcWing1018. 最低通行费 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8413140/">AcWing1027. 方格取数 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8413877/">AcWing275. 传纸条 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/252681/">AcWing T2.方格取物 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/244823/">AcWing1612. 最大正方形 - AcWing</a></li></ul><blockquote><p>对比<ahref="https://www.acwing.com/activity/content/code/content/8377166/">AcWing1413. 矩形牛棚（每日一题） - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8528586/">LeetCode85. 最大矩形 - AcWing</a></p></blockquote><h3 id="最长上升子序列">最长上升子序列★</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8155307/">AcWing895. 最长上升子序列 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/249446/">AcWing1025. 开餐馆 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8741637/">LeetCode139. 单词拆分 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8742773/">LeetCode132. 分割回文串 II - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8414494/">AcWing1017. 怪盗基德的滑翔翼 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8414507/">AcWing1014. 登山 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8415070/">AcWing482. 合唱队形 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8415527/">AcWing1012. 友好城市 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8415508/">AcWing1016. 最大上升子序列和 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8421970/">AcWing1010. 拦截导弹 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8423647/">AcWing187. 导弹防御系统 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8423515/">AcWing272. 最长公共上升子序列 - AcWing</a></li></ul><h3 id="最长公共子序列lcs">最长公共子序列（LCS）</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8155566/">AcWing897. 最长公共子序列 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8161653/">AcWing902. 最短编辑距离 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8178931/">AcWing899. 编辑距离 - AcWing</a></li></ul><blockquote><p><strong>最长公共字串</strong>问题——参考KMP</p></blockquote><h3 id="乘积最大子数组">乘积最大子数组</h3><ul><li><ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">152.乘积最大子数组 - 力扣（LeetCode）</a></li></ul><h3 id="其他">其他</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8372861/">AcWing312. 乌龟棋（每日一题） - AcWing</a></li></ul><h2 id="区间dp">★区间DP</h2><h3 id="递推若干循环">递推（若干循环）</h3><ul><li><p>区间 DP的状态<code>f[i][j]</code>是一个<strong>区间</strong></p></li><li><p>区间 DP要注意<strong>循环的先后顺序</strong>，否则可能会出现当前要计算的状态值并未在先前循环计算过，通常按照以下顺序进行循环</p><ol type="1"><li><strong>从小到大</strong>枚举<strong>区间长度</strong><ol type="1"><li>一般 <span class="math inline">\(len = 1\)</span> 时用来初始化</li><li>枚举从 <span class="math inline">\(len = 2\)</span> 开始</li></ol></li><li>枚举<strong>区间左端点</strong></li><li>枚举决策</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++) <span class="comment">// 循环区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l ++) <span class="comment">// 循环区间左端点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = l + len - <span class="number">1</span>; <span class="comment">// 计算区间右终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            f[l][r] = 初始值;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[l][r] = INF;<span class="comment">// 假设求最小值，初始化为正无穷</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 枚举左右区间分割点，构造状态转移方程</span></span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][i] + f[i + <span class="number">1</span>][r] + w[l][r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归记忆化搜索">递归（记忆化搜索）</h3><p>​ 区间 DP不仅可以用<strong>递推（若干循环）</strong>实现，也可以使用<strong>递归（记忆化搜索实现）</strong>，两者的时间复杂度相同，因此当区间DP的循环层数过多，不太好写时，我们也可以采用<strong>记忆化搜索</strong>的方式实现（例如<ahref="https://www.acwing.com/activity/content/code/content/8490430/">AcWing321. 棋盘分割 - AcWing</a>）</p><blockquote><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/9384367/">区间DP（记忆化搜索实现）- AcWing</a></p></blockquote><h3 id="例题"><a id='qujian'>例题</a></h3><p>:apple:<strong>​任意选择一个位置断开，复制形成 2倍长度的链</strong>，是解决环形 <span class="math inline">\(DP\)</span>的常用方式，详细请参考《算法竞赛进阶指南》0X55节</p><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8157696/">AcWing282. 石子合并 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8473764/">AcWing1068. 环形石子合并 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8477351/">AcWing320. 能量项链 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8485339/">AcWing479. 加分二叉树 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8482430/">AcWing1069. 凸多边形的划分 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8490430/">AcWing321. 棋盘分割 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/251935/">洛谷P4302、UVA1630. 字符串折叠 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8813370/">LeetCode312. 戳气球 - AcWing</a></p></li></ul><h2 id="计数dp">计数DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8179224/">AcWing900. 整数划分 - AcWing</a></li></ul><h2 id="树形dp">树形DP</h2><p>​ 给定一棵有 <span class="math inline">\(N\)</span>个节点的树（通常是无根树，也就是有 <spanclass="math inline">\(N-1\)</span>条无向边)，我们可以任选一个节点为根节点</p><p>​在树上设计动态规划算法时，一般就以<strong>节点从深到浅（子树从小到大）的顺序作为<span class="math inline">\(DP\)</span> 的“阶段”</strong>。<spanclass="math inline">\(DP\)</span>的状态表示中，<strong>第一维通常是节点编号</strong>（代表以该节点为根的子树）</p><p>​ 大多数时候，我们采用递归的方式实现树形动态规划。对于每个节点 <spanclass="math inline">\(x\)</span>，先<strong>递归在它的每个子节点</strong>上进行<spanclass="math inline">\(DP\)</span>，在<strong>回溯时，从子节点向节点<span class="math inline">\(x\)</span> 进行状态转移</strong></p><p>​正如深度优先和广度优先都可以对树/图进行遍历一样，除了<strong>自顶向下的递归</strong>外我们也可以用<strong>自底向上的拓扑排序</strong>来执行树形<span class="math inline">\(DP\)</span>（例如<ahref="https://www.acwing.com/activity/content/code/content/8495437/">AcWing1073. 树的中心 - AcWing</a>），通常前者已经足够</p><p>​ 对树进行 <span class="math inline">\(dfs\)</span> 递归的时间复杂度为<span class="math inline">\(O(n)\)</span></p><h3 id="树的直径">树的直径</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8493787/">AcWing1072. 树的最长路径 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8495437/">AcWing1073. 树的中心 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8496991/">AcWing1075. 数字转换 - AcWing</a></p></li></ul><h3 id="有依赖的背包问题">有依赖的背包问题</h3><p><strong>树型DP+背包问题</strong></p><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8442105/">AcWing10. 有依赖的背包问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8497892/">AcWing1074. 二叉苹果树 - AcWing</a></p></li></ul><h3 id="最大独立集问题">最大独立集问题</h3><p><strong>树型DP+状态机</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405111945707.jpg"alt="8ad78c9d283a2c53a97af032ac3c751" /><figcaptionaria-hidden="true">8ad78c9d283a2c53a97af032ac3c751</figcaption></figure><h4 id="以边为观察对象">以边为观察对象</h4><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8190672/">AcWing285. 没有上司的舞会 - AcWing</a>：每条边上最多选择一个点，最大权值</li><li><ahref="https://www.acwing.com/activity/content/code/content/8500326/">AcWing323. 战略游戏 - AcWing</a>：每条边上最少选择一个点，最小权值</li></ul><h4 id="以点为观察对象">以点为观察对象</h4><p>对于每个点，要么它被选择，要么至少有一个与它相连的节点被选择</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8500470/">AcWing1077. 皇宫看守 - AcWing</a></li></ul><h3 id="其他-1">其他</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8386701/">AcWing3465. 病毒溯源（每日一题） - AcWing</a></li></ul><h2 id="数位统计dp">数位统计DP</h2><p>​ 数位统计 <span class="math inline">\(DP\)</span>是与数字相关的一类计数问题。在这类题目中，一般给定一些限制条件，求满足限制条件的第<span class="math inline">\(K\)</span> 小的数是多少，或者求在区间 <spanclass="math inline">\([L,R]\)</span>内有多少个满足限制条件的数。解决方法通常是先用<strong>动态规划</strong>进行<strong>预处理</strong>，再基于<strong>拼凑</strong>思想，用“<strong>试填法</strong>”求出最终的答案</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8232865/">AcWing338. 计数问题 - AcWing</a></li></ul><h2 id="状态压缩dp"><a id="zhuangt">状态压缩DP</a></h2><blockquote><p>参考参考<ahref="D:\downloads\hexo\blog\source_posts\算法【基本算法】.md#erjinzhi">二进制状态压缩</a></p></blockquote><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8182668/">AcWing291. 蒙德里安的梦想 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8228208/">AcWing91. 最短Hamilton路径 - AcWing</a>、<ahref="https://www.acwing.com/solution/content/251877/">AcWing 5729.闯关游戏 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8458005/">AcWing1064. 小国王 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8458721/">AcWing327. 玉米田 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8461679/">AcWing292. 炮兵阵地 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/251232/">AcWing4009. 收集卡牌 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8731738/">AcWing1131. 拯救大兵瑞恩 - AcWing</a></li></ul><h2 id="最短路dp">最短路DP</h2><blockquote><p>参考：<ahref="D:\downloads\hexo\blog\source_posts\算法【图论】.md#tuopuDP">拓扑DP与最短路</a></p></blockquote><h2 id="单调队列优化dp"><a id="DP">单调队列优化DP</a></h2><ul><li>单调队列优化DP，在递推计算 <code>f[1]</code> 时需要用到<code>f[0]</code> ，因此需要初始化 <code>f[0]</code> 并将下标<code>0</code> 压入单调队列中.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>, q[++ tt] = <span class="number">0</span>;<span class="comment">// 初始化 f[0]</span></span><br></pre></td></tr></table></figure><ul><li>每个元素<strong>最多只会进队出队 <spanclass="math inline">\(1\)</span>次</strong>，因此队列的最大长度为元素的最大个数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;<span class="comment">// 元素个数</span></span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<ahref="D:\downloads\hexo\blog\source_posts\算法【数据结构】.md#dandiaoduilie">【数据结构】单调队列</a></p></blockquote><h3 id="最大子列和">最大子列和</h3><ul><li><p><strong>子序列长度 <span class="math inline">\(&lt;=m\)</span></strong>——单调队列优化DP</p><p><ahref="https://www.acwing.com/activity/content/code/content/8505289/">AcWing135. 最大子序和 - AcWing</a></p></li><li><p><strong>子序列长度任意</strong>——线性DP</p><ul><li><p>【类型1】给定 <span class="math inline">\(N\)</span>个整数的序列${ A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ _{k=i}^j{A_k} } $的最大值</p><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11950323/">LeetCode53. 最大子序和 - AcWing</a></p></li><li><p>【类型2】给定 <span class="math inline">\(N\)</span>个整数的序列${ A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ 0,_{k=i}^j{A_k} } $的最大值</p><p><a href="https://www.acwing.com/solution/content/244181/">AcWing1479. 最大子序列和 - AcWing</a></p></li></ul></li></ul><h3 id="其他-2">其他</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8523106/">AcWing1087. 修剪草坪 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8523468/">AcWing1089. 烽火传递 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8523997/">AcWing1090. 绿色通道 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8525131/">AcWing1091. 理想的正方形 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8526962/">AcWing1088. 旅行问题 - AcWing</a></p></li></ul><h2 id="斜率优化dp">斜率优化DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8768786/">AcWing300. 任务安排1 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/250178/">AcWing4178. 数列分段 II - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/251068/">AcWing1326. 军训队列 - AcWing</a></li></ul><h1 id="技巧">技巧</h1><h2 id="空间优化">空间优化</h2><p>​ 动态规划的状态函数 <code>f</code>如果<strong>维度过高</strong>，可能会导致变量 <code>f</code> <spanclass="math inline">\(MLE\)</span>，这时我们可以采用以下 <spanclass="math inline">\(2\)</span> 种方法优化空间</p><h3 id="状态省略">状态省略</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8133547/">AcWing2. 01背包问题 - AcWing</a>的状态转移方程 <spanclass="math inline">\(f]i,j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i])\)</span>为例，我们发现：</p><ul><li><code>f[i]</code> 仅用到了 <code>f[i - 1]</code></li><li><code>j</code> 与 <code>j - v[i]</code> 均小于<code>j</code></li></ul><p>因此我们可以将<strong>第一维</strong>省略</p><p>:taco: <strong>注意：</strong></p><ol type="1"><li>状态压缩通常只能用于类似背包问题的<strong>线性</strong>状态转移方程，需要严格满足</li></ol><ul><li><code>f[i]</code> 仅与 <code>f[i - 1]</code>、<code>f[i]</code> 或<code>f[i + 1]</code>、<code>f[i]</code> 有关</li><li>其余维度必须是<strong>线性表达式</strong>，且<strong><font color='red'>均</font>严格大于/小于</strong>之前维度数值</li></ul><ol start="2" type="1"><li>状态压缩后循环时<ol type="1"><li><font color='red'><strong>最外层</strong></font>循环一定是<font color='blue'><strong>被省略的维度</strong></font><ol type="1"><li>若 <code>f[i]</code> 仅与 <code>f[i - 1]</code>、<code>f[i]</code>有关，则<font color='red'><strong>从小到大</strong></font>枚举</li><li>若 <code>f[i]</code> 仅与 <code>f[i + 1]</code>、<code>f[i]</code>有关，则<font color='red'><strong>从大到小</strong></font>枚举</li></ol></li><li>其余维度的循环顺序：依次考虑<strong>省略维度</strong>与<strong>该维度之后所有维度</strong>之间的关系<ol type="1"><li>若该维度用到了省略维度上一层的状态时，<strong>其余维度<font color='green'>从大到小</font></strong>枚举</li><li>反之，<strong>其余维度<font color='purple'>从小到大</font></strong>枚举</li></ol></li></ol></li></ol><blockquote><p>请参考<ahref="https://www.acwing.com/solution/content/252681/">AcWing T2.方格取物 - AcWing</a></p></blockquote><h3 id="滚动数组推荐">滚动数组（推荐）</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8461679/">AcWing292. 炮兵阵地 - AcWing</a>为例</p><ul><li>滚动数组的思想很简单，通常情况下 <code>f[i]</code> 只与<code>f[i - 1]</code>、<code>f[i - 2]</code>、……、<code>f[i - k + 1]</code>有关，因此我们定义 <code>f</code> 时，可以将其第一维指定为 <spanclass="math inline">\(k\)</span> 维，从而减小空间复杂度</li><li>函数编写时按照原来的定义写，只需要将 <code>f[i]</code> 换成<code>f[i % k]</code> 即可，其余部分不需要做任何改变</li></ul><p>:taco:相较于状态压缩，滚动数组的适用条件宽松很多，也<strong>适用于更多类型的状态转移方程</strong>，<strong>只需满足1 个条件</strong>：</p><ul><li><code>f[i]</code> 只与<code>f[i - 1]</code>、<code>f[i - 2]</code>、……、<code>f[i - k + 1]</code>有关</li></ul><h2 id="循环次数加1">循环次数加1</h2><p>以<ahref="https://www.acwing.com/activity/content/code/content/8458005/">AcWing1064. 小国王 - AcWing</a>为例</p><ul><li>最终答案是 <code>f[n][m][所有合法状态]</code>中的最大值，因此我们需要枚举所有合法状态，计算最大值</li><li>:smile:这里我们可以在计算时循环到到<code>n + 1</code>，这样我们最终的答案就是<code>f[n + 1][m][0]</code>，这样我们就不需要最后枚举所有合法状态了，这也是为什么状态函数<code>f</code> 定义时，第一维度要多 <spanclass="math inline">\(1\)</span> 的原因（ <code>N = 12</code>）的原因</li></ul><h2 id="破环成链">破环成链</h2><p>​ 对于环形 <spanclass="math inline">\(DP\)</span>，最常见的解决办法就是<strong>破环成链</strong>：任选一个位置断开，<strong>复制形成2 倍长度的链</strong>，从而将环形 <spanclass="math inline">\(DP\)</span> 转化为<strong>线性 <spanclass="math inline">\(DP\)</span></strong></p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8526962/">AcWing1088. 旅行问题 - AcWing</a></li><li><a href="#qujian">区间DP例题</a></li></ul><h2 id="状态表示出现负数">状态表示出现负数</h2><p>以<ahref="https://www.acwing.com/activity/content/code/content/8753656/">LeetCode494. 目标和 - AcWing</a>为例：</p><p>本题的难点在于状态函数<code>f[i][j]</code>中的<code>j</code>可能为负数</p><ul><li><p>首先确定<code>j</code>的范围为<code>-1000 &lt;= j &lt;= 1000</code>，令<code>offset = 1000</code></p></li><li><p>先不考虑状态<code>j</code>可能为负数的问题，按状态转移方程<code>f[i][j] = f[i - 1][j - nums[i]] + f[i - 1][j + nums[i]]</code>正常编写</p></li><li><p>最后增加<strong>偏移量</strong>，即</p><ul><li><p>将<strong>所有</strong><code>f[i][j]</code>修改为<code>f[i][j + offset]</code>，这样所有的状态均为正数</p></li><li><p>将<strong>所有</strong><code>nums[i]</code>修改为<code>nums[i - 1]</code>，这样与题目中<code>nums[]</code>从下标<span class="math inline">\(0\)</span> 开始对应</p></li></ul></li></ul><h2 id="种类型的状态转移函数">2种类型的状态转移函数</h2><p>在考虑状态转移函数时，有 <span class="math inline">\(2\)</span>种思考方式</p><ol type="1"><li>【常见】考虑状态 <code>f[]</code>可以由哪些状态<strong>转移过来</strong></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201156075.png"alt="image-20240820115646749" /><figcaption aria-hidden="true">image-20240820115646749</figcaption></figure><blockquote><p>以背包问题为例，状态转移方程为：<code>f[i][j] = min(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code></p></blockquote><ol start="2" type="1"><li>【少见】考虑状态 <code>f[]</code>可以<strong>更新</strong>哪些状态</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408201149835.png"alt="image-20240820114901472" /><figcaption aria-hidden="true">image-20240820114901472</figcaption></figure><blockquote><p>以<ahref="https://www.acwing.com/activity/content/code/content/8783308/">LeetCode552. 学生出勤记录 II - AcWing</a>为例，状态转移方程为</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">2</span>)</span><br><span class="line">    f[i + <span class="number">1</span>][j][k + <span class="number">1</span>] += f[i][j][k];</span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">1</span>)</span><br><span class="line">    f[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">0</span>] += f[i][j][k];</span><br><span class="line">f[i + <span class="number">1</span>][j][<span class="number">0</span>] += f[i][j][k];</span><br></pre></td></tr></table></figure></p></blockquote><ul><li><a href="https://www.acwing.com/solution/content/252578/">牛客 WY28.跳石板 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8731738/">AcWing1131. 拯救大兵瑞恩 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【时空复杂度分析】</title>
      <link href="/2024/03/17/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%91/"/>
      <url>/2024/03/17/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="时空复杂度分析">时空复杂度分析</h1><h2 id="时间复杂度">时间复杂度</h2><h3 id="时间分析">时间分析</h3><ul><li><p><strong>C++ 1s 的运行数量大概在 <spanclass="math inline">\(1*10^7\)</span> ~ <spanclass="math inline">\(10*10^7 =10^8\)</span></strong>，所以运算量要控制在 <spanclass="math inline">\(10^8\)</span> 以内</p></li><li><p>一般ACM或者笔试题的<strong>时间限制</strong>是<strong>1秒</strong>或<strong>2秒</strong>，在这种情况下，C++代码中的操作次数控制在<span class="math inline">\(10^7\)</span>​~ <spanclass="math inline">\(10^8\)</span>​ 为最佳</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403302109655.png"alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress" /><figcaptionaria-hidden="true">aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress</figcaption></figure><h3 id="主定理">主定理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408272051164.png"alt="image-20240827205131975" /><figcaption aria-hidden="true">image-20240827205131975</figcaption></figure><h3 id="常见算法的时间复杂度">常见算法的时间复杂度</h3><p>一般来说，k重循环，算法时间复杂度就是<spanclass="math inline">\(n^k\)</span></p><table><thead><tr class="header"><th>基础算法</th><th></th></tr></thead><tbody><tr class="odd"><td>快速排序 归并排序 二分</td><td><span class="math inline">\(O(n\log n)\)</span></td></tr><tr class="even"><td>双指针 数组元素目标和</td><td><span class="math inline">\(O(n)\)</span></td></tr></tbody></table><table><thead><tr class="header"><th>数据结构</th><th></th></tr></thead><tbody><tr class="odd"><td>单链表 栈 (插入 删除操作)</td><td><span class="math inline">\(O(1)\)</span></td></tr><tr class="even"><td>单调栈 单调队列</td><td><span class="math inline">\(O(n)\)</span></td></tr><tr class="odd"><td>KMP</td><td><span class="math inline">\(O(n)\)</span></td></tr><tr class="even"><td>Trie字符串统计</td><td><span class="math inline">\(O(n)\)</span></td></tr><tr class="odd"><td>并查集 (路径压缩)</td><td><span class="math inline">\(O(n\log n)\)</span></td></tr><tr class="even"><td>堆排序</td><td><span class="math inline">\(O(n\log n)\)</span></td></tr><tr class="odd"><td>模拟散列表</td><td><span class="math inline">\(O(1)\)</span></td></tr></tbody></table><table><thead><tr class="header"><th>搜索与图论</th><th></th></tr></thead><tbody><tr class="odd"><td>排列数字（全排列）</td><td><span class="math inline">\(O(n*n!)\)</span></td></tr><tr class="even"><td>dfs bfs</td><td><span class="math inline">\(O(n+m)\)</span></td></tr><tr class="odd"><td>Dijkstra</td><td><span class="math inline">\(O(m\log m)\)</span></td></tr><tr class="even"><td>Bellman_ford</td><td><span class="math inline">\(O(nm)\)</span></td></tr><tr class="odd"><td>spfa</td><td><span class="math inline">\(O(nm)\)</span></td></tr><tr class="even"><td>Floyd</td><td><span class="math inline">\(O(n^3)\)</span></td></tr><tr class="odd"><td>Prim</td><td><span class="math inline">\(O(n^2)\)</span></td></tr><tr class="even"><td>Kruskal</td><td><span class="math inline">\(O(m\log m)\)</span></td></tr><tr class="odd"><td>染色法判定二分图</td><td><span class="math inline">\(O(m\log m)\)</span></td></tr><tr class="even"><td>匈牙利算法</td><td><span class="math inline">\(O(nm)\)</span></td></tr></tbody></table><p>spfa算法， 匈牙利算法，最大流算法时间复杂度理论值很大，但是实际运行速度很快</p><table><thead><tr class="header"><th>数学知识</th><th></th></tr></thead><tbody><tr class="odd"><td>试除法判定质数 分解质因数</td><td><span class="math inline">\(sqrt(n)\)</span></td></tr><tr class="even"><td>筛质数</td><td><span class="math inline">\(n\log n\)</span></td></tr><tr class="odd"><td>最大公约数</td><td><span class="math inline">\(\log n\)</span></td></tr><tr class="even"><td>快速幂</td><td><span class="math inline">\(\log n\)</span></td></tr></tbody></table><p>动态规划问题的计算量=<strong>状态数量*状态转移的计算量</strong></p><table><thead><tr class="header"><th>动态规划</th><th></th></tr></thead><tbody><tr class="odd"><td>背包问题</td><td><span class="math inline">\(k\)</span>重循环，算法时间复杂度就是<span class="math inline">\(n^k\)</span></td></tr><tr class="even"><td>最长上升子序列 II</td><td><span class="math inline">\(n\log n\)</span></td></tr><tr class="odd"><td>蒙德里安的梦想</td><td><span class="math inline">\(2^{2n}*n\)</span></td></tr><tr class="even"><td>没有上司的舞会</td><td><span class="math inline">\(nm\)</span></td></tr></tbody></table><span id="more"></span><h3id="由数据范围反推算法复杂度以及算法内容">由数据范围反推算法复杂度以及算法内容</h3><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol type="1"><li><p><span class="math inline">\(n \leqslant 30\)</span> =&gt;指数级别</p><p>dfs+剪枝、状态压缩 dp</p></li><li><p><span class="math inline">\(n \leqslant 10^2\)</span> =&gt; <spanclass="math inline">\(O(n^3)\)</span></p><p>floyd、dp、高斯消元</p></li><li><p><span class="math inline">\(n \leqslant 10^3\)</span> =&gt; <spanclass="math inline">\(O(n^2)\)</span>、<spanclass="math inline">\(O(n^2\log n)\)</span></p><p>dp、二分、朴素版Dijkstra、朴素版Prim、Bellman-Ford</p></li><li><p><span class="math inline">\(n \leqslant 10^4\)</span> =&gt; <spanclass="math inline">\(O(n\sqrt{n})\)</span></p><p>块状链表、分块、莫队</p></li><li><p><span class="math inline">\(n \leqslant 10^5\)</span> =&gt; <spanclass="math inline">\(O(n\log n)\)</span></p><p>各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</p></li><li><p><span class="math inline">\(n \leqslant 10^6\)</span>​</p><ol type="1"><li><span class="math inline">\(O(n)\)</span>​​：单调队列、hash、双指针扫描、BFS、并查集、kmp、AC自动机</li><li>常数比较小的 <span class="math inline">\(O(n\log n)\)</span>​算法：sort、树状数组、heap、dijkstra、spfa</li></ol></li><li><p><span class="math inline">\(n \leqslant 10^7\)</span>​ =&gt; <spanclass="math inline">\(O(n)\)</span></p><p>双指针扫描、kmp、AC自动机、线性筛素数</p></li><li><p><span class="math inline">\(n \leqslant 10^9\)</span>​ =&gt; <spanclass="math inline">\(O(\sqrt{n})\)</span>​</p><p>判断质数</p></li><li><p><span class="math inline">\(n \leqslant 10^{18}\)</span>​ =&gt;<span class="math inline">\(O(\log n)\)</span>​</p><p>最大公约数、快速幂、数位DP</p></li><li><p><span class="math inline">\(n \leqslant 10^{1000}\)</span> =&gt;<span class="math inline">\(O((\log n)^2)\)</span></p><p>高精度加减乘除</p></li><li><p><span class="math inline">\(n \leqslant 10^{100000}\)</span>=&gt; <span class="math inline">\(O(\log k * \log \logk)\)</span>，k表示位数</p><p>高精度加减、FFT/NTT</p></li></ol><!--more--><h2 id="空间复杂度">空间复杂度</h2><h3 id="空间分析">空间分析</h3><ul><li>一般 ACM或者笔试题的<strong>空间限制</strong>是<strong>64MB</strong>，最多只能<strong>使用/声明</strong><span class="math inline">\(1.6*10^7\)</span>个<code>int</code>类型变量</li></ul><p><span class="math display">\[64MB=2^{26}Byte=2^{24} int =1.6*10^7 int\]</span></p><ul><li><p>分析时要注意，计算全局<strong>变量</strong>的空间复杂度要看<strong>实际运行时会用到的空间</strong>，而不是总空间，因为全局变量在未被使用时分配的是<strong>虚拟内存</strong>，但<font color = 'red'><strong>声明时</strong>仍然不能超过<strong>64MB</strong>的空间限制</font></p></li><li><p>当代码里有<strong>递归</strong>函数或需要<strong>大量调用函数</strong>时，需要调用系统栈，因此分析空间复杂度还要加上<strong>栈空间</strong></p><ul><li>快速排序：需要递归 <span class="math inline">\(log\ n\)</span>​层，因此空间复杂度是 <span class="math inline">\(O(\log n)\)</span></li><li>归并排序：而归并排序在递归时每一层还需要开一个长度为 <spanclass="math inline">\(n\)</span> 的数组，因此空间复杂度是 <spanclass="math inline">\(O(n\log n)\)</span></li></ul></li></ul><h3 id="单位换算">单位换算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> KB= <span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> MB=<span class="number">1024</span>*<span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> Byte</span><br></pre></td></tr></table></figure><h3 id="数据类型空间大小">数据类型空间大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="number">4</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>, <span class="type">long</span> <span class="type">long</span>   <span class="number">6B</span>yte</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line">*指针 <span class="number">32</span>位系统 <span class="number">4B</span><span class="number">64</span>位系统 <span class="number">8B</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>咖啡</title>
      <link href="/2024/03/17/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/"/>
      <url>/2024/03/17/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="有关咖啡">有关咖啡</h1><h2id="咖啡因每日的安全使用量是多少">咖啡因每日的安全使用量是多少？</h2><p>一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。</p><span id="more"></span><h2id="雀巢咖啡伴侣是否含反式脂肪酸">雀巢咖啡伴侣是否含反式脂肪酸？</h2><p>在雀巢咖啡伴侣的包装上有明确的标识：反式脂肪酸为0克，所以您可以放心使用。</p><h2id="为什么咖啡伴侣的瓶子是棕色的">为什么咖啡伴侣的瓶子是棕色的？</h2><p>适量的咖啡因摄取对普通大多数的人都是安全的。可能会有一些人群对咖啡因较一般人敏感，与那些对咖啡因不太敏感的人相比，这类人群可能会对少量的咖啡感到不适。通常情况下，孕妇和老年人可能会相对更加敏感一些。</p><h2id="为什么咖啡伴侣的瓶子是棕色的-1">为什么咖啡伴侣的瓶子是棕色的？</h2><p>用棕色瓶子主要是为了避光，咖啡伴侣里某些营养成分是对光敏感的。我们为了在保质期内保证食品的安全和风味，采用了能避光的棕色玻璃瓶。</p><h2 id="喝咖啡对身体有害吗">喝咖啡对身体有害吗？</h2><p>咖啡是一种天然而且健康的饮料。咖啡中除含有咖啡因之外，它还含有对人体健康有利的多种生物活性物质和营养素，如抗氧化物质、矿物质、烟酸和内脂。咖啡能提高警觉性，让我们更有效地利用前额部的大脑皮层，提高注意力和记忆力。关于咖啡因，人们从古代的时候起就开始饮用咖啡类的饮品了。咖啡因是咖啡中的天然含有的成份。目前，人类在大约60种植物中发现了咖啡因，其中最为人知的便是茶和咖啡。而一些常见的食品，如巧克力、可乐中都含有少量咖啡因。</p><h2id="经常喝咖啡是否会导致人体内的钙流失">经常喝咖啡是否会导致人体内的钙流失?</h2><p>咖啡因对钙吸收的不良影响非常小，喝1-2勺牛奶就足以弥补了。所有证据显示，中量饮用咖啡不会改变对钙的消化吸收，不会增加尿钙排泄，也不会从大便中丢失。如果每日摄入咖啡超过1升，尿钙排泄和钙丢失就会增加，但将牛奶加到咖啡里面就可以解决这个问题。适量咖啡因摄入不会对骨代谢产生直接影响。（摘自《咖啡无罪的101个理由》）</p><h2 id="喝咖啡可以减肥吗">喝咖啡可以减肥吗？</h2><p>研究表明，适量喝咖啡有助于控制体重，咖啡中含有膳食纤维，有利于帮助肠道蠕动，促进代谢。如果您想要达到减肥的效果，我们建议您咨询专业的营养师。</p><h2 id="雀巢咖啡是如何诞生的">雀巢咖啡是如何诞生的？</h2><p>二十世纪三十年代，雀巢公司受巴西政府的委托，为其过剩的咖啡寻找保存方法。雀巢公司勇敢地接受了这一技术上的挑战，并于1938年成功开发出速溶咖啡生产工艺。采用该工艺，咖啡粉可以长久地保存而不失其香醇风味。从此，人们可以随时方便地享用美味咖啡。雀巢速溶咖啡便由此诞生了，雀巢咖啡(Nescafe)品牌名称就是由公司名称Nestlé及英文中代表咖啡的CAFE组成。</p><h2 id="咖啡中的12是什么意思">1+2咖啡中的1+2是什么意思？</h2><p>1+2咖啡中的1+2是指：1=咖啡，2=植脂末+糖</p><h2 id="每天在什么时间喝咖啡比较好">每天在什么时间喝咖啡比较好？</h2><p>建议白天饮用咖啡。如果想保持规律的生理周期，晚上不要饮用咖啡。</p><h2id="雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏">雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏？</h2><p>即饮咖啡产品冷热饮均可，如加热饮用，加热温度不宜超过55度，勿将瓶装产品放置于火上或微波炉中直接加热，以免发生危险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学知识】</title>
      <link href="/2024/03/15/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/"/>
      <url>/2024/03/15/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="数学知识">数学知识</h1><p>:smile:<strong>数论</strong> 经常会出现 <strong>数的大小越界</strong>情况：</p><ul><li>尤其是在做<strong>乘法</strong>、其次是<strong>加法</strong>的时候非常容易溢出，此时可以使用<code>long long</code> 局部转换</li><li>比较稳妥的、一劳永逸的办法是<strong>变量类型</strong>不使用int，<strong>全部使用</strong> <code>long long</code></li><li>数论部分的题目通常需要对结果取模，以下统一使用<code>mod</code>代表取模的数，具体何时取余需要根据<code>mod</code>范围进行确定</li></ul><h2 id="质数">质数</h2><ul><li><strong>质数</strong>：在大于 1 的整数中，如果只包含 1和本身这两个约数，就被成为质数，或者叫素数。</li><li><strong>算术基本定理</strong>：任一大于 1 的整数 <spanclass="math inline">\(n\)</span>​ 能够唯一地表示成</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_s}^{\alpha _s},  \alpha_i&gt;0,  i=1,2,\cdots ,s\left( * \right)\]</span></p><p>​ 分解式<span class="math inline">\((*)\)</span>叫做 <spanclass="math inline">\(n\)</span> 的标准分解式</p><p>注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 <spanclass="math inline">\(n\)</span> 表成下面形式： <spanclass="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><span id="more"></span><h3 id="判定质数试除法">判定质数——试除法</h3><p>【<strong>定理</strong>】一个数的因数都是成对出现的（例如 12 的因数有3 和 4，2 和 6）所以我们可以只枚举较小的那一个。假设较小的为 <spanclass="math inline">\(d\)</span>，较大的为 <spanclass="math inline">\(n/d\)</span>，则： <span class="math display">\[d\leqslant \frac{n}{d}\Longrightarrow d\leqslant \sqrt{n}\]</span></p><p>【时间复杂度】<span class="math inline">\(O(\sqrt{n})\)</span>​</p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8063046/">AcWing866. 试除法判定质数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意第 5 行：</p><ul><li><span class="math inline">\(i\)</span> 必须从 <spanclass="math inline">\(2\)</span> 开始，从 <spanclass="math inline">\(1\)</span> 开始会死循环</li><li>循环判断是 <span class="math inline">\(\le\)</span> 而不是 <spanclass="math inline">\(&lt;\)</span></li><li>不要写成 <span class="math inline">\(i*i&lt;= n\)</span>，因为这样在<span class="math inline">\(i\)</span> 非常大时会爆掉 <spanclass="math inline">\(INT\)</span></li><li>也不要写成 <spanclass="math inline">\(𝑖&lt;=sqrt(𝑛)\)</span>，否则每次判断循环条件是否成立都会调用<code>sqrt()</code> ，时间复杂度较高<spanclass="math inline">\(O(n^\alpha)\)</span></li></ul></blockquote><h3 id="分解质因数试除法">分解质因数——试除法</h3><p>【<strong>定理</strong>】整数 <span class="math inline">\(n\)</span>中 <font color='blue'><strong>最多只有一个</strong></font><strong>大于</strong> <span class="math inline">\(sqrt(n)\)</span>的<font color ='red'><strong>质因子</strong></font></p><blockquote><p>证明：通过反证法：如果有两个大于 <spanclass="math inline">\(sqrt(n)\)</span> 的因子，那么相乘会大于 <spanclass="math inline">\(n\)</span>，矛盾，证毕</p><p>eg：<span class="math inline">\(6\)</span> 的质因子 <spanclass="math inline">\(3&gt;sqrt(6)\)</span>、<spanclass="math inline">\(7\)</span> 的质因子 <spanclass="math inline">\(7&gt;sqrt(7)\)</span>、</p></blockquote><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(\sqrt{n})\)</span></p><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/8065120/">AcWing867. 分解质因数 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8836264/">AcWing197. 阶乘分解 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 此时 i 一定为质数 */</span></span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                s ++, n /= i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最后一个大于 sqrt(n) 的质数，注意这里的 n 可能已经被上面的代码更新过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 1\n&quot;</span>, n);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>证明</strong>：循环里面的 <spanclass="math inline">\(i\)</span> 一定是一个质数</p><blockquote><p>假如 <span class="math inline">\(i\)</span>是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是<span class="math inline">\(n\)</span> 的质因子且比 <spanclass="math inline">\(i\)</span> 要小，而比 <spanclass="math inline">\(i\)</span>小的数在之前的循环过程中一定是被条件除完了的，所以 <spanclass="math inline">\(i\)</span> 不可能是合数，只可能是质数</p></blockquote><p>最后需要判断 <span class="math inline">\(n\)</span> 是否大于 <spanclass="math inline">\(1\)</span>，如果是的话说明此时的 <spanclass="math inline">\(n\)</span> 也是原本 <spanclass="math inline">\(n\)</span> 的一个质因子</p><blockquote><p>eg：<span class="math inline">\(n = 96 = 2^5 *3\)</span>，当分解完质因数 <span class="math inline">\(2\)</span>后，<span class="math inline">\(n\)</span> 已经为 <spanclass="math inline">\(3\)</span>，此时 <span class="math inline">\(i =3\)</span>，不满足 <span class="math inline">\(i &lt;= n /i\)</span>，会进入最后判断输出 <spanclass="math inline">\(3\)</span>（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span> 且 <spanclass="math inline">\(3&gt;\sqrt{6}\)</span> ）</p><p>eg：<spanclass="math inline">\(n=16=2^4\)</span>，循环输出后，直接跳到最后判断，不会输出（<spanclass="math inline">\(1=\sqrt{1}\)</span>）</p><p>eg：<span class="math inline">\(n = 6 = 2 *3\)</span>，当分解完质因数 <span class="math inline">\(2\)</span>后，<span class="math inline">\(n\)</span> 已经为 <spanclass="math inline">\(3\)</span>，此时 <span class="math inline">\(i =3\)</span>，不满足 <span class="math inline">\(i &lt;= n /i\)</span>，会进入最后判断输出 <spanclass="math inline">\(3\)</span>（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span>）</p><p>eg：<spanclass="math inline">\(n=17\)</span>，循环不会输出，直接跳到最后判断输出<span class="math inline">\(17\)</span>（<spanclass="math inline">\(17&gt;\sqrt{17}\)</span>）</p></blockquote><h3 id="求质因数的个数试除法">求质因数的个数——试除法</h3><ul><li>【模板题：<ahref="https://www.acwing.com/solution/content/245148/">AcWing 4658.质因数个数 - AcWing</a>】</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">primes_cnt</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 此时 i 一定为质数 */</span></span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最后一个大于 sqrt(n) 的质数，注意这里的 n 可能已经被上面的代码更新过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res ++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求-1-n-中的所有素数">求 1 ~ n 中的所有素数</h3><p>【<strong>定理</strong>】<span class="math inline">\(1\sim n\)</span>中平均每 <span class="math inline">\(\ln n\)</span>个整数中就有一个质数，因此 <span class="math inline">\(1\sim N\)</span>约有 <span class="math inline">\(\frac{N}{\ln N}\)</span> 个素数</p><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/8068049/">AcWing868. 筛质数 - AcWing</a></p><h4 id="朴素筛法不用">朴素筛法（不用）</h4><p>【<strong>时间复杂度</strong>】<span class="math inline">\(O(n \logn)\)</span>​ <span class="math display">\[\frac{n}{2}+\frac{n}{3}+\cdots +\frac{n}{n}=n\left(\frac{1}{2}+\frac{1}{3}+\cdots +\frac{1}{n} \right) \approx n\log n\]</span></p><p>【<strong>原理</strong>】任意<strong>整数</strong> <spanclass="math inline">\(x\)</span> <spanclass="math inline">\((x&gt;1)\)</span>​ 的倍数 <spanclass="math inline">\(2x\)</span>，<spanclass="math inline">\(3x\)</span>，… 等都不是质数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)<span class="comment">// 循环n/i次</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eratosthenes筛法不用">Eratosthenes筛法（不用）</h4><ul><li><p>时间复杂度：<span class="math inline">\(O(n\log \logn)\)</span></p></li><li><p>原理：任意<font color='red'><strong>素数</strong></font> <spanclass="math inline">\(x\)</span> <spanclass="math inline">\((x&gt;1)\)</span> 的倍数 <spanclass="math inline">\(2x\)</span>，<spanclass="math inline">\(3x\)</span>，… 等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="literal">true</span>;<span class="comment">// 可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法">线性筛法</h4><ul><li>朴素筛法和 <span class="math inline">\(Eratosthenes\)</span>筛法存在<strong>重复筛掉</strong>的情况</li></ul><blockquote><p>例如 <span class="math inline">\(12\)</span> 既会被 <spanclass="math inline">\(2\)</span> 筛掉，又会被 <spanclass="math inline">\(3\)</span> 筛掉：</p><ol type="1"><li>在标记 <span class="math inline">\(2\)</span> 的倍数时，<spanclass="math inline">\(12 = 2 ∗ 6\)</span></li><li>在标记 <span class="math inline">\(3\)</span> 的倍数时，<spanclass="math inline">\(12 = 3 ∗ 4\)</span></li></ol><p>如何避免某个数被重复筛掉的情况呢？很简单，我们只需让 <spanclass="math inline">\(12\)</span> 只被它的<strong>最小质数</strong><span class="math inline">\(2\)</span> 筛掉即可</p></blockquote><ul><li><strong>原理</strong>：合数 <span class="math inline">\(x\)</span>只会被其<font color='red'><strong>最小质因子</strong></font>筛掉一次</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n)\)</span>​</li></ul><blockquote><p>第二层循环 <code>st[primes[j] * i] = true;</code>只会对所有<strong>合数</strong>执行一次，所以时间复杂度为 <spanclass="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储 x 是否被筛掉，只有合数才会被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;      </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么不需要写 <code>j &lt; cnt</code> ？</strong></p><ol type="1"><li><p><code>primes[]</code> 数组中存有 <spanclass="math inline">\(1\)</span> ~ <spanclass="math inline">\(i\)</span> 的所有质数</p></li><li><p>当 <span class="math inline">\(i\)</span>是合数时，肯定会在中间就 break 掉</p></li><li><p>当 <span class="math inline">\(i\)</span>​ 是质数时, 那么<code>primes[cnt - 1] = i</code>，因此当 <code>j == cnt - 1</code>时，<code>i % primes[j] == 0, break</code>，依然不会越界</p></li></ol><p><strong>为什么循环条件是<code>primes[j] &lt;= n / i</code></strong></p><ol type="1"><li>循环内筛掉的数是 <code>primes[j] * i</code></li><li>我们要求的是 <span class="math inline">\(1\)</span> ~ <spanclass="math inline">\(n\)</span> 之间的所有素数</li><li>当 <code>primes[j] &gt; n / i</code>，下面筛掉的数大于 <spanclass="math inline">\(n\)</span>，不符合我们的要求</li></ol><p><strong>证明</strong></p><ul><li>合数 x 的最小质因子只有一个</li></ul><blockquote><p>显然成立</p></blockquote><ul><li>合数 x<font color='red'><strong>只会</strong></font>被其<font color='red'><strong>最小质因子</strong></font>筛掉<font color='blue'><strong>一次</strong></font></li></ul><blockquote><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">/* 用合数 primes[j] * i 的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">     <span class="comment">// ∵primes[j] 从小到大枚举的所有质数，有以下 2 种情况：</span></span><br><span class="line">     <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">     <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">     <span class="comment">// ∴不管是上面哪种情况，primes[j] * i 都会被其最小质因子 primes[j] 筛掉</span></span><br><span class="line">     st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">     <span class="comment">// 当 i 是 prime[j] 的倍数时，即存在 k 使得 i = k * prime[j] ，如果继续运算 j + 1，</span></span><br><span class="line">     <span class="comment">// prime[j + 1] * i = prime[j + 1] * prime[j] * k  # 这里 prime[j] 是最小的质因子(因为由上面的情况 1 知道，primes[j] 是 i 的最小质因子，因此 primes[j] &lt;= k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j + 1]筛掉的，而我们已经在上一次迭代中用 primes[j] 筛掉这个数了，重复筛掉</span></span><br><span class="line">     <span class="comment">// 当 i 循环到 = k * prime[j + 1] 时会和 i * prime[j + 1] 重复 # 所以要跳出循环。</span></span><br><span class="line">     <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>所有的合数一定会被筛掉</li></ul><blockquote><p>证明：假设 <span class="math inline">\(prime[k]\)</span> 是合数 <spanclass="math inline">\(x\)</span> 的最小质因子。当 <spanclass="math inline">\(i\)</span> 枚举到 <spanclass="math inline">\(x/primes[k]\)</span> 的时候，<spanclass="math inline">\(x\)</span> 一定会被 <spanclass="math inline">\(prime[k]\)</span> 筛掉，即<code>st[primes[k] * (x / primes[k])] = true</code></p></blockquote><p>因此，所有合数一定<strong>只</strong>会被<strong>最小质因子</strong><strong>筛掉一次</strong>，时间复杂度是线性的</p><h4 id="例题">例题</h4><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8820986/">AcWing1293. 夏洛克和他的女朋友 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8820996/">AcWing1292. 哥德巴赫猜想 - AcWing</a></p></li></ul><h2 id="约数">约数</h2><h3 id="求所有约数试除法">求所有约数——试除法</h3><p>【<strong>原理</strong>】若 <spanclass="math inline">\(d|n\)</span>，则 <spanclass="math inline">\(\frac{n}{d}|n\)</span>. 所以一个数 <spanclass="math inline">\(n\)</span> 的约数肯定是成对存在的，对称轴是<spanclass="math inline">\(\sqrt{n}\)</span></p><p>因此只需要用 <span class="math inline">\(n\)</span> 除以 1 到 <spanclass="math inline">\(\sqrt{n}\)</span>​ 之间的数，如果余数是 <spanclass="math inline">\(0\)</span>，则把<code>除数</code>、<code>n / 除数</code>加到答案中</p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(\sqrt{n})\)</span></p><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/8068610/">AcWing869. 试除法求约数 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)<span class="comment">// 注意这里从 1 开始，不同于试除法</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != n / i)</span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><ul><li><strong>约束个数</strong>定理：任一大于 <spanclass="math inline">\(1\)</span> 的整数 <spanclass="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数的个数为 $( _1+1 )( _1+1 ) ( _k+1 ) $</p><ul><li><strong>证明</strong>：<span class="math inline">\(n\)</span>可以分解质因数：<span class="math inline">\(n=p_{1}^{a_1}\cdotp_{2}^{a_2}\cdot p_{3}^{a_3}\cdotsp_{k}^{a_k}\)</span>，由约束定义可知</li></ul><p>​ <span class="math inline">\(p_{1}^{a_1}\)</span> 的约数有 <spanclass="math inline">\(p_{1}^{0},p_{1}^{1},p_{1}^{2},\cdots,p_{1}^{a_1}\)</span>，共 <span class="math inline">\(a_1+1\)</span>个</p><p>​ <span class="math inline">\(p_{2}^{a_2}\)</span> 的约数有 <spanclass="math inline">\(p_{2}^{0},p_{2}^{1},p_{2}^{2},\cdots,p_{2}^{a_2}\)</span>，共 <span class="math inline">\(a_2 +1\)</span>​个</p><p>​ <span class="math inline">\(\dots\)</span></p><p>​ <span class="math inline">\(p_{k}^{a_k}\)</span> 的约数有 <spanclass="math inline">\(p_{k}^{0},p_{k}^{1},p_{k}^{2},\cdots,p_{k}^{a_k}\)</span>，共 <span class="math inline">\(a_k+1\)</span>​个</p><p>故故根据乘法原理， <span class="math inline">\(n\)</span>的正约数的个数为 $( _1+1 ) ( _1+1 ) ( _k+1 ) $</p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8070605/">AcWing870. 约数个数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的 n 在 int 范围内，因此约数一定也在 int 范围内</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">divisors_cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            res *= s + <span class="number">1</span>;<span class="comment">// 运算的逻辑就是先算完等号右侧的数值，然后再 *=</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和">约数之和</h3><p>【<strong>约束之和定理</strong>】任一正整数 <spanclass="math inline">\(n(n&gt;=2)\)</span> 分解质因式： <spanclass="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},\alpha_i&gt;0,i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n(n&gt;=2)\)</span> 的正约数之和为<span class="math inline">\(\left( p_{1}^{0}+p_{1}^{1}+\cdots+p_{1}^{\alpha _1} \right) \left( p_{2}^{0}+p_{2}^{1}+\cdots+p_{2}^{\alpha _2} \right) \cdots \left( p_{k}^{0}+p_{k}^{1}+\cdots+p_{k}^{\alpha _k} \right)\)</span></p><p>【<strong>证明</strong>】</p><p>若 <span class="math inline">\(n\)</span> 可以分解质因数：<spanclass="math inline">\(n=p_1^{a_1}\times p_2^{a_2}\timesp_3^{a_3}\times\cdots\times p_k^{a_k}\)</span></p><p>可知 <span class="math inline">\(p_{1}^{\alpha_{1}}\)</span> 的约数为<spanclass="math inline">\(p_1^0,~p_1^1,~p_1^2,\cdots,~p_1^{\alpha_1}\)</span></p><p><span class="math inline">\(\cdots \cdots\)</span></p><p>同理可知，<span class="math inline">\(p_k^{\alpha_k}\)</span>的约数为 <span class="math inline">\(p_k^0, p_k^1, p_k^2, \cdots,p_k^{\alpha_k}\)</span></p><p>实际上 <span class="math inline">\(n\)</span> 的约数是在 <spanclass="math inline">\(p_1^{\alpha_1},~p_2^{\alpha_2},\cdots,~p_k^{\alpha_k}\)</span>每一个的约数中分别挑一个相乘得来</p><p>可知共有 <spanclass="math inline">\((\alpha_1+1)(\alpha_2+1)(\alpha_3+1)\cdots(\alpha_k+1)\)</span>种挑法，即约数的个数。</p><p>由乘法原理可知它们的和为：<spanclass="math inline">\(f(n)=(p_1^0+p_1^1+p_1^2+\cdots+p_1^{\alpha_1})\cdot(p_2^0+p_2^1+p_2^2+\cdots+p_2^{\alpha_2})\cdot\cdots\cdot(p_k^0+p_k^1+p_k^2+\cdots+p_k^{\alpha_k})\)</span></p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(\sqrt{n})\)</span></p><p>【<strong>注意</strong>】一个数的<strong>约数之和</strong>一定会<strong>大于这个数本身</strong>（因为这个数本身也是自己的约数）</p><h4 id="原版">原版</h4><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071116/">AcWing871. 约数之和 - AcWing</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">divisors_sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s = s * i + <span class="number">1</span>;</span><br><span class="line">            res *= s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化">优化</h4><p>采用分治计算 <span class="math inline">\(1 + p + p^2 + ... +p^k\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % mod;</span><br><span class="line">        a = (LL)a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优化：采用分治计算 1 + p + p^2 + ... + p^k */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">qmi</span>(p, (k + <span class="number">1</span>) / <span class="number">2</span>)) * <span class="built_in">sum</span>(p, (k - <span class="number">1</span>) / <span class="number">2</span>)) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">qmi</span>(p, k / <span class="number">2</span>)) * <span class="built_in">sum</span>(p, k / <span class="number">2</span> - <span class="number">1</span>) + <span class="built_in">qmi</span>(p, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算约数之和</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">divisors_sum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s ++;</span><br><span class="line">            res = res * <span class="built_in">sum</span>(i, s) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res * n % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><ul><li><strong>欧几里得算法/辗转相除法</strong>：</li></ul><p><span class="math display">\[\begin{cases}    gcd\left( a,b \right) =gcd\left( b,a\%b \right)\\\\    gcd\left( a,0 \right) =a\\\end{cases}\]</span></p><ul><li><span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的最大公约数 <spanclass="math inline">\(gcd(a,b)\)</span> 被记作 <spanclass="math inline">\((a,b)\)</span></li></ul><p><span class="math display">\[\left( x_1,x_2,\cdots ,x_n \right) =\left( \cdots \left( \left( x_1,x_2\right) ,x_3 \right) \cdots x_n \right)\]</span></p><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span>​</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071167/">AcWing872. 最大公约数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2 个数的最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n 个数 a[0, ..., n - 1] 的最大公约数</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    g = <span class="built_in">gcd</span>(g, a[i]);</span><br></pre></td></tr></table></figure><h3 id="最小公倍数">最小公倍数</h3><p><span class="math display">\[a\times b=\left( a,b \right) \times \left[ a,b \right]\]</span></p><ul><li><span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的最小公倍数被记作 <spanclass="math inline">\([a,b]\)</span></li></ul><p><span class="math display">\[\left[ x_1,x_2,\cdots ,x_n \right] =\left[ \cdots \left[ \left[ x_1,x_2\right] ,x_3 \right] \cdots ,x_n \right]\]</span></p><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span>​</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 个数的最大公约数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a / gcd(a,b) * b;<span class="comment">// 先除再乘，避免溢出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n 个数 a[0, ..., n - 1] 的最小公倍数</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    l = lcm(l, a[i]);</span><br></pre></td></tr></table></figure><h3 id="约数与倍数">约数与倍数</h3><p>约数和倍数是一个相对概念：若 <span class="math inline">\(x\)</span>是 <span class="math inline">\(y\)</span> 的约数，则 <spanclass="math inline">\(y\)</span> 是 <spanclass="math inline">\(x\)</span>的倍数。当求约数的时间复杂度过大时，不妨从它倍数的角度来考虑解决问题</p><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8820980/">AcWing1291. 轻拍牛头 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8836264/">AcWing197. 阶乘分解 - AcWing</a></p></li></ul><h2 id="欧拉函数">欧拉函数</h2><h3 id="求欧拉函数-varphi-left-n-right">求欧拉函数 <spanclass="math inline">\(\varphi \left( n \right)\)</span></h3><ul><li><strong>定理</strong>：设正整数 <span class="math inline">\(n\(n&gt;=2)\)</span> 的标准分解式为：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},\alpha_i&gt;0,i=1,2,\cdots ,k\]</span></p><p>​ 则欧拉函数 <span class="math display">\[\varphi \left( n \right) =n\left( 1-\frac{1}{p_1} \right) \left(1-\frac{1}{p_2} \right) \cdots \left( 1-\frac{1}{p_k} \right)\]</span></p><ul><li><strong>含义</strong>： <font color='red'><spanclass="math inline">\(0/1\)</span> ~ <spanclass="math inline">\(n-1/n\)</span> 中与 <spanclass="math inline">\(n\)</span>​<strong>互素</strong>的<strong>个数</strong></font></li><li><strong>性质：</strong><ol type="1"><li>若 <span class="math inline">\(p\)</span> 为素数，则 <spanclass="math inline">\(\varphi \left( p \right) = p-1\)</span></li><li>若<span class="math inline">\((n, m) =1\)</span>，则 $( mn ) =( m )( n ) $</li><li><span class="math inline">\(\varphi \left( a^b \right) =a^{b-1}\cdot\varphi \left( a \right)\)</span>，<spanclass="math inline">\(a&gt;=2\)</span></li></ol></li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span>​</li></ul><blockquote><p>对比：如果对 <span class="math inline">\(1\)</span> ~ <spanclass="math inline">\(n\)</span> 每个数使用 3.1 计算 <spanclass="math inline">\(\varphi(i)\)</span>，时间复杂度为 <spanclass="math inline">\(O(n \sqrt{n})\)</span></p></blockquote><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8072352/">AcWing873. 欧拉函数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求 n &gt;= 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);<span class="comment">// 注意是先除再乘，不要使用逆元求解，因为某些数可能没有逆元</span></span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);<span class="comment">// 注意是先除再乘，不要使用逆元求解，因为某些数可能没有逆元</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性筛法求-1-n-中每个数的欧拉函数">线性筛法——求 1 ~ n中每个数的欧拉函数</h3><ul><li>给定一个正整数 <span class="math inline">\(n\)</span> ，求 <spanclass="math inline">\(1\)</span> ∼ <spanclass="math inline">\(n\)</span>​中<strong>每个数的</strong>欧拉函数</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8073032/">AcWing874. 筛法求欧拉函数 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> eulers[N];       <span class="comment">// primes[i]存储i的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉(状态state)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eulers[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">// Attention!!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求素数 i 的欧拉函数 phi(i) = i - 1</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            eulers[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 求合数 t = primes[j] * i 的欧拉函数</span></span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 情况1：i % primes[j] == 0，此时 primes[j] 既是 i 的最小质因数，也是 t 的最小质因数，因此 i 和 t = primes[j] * i 的质因子是相同的，根据公式可知 phi(t) = phi(primes[j] * i) = primes[j] * phi(i)</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                eulers[t] = primes[j] * eulers[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2：i % primes[j] != 0，此时 primes[j] 不是 i 的质因数（primes[j] &lt; i的最小质因数），但却是 t 的最小质因数，此时 (primes[j], i) == 1，因此phi(t) = phi(primes[j] * i) = phi(primes[j]) * phi(i) = (primes[j] - 1) * phi(i)</span></span><br><span class="line">            eulers[t] = (primes[j] - <span class="number">1</span>) * eulers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-1">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8373629/">AcWing4968. 互质数的个数（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="快速幂">快速幂</h2><p>快速求出 <span class="math inline">\(a^b\,\,mod\,\,p\)</span>​</p><h3 id="原理">原理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151618057.png"alt="04a91bf62e0bd92e3db3b3a73c76793" /><figcaptionaria-hidden="true">04a91bf62e0bd92e3db3b3a73c76793</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151619524.png"alt="bb9db9bc6547be4cfcf9dba7ac9190a" /><figcaptionaria-hidden="true">bb9db9bc6547be4cfcf9dba7ac9190a</figcaption></figure><h3 id="普通快速幂">普通快速幂</h3><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(logb)\)</span></p><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/8074336/">AcWing875. 快速幂 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 特判：p == 1</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left. \begin{array}{r}    a^{2^0}=a^1\\    a^{2^1}=a^2\\    a^{2^2}=a^4\\    \cdots\\    a^{2^{k-1}}\\\end{array} \right\} \Rightarrow a^{2^i}=\left( a^{2^{i-1}} \right) ^2\]</span></p><ul><li><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11777233/">AcWing504. 转圈游戏（每日一题） - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/253062/">AcWing3388. 求root(N, k) - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8820994/">AcWing1289. 序列的第k个数 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8820988/">AcWing1290. 越狱 - AcWing</a></p></li></ul><h3 id="高精度快速幂">高精度快速幂</h3><p>【<strong>时间复杂度</strong>】<span class="math inline">\(O(nm\timeslogb)\)</span></p><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/solution/content/252457/">AcWing 416.麦森数 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>(), m = B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            <span class="keyword">if</span>(i + j &lt; N)</span><br><span class="line">                C[i + j] += A[i] * B[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; n + m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">qmi</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="built_in">mul</span>(res, A);<span class="comment">// res = res * A</span></span><br><span class="line">        A = <span class="built_in">mul</span>(A, A);<span class="comment">// A = A * A</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 A ^ p</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> res = <span class="built_in">qmi</span>(A, p);</span><br></pre></td></tr></table></figure><h3 id="矩阵快速幂"><a id="qmi">矩阵快速幂</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  c[][] = a[][] * b[][]   */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k ++ )</span><br><span class="line">                t[i][j] = (t[i][j] + (LL) a[i][k] * b[k][j]) % mod;</span><br><span class="line">    <span class="built_in">memcpy</span>(c, t, <span class="keyword">sizeof</span> t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 坑1：必须重新定义 res[][] 结果数组，并初始化为单位矩阵（对角线上全为 1，其余全为 0）</span></span><br><span class="line">    <span class="type">int</span> res[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        res[i][i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">mul</span>(res, res, a);  <span class="comment">// res = res * a</span></span><br><span class="line">        <span class="built_in">mul</span>(a, a, a);<span class="comment">// a = a * a</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 坑2：不能写sizeof c，因为函数参数 c 实际上是指向第一个数组元素的指针，因此对其求 sizeof 返回的是指针的大小 8</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c, res, <span class="keyword">sizeof</span> res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于坑 <span class="math inline">\(1\)</span> 的解释：下面这样直接对<code>c</code> 进行操作计算是错误的，根本原因是 <code>qmi()</code>函数的参数 <code>c</code> 、<code>a</code>实际上是一个指针，有可能传入的指针 <code>c</code> 和 <code>a</code>实参相同（即指向同一块内存空间），这样当你对 <code>c[]</code>进行操作的时候实际上也直接改变了 <code>a[]</code>的值，导致下面计算出错</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        c[i][i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">mul</span>(res, res, a);  <span class="comment">// res = res * a</span></span><br><span class="line">        <span class="built_in">mul</span>(a, a, a);<span class="comment">// a = a * a</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正确的做法是新开一个结果数组，这样就不会出现对结果进行赋值的时候可能改变<code>a[]</code> 的值</p></blockquote><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8388593/">AcWing205. 斐波那契（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8389363/">AcWing1303. 斐波那契前 n 项和 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8396571/">AcWing1304. 佳佳的斐波那契 - AcWing</a></li></ul><h2 id="拓展欧几里得算法">拓展欧几里得算法</h2><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8074640/">AcWing877. 扩展欧几里得算法 - AcWing</a>】</p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(log(a+b))\)</span></p><h3 id="求齐次方程axby-0的解">求齐次方程<spanclass="math inline">\(ax+by = 0\)</span>的解</h3><p><span class="math display">\[ax + by = 0\\x=-\frac{by}{a}\]</span></p><p>设 <span class="math inline">\(d = (a, b)\)</span>，则 <spanclass="math inline">\(a = a_0 * d, b = b_0 * d\)</span> 且 <spanclass="math inline">\((a_0, b_0) = 1\)</span> <spanclass="math display">\[x=-\frac{b_0y}{a_0}\]</span> 因为 <span class="math inline">\(a_0\)</span>、<spanclass="math inline">\(b_0\)</span> 互质， 则 <spanclass="math inline">\(x\)</span> 有整数解 =&gt; <spanclass="math inline">\(a_0 | y\)</span> =&gt; <spanclass="math inline">\(y = k * a_0\)</span> ，其中 <spanclass="math inline">\(k\)</span> 为任意整数 =&gt;通解为 <spanclass="math display">\[x = - k * \frac{b}{(a,b)},\quad y = k * \frac{a}{(a,b)}\quad k\in\mathbb{Z}\]</span> 其中 <span class="math inline">\(k\)</span> 为任意整数</p><h3 id="求axby-gcdab的解">求<span class="math inline">\(ax+by =gcd(a,b)\)</span>的解</h3><p><strong>【贝祖等式】</strong>对任意<strong>正整数</strong><strong><span class="math inline">\(a, b\)</span></strong>，一定存在整数 <strong><span class="math inline">\(x,y\)</span></strong> 使得 <span class="math display">\[ax+by=\left( a,b \right)\]</span></p><blockquote><p>注意 <strong><span class="math inline">\(x, y\)</span></strong>也可能为负数</p></blockquote><hr /><p>（1）求解上述等式的<strong>特解</strong> <strong><spanclass="math inline">\(x&#39;, y&#39;\)</span></strong>——<strong>拓展欧几里得算法</strong></p><ul><li><p>当 <span class="math inline">\(b = 0\)</span> 时 <spanclass="math inline">\(\quad ax + by = a\)</span> 故而 <spanclass="math inline">\(x&#39; = 1, y&#39; = 0\)</span></p></li><li><p>当 <span class="math inline">\(b ≠ 0\)</span> 时</p></li></ul><p>因为<br /><span class="math display">\[gcd(b, a\%b) = gcd(a, b)\]</span> 而 <span class="math display">\[bx&#39;&#39; + (a \% b)y&#39;&#39; = gcd(b, a\%b)\]</span></p><p><span class="math display">\[bx&#39;&#39; + (a-\lfloor a/b \rfloor*b)y&#39;&#39; = gcd(b, a\%b)\]</span></p><p><span class="math display">\[ay&#39;&#39; + b(x&#39;&#39;-\lfloor a/b \rfloor*y&#39;&#39;) = gcd(b,a\%b) = gcd(a, b)\]</span></p><p>故而</p><p><span class="math display">\[x&#39; = y&#39;&#39; , \quad y&#39; = x&#39;&#39; - \lfloor a/b\rfloor*y&#39;&#39;\]</span> 因此可以采取递归算法 先求出下一层的 <spanclass="math inline">\(x&#39;&#39;\)</span> 和 <spanclass="math inline">\(y&#39;&#39;\)</span> 再利用上述公式回代即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a, b</span></span><br><span class="line"><span class="comment">   输出：(a, b), x, y 使得 ax + by = (a, b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果中间运算过程中 <span class="math inline">\(x,y\)</span> 爆掉INT，则将其类型修改为 <code>LL</code></p></blockquote><hr /><p>（2）求解上述等式的<strong>通解</strong> <strong><spanclass="math inline">\(x, y\)</span></strong></p><p><strong>通解 = 特解 + 齐次解</strong>，而齐次解即为方程 <spanclass="math inline">\(ax + by = 0\)</span> 的解，故而通解为 <spanclass="math display">\[x=x’+k*\frac{b}{(a,b)},\quad y=y’-k*\frac{a}{(a,b)}\quad k\in \mathbb{Z}\]</span> 若令 <span class="math inline">\(t=b/d\)</span>， 则对于 <spanclass="math inline">\(x\)</span> 的<strong>最小非负整数解</strong>为<span class="math inline">\((x’\%t+t)\%t\)</span></p><h3 id="求ax-by-c的解">求<span class="math inline">\(ax + by =c\)</span>的解</h3><p>【<strong>定理</strong>】对任意正整数 <strong><spanclass="math inline">\(a, b\)</span></strong> ：存在 <spanclass="math inline">\(x,y\)</span> 使得 <span class="math inline">\(ax +by = c\)</span> 等价于 <span class="math inline">\((a,b)|c\)</span></p><blockquote><p>证明</p><p>（1）正向：因为 <span class="math inline">\(a,b\)</span> 是 <spanclass="math inline">\((a,b)\)</span> 的倍数，则<spanclass="math inline">\(ax + by=c\)</span>一定也是<spanclass="math inline">\((a,b)\)</span>的倍数，所以 <spanclass="math inline">\((a,b)|c\)</span></p><p>（2）反向：由贝祖等式知，一定存在 <spanclass="math inline">\(x_0,y_0\)</span> 使得 <spanclass="math inline">\(ax_0+by_0=\left( a,b\right)\)</span>，因此两边同时乘以 <spanclass="math inline">\(\frac{c}{(a,b)}\)</span>【反向证明已知条件 <spanclass="math inline">\((a,b)|c\)</span> 】，得到 <spanclass="math inline">\(a\frac{x_0c}{\left( a,b\right)}+b\frac{y_0c}{\left( a,b \right)}=c\)</span>，即存在特解 <spanclass="math inline">\(x=\frac{x_0c}{\left( a,b\right)},y=b\frac{y_0c}{\left( a,b \right)}\)</span> 使得 <spanclass="math inline">\(ax + by = c\)</span></p><p>注意：该定理结合贝祖等式，说明由 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的倍数之和凑出的最小正整数是 <spanclass="math inline">\((a,b)\)</span>，所有凑出来的数都是 <spanclass="math inline">\((a,b)\)</span> de</p></blockquote><hr /><p>（1）求解上述等式的<strong>特解</strong> <strong><spanclass="math inline">\(x&#39;, y&#39;\)</span></strong> ？</p><ol type="1"><li><p>使用 拓展欧几里得算法 ，求出 <spanclass="math inline">\(x_0\)</span>、<spanclass="math inline">\(y_0\)</span>，使得 <spanclass="math inline">\(ax_0+by_0=(a,b)\)</span></p></li><li><p>左右两侧同时乘以 <span class="math inline">\(\frac{c}{\left( a,b\right)}\)</span>，得到 <span class="math display">\[a\frac{x_0c}{\left( a,b \right)}+b\frac{y_0c}{\left( a,b \right)}=c\]</span></p></li><li><p>因此特解</p></li></ol><p><span class="math display">\[x&#39;=\frac{x_0c}{\left( a,b \right)},\quad y&#39;=b\frac{y_0c}{\left(a,b \right)}\quad k\in \mathbb{Z}\]</span></p><hr /><p>（2）求解上述等式的<strong>通解</strong> <strong><spanclass="math inline">\(x, y\)</span></strong></p><p><strong>通解 = 特解 + 齐次解</strong>，而齐次解即为方程 <spanclass="math inline">\(ax + by = 0\)</span> 的解，故而通解为 <spanclass="math display">\[x=x’+k*\frac{b}{(a,b)},\quad y=y’-k*\frac{a}{(a,b)}\quad k\in \mathbb{Z}\]</span> 若令 <span class="math inline">\(t=b/d\)</span>， 则对于 <spanclass="math inline">\(x\)</span> 的<strong>最小非负整数解</strong>为<span class="math inline">\((x’\%t+t)\%t\)</span></p><h3 id="例题-2">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8821002/">AcWing203. 同余方程 - AcWing</a></li></ul><h2 id="求逆">求逆</h2><p><strong>定义</strong>：当 <span class="math inline">\(ax≡1 \ mod \p\)</span>, <span class="math inline">\(a^{-1}\)</span> <spanclass="math inline">\(mod\)</span> <spanclass="math inline">\(p\)</span> 称为 <spanclass="math inline">\(a∈{1,2,…,p-1}\)</span> 的乘法逆</p><p><strong>【定理】</strong>：当且仅当 <spanclass="math inline">\(gcd(a,p)=1, \ a^{-1} \ mod \ p\)</span>​ 存在</p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8078478/">AcWing876. 求逆元 - AcWing</a>】</li></ul><h3 id="费马小定理求逆元">费马小定理——求逆元</h3><p><strong>【欧拉定理】</strong>若 <spanclass="math inline">\(gcd(a,n)=1\)</span>，则 <spanclass="math display">\[a^{\varphi \left( n \right)}\equiv 1\,\, mod\,\,n\]</span></p><p><strong>【费马小定理】</strong>若 <spanclass="math inline">\(p\)</span> 为素数，则 <spanclass="math display">\[a^{p-1}\equiv 1 \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><p>​ 因此，<span class="math inline">\(a\)</span> 的逆为 <spanclass="math display">\[a^{-1}=a^{p-2}\, \, \left( mod\,\,p \right)\quad s.t. a\not \equiv 0\,\,mod\,\,p\]</span></p><hr /><p>若<font color='red'> <span class="math inline">\(p\)</span> 为素数</font>，则可以使用费马小定理求 <span class="math inline">\(a^{-1}\ mod\p\)</span></p><p>（1）<strong>判断<spanclass="math inline">\(a^{-1}\)</span>是否存在</strong> <spanclass="math display">\[a^{-1}\text{存在}\Longleftrightarrow gcd\left( a,p \right)=1\xLeftrightarrow{p\text{为素数}}a\not \equiv 0\,\,mod\,\,p\]</span> （2）若<span class="math inline">\(a^{-1}\)</span>存在，则<span class="math display">\[a^{-1}=a^{p-2}\, \, \left( mod\,\,p \right)\quad s.t. a\not \equiv 0\,\,mod\,\,p\]</span></p><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(logp)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在逆元</span></span><br><span class="line"><span class="keyword">if</span> (a % p == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)<span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p) % p + p) % p);</span><br></pre></td></tr></table></figure><h3 id="拓展欧几里得求逆元">拓展欧几里得——求逆元</h3><ul><li><p>不要求 <span class="math inline">\(p\)</span> 为素数， <spanclass="math inline">\(p\)</span> 为任意数即可</p></li><li><p>使用拓展欧几里得算法求一个元素的逆</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a, b</span></span><br><span class="line"><span class="comment">   输出：(a, b), x, y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断逆元是否存在</span></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line"><span class="keyword">if</span> (g != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x + p) % p); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x + p 可能爆 int,所以用 long long</span></span><br><span class="line"><span class="comment">+ p % p 是为了将 x 转换到 0 ~ p - 1</span></span><br><span class="line"><span class="comment">/ % 的优先级要高于 + -，所以这里必须加上括号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="求解同余式">求解同余式</h2><p><strong>【定理】</strong>一次同余式 <span class="math display">\[ax\equiv b\left( mod\,\,m \right) \text{，}a\not \equiv 0\left( mod\,\,m\right)\]</span></p><p>（1）有解<span class="math inline">\(\Longleftrightarrow \left( a,m\right) |b\)</span>​</p><p>（2）当同余式有解时，其解数为 <spanclass="math inline">\(d=(a,m)\)</span>​​</p><p>（3）求特解 <span class="math inline">\(x\)</span>，满足 <spanclass="math inline">\(ax≡b(mod \ m)\)</span> &lt;==&gt; 求特解 <spanclass="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>满足 <span class="math inline">\(ax+my=b\)</span></p><ol type="1"><li>使用 拓展欧几里得算法 ，求出 <spanclass="math inline">\(x_0\)</span>、<spanclass="math inline">\(y_0\)</span>，使得</li></ol><p><span class="math display">\[ax_0+my_0=(a,m)\]</span></p><ol start="2" type="1"><li>左右两侧同时乘以 <span class="math inline">\(\frac{b}{\left( a,m\right)}\)</span>，得到</li></ol><p><span class="math display">\[a\frac{x_0b}{\left( a,m \right)}+m\frac{y_0b}{\left( a,m \right)}=b\]</span></p><ol start="3" type="1"><li>因此特解</li></ol><p><span class="math display">\[x=\frac{x_0b}{\left( a,m \right)}\quad \%  m\]</span></p><blockquote><p>特别的 当 <span class="math inline">\(b = 1\)</span> 且 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(m\)</span> 互质时 则所求的 <spanclass="math inline">\(x\)</span> 即为 <spanclass="math inline">\(a\)</span> 的逆元</p></blockquote><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8082881/">AcWing878. 线性同余方程 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (b % g)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x * b / g + m)% m);</span><br><span class="line"><span class="comment">// x * b可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">// * / % 的优先级相同，按照顺序从左到右依次运行</span></span><br><span class="line"><span class="comment">// + m % m 是为了将 x 转换到 0 ~ p-1</span></span><br></pre></td></tr></table></figure><h2 id="求解一次同余组">求解一次同余组</h2><h3 id="中国剩余定理">中国剩余定理</h3><ul><li>要求： <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161457480.png"alt="image-20240316145735216" /><figcaption aria-hidden="true">image-20240316145735216</figcaption></figure><h3 id="拓展中国剩余定理">拓展中国剩余定理</h3><ul><li>不要求 <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8086576/">AcWing204. 表达整数的奇怪方式 - AcWing</a>】</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408132151157.png"alt="image-20240813215123821" /><figcaption aria-hidden="true">image-20240813215123821</figcaption></figure><h2 id="高斯消元">高斯消元</h2><h3 id="解线性方程组">解线性方程组</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192214816.png"alt="image-20240319221424411" /><figcaption aria-hidden="true">image-20240319221424411</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192222282.png"alt="image-20240319222223978" /><figcaption aria-hidden="true">image-20240319222223978</figcaption></figure><p>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8128731/">AcWing883. 高斯消元解线性方程组 - AcWing</a>】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断是否有解</span></span><br><span class="line"><span class="comment">- 返回0，表示无解</span></span><br><span class="line"><span class="comment">- 返回1：表示有无穷多组解</span></span><br><span class="line"><span class="comment">- 返回2：表示有解a[0][n]~a[n-1][n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r; <span class="comment">// c 代表 列 col ， r 代表 行 row</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先找到当前这一列绝对值最大的一个数字所在的行号 t</span></span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行，换到最上面（不是第一行，是第 r 行）去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行的第一个数，变成 1，方程两边同时除以第一个数，必须倒着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--)</span><br><span class="line">            a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把【当前列】下面的所有数，全部消成 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--) <span class="comment">// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];</span></span><br><span class="line">                a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r++; <span class="comment">// 这一行的工作做完，换下一行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r &lt; n 表明剩下方程的个数是小于 n 的，不是唯一解，判断是无解还是无穷多解</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;                                <span class="comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps) <span class="comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一解，从下往上回代，得到方程的解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n]; <span class="comment">// 因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要找绝对值最大的那一行？</p><ol type="1"><li>一是因为可以寻找一个非零行</li><li>二是作浮点数除法时，显然<strong>除以一个大数会让精度更好</strong>，误差更小</li></ol></blockquote><h3 id="解异或方程组">解异或方程组</h3><ul><li><strong>核心思想</strong>：<strong>异或</strong>&lt;==&gt;<strong>不进位的加法</strong></li><li>等式与等式间的异或要一起进行才能保证等式左右两边依然是相等关系：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a^b^c = x</span><br><span class="line">   d^f = y</span><br><span class="line">则</span><br><span class="line"> a^b^d^c^f = x^y</span><br></pre></td></tr></table></figure><ul><li><strong>算法步骤</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 左下角消0</span><br><span class="line">  1.1 枚举列</span><br><span class="line">  1.2 找第一个非零行</span><br><span class="line">  1.3 交换</span><br><span class="line">  1.4 把同列下面行消零(异或)</span><br><span class="line">2 判断3种情况</span><br><span class="line">  2.1 唯一解</span><br><span class="line">  2.2 秩&lt;n</span><br><span class="line">      2.2.1 有矛盾 无解</span><br><span class="line">      2.2.2 无矛盾 无穷多解</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8161242/">AcWing884. 高斯消元解异或线性方程组 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">            &#123;</span><br><span class="line">                t = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!a[t][c])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= n; j++)</span><br><span class="line">                    a[i][j] ^= a[r][j];</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][n])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 无解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无穷解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] ^= a[i][j] * a[j][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数">组合数</h2><p><span class="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}=C_{a}^{a-b}\\    \\    \,\,C_{a}^{0}=1\\\end{cases}\,\,         0\leqslant a\leqslant b\]</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061551561.png"alt="image-20240406155131232" /><figcaption aria-hidden="true">image-20240406155131232</figcaption></figure><h3 id="模板一">模板一</h3><ul><li><strong>适用条件</strong>：<ul><li>询问次数 <span class="math inline">\(n\)</span> 非常多</li><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^5\\1&lt;=b&lt;=a&lt;=2000\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong>：</li></ul><p><span class="math display">\[C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}\]</span></p><ul><li><strong>时间复杂度</strong>：<font color='red'><spanclass="math inline">\(O(n^2)\)</span>​</font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8108970/">AcWing885. 求组合数 I - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)<span class="comment">// 注意：这里是 j &lt;= i</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板二">模板二</h3><ul><li><strong>适用条件</strong><ul><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^4\\1&lt;=b&lt;=a&lt;=10^5\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong></li></ul><p><span class="math display">\[\frac{a}{b}mod\,\,p=a*b^{-1}\,\,mod\,\,p\ne\frac{a\,\,mod\,\,p}{b\,\,mod\,\,p}\]</span></p><p><span class="math display">\[\left( a*b \right) ^{-1}\,\,mod\,\,p=a^{-1}*b^{-1}\,\,mod\,\,p\]</span></p><p><span class="math display">\[C_{a}^{b}=\frac{a!}{b!\left( a-b \right) !}=fact\left( a \right) \,\,*infact\left( b \right) \,\,* infact\left( a-b \right)\,\,   \text{其中}\begin{cases}    fact\left( a \right) =a! \% mod\\    infact\left( a \right) =\left( a! \right) ^{-1}\,\,\% mod\\\end{cases}\\\\\]</span> :smile:注意：<span class="math inline">\(mod=1e^9+7\)</span>为<strong>质数</strong>，所以计算逆元 <spanclass="math inline">\(i^{-1}\)</span>可以采用<strong>费马小定理</strong> <span class="math display">\[\text{递推公式：}\begin{cases}    fact\left( a \right) =fact\left( a-1 \right) \,\,* a\,\,\% mod\\    \\    infact\left( a \right) =infact\left( a-1 \right) \,\,* a^{-1}\,\,\%mod\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8110941/">AcWing886. 求组合数 II - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0! = 1, 0!^&#123;-1&#125; = 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2个 int 相乘会爆 int ，使用类型转化为 long long</span></span><br><span class="line">        fact[i] = (LL) fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL) infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">// 三个 int 相乘会爆 long long，所以每2个数相乘就对 mod 取模</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)fact[a] * infact[b]) % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板三">模板三</h3><ul><li><strong>适用条件</strong></li></ul><p><span class="math display">\[1&lt;= n &lt;= 20\\1&lt;=b&lt;=a&lt;=10^{18}\\1&lt;=p&lt;=10^5，且\ p\ 为质数\]</span></p><ul><li><strong>卢卡斯定理 <span class="math inline">\(Lucas \Theory\)</span></strong></li></ul><p><span class="math display">\[C_{a}^{b}\equiv C_{a\,\,mod\,\,p}^{b\,\,mod\,\,p}\,\,*C_{a/p}^{b/p}\,\,mod\,\,p   \ \ \ \ \ \ p\ 为素数\]</span></p><p>​ 当 <span class="math inline">\(a&lt;p\)</span> 且 <spanclass="math inline">\(b&lt;p\)</span> 时，适用组合数定义求 <spanclass="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}\\    \,\,C_{a}^{0}=1\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121840/">AcWing887. 求组合数 III - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这里的 a 和 b 需要保证小于 p , 因此(b!,p)=1, b!的逆元一定存在</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * j % p;</span><br><span class="line">        y = (LL)y * i % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)x * <span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lucas</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板四">模板四</h3><ul><li><strong>适用条件</strong><ul><li>只计算一个组合数</li><li><span class="math inline">\(p\)</span> 为质数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Cab mod p</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i ++, j --)</span><br><span class="line">&#123;</span><br><span class="line">    res = (LL)res * j % p;</span><br><span class="line">    res = (LL)res * qmi(i, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板五">模板五</h3><ul><li><strong>使用条件</strong></li></ul><p>当我们需要求出<strong>组合数的真实值</strong>，而非对某个数的余数时，分解质因数的方式比较好用：</p><ul><li><strong>原理</strong></li></ul><ol type="1"><li>筛法求出范围内的所有质数</li><li>通过 <span class="math inline">\(C\left( a,b \right)=\frac{a!}{b!\left( a-b \right) !}\)</span>这个公式求出每个质因子的次数。 <span class="math inline">\(n!\)</span>中 <span class="math inline">\(p\)</span> 的次数是</li></ol><p><span class="math display">\[n / p + n / p^2 + n / p^3 + ...\]</span></p><ol start="3" type="1"><li>用高精度乘法将所有质因子相乘</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403191527951.png"alt="image-20240319152754655" /><figcaption aria-hidden="true">image-20240319152754655</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121842/">AcWing888. 求组合数 IV - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];         <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求n！分解质因数后， p 的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高精度乘低精度模板 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a); <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j++)</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><h3 id="例题-3">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8311244/">AcWing211. 计算系数（每日一题） - AcWing</a></li></ul><h2 id="卡特兰数">卡特兰数</h2><h3 id="原理-1">原理</h3><p>​ 给定 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(1\)</span>，它们按照某种顺序排成长度为 <spanclass="math inline">\(2n\)</span> 的序列，满足任意前缀中 <spanclass="math inline">\(0\)</span> 的个数都不少于 <spanclass="math inline">\(1\)</span> 的个数的序列的数量为： <spanclass="math display">\[Cat_n=\frac{C_{2n}^{n}}{n+1}\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403282301866.png"alt="image-20240328230128530" /></p><h3 id="例题-4">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8121833/">AcWing889. 满足条件的01序列 - AcWing</a></li></ul><h2 id="容斥原理">容斥原理</h2><h3 id="原理-2">原理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201238750.png"alt="image-20240319184649042" /><figcaption aria-hidden="true">image-20240319184649042</figcaption></figure><h3 id="例题-5">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8129504/">AcWing890. 能被整除的数 - AcWing</a></li></ul><h2 id="博弈论之sg函数">博弈论之SG函数</h2><h3 id="nim游戏">NIM游戏</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403281718365.png"alt="image-20240328171850955" /><figcaption aria-hidden="true">image-20240328171850955</figcaption></figure><h4 id="定理">定理</h4><p>​ 假设 <span class="math inline">\(n\)</span>​ 堆石子，数目分别是 <spanclass="math inline">\(A_1,A_1,\cdots,A_n\)</span>​</p><ul><li>如果 <span class="math inline">\(A_1\oplus A_2\oplus \cdots \oplusA_n\ne 0\)</span>​​，则先手必胜</li><li>否则先手必败</li></ul><h4 id="证明">证明</h4><ul><li><p>操作到最后时，每堆石子数都是<spanclass="math inline">\(0\)</span>，<span class="math inline">\(0 \oplus 0\oplus … 0 = 0\)</span></p></li><li><p>在操作过程中，如果 <span class="math inline">\(a_1 \oplus a_2\oplus … \oplus a_n = x \neq0\)</span>。那么玩家必然可以通过拿走某一堆若干个石子将异或结果变为0</p><p>证明：不妨设x的二进制表示中最高一位1在第k位，那么在<spanclass="math inline">\(a_1,a_2,…,a_n\)</span>中，必然有一个数<spanclass="math inline">\(a_i\)</span>，它的第k为时1，且<spanclass="math inline">\(a_i \oplus x &lt; a_i\)</span>，那么从第<spanclass="math inline">\(i\)</span>堆石子中拿走<spanclass="math inline">\((a_i - a_i \oplus x\)</span>)个石子，第<spanclass="math inline">\(i\)</span>堆石子还剩<spanclass="math inline">\(a_i - (a_i - a_i \oplus x) = a_i \oplusx\)</span>，此时<span class="math inline">\(a_1 \oplus a_2 \oplus …\oplus a_i \oplus x \oplus… \oplus a_n = x \oplus x =0\)</span>。</p></li><li><p>在操作过程中，如果 <span class="math inline">\(a_1 \oplus a_2\oplus … \oplus a_n =0\)</span>，那么无论玩家怎么拿，必然会导致最终异或结果不为<spanclass="math inline">\(0\)</span></p><p>反证法：假设玩家从第<spanclass="math inline">\(i\)</span>堆石子拿走若干个，结果仍是<spanclass="math inline">\(0\)</span>。不妨设还剩下<spanclass="math inline">\(a’\)</span>个，因为不能不拿，所以<spanclass="math inline">\(0 \leq a’ &lt; a_i\)</span>，且<spanclass="math inline">\(a_1 \oplus a_2 \oplus … \oplus a’ \oplus… \oplusa_n = 0\)</span>。那么<span class="math inline">\((a_1 \oplus a_2 \oplus… \oplus a_i \oplus… a_n) \oplus (a_1 \oplus a_2 \oplus … \oplus a’\oplus… \oplus a_n) = a_i \oplus a’ = 0\)</span>，则 <spanclass="math inline">\(a_i = a’\)</span>，与假设<spanclass="math inline">\(0 \leq a’ &lt; a_i\)</span>矛盾</p></li></ul><p><strong>:tomato:基于上述三个证明：</strong></p><ol type="1"><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n\ne0\)</span>，那么先手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，最后一定是后手面临最终没有石子可拿的状态，先手必胜。</li><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n=0\)</span>，那么无论先手怎么拿，都会将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplus a_n\ne0\)</span>，那么后手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，后一定是先手面临最终没有石子可拿的状态，先手必败。</li></ol><h3 id="公平组合游戏icg">公平组合游戏ICG</h3><p>若一个游戏满足：</p><ol type="1"><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个<strong>公平组合游戏</strong>。</p><p>​NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h3 id="有向图游戏">有向图游戏</h3><p>​给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为<strong>有向图游戏</strong>。​<strong>任何一个公平组合游戏都可以转化为有向图游戏</strong>。具体方法是，<font color ='red'>把每个<strong>局面</strong>看成图中的一个<strong>节点</strong>，并且从<strong>每个局面</strong>向沿着合法行动能够到达的<strong>下一个局面</strong>连<strong>有向边</strong>。</font></p><h3 id="mex运算">Mex运算</h3><p>​ 设 <span class="math inline">\(S\)</span> 表示一个非负整数集合。定义<span class="math inline">\(mex(S)\)</span>为求出<strong>不属于</strong>集合 <span class="math inline">\(S\)</span>的最小非负整数的运算，即： <span class="math display">\[mex(S) = min\{x\},\ x\ 属于自然数，且\ x\ 不属于\ S\]</span></p><h3 id="sg函数">SG函数</h3><p>​ 在有向图游戏中，对于每个节点 <spanclass="math inline">\(x\)</span>，设从 <spanclass="math inline">\(x\)</span> 出发共有 <spanclass="math inline">\(k\)</span> 条有向边，分别到达节点 <spanclass="math inline">\(y_1, y_2, …, y_k\)</span> ，定义 SG(x) 为 x的后继节点 <span class="math inline">\(y_1, y_2, …, y_k\)</span> 的SG函数值 构成的集合再执行 mex(S) 运算的结果，即： <spanclass="math display">\[SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})\]</span> 特别地，整个有向图游戏 G 的 SG 函数值被定义为有向图游戏起点 s的 SG 函数值，即： <span class="math display">\[SG(G) = SG(s)\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201408408.png"alt="image-20240320140827062" /></p><h3 id="有向图游戏的和">有向图游戏的和</h3><p>​ 设 G1，G2,····,Gm 是 m 个有向图游戏。定义有向图游戏G，他的行动规则是任选某个有向图游戏 Gi，并在 Gi 上行动一步。G被称为<strong>有向图游戏 G1，G2，·····，Gm的和</strong></p><p>​有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的<strong>异或和</strong>，即：<span class="math display">\[SG\left( G \right) =SG\left( G_1 \right) \oplus SG\left( G_2 \right)\oplus \cdots \oplus SG\left( G_m \right)\]</span></p><h3 id="定理-1">定理</h3><ul><li>有向图游戏的某个局面<strong>必胜</strong>，当且仅当该局面对应节点的<strong>SG函数值大于0</strong></li><li>有向图游戏的某个局面<strong>必败</strong>，当且仅当该局面对应节点的<strong>SG函数值等于0</strong></li></ul><p>我们不再详细证明该定理。读者可以这样理解：</p><ul><li>在一个<strong>没有出边</strong>的节点上，棋子<strong>不能</strong>移动，它的SG 值为 0，对应必败局面。</li><li>若一个节点的某个后继节点 SG 值为 0，在 mex 运算后，该节点的 SG值大于0。这等价于，若一个局面的后继局面中存在必败局面，则当前局面为必胜局面。</li><li>若一个节点的后继节点 SG 值均不为 0，在mex运算后，该节点的 SG 值为0。这等价于，若一个局面的后继局面全部为必胜局面，则当前局面为必败局面。</li></ul><p>对于若干个有向图游戏的和，其证明方法与 NIM 博弈类似。</p><h3 id="例题-6">例题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8129672/">AcWing891. Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8221695/">AcWing892. 台阶-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8131666/">AcWing893. 集合-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8223036/">AcWing894. 拆分-Nim游戏 - AcWing</a></p></li></ul><h2 id="矩阵乘法">矩阵乘法</h2><h3 id="模板">模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 矩阵乘法： 函数重载 */</span></span><br><span class="line"><span class="comment">/*  c[] = a[] * b[][]   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> c[], <span class="type">int</span> a[], <span class="type">int</span> b[][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 坑1：不能直接在 c[] 数组上操作，必须新开一个结果数组t[]</span></span><br><span class="line">    <span class="comment">// 坑2：新开的数组 t[] 必须赋初始值为&#123;0&#125;，否则就是随机数，影响下面的计算结果</span></span><br><span class="line">    <span class="type">int</span> t[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            t[i] = (t[i] + (LL) a[j] * b[j][i]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将计算结果重新复制给 c[] 返回主函数</span></span><br><span class="line">    <span class="comment">// 坑3：不能写sizeof c，因为函数参数 c 实际上是指向第一个数组元素的指针，因此对其求sizeof返回的是指针的大小 8</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c, t, <span class="keyword">sizeof</span> t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  c[][] = a[][] * b[][]   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 坑1：不能直接在 c[][] 数组上操作，必须新开一个结果数组t[]</span></span><br><span class="line">    <span class="comment">// 坑2：新开的数组 t[][] 必须赋初始值为&#123;0&#125;，否则就是随机数，影响下面的计算结果</span></span><br><span class="line">    <span class="type">int</span> t[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k ++ )</span><br><span class="line">                t[i][j] = (t[i][j] + (LL) a[i][k] * b[k][j]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将计算结果重新复制给 c[][] 返回主函数</span></span><br><span class="line">    <span class="comment">// 坑3：不能写sizeof c，因为函数参数 c 实际上是指向第一个数组元素的指针，因此对其求sizeof返回的是指针的大小 8</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c, t, <span class="keyword">sizeof</span> t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于坑 <span class="math inline">\(1\)</span> 的解释：下面这样直接对<code>c</code> 进行操作计算是错误的，有 2 点原因</p><ol type="1"><li>函数参数 <code>c[][]</code> 的传入值未必全部为 <spanclass="math inline">\(0\)</span>，会影响下面的迭代计算</li><li>也不能使用 <code>memset(c, 0, N * N * 4)</code> 重新初始化为 <spanclass="math inline">\(0\)</span>，因为 <code>c</code>指向的内存空间可能与 <code>a</code>、<code>b</code> 相同，导致对<code>c</code> 的初始化实际上也直接对 <code>a</code>、<code>b</code>进行了初始化，导致计算错误</li></ol><p>根本原因是 <code>qmi()</code> 函数的参数 <code>a</code>、<code>b</code>、<code>a</code> 实际上是指针，有可能传入的指针<code>c</code> 和 <code>a</code>、<code>b</code>实参相同（即指向同一块内存空间），这样当你对 <code>c[]</code>进行操作的时候实际上也直接改变了 <code>a[]</code>的值，导致下面计算出错</p></blockquote><h3 id="例题-7">例题</h3><ul><li><a href="#qmi">矩阵快速幂</a></li></ul><blockquote><p>注意：矩阵乘法通常会结合快速幂一块考察</p></blockquote><h2 id="斐波那契">斐波那契</h2><p><strong><ahref="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法- AcWing</a></strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407011828119.png" alt="image-20240701182813624" style="zoom:20%;" /></p><p>在斐波那契数列中：<span class="math inline">\(f_0=0, f_1=1,f_n=f_{n-1}+f_{n-2} (n&gt;1)\)</span></p><h3 id="递归递推">递归/递推</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8388593/">AcWing205. 斐波那契（每日一题） - AcWing</a></li></ul><h3 id="矩阵乘法快速幂">矩阵乘法+快速幂</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8389363/">AcWing1303. 斐波那契前 n 项和 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8396571/">AcWing1304. 佳佳的斐波那契 - AcWing</a></p></li></ul><h2 id="分数规划">01分数规划</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406061631216.png"alt="image-20240606163123862" /><figcaption aria-hidden="true">image-20240606163123862</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406061630681.jpg"alt="b32752365b6d94730e783293f6864fe" /><figcaptionaria-hidden="true">b32752365b6d94730e783293f6864fe</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406061632463.png"alt="image-20240606163223852" /><figcaption aria-hidden="true">image-20240606163223852</figcaption></figure><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8575194/">AcWing361. 观光奶牛 - AcWing</a></li></ul><h2 id="概率与数学期望"><a id="qiwang">概率与数学期望</a></h2><p>【<strong>定义</strong>】</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408161636723.png"alt="image-20240816163614193" /><figcaption aria-hidden="true">image-20240816163614193</figcaption></figure><p>【<strong>性质</strong>】</p><p>设 <span class="math inline">\(a,b,c\)</span> 为常数，<spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是两个随机变量 <spanclass="math display">\[E(C)=C\]</span></p><p><span class="math display">\[E(CX)=CE(X)\]</span></p><p><span class="math display">\[E(aX+bY)=a*E(X)+b*E(Y)\]</span></p><p>期望的<strong>线性</strong>性质是进行 <font color='red'><strong><spanclass="math inline">\(DP\)</span> 递推求解</strong></font>的关键</p><p>【<strong>例题</strong>】</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8772879/">AcWing217. 绿豆蛙的归宿 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/251232/">AcWing4009. 收集卡牌 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8773607/">AcWing218. 扑克牌 - AcWing</a></li></ul><h2 id="方差与标准差">方差与标准差</h2><p>【<strong>均值</strong>】 <span class="math display">\[\bar{x}=\frac{1}{n}\sum_{i=1}^n{x_i}\]</span> 【<strong>方差</strong>】 <span class="math display">\[\sigma^2=\frac{1}{n}\sum_{i=1}^n{(}x_i-\bar{x})^2=\frac{1}{n}\sum_{i=1}^n{x_{i}^{2}}-\bar{x}^2\]</span></p><p><strong>标准差</strong> <span class="math display">\[\sigma=\sqrt{\frac{1}{n}\sum_{i=1}^n{(}x_i-\bar{x})^2}=\sqrt{\frac{1}{n}\sum_{i=1}^n{x_{i}^{2}}-\bar{x}^2}\]</span></p><blockquote><p>推导 <span class="math display">\[\begin{aligned}  &amp;\frac{\sum_{i=1}^n{(}x_i-\bar{x})^2}{n}\\  &amp;=\frac{1}{n}*\sum_{i=1}^n{(}x_{i}^{2}-2x_i\bar{x}+\bar{x}^2)\\  &amp;=\frac{1}{n}(\sum_{i=1}^n{x_{i}^{2}}-2\bar{x}*\sum_{i=1}^n{x_i}+n\bar{x}^2)\\  &amp;=\frac{1}{n}(\sum_{i=1}^n{x_{i}^{2}}-2n\bar{x}^2+n\bar{x}^2)\\  &amp;=\frac{1}{n}(\sum_{i=1}^n{x_{i}^{2}}-n\bar{x}^2)\\  &amp;=\frac{1}{n}\sum_{i=1}^n{x_{i}^{2}}-\bar{x}^2\\  &amp;=\frac{1}{n}\sum_{i=1}^n{x_{i}^{2}}-\left(\frac{1}{n}\sum_{i=1}^n{x_i} \right) ^2\\\end{aligned}\]</span></p></blockquote><p>注意：一定要会方差公式的<strong>推导变换</strong></p><ul><li><a href="https://www.acwing.com/solution/content/251646/">洛谷P10389. 蓝桥杯 2024 省 A -成绩统计 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8490430/">AcWing321. 棋盘分割 - AcWing</a></li></ul><h2 id="标准记号与常用函数">标准记号与常用函数</h2><h3 id="单调性">单调性</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020678.png"alt="image-20240407121507444" /><figcaption aria-hidden="true">image-20240407121507444</figcaption></figure><h3 id="取整">取整</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020777.png"alt="image-20240407121531163" /><figcaption aria-hidden="true">image-20240407121531163</figcaption></figure><!--more--><h3 id="模运算">模运算</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020702.png"alt="image-20240805104600924" /><figcaption aria-hidden="true">image-20240805104600924</figcaption></figure><h3 id="多项式">多项式</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020795.png"alt="image-20240805104543273" /><figcaption aria-hidden="true">image-20240805104543273</figcaption></figure><h3 id="指数">指数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020689.png"alt="image-20240407121617613" /><figcaption aria-hidden="true">image-20240407121617613</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020713.png"alt="image-20240407121635279" /><figcaption aria-hidden="true">image-20240407121635279</figcaption></figure><h3 id="对数">对数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020445.png"alt="image-20240407121705853" /><figcaption aria-hidden="true">image-20240407121705853</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020458.png"alt="image-20240805104705234" /><figcaption aria-hidden="true">image-20240805104705234</figcaption></figure><h3 id="阶乘">阶乘</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020507.png"alt="image-20240805104641235" /><figcaption aria-hidden="true">image-20240805104641235</figcaption></figure><h3 id="多重函数">多重函数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020496.png"alt="image-20240407121748074" /><figcaption aria-hidden="true">image-20240407121748074</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020478.png"alt="image-20240805104846692" /><figcaption aria-hidden="true">image-20240805104846692</figcaption></figure><h3 id="斐波那契-1">斐波那契</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409251020583.png"alt="image-20240805104827620" /><figcaption aria-hidden="true">image-20240805104827620</figcaption></figure><h3 id="例题-8">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8320617/">AcWing4956. 冶炼金属（蓝桥杯辅导课） - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先队列priority_queue</title>
      <link href="/2024/03/08/%5Bobject%20Object%5D/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/"/>
      <url>/2024/03/08/%5Bobject%20Object%5D/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/</url>
      
        <content type="html"><![CDATA[<h1 id="优先队列priority_queue">优先队列priority_queue</h1><p>:smile: priority_queue实际上就是 <strong>堆</strong></p><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为大根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>堆大小</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>插入</font></strong>堆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分别返回<strong><font color='red'>堆顶元素</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p><font color='blue'><strong>删除</strong></font>堆顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 queue 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><hr /><p>:smile:注意： 使用 <code>q.top()</code>和<code>q.pop()</code>函数前，必须用<code>q.empty()</code>判断队列==<strong>是否为空</strong>==，否则可能因为<strong>队空</strong>而出现<strong>SegmentationFault</strong>错误</p><h2 id="举例">举例</h2><ol type="1"><li>基本类型例子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(i);</span><br><span class="line">        c.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">cbd abcd abc</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>pari的比较，先比较第一个元素，第一个相等比较第二个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>对于自定义类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《致谢》——黄国平</title>
      <link href="/2024/03/04/%5Bobject%20Object%5D/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/"/>
      <url>/2024/03/04/%5Bobject%20Object%5D/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="致谢">致谢</h1><p>​<strong>我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。</strong></p><p>​出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。<strong>每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。</strong></p><p>​<strong>人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。</strong>家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。</p><span id="more"></span><p>​<strong>人后的苦尚旦还能克服，人前的尊严却无比脆弱。</strong>上课的时候，因拖欠学费而经常被老师叫出教室约谈。雨天湿漉着上课，屁股后面说不定还是泥。夏天光着脚走在滚烫的路上。冬天穿着破旧衣服打着寒颤穿过那条长长的过道领作业本。这些都可能成为压垮骆驼的最后一根稻草。如果不是考试后常能从主席台领奖金，顺便能贴一墙奖状满足最后的虚荣心，我可能早已放弃。</p><p>​<strong>身处命运的旋涡，耗尽心力去争取那些可能本就是稀松平常的东西，每次转折都显得那么的身不由己。幸运的是，命运到底还有一丝怜惜。</strong>进入高中后,学校免了全部学杂费，■■■一家帮助解决了生活费。进入大学后，计算机终于成了我一生的事业与希望，胃溃疡和胃出血也终与我作别。</p><p>​我很庆幸保研时选择了自动化所，感谢研究生部的老师们将我从别的部门调剂到模式识别实验室，感谢导师宗成庆老师选择了我，宗老师将我引入了科学研究的大门，博士这五年无疑是我过去最幸福的时光。惭愧的是，离宗老师的期望显然还有很远的距离，我也知道本可以做得更好。这一段经历已经成为我这一生值得回味的美好瞬间之一。我很喜欢人机交互式机器翻译这个题目，但也仅开了个头。在未来，希望能有机会弥补这段遗憾。</p><p>​从家出发坐大巴需要两个半小时才能到县城，一直盼着走出大山。从炬光乡小学、大寅镇中学、仪陇县中学、绵阳市南山中学，到重庆的西南大学，再到中科院自动化所，我也记不清有多少次因为现实的压力而觉得自己快扛不下去了。<strong>这一路，信念很简单。把书念下去，然后走出去，不枉活一世。世事难科，未来注定还会面对更为复杂的局面。但因为有了这些点点滴滴，我已经有勇气和耐心面对任何困难和挑战。理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。</strong></p><p>​ 最近这些年，特别感谢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■重塑了我的人生。</p><p>​感谢■■■老师和■■■老师为我的研究提出诸多建设性的意见和建议。与他们的交流过程中，我也被他们坦诚为人、踏实做事的处事风格所感染。感谢所有和我一起在课题组工作的老师们和学习的同学们：■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■。我们在研究上共同努力，互相学习，如亲兄弟姐妹一般谈笑风生。不论大家将来在何处，我想我们都不会忘记这些年一起度过的时光。感谢课题组■■■女士，感谢模式识别综合办实验室的■■■、■■■和■■■等老师，感谢研究生部的■■■、■■■、■■■和■■■等老师，他们为我的学习和工作给予了极大的帮助。这会成为我日后工作的动力，希望最后能成为课题组值得骄傲的学生。</p><p>​感谢父母给了我生命，感谢婆婆和叔辈对我的抚养，感谢■■■■■■■■■■■■■■■■■■对我的牵挂，感谢■■■和■■■对我的支持，感谢一路上让我生活变得美好或者不那么美好的人和事。</p><p>​ 最后，对参加论文评审、答辩的各位老师表示衷心的感谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> fighting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基本算法】</title>
      <link href="/2024/03/03/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%91/"/>
      <url>/2024/03/03/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="排序">排序</h1><h2 id="快速排序">快速排序</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403260909414.png"alt="image-20240306185054453" /><figcaption aria-hidden="true">image-20240306185054453</figcaption></figure><p>【模板题：<ahref="https://www.acwing.com/activity/content/code/content/7946447/">AcWing785. 快速排序 - AcWing</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要轻易改动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            i ++;</span><br><span class="line">        <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            j --;</span><br><span class="line">        <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q[l...j] 均 &lt;= x , q[j...r] 均 &gt;= x</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:star:<strong>分界点的位置不一定是 <code>x</code></strong>，因为<code>x</code> 参与交换之后可能会被留在左区间 或 右区间</p><span id="more"></span><p><strong>为什么移动 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 指针的条件是 <code>q[i] &lt; x</code>和 <code>q[j] &gt; x</code>，而不是 <code>q[i] &lt;= x</code> 和<code>q[j] &gt;= x</code> ？</strong></p><ul><li>因为如果选取的 <code>x</code> 是数组里最大的数，那么一直都满足<code>q[i] &lt;= x</code>，导致一直 <code>i ++</code> 最终数组越界 <spanclass="math inline">\(Segmentation\ Fault\)</span></li><li>同理，如果选取的 <code>x</code> 是数组里最小的数，那么一直都满足<code>q[j] &gt;= x</code>，导致一直 <code>j --</code> 最终数组越界 <spanclass="math inline">\(Segmentation\ Fault\)</span></li></ul><p><strong>为什么指针 <code>i</code> 和 <code>j</code>初始化为数组两侧外一个元素，即<code>i = l - 1, j = r + 1</code>，而不能让 <code>i = l, j = r</code>然后使用 while 循环代替 do-while 循环 ？</strong></p><ul><li>因为如果数组中存在重复的数字，那么某一轮可能存在 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 都指向相同的数字，并且划分数字 <spanclass="math inline">\(x\)</span> 也是这个数字，那么<code>while (q[i] &lt; x)</code> 和 <code>while (q[j] &gt; x)</code>判断不成立不会进入，又因为<code>q[i] = q[j] = x</code>，交换它们之后这个局面仍然不会改变，从而陷入死循环</li><li>所以要使用 do-while循环，确保每次两个指针都至少会移动一步，以保证上一次交换的结果能被走掉</li></ul><p><strong>为什么在 <code>swap(q[i], q[j])</code> 前检查指针<code>i, j</code> 相对位置?</strong></p><ul><li><p>当两个指针都停下来之后，这一对数都是错位的，所以把它们交换一下，交换完成之后<code>q[i] &lt; x</code>并且<code>q[j] &gt; x</code>，下一轮就可以让<code>i</code>和<code>j</code>（只要满足<code>i &lt; j</code>）继续对向移动了</p></li><li><p>这里考虑一个边界问题，试想<code>q[i]</code>和<code>q[j]</code>在<code>i == j - 1</code>时停下来做交换的场景，交换完成之后<code>i</code>和<code>j</code>会各自前进（<code>i ++, j --</code>）一步，形成<code>i &gt; j</code>（具体是<code>i == j + 1</code>）的不合法局面，这时候就不应该做交换了，所以在<code>swap</code>之前需要再判断一次<code>i &lt; j</code>。</p></li><li><p>反例数据： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 1 2</span><br></pre></td></tr></table></figure> &gt;说明：交换完<code>3</code>和<code>1</code>后形成<code>1 3 2</code>的局面，<code>i ++</code>变成<code>1</code>指向元素<code>3</code>，<code>j --</code>变成<code>0</code>指向元素<code>1</code>，没有做检查指针相对位置的判断，又发生了一次交换，恢复成<code>3 1 2</code>的局面</p></li></ul><p><strong>为什么使用<code>[l, j]</code>作为区间左半边而不是<code>[l, i]</code>？</strong></p><ul><li><p>在快排一轮的处理结束后，递归处理的两个子区间应该是<code>[l, j]</code>、<code>[j + 1, r]</code>而不是<code>[l, i]</code>、<code>[i + 1, r]</code>。</p></li><li><p>这里考虑一个边界问题，试想<code>q[i]</code>和<code>q[j]</code>在<code>i == j - 1</code>时停下来做交换的场景，交换完成之后<code>i</code>和<code>j</code>会各自前进（<code>i ++, j --</code>）一步，形成<code>i &gt; j</code>（具体是<code>i == j + 1</code>）的不合法局面。在这个局面下，满足性质<code>&lt;= x</code>的区间是<code>[l, j]</code>而不是<code>[l, i]</code>，因此划分的两个区间是<code>[l, j]</code>、<code>[j + 1, r]</code>。</p></li><li><p>反例数据： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 1 2</span><br></pre></td></tr></table></figure></p></li></ul><blockquote><p>说明：第一轮时选取的<code>x = 1</code>，在<code>3</code>和<code>1</code>发生交换后，<code>i ++</code>变成<code>1</code>，<code>j --</code>变成<code>0</code>，满足性质<code>&lt;= 1</code>的区间应当是<code>[0, j = 0]</code>，而不是<code>[0, i = 1]</code>。</p></blockquote><blockquote><p><ahref="https://blog.csdn.net/SHU15121856/article/details/109839618">【算法学习笔记】8：快速排序中的边界问题_快速排序分界点-CSDN博客</a></p></blockquote><h2 id="第-k-大数">第 k 大数</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404281609836.png"alt="image-20240428160942512" /><figcaption aria-hidden="true">image-20240428160942512</figcaption></figure><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7963364/">AcWing786. 第k个数 - AcWing</a></li></ul><h2 id="归并排序">归并排序</h2><ul><li><strong>步骤</strong>：<ol type="1"><li>[ L , R ] =&gt; [ L , mid ] , [ mid + 1 , R ]</li><li>递归排序 [ L , mid ] 和 [ mid + 1 , R]</li><li>归并，将左右 2 个有序序列合并成 1 个有序序列</li></ol></li><li>【模板题：<ahref="https://www.acwing.com/activity/content/code/content/7946634/">AcWing787. 归并排序 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> q[N], temp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归排序 [l, mid] 和 [mid + 1, r]</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并，将左右 2 个有序序列合并成 1 个有序序列</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &gt; q[j])<span class="comment">// 此处也可以是 &gt;=，但在求逆序对时必须是 &gt;</span></span><br><span class="line">            temp[k ++] = q[j ++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        temp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        temp[k ++] = q[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++)</span><br><span class="line">        q[i] = temp[j ++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆序对">逆序对</h2><p>a1 a2 a3 a4 a5</p><ul><li><p><strong>定义：</strong>对于一个序列 <spanclass="math inline">\(a\)</span>，若 <spanclass="math inline">\(i&lt;j\)</span> 且 <spanclass="math inline">\(a[i]&gt;a[j]\)</span>，则称 <spanclass="math inline">\(a[i]\)</span> 与 <spanclass="math inline">\(a[j]\)</span> 构成逆序对</p></li><li><p><strong>性质：</strong></p><ul><li>每交换一个<strong>相邻逆序对</strong>，就会使序列的逆序对数量<strong>减<span class="math inline">\(1\)</span></strong></li><li>每交换一个<strong>相邻正序对</strong>，就会使序列的逆序对数量<strong>加<span class="math inline">\(1\)</span></strong></li><li>对于一个长度为 <span class="math inline">\(n\)</span> 的序列<ul><li><strong>正序</strong>序列的逆序对数量<strong>最少</strong>——为 <spanclass="math inline">\(0\)</span></li><li><strong>逆序</strong>序列的逆序对数量<strong>最多</strong>——为 <spanclass="math inline">\(\frac{n\left( n-1 \right)}{2}\)</span></li></ul></li></ul></li><li><p>冒泡排序的原理就是将<strong>不断交换相邻逆序对</strong>，使得逆序对数量最终为0，从而得到正序序列，因此<strong>冒泡排序的交换次数</strong>就是序列中<strong>逆序的数量</strong></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7962764/">AcWing788. 逆序对的数量 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8455207/">AcWing107. 超快速排序 - AcWing</a></p></li></ul><h2 id="中位数">中位数</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8454837/">AcWing106. 动态中位数 - AcWing</a></li></ul><h2 id="st-算法">ST 算法</h2><p>​在<strong>RMQ</strong>问题（区间最值问题）中，著名的ST算法就是倍增的产物。给定一个长度为<span class="math inline">\(N\)</span> 的数列 <spanclass="math inline">\(a\)</span>，ST算法能在 <spanclass="math inline">\(O(NlogN)\)</span>时间的<strong>预处理</strong>后，以 <spanclass="math inline">\(O(1)\)</span>的时间复杂度<strong>在线回答</strong>“数列A中下标在 <spanclass="math inline">\(l\)</span> ~ <spanclass="math inline">\(r\)</span>​之间的数的<strong>最大值/最小值</strong>是多少”这样的区间最值问题</p><p>​ <code>f[i][j]</code> 表示从 <span class="math inline">\(i\)</span>开始，长度是 <span class="math inline">\(2^j\)</span>的区间最大/小值，即区间 <span class="math inline">\([i, i + (1 &lt;&lt;j) - 1]\)</span> 的最大/小值</p><p><strong>初始化</strong>： <spanclass="math inline">\(O(nlogn)\)</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404281854357.png"alt="Snipaste_2024-04-28_18-38-41.png" /><figcaptionaria-hidden="true">Snipaste_2024-04-28_18-38-41.png</figcaption></figure><p><span class="math display">\[f\left( i,j \right) =\max \left\{ f\left( i,j-1 \right) ,f\left(i+2^{j-1},j-1 \right) \right\}\]</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化f[][] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = log2(n) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 类似于区间 DP</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j ++)   <span class="comment">// 先循环区间长度 j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++) <span class="comment">// 再循环区间左端点【注意：区间右端点不能超过终点】</span></span><br><span class="line">        <span class="keyword">if</span>(!j)</span><br><span class="line">            f[i][j] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询：</strong> <span class="math inline">\(O(1)\)</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404281859476.png"alt="image-20240428185957256" /><figcaption aria-hidden="true">image-20240428185957256</figcaption></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404281901305.png"alt="image-20240428190137136" /> <span class="math display">\[f\left( L,R \right) =\max \left\{ f\left( L,k \right) ,f\left( R-2^k+1,k\right) \right\}\]</span> 其中：<span class="math inline">\(k\)</span> 是满足 <spanclass="math inline">\(2^k \le len\)</span>的<strong>最大值</strong>，区间长度 <spanclass="math inline">\(len=r-l+1\)</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查询 [l, r] 区间的最大值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = log2(len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：ST算法只能用于<strong>静态区间</strong>求最值，<strong>动态区间</strong>求最值只能用<strong>线段树</strong></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8456600/">AcWing1273. 天才的记忆 - AcWing</a></p></li></ul><h1 id="二分">二分</h1><ul><li>只要一个序列满足在某一<font color='blue'>分割点</font><strong>左侧满足性质A</strong>，<strong>右侧满足性质B</strong>，就可以使用二分求出这个边界</li><li>二分既可以对<strong>变量</strong>进行二分，也可以对<strong>答案</strong>进行二分</li><li>二分<strong>关键词</strong>：==<font color='red'><strong>最少/最多</strong></font>==</li></ul><h2 id="浮点数二分">浮点数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>; <span class="comment">// eps 表示精度，取决于题目对精度的要求，通常比题目精度高2位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">// 这里不能使用 &gt;&gt; 且必须加括号 (l + r) / 2</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>切记是 <code>double</code></p></blockquote><h2 id="整数二分">整数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> &amp;l, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> &amp;l, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403260942345.jpeg"alt="57ac86165a5b843d61595f2983a9be5" /><figcaptionaria-hidden="true">57ac86165a5b843d61595f2983a9be5</figcaption></figure><p>:smile:具体使用时：</p><ul><li>首先确定性质A、性质B、我们要求的是 <strong>满足性质A的边界</strong>or <strong>满足性质B的边界</strong></li><li>然后编写check函数，<code>mid = l + r &gt;&gt; 1</code><ul><li>求满足性质A的边界：<ul><li>check(mid满足性质A) <code>l = mid</code></li><li>check(mid不满足性质A) <code>r = mid-1</code></li><li>改为<code>mid = l + r + 1 &gt;&gt; 1</code></li></ul></li><li>求满足性质B的边界：<ul><li>check(mid满足性质B) <code>r = mid</code></li><li>check(mid不满足性质B) <code>l = mid + 1</code></li></ul></li></ul></li></ul><p>:tada:注意</p><ul><li>二分的循环的条件是<code>i &lt; j</code>，当<code>l = r</code>时，循环结束，返回<code>l</code></li><li>所有用到二分思想的算法，循环条件都是<strong>小于</strong>，而不是<strong>小于等于</strong></li></ul><h2 id="技巧">技巧</h2><ul><li>上述模板<strong>题目</strong>需要保证<strong>边界一定存在</strong>，否则就会出错，具体而言：<ul><li>如果我们求的是满足<strong>左侧性质A</strong>的边界，但是区间<code>[l,r]</code>均不满足性质A，那么就会返回区间的<strong>最左侧端点<code>l</code></strong></li><li>如果我们求的是满足<strong>右侧性质B</strong>的边界，但是区间<code>[l,r]</code>均不满足性质B，那么就会返回区间的<strong>最右侧端点<code>r</code></strong></li></ul></li><li>因此，如果题目<strong>不能确保边界一定存在</strong>，我们有 2种处理办法</li></ul><ol type="1"><li><p><strong>二分结束后进行判断</strong>【推荐】</p><ol type="1"><li>如果我们要在区间 <code>[l,r]</code>找到满足<strong>左侧性质A</strong>的边界，但是返回的边界不满足<strong>性质A</strong>（<code>check(l)</code> 返回 <code>false</code>），说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质A</strong>的边界</li><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质B</strong>的边界，但是返回的边界不满足<strong>性质B</strong>（<code>check(l)</code>返回 <code>false</code>），说明区间 <code>[l,r]</code><strong>不存在</strong>满足<strong>性质B</strong>的边界</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bsearch</span>(l, r);</span><br><span class="line"><span class="comment">/* 整数二分 */</span></span><br><span class="line"><span class="keyword">if</span>(l == r &amp;&amp; <span class="built_in">check</span>(l))</span><br><span class="line"><span class="comment">/* k为边界 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 不存在边界 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 浮点数二分 */</span></span><br><span class="line"><span class="keyword">if</span>(r - l &lt; eps &amp;&amp; <span class="built_in">check</span>(l))</span><br><span class="line"><span class="comment">/* k为边界 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 不存在边界 */</span></span><br></pre></td></tr></table></figure></li><li><p><strong>二分开始前设置哨兵</strong>【不推荐】</p><ol type="1"><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质A</strong>的边界，则设置哨兵a[l-1]，随便赋值使<code>a[l-1]</code>满足性质A，然后将搜索区间改为<code>[l-1,r]</code>，这样当<code>返回边界=l-1</code>时，说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质A</strong>的边界</li><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>右侧性质B</strong>的边界，则设置哨兵a[l-1]，随便赋值使<code>a[r+1]</code>满足性质B，然后将搜索区间改为<code>[l,r+1]</code>，这样当<code>返回边界=r+1</code>时，说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质B</strong>的边界</li></ol></li></ol><ul><li>二分区间<strong>必须包含答案的取值区间</strong>，在此基础上可以大点也可以小点</li></ul><h2 id="例题">例题</h2><h3 id="整数二分-1">整数二分</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7945110/">AcWing789. 数的范围 - AcWing</a></li></ul><h4 id="二分答案">二分答案</h4><p>【<strong>关键词</strong>】最大、最小、最小值最大、最大值最小</p><p>【<strong>技巧</strong>】</p><ol type="1"><li>如果最终要求答案的<strong>最大值</strong> <spanclass="math inline">\(res\)</span>，那么应该关注<strong>左侧</strong>区间<span class="math inline">\(x\le res\)</span>满足的<font color='blue'><strong>不等性质</strong></font></li><li>如果最终要求答案的<strong>最小值</strong> <spanclass="math inline">\(res\)</span>，那么应该关注<strong>右侧</strong>区间<span class="math inline">\(x\ge res\)</span>满足的<font color='blue'><strong>不等性质</strong></font></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409042056718.jpg"alt="a7624c4e87a6c094b0c7e611a4932d1" /><figcaptionaria-hidden="true">a7624c4e87a6c094b0c7e611a4932d1</figcaption></figure><p>最大、最小类</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8332805/">AcWing1227. 分巧克力（蓝桥杯辅导课） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8318785/">AcWing3745. 牛的学术圈 I（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8575194/">AcWing361. 观光奶牛 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/254189/">AcWing4936. 子序列 - AcWing</a></li></ul><p>最小值最大、最大值最小</p><ul><li><p><a href="https://www.acwing.com/solution/content/250178/">AcWing4178. 数列分段 II - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8822994/">AcWing257. 关押罪犯 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8540931/">AcWing1142. 繁忙的都市 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8523997/">AcWing1090. 绿色通道 - AcWing</a></p></li></ul><h4 id="特殊二分">特殊二分</h4><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8448448/">LeetCode162. 寻找峰值 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8448483/">AcWing113. 特殊排序 - AcWing</a></li></ul><hr /><ul><li><ahref="https://leetcode.cn/problems/binary-search/description/">704.二分查找 - 力扣（LeetCode）</a></li><li><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置 - 力扣（LeetCode）</a></li><li><ahref="https://leetcode.cn/problems/search-a-2d-matrix/description/">74.搜索二维矩阵 - 力扣（LeetCode）</a></li><li><ahref="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240.搜索二维矩阵 II - 力扣（LeetCode）</a></li><li><ahref="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></li><li><ahref="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33.搜索旋转排序数组 - 力扣（LeetCode）</a></li><li><ahref="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">153.寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></li></ul><h3 id="浮点数二分-1">浮点数二分</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7945336/">AcWing790. 数的三次方根 - AcWing</a></li></ul><h1 id="高精度">高精度</h1><ul><li>高精度指的是计算机在处理数值计算时，不受限于标准数据类型（如int,float,double等）的精度限制，可以处理<strong>任意长度的数字和精度</strong></li><li>在C/C++中，当数据过大，<code>long long</code> 存储不下时，可以使用<code>vector</code> 数组或 <code>__int128</code> 存储，然后计算</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408141239249.png"alt="image-20240814123902809" /><figcaption aria-hidden="true">image-20240814123902809</figcaption></figure><h2 id="数组">数组</h2><p>高精度数采用<strong>数组</strong>、从<font color='purple'><strong>低位向高位</strong></font>依次存储，便于向<strong>高位进位</strong></p><blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261025407.jpeg" alt="7f7747b40d2f813ace3c448acb250a5" style="zoom: 25%;" /></p></blockquote><blockquote><ul><li>一般vector或者数组中每个数据都是一个int，<strong>如果每个位置只是存储0~9一位数字的话，比较浪费空间，并且计算也会变慢</strong>。因此可以让每个位置存储连续的多位数字，这被称作<font color='red'><strong>压位</strong></font></li></ul></blockquote><blockquote><ul><li>压位和不压位的高精度计算存在三点不同点（以下提到的压位都是压 4 位）<ol type="1"><li>存储：不压位的话，vector或者数组中每个数据是 0 ~9；压位以后，每个数据是 0 ~ 9999</li><li>计算过程：不压位的话，除数和模数都是 10；压位以后，除数和模数都是10000</li><li>输出：不压位的话，直接输出；压位的话，需要格式化输出，<strong>最高位直接输出</strong>，<strong>其他位都需要输出4位数字，不足的前面补零</strong></li></ol></li><li>高精度<strong>加减</strong>法<strong>最多可以压 9位</strong>，高精度<strong>乘除</strong>法<strong>最多可以压 4位</strong>，这里为了演示，均以压 4位为例，也就是说：vector或者数组中每个位置存储四个连续的数字</li></ul></blockquote><p>以下只讨论</p><ul><li>高精度加法</li><li>高精度减法</li><li>高精度 ✖ 低精度</li><li>高精度➗低精度</li></ul><p>对于两个高精度数相乘/相除很少见，在此不予阐述</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261025399.jpeg" alt="8147590f449a6d0077d9bd05a829853" style="zoom: 33%;" /></p><h3 id="高精度加法">高精度加法</h3><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/7947226/">AcWing791. 高精度加法 - AcWing</a>、<ahref="https://www.acwing.com/solution/content/251685/">AcWing 3453.整数查询 - AcWing</a>、<ahref="https://www.acwing.com/solution/content/251830/">AcWing 5508.回文数 - AcWing</a></p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(max(n,m))\)</span>，其中 <spanclass="math inline">\(n,m\)</span> 分别为 2个<strong>高精度运算数</strong>的<font color='red'><strong>位数</strong></font></p><h4 id="不压位">不压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除前导0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="压位">压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 模数设置为 1e4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % M);</span><br><span class="line">        t /= M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改输入格式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        B.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改输出格式</span></span><br><span class="line">cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度减法">高精度减法</h3><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/7947515/">AcWing792. 高精度减法 - AcWing</a></p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(max(n,m))\)</span>，其中 <spanclass="math inline">\(n,m\)</span> 分别为 2个<strong>高精度运算数</strong>的<font color='red'><strong>位数</strong></font></p><h4 id="不压位-1">不压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较a, b大小：如果 a &gt;= b返回 true；否则返回 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// A 等于 B 时返回 true（不能写 false，否则会出现 -0）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(A, B);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="压位-1">压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 模数设置为 1e4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较a, b大小：如果 a &gt;= b返回 true；否则返回 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// A 等于 B 时返回 true（不能写 false，否则会出现 -0）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + M) % M);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改输入格式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        B.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(A, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    <span class="comment">// 修改输出格式</span></span><br><span class="line">cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘低精度">高精度乘低精度</h3><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/7947712/">AcWing793. 高精度乘法 - AcWing</a></p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>为<strong>高精度运算数</strong>的<font color='red'><strong>位数</strong></font></p><h4 id="不压位-2">不压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="压位-2">压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压 4 位, 模数设置为 1e4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;<span class="comment">// 小心：当 M * b &gt; INT 时，这里会爆 INT，此时应将压位减少</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % M);</span><br><span class="line">        t /= M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改输入格式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改输出格式</span></span><br><span class="line">    cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘高精度">高精度乘高精度</h3><p>【<strong>结论</strong>】<span class="math inline">\(n\)</span>位数乘 <span class="math inline">\(m\)</span>位数，乘积<font color='blue'><strong>最多</strong></font>是<strong><font color='red'><spanclass="math inline">\(n+m\)</span></font></strong>位数，<font color='blue'><strong>最少</strong></font>是<strong><font color='red'><spanclass="math inline">\(n+m-1\)</span></font></strong> 位数</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408212130072.png"alt="image-20240821213034667" /><figcaption aria-hidden="true">image-20240821213034667</figcaption></figure><p>【<strong>模板题</strong>】</p><ul><li><a href="https://www.acwing.com/solution/content/251681/">洛谷P1303. 高精度乘法II - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8787716/">LeetCode43. 字符串相乘 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/251686/">AcWing1481. 多项式乘积 - AcWing</a></li></ul><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(nm)\)</span>，其中 <spanclass="math inline">\(n,m\)</span> 分别为 2个<strong>高精度运算数</strong>的<font color='red'><strong>位数</strong></font></p><h4 id="不压位-3">不压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>(), m = B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; n + m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="压位-3">压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3</span>, M = <span class="number">1e3</span>;<span class="comment">// 这里根据情况需要调整压位数，否则 C[] 可能会溢出</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>(), m = B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n + m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; n + m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % M;</span><br><span class="line">        t /= M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        B.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, B);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%03d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度除低精度">高精度除低精度</h3><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/7947725/">AcWing794. 高精度除法 - AcWing</a></p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(n)\)</span>，其中 <spanclass="math inline">\(n\)</span>为<strong>高精度运算数</strong>的<font color='red'><strong>位数</strong></font></p><h4 id="不压位-4">不压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)<span class="comment">// 注意这里是从高位往低位</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;<span class="comment">// 这里记得一定要将 r 初始化为 0</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="压位-4">压位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压 4 位, 模数设置为 1e4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)<span class="comment">// 注意这里是从高位往低位</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = r * M + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);<span class="comment">// 注意这里是 /</span></span><br><span class="line">        r %= b;   <span class="comment">// 注意这里是 %</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());<span class="comment">// 需要反转：低位低下标、高位高下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导 0，直到结果为 0 或 最高位不为 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;<span class="comment">// 这里记得一定要将 r 初始化为 0</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改输出格式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C.<span class="built_in">back</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int128"><code>__int128</code></h2><ul><li>C++ 中有一种数据类型叫<code>__int128</code>，它可以保存128位，被包含在 iostream 头文件中</li></ul><blockquote><p><code>int</code> 存<span class="math inline">\(10^9\)</span>的数量级，<code>long long</code> 存 <spanclass="math inline">\(10^{18}\)</span> 的数量级，而<code>__int128</code> 存 <span class="math inline">\(10^{38}\)</span>的数量级</p></blockquote><ul><li>C/C++标准IO是不认识 <code>__int128</code>这种数据类型的，cin和cout是无法输入输出 <code>__int128</code>的，所以我们<strong>只需要</strong>自己实现<strong>输入输出</strong>，<strong>仅仅</strong>在输入输出的时候不同，其他<strong>所有的运算</strong>（<spanclass="math inline">\(=、+、-、*、/、\%、\)</span>赋值<spanclass="math inline">\(、\)</span>强制类型转换等），与int没有什么不同</li><li><code>__int128</code> 在gcc、codeblocks、vs2017都是不被支持的，不过<code>__int128</code>在Linux上可以编译并且能用，我们提交到大部分OJ上都是可以编译且能用的</li><li><ahref="https://www.acwing.com/activity/content/code/content/8279228/">AcWing90. 64位整数乘法 - AcWing</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快读函数，用于输入 */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">// 去除空白字符</span></span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快写函数，用于输出 */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int128 a = <span class="built_in">read</span>();</span><br><span class="line">    __int128 b = <span class="built_in">read</span>();</span><br><span class="line">    __int128 c = <span class="built_in">read</span>();</span><br><span class="line">    __int128 p = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 支持= + - * / % 等操作 */</span> </span><br><span class="line">    a += b;</span><br><span class="line">    a -= c;</span><br><span class="line">    a *= b;</span><br><span class="line">    a /= c;</span><br><span class="line">    _int128 res = (a * d - c + b) % p;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用python">使用python</h2><p><span class="math inline">\(python\)</span> 中的 <code>int</code>类型<font color='red'><strong>支持高精度，没有大小限制</strong></font>，以<ahref="https://www.acwing.com/solution/content/253897/">AcWing 1026.乘积最大 - AcWing</a>为例，如果题目没有要求必须使用 <spanclass="math inline">\(C/C++\)</span>，可以改为 <spanclass="math inline">\(python\)</span> 语言</p><h2 id="例题-1">例题</h2><ul><li><a href="https://www.acwing.com/solution/content/251688/">HDU 1230.火星A+B - AcWing</a></li><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/12352515/">AcWing114. 国王游戏 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/252457/">AcWing416. 麦森数 - AcWing</a></li></ul><h1 id="前缀和差分">前缀和&amp;&amp;差分</h1><ul><li><p><strong>前缀和</strong> 与 <strong>差分</strong>是一对<font color='red'><strong>逆运算</strong></font></p><ul><li>前缀和最用：求某一区域/区间 的和</li><li>差分作用：将某一区域/区间内的数全部<strong>加上/减去指定数值</strong></li></ul></li><li><p>差分序列通常<strong>不需要构建</strong>：</p><ul><li>将<strong>前缀和序列</strong>、<strong>差分序列</strong>均初始化为0（满足前缀和定义）</li><li>然后将原始数据<strong>依次插入</strong>前缀和序列，即可自动更新差分序列</li></ul></li><li><p><font color='red'><strong>原始数据 <code>a[]</code>，前缀和<code>S[]</code>，差分序列 <code>B[]</code> 都是从下标 1开始存储的</strong></font></p></li><li><p><strong>原数据 <code>a[]</code></strong>与<strong>前缀和<code>S[]</code></strong>，<strong>原数据<code>a[]</code></strong>与<strong>差分序列<code>B[]</code></strong>没有实时联动关系，<strong>对某一数组操作以后需要通过手动操作同步</strong></p></li></ul><h2 id="前缀和">前缀和</h2><ul><li>前缀和通常会爆 <span class="math inline">\(INT\)</span>，通常采用<code>LL</code> 存储</li></ul><h3 id="一维前缀和">一维前缀和</h3><ul><li><strong>定义：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">0</span>] = <span class="number">0</span>, S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i](<span class="number">1</span> &lt;= i &lt;= n)</span><br></pre></td></tr></table></figure><ul><li><strong>性质：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i] = S[i - <span class="number">1</span>] + a[i]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1]</span><br></pre></td></tr></table></figure><blockquote><p>切记：前缀和 S 从下标 1 开始，S[0] = 0 用来解决边界问题</p></blockquote><ul><li>边输入，边构造</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;S[i]);</span><br><span class="line">    S[i] += S[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7948798/">AcWing795. 前缀和 - AcWing</a>】</li></ul><p><strong>注意</strong>：给定一个长度为 <spanclass="math inline">\(n\)</span> 的数列{<spanclass="math inline">\(a_1,a_2,…,a_n\)</span>}，每次选择一个区间<code>[l, r]</code>，计算下标在这个区间内的数之和，则这个操作对应的<font color ='red'><strong>前缀和序列 <spanclass="math inline">\(S\)</span> 的下标范围是<code>[0, n]</code></strong></font> <span class="math display">\[\left[ 1,n \right] \cup \left[ 0,n-1 \right] =\left[ 0,n \right]\]</span></p><h3 id="二维前缀和">二维前缀和</h3><ul><li><strong>定义：</strong></li></ul><p><span class="math display">\[S\left[ x \right] \left[ y \right] =\sum_{i=1}^x{\sum_{j=1}^y{a\left[ i\right] \left[ j \right]}}\]</span></p><ul><li><strong>性质：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]</span><br></pre></td></tr></table></figure><p>​ 以 <span class="math inline">\((x1, y1)\)</span> 为左上角， <spanclass="math inline">\((x2, y2)\)</span> 为右下角的子矩阵的和为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[x2, y2] - S[x2, y1 - <span class="number">1</span>] - S[x1 - <span class="number">1</span>, y2] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032157.png" alt="image-20240305172624211" style="zoom: 15%;" /></p><ul><li>边输入，边构造</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;S[i][j]);</span><br><span class="line">        S[i][j] += S[i][j - <span class="number">1</span>] + S[i - <span class="number">1</span>][j] - S[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7949245/">AcWing796. 子矩阵的和 - AcWing</a>】</li></ul><h3 id="例题-2">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8774456/">AcWing3412. 邻域均值 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8303325/">AcWing562. 壁画（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8308107/">AcWing99. 激光炸弹（算法提高课） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8306422/">AcWing1230. K倍区间（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="差分">差分</h2><h3 id="一维差分">一维差分</h3><ul><li><strong>定义：</strong>【不用记，用不到】</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i] = a[i] - a[i - <span class="number">1</span>](<span class="number">1</span> &lt;= i &lt;= n)</span><br></pre></td></tr></table></figure><blockquote><p>切记：原始序列 a 从下标 1 开始，<code>a[0] = 0</code>用来解决边界问题</p></blockquote><ul><li><strong>性质：</strong><code>a[]</code>是<code>B[]</code>的前缀和，<code>B[]</code>是<code>a[]</code>的差分，所以：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i] = B[<span class="number">1</span>] + B[<span class="number">2</span>] + ... B[i]</span><br><span class="line">a[i] = a[i - <span class="number">1</span>] + B[i]</span><br></pre></td></tr></table></figure><p>:smile:以上​实际上是前缀和的定于与性质</p><ul><li><strong>操作：</strong>给区间 <span class="math inline">\([l,r]\)</span> 中的每个数加上 <span class="math inline">\(c\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[l] += c;</span><br><span class="line">    B[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>边输入，边构造</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    insert(i, i, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7949620/">AcWing797. 差分 - AcWing</a>】</li></ul><p><strong>注意</strong>：给定一个长度为 <spanclass="math inline">\(n\)</span> 的数列{<spanclass="math inline">\(a_1,a_2,…,a_n\)</span>}，每次可以选择一个区间<code>[l, r]</code>，使下标在这个区间内的数都加 <spanclass="math inline">\(1\)</span> 或者都减 <spanclass="math inline">\(1\)</span>，则这个操作对应的<font color ='red'><strong>差分序列<span class="math inline">\(B\)</span>的下标范围是 <code>[1, n + 1]</code></strong></font></p><p><span class="math display">\[\left[ 1,n \right] \cup \left[ 2,n+1 \right] =\left[ 1,n+1 \right]\]</span></p><h3 id="二维差分">二维差分</h3><ul><li><strong>定义：</strong>【不用记，用不到】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i][j] = a[i][j] - a[i - <span class="number">1</span>][j] - a[i][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>性质：</strong><code>a[][]</code>是<code>B[][]</code>的前缀和，<code>B[][]</code>是<code>a[][]</code>的差分，因此：</li></ul><p><span class="math display">\[a\left[ i \right] \left[ j \right] =\sum_{i=1}^n{\sum_{j=1}^m{B\left[ i\right] \left[ j \right]}}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j] = a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>] + B[i][j];</span><br></pre></td></tr></table></figure><p>:smile:以上实际上是前缀和的定于与性质</p><ul><li><strong>操作：</strong>给以(x1, y1)为左上角，(x2,y2)为右下角的子矩阵中的所有元素加上c：</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032057.png" alt="20201217174836198.png" style="zoom:30%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[x1][y1] += c;</span><br><span class="line">    B[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032099.png"alt="20201217170336254.png" /><figcaption aria-hidden="true">20201217170336254.png</figcaption></figure><ul><li>边输入边构造</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        insert(i, j, i, j, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7954891/">AcWing798. 差分矩阵 - AcWing</a>】</li></ul><h3 id="例题-3">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8275142/">AcWing100. 增减序列 - AcWing</a>、<ahref="https://www.acwing.com/solution/content/251600/">AcWing 531.铺设道路 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8271772/">AcWing4262. 空调（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8281066/">AcWing5396. 棋盘（蓝桥杯辅导课） - AcWing</a></li></ul><h1 id="双指针">双指针</h1><h2 id="模板">模板</h2><ul><li><p>双指针的主要<strong>作用</strong>是 ——<strong>优化时间复杂度</strong>，通常可以将时间复杂度从 <spanclass="math inline">\(O(n^2)\)</span> 优化到 <spanclass="math inline">\(O(n)\)</span></p></li><li><p>可以从朴素思想开始，思考两个指针是否具有某种性质，eg：<strong>分类：</strong></p></li></ul><h3 id="对于1一个序列">对于1一个序列</h3><ul><li>2 个指针一前一后【快慢指针】，用两个指针维护一段区间，2个指针<strong>均只能向前移动</strong>，而不能向后移动</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312109496.png"alt="image-20240331210906340" /><figcaption aria-hidden="true">image-20240331210906340</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 快指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动慢指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= i &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 慢指针 j 移动后的操作【必须在 j++ 前面】 */</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描，<spanclass="math inline">\(j\)</span> 指针<strong>从后往前</strong>扫描</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312117865.png"alt="image-20240331211703704" /><figcaption aria-hidden="true">image-20240331211703704</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 指针 j 移动后的操作 */</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于2个序列">对于2个序列</h3><ol start="2" type="1"><li>对于<strong>两个序列</strong>，2 个指针分别指向 2个序列，维护某种次序</li></ol><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描 <span class="math inline">\(A\)</span>序列，<span class="math inline">\(j\)</span>指针<strong>从后往前</strong>扫描 <span class="math inline">\(B\)</span>序列</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312055114.png"alt="image-20240331205557944" /><figcaption aria-hidden="true">image-20240331205557944</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 指针 j 移动后的操作*/</span></span><br><span class="line">        j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描 <span class="math inline">\(A\)</span>序列，<span class="math inline">\(j\)</span>指针<strong>从后往前</strong>扫描 <span class="math inline">\(B\)</span>​序列</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312057578.png"alt="image-20240331205747366" /><figcaption aria-hidden="true">image-20240331205747366</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i 指针移动后的操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否要移动 j 指针</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* j 指针移动后的操作 */</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>举例：分行输出字符串</strong></li></ul><p>​给你一个字符串，请将其中的每个单词依次输出（假设字符串开头没有空格，且单词之间有且仅有一个空格）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">            cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-4">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8776886/">LeetCode76. 最小覆盖子串 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7957914/">AcWing799. 最长连续不重复子序列 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7958047/">AcWing800. 数组元素的目标和 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8870992/">LeetCode15. 三数之和 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7958255/">AcWing2816. 判断子序列 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/254014/">AcWing1575. 盛水最多的容器 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8318785/">AcWing3745. 牛的学术圈 I（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8323692/">AcWing1238. 日志统计（蓝桥杯辅导课） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8304518/">AcWing4405. 统计子矩阵（蓝桥杯辅导课） - AcWing</a></li></ul><h1 id="位运算">位运算</h1><h2 id="位运算符">位运算符</h2><table style="width:100%;"><colgroup><col style="width: 7%" /><col style="width: 5%" /><col style="width: 11%" /><col style="width: 64%" /><col style="width: 10%" /></colgroup><thead><tr class="header"><th style="text-align: center;">C语言</th><th style="text-align: center;">描述</th><th>输入个数</th><th style="text-align: center;">运算规则</th><th>单位元f</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>&amp;</code></td><td style="text-align: center;">与</td><td><span class="math inline">\(\ge 2\)</span></td><td style="text-align: center;">对应位都为1时，结果才为1</td><td>1</td></tr><tr class="even"><td style="text-align: center;"><code>|</code></td><td style="text-align: center;">或</td><td><span class="math inline">\(\ge 2\)</span></td><td style="text-align: center;">对应位都为0时，结果才为0</td><td>0</td></tr><tr class="odd"><td style="text-align: center;"><code>~</code></td><td style="text-align: center;">非</td><td><span class="math inline">\(=1\)</span></td><td style="text-align: center;">0变1，1变0</td><td>\</td></tr><tr class="even"><td style="text-align: center;"><code>^</code></td><td style="text-align: center;">异或</td><td><span class="math inline">\(\ge 2\)</span></td><td style="text-align: center;"><strong>不进位的加法</strong></td><td>0</td></tr><tr class="odd"><td style="text-align: center;"><code>|!</code></td><td style="text-align: center;">与非</td><td><span class="math inline">\(\ge 2\)</span></td><tdstyle="text-align: center;">先全部与后取非/逐个<strong>取反</strong>后相或</td><td>0</td></tr><tr class="even"><td style="text-align: center;"><code>&amp;!</code></td><td style="text-align: center;">或非</td><td><span class="math inline">\(\ge 2\)</span></td><tdstyle="text-align: center;">先全部或后取非/逐个<strong>取反</strong>后相与</td><td>1</td></tr><tr class="odd"><td style="text-align: center;"><code>&lt;&lt;</code></td><td style="text-align: center;">左移</td><td></td><tdstyle="text-align: center;">各二进位全部左移若干位，高位丢弃，低位补0</td><td>\</td></tr><tr class="even"><td style="text-align: center;"><code>&gt;&gt;</code></td><td style="text-align: center;">右移</td><td></td><tdstyle="text-align: center;">各二进位全部右移若干位，高位补0或符号位补齐</td><td>\</td></tr></tbody></table><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8776873/">AcWing3294. 点亮数字人生 - AcWing</a></li></ul><h2 id="常见操作">常见操作</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261639341.jpg"alt="aa5212f8f0993c186015d618c0e496e" /><figcaptionaria-hidden="true">aa5212f8f0993c186015d618c0e496e</figcaption></figure><ul><li><strong>求 <span class="math inline">\(x\)</span> 二进制的第 <spanclass="math inline">\(k\)</span> 位数字：</strong><ol type="1"><li>先把第 <span class="math inline">\(k\)</span> 位移到最后一位 <spanclass="math inline">\(x&gt;&gt;k\)</span></li><li>看个位是几 <span class="math inline">\(x \&amp; 1\)</span></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt;&gt; k &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><strong>返回 <span class="math inline">\(x\)</span>的最后一位1：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 判断 x 是奇数还是偶数 */</span></span><br><span class="line">x &amp; <span class="number">1</span><span class="comment">// 返回 1：奇数返回 0：偶数</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[x=\left( 1010 \right) _2\Rightarrow lobit\left( x \right) =\left( 10\right) _2\\x=\left( 101000 \right) _2\Rightarrow lobit\left( x \right) =\left( 1000\right) _2\]</span></p><blockquote><p>最常见的应用：统计某个二进制数中 1 的个数</p></blockquote><ul><li><strong>将 <span class="math inline">\(x\)</span> 二进制的第 <spanclass="math inline">\(k\)</span> 位数字取反</strong> ——xor异或<strong>取反</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x ^ <span class="number">1</span> &lt;&lt; k</span><br></pre></td></tr></table></figure><ul><li><strong>将 <span class="math inline">\(x\)</span> 二进制的第 <spanclass="math inline">\(k\)</span> 位数字置 1</strong>——OR 或 <strong>置1</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x | <span class="number">1</span> &lt;&lt; k</span><br></pre></td></tr></table></figure><ul><li><strong>将 <span class="math inline">\(x\)</span> 二进制的第 <spanclass="math inline">\(k\)</span> 位数字置 0：</strong>——AND <strong>置0</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp; (~ (<span class="number">1</span> &lt;&lt; k))</span><br></pre></td></tr></table></figure><ul><li><strong>将 x 乘以 <spanclass="math inline">\(2^k\)</span>​</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&lt; k</span><br><span class="line"><span class="comment">// eg: 2^k 可以表示为 2 &lt;&lt; k</span></span><br></pre></td></tr></table></figure><ul><li>注意位运算符的<strong>优先级</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404282138608.png"alt="image-20240428213806356" /><figcaption aria-hidden="true">image-20240428213806356</figcaption></figure><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7958394/">AcWing801. 二进制中1的个数 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8279228/">AcWing90. 64位整数乘法 - AcWing</a></li><li><ahref="https://leetcode.cn/problems/single-number/description/">136.只出现一次的数字 - 力扣（LeetCode）</a></li></ul><h2 id="二进制状态压缩"><a id="erjinzhi">二进制状态压缩</a></h2><p>二进制状态压缩，是指用一个 <strong><spanclass="math inline">\(N\)</span> 位二进制整数<spanclass="math inline">\([b_0,b_1,\cdots,b_{N-1}]\)</span></strong>表示<strong>状态</strong>的方法</p><ul><li><p><span class="math inline">\(N\)</span> 位二进制数从下标 <spanclass="math inline">\(0\)</span> 开始存储</p></li><li><p><span class="math inline">\(N\)</span> 的第 <spanclass="math inline">\(k(0\le k \le N-1)\)</span> 位</p></li></ul><h3 id="notations">Notations</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; state;      <span class="comment">// 存储所有合法状态</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; head[M];    <span class="comment">// head[a] 存储状态 a 的所有合法的转移状态&#123;...&#125;</span></span><br><span class="line"><span class="type">int</span> ones[M];   <span class="comment">// ones[i] 存储状态 i 的二进制表示中 1 的个数</span></span><br><span class="line"><span class="type">int</span> log2[M];   <span class="comment">// log2[i] 存储 以 2 为底 i 的对数，其中 i 为 2的指数幂</span></span><br></pre></td></tr></table></figure><h3 id="常见的操作">常见的操作</h3><ul><li>预处理得到 <code>log2[]</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理得到 log2[]</span></span><br><span class="line"><span class="type">int</span> log2[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    log2[<span class="number">1</span> &lt;&lt; i] = i;</span><br></pre></td></tr></table></figure><ul><li>二进制状态中 <span class="math inline">\(1\)</span> 的个数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回某一状态 x 的二进制表示中 1 的个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">        cnt ++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 预处理所有状态的二进制表示中 1 的个数 */</span></span><br><span class="line"><span class="type">int</span> ones[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i++)</span><br><span class="line">    ones[i] = count(i);</span><br></pre></td></tr></table></figure><ul><li>依次得到二进制 <span class="math inline">\(x\)</span> 状态中 1的下标/位数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = log2[lowbit(i)];<span class="comment">// 当前下标 t 对应的位为 1</span></span><br><span class="line">    <span class="comment">/* 题目具体逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>依次得到二进制 <span class="math inline">\(x\)</span> 状态中 0的下标/位数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> - x; i; i -= lowbit(i))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = log2[lowbit(i)];<span class="comment">// 当前下标 t 对应的位为 1</span></span><br><span class="line">    <span class="comment">/* 题目具体逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>(1 &lt;&lt; N) - 1 - x</code> 会将 <spanclass="math inline">\(x\)</span> 二进制中的所有 1 变为 0，所有 0 变为1</p></blockquote><ul><li>判断某二进制状态中是否存在连续的 <spanclass="math inline">\(1\)</span></li></ul><p><span class="math display">\[x=a_na_{n-1}\cdots a_2a_1\\x\gg 1=0a_n\cdots a_3a_2\]</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断某二进制状态中是否存在连续的 1 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; x &gt;&gt; <span class="number">1</span>;<span class="comment">// 存在返回 1，不存在返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断某二进制状态中是否合法（不存在连续的 0 ） */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(x &amp; x &gt;&gt; <span class="number">1</span>);<span class="comment">// 合法返回 true，不合法返回 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断某二进制状态中是否存在连续 3 个 1 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; x &gt;&gt; <span class="number">1</span>) &amp;&amp; (x &gt;&gt; <span class="number">1</span> &amp; x &gt;&gt; <span class="number">2</span>);<span class="comment">// 存在返回 true，不存在返回 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断某二进制状态中是否合法（不存在连续 3 个 1） */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !((x &amp; x &gt;&gt; <span class="number">1</span>) &amp;&amp; (x &gt;&gt; <span class="number">1</span> &amp; x &gt;&gt; <span class="number">2</span>));<span class="comment">// 合法返回 true，不合法返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断某二进制状态中是否存在连续的、长度为奇数的 <spanclass="math inline">\(1\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断某二进制状态中是否存在连续的、长度为奇数的 0 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)<span class="comment">// 0 的个数为奇数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 预处理所有状态的二进制表示中是否存在连续的、长度为奇数的 0 */</span></span><br><span class="line"><span class="type">bool</span> st[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)</span><br><span class="line">st[i] = check(i);</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><ul><li><p><strong><span class="math inline">\(x\)</span> 的第 <spanclass="math inline">\(k\)</span> 位</strong>，这里的 <spanclass="math inline">\(k\)</span> 从 <spanclass="math inline">\(0\)</span> 开始。但是在实际问题中，第 <spanclass="math inline">\(k\)</span> 位表示的实际含义有可能是从 <spanclass="math inline">\(k=1\)</span> 开始</p></li><li><p>因此我们只需要从下标 0 开始存储第 <spanclass="math inline">\(k\)</span> 位表示的实际含义即可</p></li></ul><h2 id="例题-5">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8772341/">LeetCode78. 子集 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8400569/">AcWing166. 数独 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8490430/">AcWing321. 棋盘分割 - AcWing</a></li><li><ahref="D:\downloads\hexo\blog\source_posts\算法【动态规划】.md#zhuangtaiyasuo">状态压缩DP</a></li><li><ahref="D:\downloads\hexo\blog\source_posts\算法【搜索】.md#kaiguanwenti">递推之开关问题</a></li></ul><h1 id="离散化">离散化</h1><h2 id="模板-1">模板</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404191822132.png"alt="image-20240419182257583" /><figcaption aria-hidden="true">image-20240419182257583</figcaption></figure><ul><li><p><strong>本质</strong>：建立了<strong>一段数列</strong>到<strong>自然数</strong>之间的映射关系（value-&gt;index)，通过建立新索引，来<font color = 'red'><strong>缩小目标区间</strong></font></p></li><li><p><strong>适用条件</strong>：<font color='red'><strong>值域 ＞&gt;个数</strong></font></p></li><li><p>离散化有 <span class="math inline">\(2\)</span> 种类型</p><ul><li><font color = 'blue'><strong>保序</strong></font>型离散化：<strong>排序+去重</strong>，可以进行一系列连续数组可以进行的操作（比如二分，前缀和…）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; alls;<span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 离散化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">discrete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sort(alls.begin(), alls.end());<span class="comment">// 排序</span></span><br><span class="line">    alls.erase(unique(alls.begin(), alls.end()), alls.end());<span class="comment">// 去重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询 x 映射为哪个 0 ~ m - 1 之间的整数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(alls.begin(), alls.end(), x) - alls.begin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404191826158.png"alt="image-20240419182622655" /><figcaption aria-hidden="true">image-20240419182622655</figcaption></figure><ul><li><font color = 'blue'><strong>非保序</strong></font>型离散化：<strong>哈希表<code>unordered_map</code></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get函数返回离散化之后的下标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (h.count(x) == <span class="number">0</span>)</span><br><span class="line">        h[x] = idx ++;</span><br><span class="line">    <span class="keyword">return</span> h[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="例题-6">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7958787/">AcWing802. 区间和 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8407518/">AcWing237. 程序自动分析 - AcWing</a></li></ul><h1 id="区间合并">区间合并</h1><h2 id="模板-2">模板</h2><ul><li>将所有存在交集的区间合并</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261048486.png" alt="image-20240306142625082" style="zoom: 25%;" /></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7960049/">AcWing803. 区间合并 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模板一：需要返回【合并后的区间】 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span> <span class="comment">// segments线段</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模板二：只需要返回合并后的区间的数量、长度等等 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">PII segs[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间合并</span></span><br><span class="line">    <span class="built_in">sort</span>(segs, segs + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右端点初始化为【负无穷】</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; segs[i].first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始的[-无穷，-无穷]区间要跳过，不能装入</span></span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">                <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">            st = segs[i].first, ed = segs[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ed = <span class="built_in">max</span>(ed, segs[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最后一个区间</span></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">        <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-7">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8282539/">AcWing1343. 挤牛奶（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8287992/">AcWing422. 校门外的树 - AcWing</a></li></ul><h1 id="贡献法">贡献法</h1><p>​<strong>贡献法</strong>：从<strong>枚举</strong>的思路改为每个元素能<strong>为总和贡献</strong>多少，跟贪心一样是一种思想，没有固定的模板和套路，只能因题而异。</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8277974/">AcWing4261. 孤独的照片（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8280953/">AcWing2868. 子串分值（蓝桥杯辅导课） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8280737/">AcWing5154. 牛的基因学 - AcWing</a></li></ul><h1 id="前后缀分解">前后缀分解</h1><p>​ 以<a href="https://www.acwing.com/solution/content/250083/">AcWing1056. 股票买卖 III - AcWing</a>为例，如果考虑所有交易 <spanclass="math inline">\(2\)</span> 次的情况（抽象为 <spanclass="math inline">\(2\)</span> 个不重合的区间），那么我们可以枚举<span class="math inline">\(2\)</span> 次交易的分界点 <spanclass="math inline">\(i\)</span>，这样就将题目简化为 <spanclass="math inline">\(2\)</span> 个独立的子问题</p><ul><li>在区间 <span class="math inline">\([1,i]\)</span>完成第一次交易</li><li>在区间 <span class="math inline">\([i,n]\)</span>完成第二次交易</li></ul><p><strong>例题</strong></p><ul><li><a href="https://www.acwing.com/solution/content/250083/">AcWing1056. 股票买卖 III - AcWing</a></li><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/12257712/">AcWing341. 最优贸易 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】</title>
      <link href="/2024/02/29/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91/"/>
      <url>/2024/02/29/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="内外部搜索">内/外部搜索</h1><ol type="1"><li>搜索有 <span class="math inline">\(2\)</span> 大类：</li></ol><ul><li><p><strong>内部搜索</strong>：把棋盘中的<strong>每个格子</strong>当作一个<strong>点</strong>，从<strong>棋盘内</strong>中的<strong>一个点</strong>搜索到<strong>另一个点</strong>——不需要恢复现场</p></li><li><p><strong>外部搜索</strong>：把<strong>整个棋盘</strong>当作一个<strong>点</strong>，从<strong>一个棋盘状态</strong>搜索到<strong>另一个棋盘状态</strong></p><ul><li>在<strong>棋盘现场/点</strong>上直接操作，需要<strong>恢复现场</strong></li><li>拷贝<strong>棋盘现场/点</strong>，然后在<strong>棋盘现场/点的副本</strong> 上操作，不需要恢复现场</li></ul></li></ul><ol start="2" type="1"><li><p>是否需要回溯的关键在于——<code>st[][]</code>表示的这个<strong>状态/点</strong>能否被<font color = 'red'><strong>其他DFS分支</strong></font>搜索到，或者说<code>st[][]</code>表示的这个<strong>状态/点</strong>是否只能被访问1 次</p></li><li><p><strong>总结：</strong>只有<strong>可行性dfs</strong>（最优性也是需要的因为他还要搜其他路）和<strong>连通性dfs</strong>不需要恢复现场, 其他的 dfs 题都写吧~</p></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404041541544.png"alt="image-20240404154110448" /><figcaption aria-hidden="true">image-20240404154110448</figcaption></figure><span id="more"></span><h1 id="flood-fill">Flood FIll</h1><ol type="1"><li><p>搜索之<strong>连通性模型</strong>，即 <spanclass="math inline">\(Flood\ Fill\)</span> 洪水覆盖算法，有 <spanclass="math inline">\(DFS\)</span>、<spanclass="math inline">\(BFS\)</span> 两种实现方式</p><ul><li><p><span class="math inline">\(DFS\)</span> 代码简短，但是 <spanclass="math inline">\(DFS\)</span>只能求出<strong>是否连通</strong>，无法求出<strong>最短距离</strong>，且<span class="math inline">\(DFS\)</span>存在<strong>爆栈</strong>的风险；</p></li><li><p><span class="math inline">\(BFS\)</span> 代码略长，但是<spanclass="math inline">\(BFS\)</span>既能求出<strong>是否连通</strong>，又能求出<strong>最短距离</strong>，且不存在爆栈风险</p></li></ul></li><li><p><strong>适用题目</strong>：求<strong>连通块</strong></p></li><li><p><strong>技巧</strong>：进行<strong>不同方向的搜索</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4 联通</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 联通</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y +<span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == t.x &amp;&amp; j == t.y)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/* ...... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟中国象棋中的“马”</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="dfs">DFS</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8291582/">AcWing1112. 迷宫 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8292209/">AcWing1113. 红与黑 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8408743/">AcWing2060. 奶牛选美（每日一题） - AcWing</a></p></li></ul><h2 id="bfs">BFS</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8785320/">LeetCode994. 腐烂的橘子 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8236928/">AcWing1097. 池塘计数 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8263353/">AcWing1106. 山峰和山谷 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8262814/">AcWing1098. 城堡问题 - AcWing</a></li></ul><h1 id="bfs-1">BFS</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403300912028.png" alt="image-20240330091250874" style="zoom: 25%;" /></p><ul><li><span class="math inline">\(BFS\)</span>通常用于<strong>求最小</strong></li><li><span class="math inline">\(BFS\)</span> 基于<strong>迭代</strong>，<span class="math inline">\(DFS\)</span>基于<strong>递归</strong>，递归相较于迭代需要更多的时间和空间，因此<font color = 'red'><strong>能用<span class="math inline">\(BFS\)</span> 我们通常不用 <spanclass="math inline">\(DFS\)</span></strong></font></li><li><spanclass="math inline">\(BFS\)</span>过程中，如果要<strong>加判断</strong>进行<strong>剪枝</strong>，只能在<font color = 'blue'><strong>入队前</strong></font>（2处代码）/<font color = 'blue'><strong>出队后</strong></font>（1处代码）判断</li><li><code>st[][]</code>必须在<strong>入队后</strong>标记为<strong>已访问</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">PII q[M]; <span class="comment">// 注意：队列大小要开 N * N</span></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  入队前加判断 */</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++tt] = &#123;sx, sy&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始值为 -1，表示未访问</span></span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q[hh++];</span><br><span class="line">        <span class="comment">/*  出队后加判断 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; n &amp;&amp; !st[a][b] &amp;&amp; ...)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*  入队前加判断 */</span></span><br><span class="line">                q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">                st[a][b] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路模型">最短路模型</h2><ul><li><strong>要求</strong>：<strong>边权</strong>都<font color ='red'><strong>相等</strong></font>且<font color ='red'><strong>大于<span class="math inline">\(0\)</span></strong> </font></li><li><strong>注意：</strong>以二维坐标系上的点为例<ul><li><strong>最短距离</strong>：使用<code>dist[i][j]</code>存储 <spanclass="math inline">\((i,j)\)</span>距离<strong>源点</strong>的最短距离，同时充当<code>st[]</code>的作用</li><li><strong>记路径找前驱</strong>：使用<code>pre[][]</code>记录搜索路径，同时充当<code>st[]</code>的作用</li></ul></li></ul><h3 id="单源bfs">单源BFS</h3><p><strong>适用题目</strong>：求棋盘内的点 到<strong>一个起点</strong>的<strong>最短路径</strong></p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7996829/">AcWing844. 走迷宫 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8269590/">AcWing1076. 迷宫问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8269663/">AcWing188. 武士风度的牛 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8270123/">AcWing1100. 抓住那头牛 - AcWing</a></li></ul><h3 id="多源bfs">多源BFS</h3><ul><li><p><strong>适用题目</strong>：求棋盘内的点 到<strong>多个起点</strong>路径中的<strong>最短路径</strong></p></li><li><p><strong>关键</strong>：<strong>初始时</strong>将<font color = 'red'><strong>所有源点</strong></font>先<strong>入队</strong>，然后进行正常的BFS 即可</p></li><li><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11676142/">AcWing173. 矩阵距离 - AcWing</a></p></li></ul><h2 id="最小步数模型"><a id="BFS_最小步数模型">最小步数模型</a></h2><ul><li><p><strong>适用题目</strong>：一个<strong>局面</strong> 变成<strong>另一个局面</strong> 所需的最少<strong>操作步数</strong></p></li><li><p><strong>关键</strong>：【<strong>外部搜索</strong>】把<strong>局面</strong>看作<strong>点</strong>，把<strong>操作</strong>看作<strong>边</strong></p></li><li><p><strong>难点</strong>：如何将<strong>局面</strong>抽象为<strong>点</strong>（将<strong>局面</strong>通过<strong>变量</strong>唯一确定下来）</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8218005/">AcWing845. 八数码 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8284313/">AcWing1107. 魔板 - AcWing</a></p></li></ul><h2 id="双端队列广搜">双端队列广搜</h2><h2 id="双向bfs">双向BFS</h2><p>​ 双向 BFS 的思想与双向 DFS 的思想完全相同，我们就不再重复描述。因为BFS 本身就是逐层搜索的算法，所以双向 BFS的实现更加自然、简便。以普通的求最少步数的双向 BFS为例，我们只需从起始状态、目标状态分别开始，<strong>两边轮流进行，每次各扩展一整层</strong>。当两边各自有一个状态在记录数组中发生重复时，就说明这两个搜索过程相遇了，可以合并得出起点到终点的最少步数。</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8818989/">AcWing190. 字串变换 - AcWing</a></li></ul><h2 id="a">A*</h2><h1 id="dfs-1">DFS</h1><ul><li><p><code>dfs</code> 有两种方法记录<strong>搜索路径</strong>：</p><ul><li><font color = 'red'><strong>函数形参</strong></font>：特别适合于搜索路径是string类型，以<ahref="https://www.acwing.com/activity/content/code/content/8785277/">LeetCode17. 电话号码的字母组合 - AcWing</a>为例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string digits;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string number[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// path 记录搜索路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, string path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : number[digits[u] - <span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>，, path + c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; n = digits.<span class="built_in">length</span>(), <span class="keyword">this</span> -&gt; digits = digits;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="string">&quot;&quot;</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><font color='red'><strong>全局变量</strong></font>：更常用，切记要<strong>恢复现场</strong>，以<ahref="https://www.acwing.com/activity/content/code/content/8342624/">AcWing94. 递归实现排列型枚举 - AcWing</a>为例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 标记每个数是否使用过</span></span><br><span class="line"><span class="type">int</span> path[N]; <span class="comment">// 记录方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u 表示当前得到的序列中元素的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);     <span class="comment">// 不能直接对 u 进行操作</span></span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">            path[u] = <span class="number">0</span>;     <span class="comment">// 也可以省略这个,因为之后的会覆盖 path[u]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>DFS</code>的关键在于<strong>搜索顺序</strong>：按照什么顺序搜索才能<strong>不重不漏地搜素出所有合法方案</strong></p></li></ul><h2 id="搜索顺序">搜索顺序</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7994793/">AcWing843. n-皇后问题 - AcWing</a>、<ahref="https://www.acwing.com/solution/content/252257/">AcWing 1114.棋盘问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8295785/">AcWing1116. 马走日 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8299052/">AcWing1117. 单词接龙 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8303209/">AcWing1118. 分成互质组 - AcWing</a></li></ul><p><strong>简单版：</strong></p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8785293/">LeetCode39. 组合总和 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8784848/">LeetCode79. 单词搜索 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8785277/">LeetCode17. 电话号码的字母组合 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8785299/">LeetCode22. 括号生成 - AcWing</a></li></ul><h2 id="剪枝与优化">剪枝与优化</h2><p>​剪枝，就是减小搜索树规模、尽早排除搜索树中不必要的分支的一种手段。形象地看，就好像剪掉了搜索树的枝条，故被称为“剪枝”。在深度优先搜索中，有以下几类常见的剪枝方法：</p><h3 id="优化搜索顺序">优化搜索顺序</h3><p>​在一些搜索问题中，搜索树的各个层次、各个分支之间的顺序不是固定的。不同的搜索顺序会产生不同的搜索树形态，其规模大小也相差甚远。例如：</p><p>（1）在上一节的 <ahref="https://www.acwing.com/activity/content/code/content/8399835/">AcWing165. 小猫爬山 - AcWing</a> 问题中，把小猫按照重量递减的顺序进行搜索</p><p>（2）在上一节的 <ahref="https://www.acwing.com/activity/content/code/content/8400569/">AcWing166. 数独</a> 问题中，优先搜索“能填的合法数字”最少的位置</p><blockquote><p>大部分情况下，我们应该优先搜索<font color = 'red'><strong>分支较少的节点</strong></font></p></blockquote><h3 id="排除等效冗余">排除等效冗余</h3><p>​在搜索过程中，如果我们能够判定从搜索树的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分支执行搜索。我们会在本节的<ahref="https://www.acwing.com/activity/content/code/content/8400608/">AcWing167. 木棒</a> 问题中看到该剪枝的应用。 ​ 另外，就如我们在 <ahref="https://www.acwing.com/activity/content/code/content/8400569/">AcWing166. 数独</a>问题中提出的，初学者一定要避免重叠、混淆“层次”与“分支”，避免遍历若干棵覆盖同一状态空间的等效搜索树。</p><h3 id="可行性剪枝">可行性剪枝</h3><p>​在搜索过程中，及时对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。这就好比我们在道路上行走时，远远看到前方是一个死胡同，就应该立即折返绕路，而不是走到路的尽头再返回。​某些题目条件的范围限制是一个区间，此时可行性剪枝也被称为“上下界剪枝”。</p><h3 id="最优性剪枝">最优性剪枝</h3><p>​在最优化问题的搜索过程中，如果当前花费的代价已经超过了当前搜到的最优解，那么无论采取多么优秀的策略到达递归边界，都不可能更新答案。此时可以停止对当前分支的搜索，执行回溯。</p><h3 id="例题">例题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8400608/">AcWing167. 木棒 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8400569/">AcWing166. 数独 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8399835/">AcWing165. 小猫爬山 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11818008/">AcWing168. 生日蛋糕 - AcWing</a></p></li></ul><h2 id="迭代加深">迭代加深</h2><p>​深度优先搜索每次选定一个分支，不断深入，直至到达递归边界才回溯。这种策略带有一定的缺陷。试想以下情况：搜索树<strong>某些分支的层数非常深</strong>，但是<strong>问题的答案在某个较浅的层上</strong>。如果深搜在一开始选错了分支，就很可能在不包含答案的深层子树上浪费许多时间。​如果下图左半部分是问题的状态空间，五角星标识着答案，那么深度优先搜索算法产生的搜索树就如下图右半部分所示，算法在矩形圈出的深层子树上浪费了很多时间。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408210008801.png"alt="image-20240821000800289" /><figcaption aria-hidden="true">image-20240821000800289</figcaption></figure><p>​此时，我们可以从小到大限制搜索的深度，如果在当前深度限制下搜不到答案，就把深度限制增加，重新进行一次搜索，这就是<strong>迭代加深</strong>思想。所谓“迭代”，就是以上一次的结果为基础，重复执行以逼近答案的意思。选代加深DFS的过程如下：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408210009882.png"alt="image-20240821000912423" /><figcaption aria-hidden="true">image-20240821000912423</figcaption></figure><p>​ 虽然该过程在深度限制为 <span class="math inline">\(d\)</span>时，会重复搜索第 <span class="math inline">\(1\sim d-1\)</span>层的节点，但是当搜索树节点分支数目较多时，随着层数的深入，每层节点数会呈指数级增长，这点重复搜索与深层子树的规模相比，实在是小巫见大巫了。​总而言之，当<strong>搜索树规模随着层次的深入增长很快，并且我们能够确保答案在一个较浅层的节点</strong>时,就可以采用迭代加深的深度优先搜索算法来解决问题。读者可以进行大致的估算,有些题目描述甚至会包含“如果10步以内搜不到结果就算无解”的字样</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8811059/">AcWing170. 加成序列 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8423647/">AcWing187. 导弹防御系统 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8409818/">AcWing1243. 糖果（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="双向dfs">双向DFS</h2><p>​除了迭代加深之外，双向搜索也可以避免在深层子树上浪费时间。在一些题目中，问题不但具有“初态”，还具有明确的“终态”，并且从初态开始搜索与从终态开始逆向搜索产生的搜索树都能覆盖整个状态空间。在这种情况下，就可以采用<strong>双向搜索——从初态和终态出发各搜索一半状态，产生两棵深度减半的搜索树，在中间交会、组合成最终的答案。</strong></p><p>​如下图所示,左侧是直接进行一次搜索产生的搜索树,右侧是双向搜索的两棵搜索树，避免了层数过深时分支数量的大规模增长。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409031539119.png"alt="image-20240903153932903" /><figcaption aria-hidden="true">image-20240903153932903</figcaption></figure><h2 id="ida">IDA*</h2><h2 id="重复覆盖模型">重复覆盖模型</h2><p>舞蹈链（Dancing LinksX，DLX）是专门解决精确覆盖与重复覆盖问题的数据结构，而著名的 <spanclass="math inline">\(n\)</span>皇后问题与数独问题都可化为精确覆盖问题。DLX的本质是双向十字循环链表。</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8409818/">AcWing1243. 糖果（蓝桥杯辅导课） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7994793/">AcWing843. n-皇后问题 - AcWing</a></li></ul><h2 id="最小步数模型-1">最小步数模型</h2><p><span class="math inline">\(BFS\)</span>可用于求解最小步数模型，<strong>但是</strong>在某些情况下，<spanclass="math inline">\(BFS\)</span> 求解最小步数存在</p><ul><li>空间消耗大：需要存储每层指数级别的节点数量，存在爆栈风险</li><li>无法对搜索进行<strong>剪枝</strong>：相较于 <spanclass="math inline">\(DFS\)</span> 而言</li><li>节点状态难以定义</li></ul><p>因此在某些情况下，我们需要使用 <spanclass="math inline">\(DFS\)</span> 爆搜求最小步数（如<ahref="https://www.acwing.com/activity/content/code/content/8423647/">AcWing187. 导弹防御系统 - AcWing</a>）。但与 <spanclass="math inline">\(BFS\)</span> 不同的是，<spanclass="math inline">\(DFS\)</span>第一次搜索到的节点不一定是步数最短的节点，因此需要进行额外处理，一般有两种处理方式：</p><ul><li><strong>全局变量记录最小值</strong>：搜索过程中不断更新（<ahref="https://www.acwing.com/video/365/">AcWing 187.导弹防御系统（算法提高课） - AcWing</a>）</li><li><strong>迭代加深</strong>：一般平均答案深度较低时可以采用这种方式（<ahref="https://www.acwing.com/video/348/">AcWing 187. 导弹防御系统 -AcWing</a>）</li></ul><h1 id="递归与递推">递归与递推</h1><h2 id="递推">递推</h2><p>以斐波那契序列为例：<ahref="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法- AcWing</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">0</span>, f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="开关问题"><a id="kaiguanwenti">开关问题</a></h3><p>用于解决开关问题的题目均具备 <span class="math inline">\(2\)</span>个特点</p><ol type="1"><li><strong>每个开关至多只能按 <span class="math inline">\(1\)</span>次</strong>（按 <span class="math inline">\(2\)</span> 次相当于没按，按<span class="math inline">\(3\)</span> 相当于只按下 <spanclass="math inline">\(1\)</span> 次）</li><li><strong>最终解与按下开关的顺序无关</strong>（即：每个灯泡的最终状态只与影响其状态的操作次数之和有关）</li></ol><blockquote><p>参考<ahref="D:\downloads\hexo\blog\source_posts\算法【基本算法】.md#erjinzhi">二进制状态压缩</a></p></blockquote><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8345157/">AcWing95. 费解的开关 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/241197/">AcWing1208. 翻硬币 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11792432/">AcWing116. 飞行员兄弟 - AcWing</a></p></li></ul><h3 id="动态规划">动态规划</h3><p><ahref="https://njfjnkm.github.io/2024/03/25/%5Bobject%20Object%5D/算法/【动态规划】/">【动态规划】| 天道酬勤，厚德载物 (njfjnkm.github.io)</a></p><h3 id="滚动数组状态压缩">滚动数组/状态压缩</h3><p><strong>滚动数组/状态压缩</strong>是对<strong>递归</strong>的改进，主要用于<strong>空间优化</strong></p><h2 id="递归">递归</h2><ul><li>递归的关键在于寻找<strong>顺序</strong>，能够<strong>不重不漏地搜素出所有方案</strong></li><li>所有的<strong>递归</strong>问题最终都可以转化成一棵<font color = 'red'><strong>递归搜索树</strong></font></li></ul><p>以斐波那契序列为例：<ahref="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法- AcWing</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/6489818/">论递归算法的数学原理- AcWing</a></p></blockquote><h3 id="记忆化搜索">记忆化搜索</h3><ul><li><p>记忆化搜索是对<strong>递归</strong>的改进，主要用于解决<strong>重复搜索</strong>的问题</p></li><li><p><strong>基本思想：开一个大数组记录中间结果，如果一个状态被计算过，则直接查表，否则再递归计算</strong></p></li><li><p><strong>具体实现：</strong>在原始 <spanclass="math inline">\(dfs\)</span>​ 的基础上：</p><ul><li>增加 <code>f[]</code> 数组，<strong><spanclass="math inline">\(f\)</span> 的各个维度与 <spanclass="math inline">\(dfs\)</span> 的函数参数一一对应</strong></li><li>根据具体问题，将 <code>f[]</code> 初始化为 <spanclass="math inline">\(dfs\)</span> 不可能的返回值（例如 <spanclass="math inline">\(0\)</span>、<spanclass="math inline">\(-1\)</span>、<spanclass="math inline">\(inf\)</span>、<spanclass="math inline">\(-inf\)</span>等，这里假设为 <spanclass="math inline">\(-1\)</span>）</li><li>在 原始 <span class="math inline">\(dfs\)</span>​ 的最开始处，根据<code>f[]</code> 的取值是否为初始值，判断本次 <spanclass="math inline">\(dfs\)</span>​ 是否曾经搜索过：<ul><li>本次 <span class="math inline">\(dfs\)</span> 搜索过：直接返回<code>f[]</code></li><li>否则继续执行</li></ul></li><li>在 原始 <span class="math inline">\(dfs\)</span> 的<code>return</code> 处，用 <code>f[]</code> 记录本次 <spanclass="math inline">\(dfs\)</span> 的返回值</li><li>其余不变</li></ul></li><li><p>以<ahref="https://www.acwing.com/activity/content/code/content/8490430/">AcWing321. 棋盘分割 - AcWing</a>为例</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> f[M][M][M][M][N]; <span class="comment">// 增加 f[] 数组，f 的各个维度与 dfs 的函数参数一一对应</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f); <span class="comment">// 根据具体问题，将 f[] 初始化为 dfs 不可能的返回值（例如 0、-1、0x3f3f3f3f 等），本题初始化为 -nan</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> &amp;v = f[x1][y1][x2][y2][k];   <span class="comment">// 减小代码长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在 原始 dfs 的最开始处，根据 f[] 的取值是否为初始值，判断本次 dfs 是否曾经搜索过 */</span></span><br><span class="line"><span class="comment">// 本次 dfs 搜索过：直接返回 f[]</span></span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">0</span>)     <span class="comment">// 这里不能写成 if(v != -1) </span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 本次 dfs 没搜索过：则继续执行</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> v = get(x1, y1, x2, y2); <span class="comment">// 在 return 处，用 f[] 记录本次 dfs 的返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化为最大值</span></span><br><span class="line">    <span class="type">double</span> res = INF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 横切</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x1; i &lt; x2; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        res = min(res, dfs(x1, y1, i, y2, k - <span class="number">1</span>) + get(i + <span class="number">1</span>, y1, x2, y2));</span><br><span class="line">        res = min(res, dfs(i + <span class="number">1</span>, y1, x2, y2, k - <span class="number">1</span>) + get(x1, y1, i, y2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纵切</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = y1; i &lt; y2; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        res = min(res, dfs(x1, y1, x2, i, k - <span class="number">1</span>) + get(x1, i + <span class="number">1</span>, x2, y2));</span><br><span class="line">        res = min(res, dfs(x1, i + <span class="number">1</span>, x2, y2, k - <span class="number">1</span>) + get(x1, y1, x2, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v = res;     <span class="comment">// 在 return 处，用 f[] 记录本次 dfs 的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里对 double 类型数组按字节赋值 -1，结果为 -nan</p></blockquote><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8191621/">AcWing901. 滑雪 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8740899/">LeetCode1340. 跳跃游戏 V - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8490430/">AcWing321. 棋盘分割 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/251232/">AcWing4009. 收集卡牌 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8772879/">AcWing217. 绿豆蛙的归宿 - AcWing</a></p></li></ul><h3 id="简单运用">简单运用</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404160812350.png"alt="image-20240409142141963" /><figcaption aria-hidden="true">image-20240409142141963</figcaption></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8338997/">AcWing92. 递归实现指数型枚举 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8742768/">LeetCode131. 分割回文串 - AcWing</a></p></li></ul><hr /><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8345534/">AcWing93. 递归实现组合型枚举 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/253897/">AcWing1026. 乘积最大 - AcWing</a></p></li></ul><hr /><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8342624/">AcWing94. 递归实现排列型枚举 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8784183/">AcWing4957. 飞机降落（蓝桥杯辅导课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8352597/">AcWing1209. 带分数（蓝桥杯辅导课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8333433/">AcWing1360. 有序分数（每日一题） - AcWing</a></p></li></ul><h3 id="分治">分治</h3><p>​分治法把一个问题划分为若干个规模更小的同类子问题，对这些子问题<strong>递归</strong>求解然后在回溯时通过它们推导出原问题的解。</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8351803/">AcWing97. 约数之和 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Tag】</title>
      <link href="/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90tag%E3%80%91/"/>
      <url>/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90tag%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="tag">Tag</h1><h2 id="期望dp记忆化搜索">期望+DP+记忆化搜索</h2><ul><li><p><a href="https://www.acwing.com/solution/content/251232/">AcWing4009. 收集卡牌 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8772879/">AcWing217. 绿豆蛙的归宿 - AcWing</a></p></li></ul><h2 id="二分差分前缀和其他">二分+差分/前缀和+其他</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8212454/">AcWing503. 借教室（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8335344/">AcWing102. 最佳牛围栏（算法提高课） - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/254189/">AcWing4936. 子序列 - AcWing</a></p></li></ul><h2 id="二分合并区间">二分+合并区间</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8305828/">AcWing5407. 管道（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="二分贪心">二分+贪心</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8155307/">AcWing895. 最长上升子序列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8421970/">AcWing1010. 拦截导弹 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8423647/">AcWing187. 导弹防御系统 - AcWing</a></p></li></ul><h2 id="二分图论">二分+图论</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8575194/">AcWing361. 观光奶牛 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8569870/">AcWing340. 通信线路 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8540931/">AcWing1142. 繁忙的都市 - AcWing</a></li></ul><h2 id="差分贪心">差分+贪心</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8281317/">AcWing4655. 重新排序（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="贪心dp">贪心+DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8802847/">AcWing734. 能量石 - AcWing</a></li></ul><h2 id="双指针前缀和">双指针+前缀和</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8304518/">AcWing4405. 统计子矩阵（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="并查集离散化">并查集+离散化</h2><ul><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11822485/">AcWing237. 程序自动分析 - AcWing</a></li></ul><h2 id="并查集01背包">并查集+0/1背包</h2><ul><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11821366/">AcWing1252. 搭配购买 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】</title>
      <link href="/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91/"/>
      <url>/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91/</url>
      
        <content type="html"><![CDATA[<ul><li>图论的难点在于如何将具体问题<strong>抽象为图论中的模型</strong>，之后就是选择模板、默写代码</li><li>选择模板时，在能过的基础上，选择最熟悉的、代码最短的写法即可</li><li>对于无向树/图中的边 <span class="math inline">\(a\)</span> — <spanclass="math inline">\(b\)</span> ，存储两条有向边<code>a -&gt; b</code>、<code>b -&gt; a</code>即可，因此我们可以只考虑有向树/图的模型</li></ul><h1 id="树">树</h1><p>​ <strong>树是一种特殊的图</strong></p><p>:apple:无向树性质：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405101139307.png" alt="image-20240510113916052" style="zoom: 15%;" /></p><ul><li>无向树的<strong>任意一个节点</strong>都可以作为<strong>树的根节点</strong></li></ul><blockquote><p>可以想象为节点是有质量，边是没有质量的，将这个根节点拎起来即可</p></blockquote><ul><li>无向树中<strong>任意 <span class="math inline">\(2\)</span>个节点</strong>之间都是<strong>连通的</strong>，且<strong>路径唯一</strong></li></ul><p>:orange:有向树性质：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405101139785.png" alt="image-20240510113948565" style="zoom:15%;" /></p><ul><li>有向树的<strong>根节点是唯一的</strong>，即<strong>入度为 <spanclass="math inline">\(0\)</span></strong> 的节点</li><li>有向树中<strong>任意 <span class="math inline">\(2\)</span>个节点</strong>之间<strong>未必连通</strong>，但<strong>从根节点到任意一个节点</strong>都是<strong>连通的</strong>，且<strong>路径唯一</strong></li></ul><h2 id="树的存储">树的存储</h2><p>​ <span class="math inline">\(n\)</span> 个顶点，无向树有 <spanclass="math inline">\(m=n-1\)</span> 条边，有向树有 <spanclass="math inline">\(m=2\times (n-1)\)</span> 条边</p><p>:banana:<strong>树</strong>的题目<strong>只会告诉你顶点的数量</strong>（因为已知顶点的数量，边的数量是确定的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无向树 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="comment">/* 有向树 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">2</span> * N;</span><br></pre></td></tr></table></figure><p>:heart:树采用<font color ='blue'><strong>临界表</strong></font>存储</p><h3 id="有权树">有权树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点 k，开一个单链表，存储 k 所有可以走到的点</span></span><br><span class="line"><span class="comment">// h[k] 存储这个单链表的头结点，w[] 存储边的权重</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b，权重为 c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无权树">无权树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点 k，开一个单链表，存储 k 所有可以走到的点</span></span><br><span class="line"><span class="comment">// h[k] 存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><ul><li><a href="https://www.acwing.com/solution/content/249035/">AcWing 38.二叉树的镜像 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/249034/">AcWing 39.对称的二叉树 - AcWing</a></li></ul><h2 id="树的遍历">树的遍历</h2><ul><li><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n)\)</span>，<spanclass="math inline">\(n\)</span> 表示点数</li></ul><h3 id="无向树">无向树</h3><ul><li>无向树<strong>任选</strong>一个节点进行遍历即可，但需要<font color='red'><strong>避免重复遍历</strong></font>（否则一上一下会死循环，导致<span class="math inline">\(TLE/MLE\)</span>），有 <spanclass="math inline">\(2\)</span> 种方式<ul><li>使用 <code>st[]</code> 标记每个节点是否被遍历，代码与图的 <spanclass="math inline">\(dfs/bfs\)</span> 一摸一样</li><li><span class="math inline">\(dfs\)</span>在遍历时也可以传入父节点，判断是否相同，从而避免重复</li></ul></li></ul><h4 id="dfs">dfs</h4><ul><li>法1：使用 <code>st[]</code> 标记每个节点是否被遍历，代码与 <ahref="#图的dfs">图的dfs</a> 一模一样</li></ul><hr /><ul><li>法2：传入参数 <code>fa</code>，表示父节点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (u != fa)</span><br><span class="line">            dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bfs">bfs</h4><ul><li>有向树遍历时<strong>一定不会重复遍历</strong>，因此不需要<code>st[]</code></li><li>使用 <code>st[]</code> 标记每个节点是否被遍历，代码与 <ahref="#图的bfs">图的bfs</a> 一模一样</li></ul><h3 id="有向树">有向树</h3><ul><li>有向树<strong>必须从根节点开始</strong>进行遍历，永远不可能遍历一个节点两次，不需要判断是否重复遍历</li><li>寻找根节点的办法如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> has_fa[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入 n - 1 条边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    add(a, b);<span class="comment">// 添加一条从 a 走向 b 的有向边</span></span><br><span class="line">    has_fa[b] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求树的根节点（没有父节点）</span></span><br><span class="line"><span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (has_fa[root])</span><br><span class="line">    root++;</span><br></pre></td></tr></table></figure><h4 id="dfs-1">dfs</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">            dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>去掉了与 <code>st[]</code> 相关的部分</p></blockquote><h4 id="bfs-1">bfs</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            q.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>去掉了与 <code>st[]</code> 相关的部分</p></blockquote><h3 id="例题-1">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8792976/">AcWing1476. 数叶子结点 - AcWing</a></li></ul><h2 id="树的最短路">树的最短路</h2><ul><li>无向树中<strong>任意 <span class="math inline">\(2\)</span>​个节点</strong>之间都是<strong>连通的</strong>，且<strong>路径唯一</strong></li><li>有向树中<strong>任意 <span class="math inline">\(2\)</span>个节点</strong>之间<strong>未必连通</strong>，但<strong>从根节点到任意一个节点</strong>都是<strong>连通的</strong>，且<strong>路径唯一</strong></li></ul><p>​ 因此：</p><ul><li>通常情况下，我们只对<font color ='red'><strong>无向树</strong></font>求最短路径</li><li><strong>无向树</strong>的最短路径即为 dfs / bfs的一条<strong>有效路径</strong></li></ul><h3 id="dfs-2">dfs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father, <span class="type">int</span> distance)</span></span><br><span class="line">&#123;</span><br><span class="line">    dist[u] = distance;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != father)</span><br><span class="line">            dfs(j, u, distance + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设求 1 号节点到其他所有点的最短距离</span></span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="bfs-2">bfs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.push(u);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[u] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的直径">树的直径</h2><p><strong>树的直径</strong> 是 树中长度最长的路径，可以使用树型 <spanclass="math inline">\(DP\)</span> 求解</p><p>​任选一个点作为无向树的根节点，将这个根节点拎起来（可以想象为节点是有质量，边是没有质量的），考虑从集合的角度划分问题：</p><ul><li><p>任何一条路径 都可以划分到其 <strong>路径最高节点</strong>对应的集合</p></li><li><p><span class="math inline">\(dp[u]\)</span> 表示以 <spanclass="math inline">\(u\)</span>（<span class="math inline">\(u =1,2,...,n\)</span>）为 <strong>路径最高点</strong>的所有路径下的最长路径</p></li></ul><p>如下图，红色线便是<spanclass="math inline">\(u\)</span>作为制高点的一条路径（同时也正好是 <spanclass="math inline">\(u\)</span> 集合下的一条最长路径）</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405101317859.png"alt="image-20240510131706551" /><figcaption aria-hidden="true">image-20240510131706551</figcaption></figure><p>​ 考虑上图，我们已知了 <span class="math inline">\(dp[2]\)</span> 和<span class="math inline">\(dp[3]\)</span>，如何使用树形 <spanclass="math inline">\(dp\)</span> 的思想求解 <spanclass="math inline">\(dp[1]\)</span>？我们可以发现：</p><ul><li><span class="math inline">\(dp[1]\)</span> 和 <spanclass="math inline">\(dp[2]\)</span>、<spanclass="math inline">\(dp[3]\)</span> 之间并没有直接关系</li><li>但<strong>以 <span class="math inline">\(1\)</span>​为制高点的最长路径</strong>：<ul><li>要么选择其下方<font color='blue'><strong>最长的一条路径</strong></font>（此时次长路径的长度&lt; 0）</li><li>要么选择其下方<font color='blue'><strong>每一个儿子方向上的路径最长的两条</strong></font>（此时次长路径的长度&gt; 0）</li></ul></li></ul><p>所以我们可以存储<strong>每个点往下能走的最长路径</strong>（记作<code>maxlen</code>），那么我们可以得到转移方程：</p><p><span class="math display">\[dp[u] = max _1\left\{ \max len\left( son_i \right) +w\left[ u \right]\left[ son_i \right] \right\} +max _2\left\{ \max len\left( son_i\right) +w\left[ u \right] \left[ son_i \right] \right\}\]</span> 其中，<span class="math inline">\(max_1\)</span>​表示最大值，<span class="math inline">\(max_2\)</span>​ 表示次大值，<spanclass="math inline">\(maxlen\)</span> 显然是可以递归的，可以使用 <spanclass="math inline">\(dfs\)</span> 求解，即 <spanclass="math display">\[maxlen(u)=max(maxlen[son_i]+w[u][son_i])\]</span> 最终答案即为 <span class="math inline">\(dp\)</span>​数组中的最大值</p><p><strong>注意：</strong></p><ul><li>假设顶点 <span class="math inline">\(u\)</span> 有 <spanclass="math inline">\(t\)</span> 个儿子节点 <spanclass="math inline">\(son_1\)</span>,...,<spanclass="math inline">\(son_t\)</span>，则 <spanclass="math inline">\(max_1\)</span>、<spanclass="math inline">\(max_2\)</span> 是从含有 <spanclass="math inline">\(t+1\)</span> 条路径的集合 { <spanclass="math inline">\(u\)</span>，<spanclass="math inline">\(u\)</span>-&gt;<spanclass="math inline">\(son_1\)</span>-&gt;...，<spanclass="math inline">\(u\)</span>-&gt;<spanclass="math inline">\(son_2\)</span>-&gt;...，······，<spanclass="math inline">\(u\)</span>-&gt;<spanclass="math inline">\(son_t\)</span>-&gt;...} 中选出最长的 <spanclass="math inline">\(d_1\)</span> 和次长的 <spanclass="math inline">\(d_2\)</span><ul><li>路径 <span class="math inline">\(\{u\}\)</span> 的长度为 <spanclass="math inline">\(0\)</span>，因此我们将 <spanclass="math inline">\(max_1\)</span>、<spanclass="math inline">\(max_2\)</span> 的初值赋为 <spanclass="math inline">\(0\)</span></li></ul><blockquote><p>表示如果从当前节点 <span class="math inline">\(u\)</span>往每一个儿子方向上的 <span class="math inline">\(t\)</span>条路径长度最大值/次大值小于 <spanclass="math inline">\(0\)</span>，我们就<strong>不</strong>从当前这个点往下走，这样路径即为<span class="math inline">\(\{u\}\)</span>，距离为 <spanclass="math inline">\(0\)</span></p></blockquote><ul><li>剩下的 <span class="math inline">\(t\)</span> 条路径是当前节点 <spanclass="math inline">\(u\)</span> 往下走，每一个儿子方向上的路径，从第<span class="math inline">\(2\)</span> 个点开始就各不相同，所以这 <spanclass="math inline">\(t\)</span> 条路径也一定是完全不同的路径</li><li><span class="math inline">\(max_1\)</span> 一定是从当前顶点 <spanclass="math inline">\(u\)</span> 向下走的最大距离，但是 <spanclass="math inline">\(max_2\)</span> 不一定是从当前顶点 <spanclass="math inline">\(u\)</span>向下走的次大距离，因为最大距离和次大距离对应的路径有可能经过 <spanclass="math inline">\(u\)</span>的同一个儿子节点，但是我们的集合不包含这种情况</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">0</span>; <span class="comment">// 全局变量，记录最长路径，便于在 dfs 中更新（当路径中只有一个节点的路径长度为 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回从根节点 u 往下走的最大距离 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>; <span class="comment">// 根节点 u 往下走的最大距离 d1 和次大距离 d2，初始值为 0，表示不往下走，路径中只包含 u 的距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != father) <span class="comment">// 否则一上一下会死循环，导致 TLE/MLE</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = dfs(j, u) + w[i];</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= d1) <span class="comment">// 这里必须是 ≥</span></span><br><span class="line">                d2 = d1, d1 = t;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; d2) <span class="comment">// 这里可以是 &gt; 也可以是 ≥</span></span><br><span class="line">                d2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = max(ans, d1 + d2); <span class="comment">// dp[u] = d1 + d2，直接更新最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8409456/">AcWing1207. 大臣的旅费（蓝桥杯辅导课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8493787/">AcWing1072. 树的最长路径 - AcWing</a></p></li></ul><h2 id="最近公共祖先lca">最近公共祖先LCA</h2><p>​ 给定一棵有根树，若节点 <span class="math inline">\(z\)</span>既是节点 <span class="math inline">\(x\)</span> 的祖先，也是节点 <spanclass="math inline">\(y\)</span> 的祖先，则称 <spanclass="math inline">\(z\)</span> 是 <spanclass="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>的公共祖先。在 <span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span> 的所有公共祖先中，深度最大的一个称为<span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span> 的最近公共祖先，记为 <spanclass="math inline">\(LCA(x,y)\)</span>​</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406081754498.png"alt="image-20240608175459145" /><figcaption aria-hidden="true">image-20240608175459145</figcaption></figure><p><span class="math inline">\(LCA(x,y)\)</span> 是 <spanclass="math inline">\(x\)</span> 到根的路径与 <spanclass="math inline">\(y\)</span> 到根的路径的交会点。它也是 <spanclass="math inline">\(x\)</span> 与 <spanclass="math inline">\(y\)</span>​之间的路径上深度最小的节点。求最近公共祖先的方法通常有三种：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406081937492.png"alt="image-20240608193703117" /><figcaption aria-hidden="true">image-20240608193703117</figcaption></figure><h3 id="树上倍增法">树上倍增法☆</h3><p>【<strong>模板题</strong>：<ahref="https://www.acwing.com/activity/content/code/content/8578980/">AcWing1172. 祖孙询问 - AcWing</a>】</p><h4 id="预处理">预处理</h4><p><span class="math inline">\(BFS\)</span> 预处理得到 <spanclass="math inline">\(depth[\ ]\)</span>、<spanclass="math inline">\(fa[\ ][\ ]\)</span></p><ul><li><span class="math inline">\(depth[i]\)</span> 表示 <spanclass="math inline">\(i\)</span> 的深度，<spanclass="math inline">\(1\le i \le n\)</span>​</li><li><span class="math inline">\(fa\left[ i,j \right]\)</span> 表示从<span class="math inline">\(i\)</span> 开始向上走 <spanclass="math inline">\(2^j\)</span> 步到达的节点，<spanclass="math inline">\(0\le j \le logn\)</span></li></ul><p><span class="math display">\[\begin{cases}    fa\left[ i,0 \right] =i\ \text{的父节点}\\    \\    fa\left[ i,j \right] =fa\left[ fa\left[ i,j-1 \right] ,j-1 \right],  1\le j\le logn\\\end{cases}\]</span></p><blockquote><ol type="1"><li>由于 <span class="math inline">\(2^j=2^{j-1}+2^{j-1}\)</span>，因此从 <span class="math inline">\(i\)</span> 向上跳 <spanclass="math inline">\(2^{j}\)</span> 步到达 <spanclass="math inline">\(fa[i,j]\)</span>，等价于先从 <spanclass="math inline">\(i\)</span> 向上跳 <spanclass="math inline">\(2^{j-1}\)</span> 步到达 <spanclass="math inline">\(fa[i,j-1]\)</span>，再从 <spanclass="math inline">\(fa[i,j-1]\)</span> 向上跳 <spanclass="math inline">\(2^{j-1}\)</span> 步最终到达 <spanclass="math inline">\(fa[i,j]\)</span></li><li>这类似于一个树型<spanclass="math inline">\(DP\)</span>过程，“阶段”就是节点的深度。因此，我们可以对树进行广度优先遍历，按照层次顺序，在节点入队之前，计算它在<span class="math inline">\(fa[]\)</span> 中相应的值</li></ol></blockquote><ul><li><strong>哨兵 <span class="math inline">\(0\)</span>号节点</strong>：<span class="math inline">\(depth[0]=0\)</span>，如果从<span class="math inline">\(i\)</span> 开始跳 <spanclass="math inline">\(2^j\)</span> 步会跳过根节点，那么 <spanclass="math inline">\(fa[i,j]=0\)</span></li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(nlogn)\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e4</span> + <span class="number">5</span>, M = <span class="number">2</span> * N + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];<span class="comment">// 16 = log(n) / log(2) 上取整</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> root)</span></span><br><span class="line">&#123;</span><br><span class="line">    depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++ tt] = root;</span><br><span class="line">    <span class="comment">// 初始化 fa[root][...] = 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!depth[j])<span class="comment">// 无向树需要使用标记数组</span></span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">                <span class="comment">/* 树型 DP 计算 fa[j][] */</span></span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++)</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询">查询</h4><p>基于 <span class="math inline">\(depth[\ ]\)</span>、<spanclass="math inline">\(fa[\ ][\ ]\)</span> 计算 <spanclass="math inline">\(LCA(a,b)\)</span>​</p><ul><li><strong>算法思想</strong>：</li></ul><ol type="1"><li>先将两个点跳到同一层</li><li>让两个点同时往上跳，一直跳到它们的<font color='red'><strong>最近公共祖先的下一层</strong></font></li></ol><blockquote><p>为什么要跳到最近公共祖先的下一层，而不是直接跳到最近公共祖先那一层呢？</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假如 fa[x][k] == f[y][k] &lt;=&gt; f[x][k] or f[y][k] 是 x 和 y 的一个公共祖先，但不一定是最近的</span><br><span class="line">      1        </span><br><span class="line">     / \      </span><br><span class="line">    2   3    </span><br><span class="line">   / \      </span><br><span class="line">  4   5   </span><br><span class="line"> / \  /   </span><br><span class="line">x  y 6</span><br><span class="line">举个例子，此时f[x][1] == f[y][1] = 节点2 是 x 和 y 的一个公共祖先 但不是最近公共祖先 4</span><br><span class="line">但由于我们是从大到小拼凑的，假如拼凑终止条件为 f[x][k] == f[y][k]，则此时会停在公共祖先 2 而非最近公共祖先 4</span><br></pre></td></tr></table></figure></p></blockquote><ul><li><strong>实现步骤</strong>：</li></ul><ol type="1"><li>不妨设 <span class="math inline">\(depth[a] \gedepth[b]\)</span>（否则可交换 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>）</li><li>用二进制拆分思想，把 <span class="math inline">\(a\)</span>向上调整到与 <span class="math inline">\(b\)</span>​ 同一深度</li></ol><blockquote><p>具体来说，就是依次尝试从 <span class="math inline">\(a\)</span>向上走 <span class="math inline">\(k=2^{logn},…,2^1,2^0\)</span>步，检查到达的节点是否比 <span class="math inline">\(b\)</span>深。在每次检查中，若是，则令 <spanclass="math inline">\(a=fa[a,k]\)</span></p></blockquote><ol start="3" type="1"><li><p>若此时 <span class="math inline">\(a=b\)</span>，说明已经找到了<span class="math inline">\(LCA\)</span>，<spanclass="math inline">\(LCA\)</span> 就等于 <spanclass="math inline">\(b\)</span>（这就是上面的图中的第三种情况）</p></li><li><p>用<strong>二进制拼凑</strong>的思想，把 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>同时向上跳，并保持深度一致且二者不相会</p></li></ol><blockquote><p>具体来说，就是<font color =’blue'><strong>依次尝试</strong></font>把<span class="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span> 同时向上走 <spanclass="math inline">\(k=2^{logn},…,2^1,2^0\)</span> 步，在每次尝试中，若<span class="math inline">\(fa[a,k]\nefa[b,k]\)</span>（即仍未相会），则令 <spanclass="math inline">\(x=F[x,k],y = F[y,k]\)</span></p></blockquote><ol start="5" type="1"><li><font color =’blue'><strong>此时 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>必定只差一步就相会了</strong></font>，它们的父节点 <spanclass="math inline">\(fa[a,0]\)</span> 或 <spanclass="math inline">\(fa[b,0]\)</span> 就是 <spanclass="math inline">\(LCA(a,b)\)</span></li></ol><ul><li><strong>时间复杂度</strong>：<ul><li>对于每个询问，时间复杂度为 <spanclass="math inline">\(O(logn)\)</span></li><li>如果有 <span class="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 个询问，总共的时间复杂度为 <spanclass="math inline">\(O(mlogn)\)</span></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">    <span class="comment">// 哨兵作用1：如果跳过根节点，fa[a][k] 会返回 0，depth[0] = 0，由于树中任何一个节点的 depth[] 均大于 0，if 判断条件不成立，不会跳</span></span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k =  <span class="number">16</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">    <span class="comment">// 哨兵作用2：如果跳过根节点，由于 a 和 b 的深度相同，此时 fa[a][k] = fa[a][k] = 0，if 判断条件不成立，不会跳</span></span><br><span class="line">        <span class="keyword">if</span>(fa[a][k] != fa[b][k])</span><br><span class="line">        &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];<span class="comment">// return fa[b][0];也是正确的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向上标记法">向上标记法</h3><ul><li><p>从 <span class="math inline">\(x\)</span>​向上走到根节点，并标记所有经过的节点。</p></li><li><p>从 y向上走到根节点，当第一次遇到已标记的节点时，就找到了 <spanclass="math inline">\(LCA(x,y)\)</span></p></li><li><p><strong>时间复杂度</strong>：</p><ul><li>对于每个询问，时间复杂度为 <spanclass="math inline">\(O(n)\)</span>​</li><li>如果有 <span class="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span> 个询问，总共的时间复杂度为 <spanclass="math inline">\(O(nm)\)</span></li></ul></li></ul><blockquote><p>基本不用这种方法</p></blockquote><h3 id="tarjan-lca算法">Tarjan-LCA算法★</h3><p>​ <span class="math inline">\(Tarjan-LCA\)</span>算法本质上是<strong>使用并查集对“向上标记法”的优化</strong>。它是一个离线算法，需要把m 个询问一次性读入，统一计算，最后统一输出 -<strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span>，其中 <spanclass="math inline">\(n\)</span>为节点数量，<spanclass="math inline">\(m\)</span> 为询问数量</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406082139869.png"alt="image-20240608213845895" /><figcaption aria-hidden="true">image-20240608213845895</figcaption></figure><p>在深度优先遍历时，将所有树中节点分为三类：</p><ol type="1"><li><p><strong>已经</strong>访问完毕且<strong>回溯</strong>的节点，标记为<span class="math inline">\(2\)</span></p></li><li><p>已经开始递归，但尚未回溯的节点，标记为 <spanclass="math inline">\(1\)</span></p></li></ol><blockquote><p>这些节点就是当前正在访问的节点 <span class="math inline">\(x\)</span>以及的 <span class="math inline">\(x\)</span> 的祖先</p></blockquote><ol start="3" type="1"><li>尚未访问的节点，标记为 <span class="math inline">\(0\)</span></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406082140480.png"alt="image-20240608214025565" /><figcaption aria-hidden="true">image-20240608214025565</figcaption></figure><ul><li><span class="math inline">\(tarjan\)</span> 本质是<font color='red'><strong><span class="math inline">\(DFS\)</span>​ +并查集</strong></font></li><li>【<strong>模板题</strong>：<ahref="https://www.acwing.com/activity/content/code/content/8579327/">AcWing1171. 距离 - AcWing</a>】</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> st[M];              <span class="comment">// 用于 tarjan 标记节点</span></span><br><span class="line"><span class="type">int</span> res[M];             <span class="comment">// 存储离线查询结果</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; query[N];   <span class="comment">// query[i] 存储与节点 i 相关的查询：first 存储查询的另一个点， second 存储查询编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">        p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(j);</span><br><span class="line">            p[j] = u;   <span class="comment">// p[u] = j 错误且一定要在回溯 tarjan(j) 结束后</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = item.first, id = item.second;</span><br><span class="line">        <span class="keyword">if</span>(st[y] == <span class="number">2</span>)</span><br><span class="line">            res[id] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* ........................ */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">/* 如果 a == b 答案就是 res[] 初始值 0 */</span></span><br><span class="line">        <span class="keyword">if</span>(a != b)<span class="comment">// 必须加 2 遍</span></span><br><span class="line">        &#123;</span><br><span class="line">            query[a].push_back(&#123;b, i&#125;);</span><br><span class="line">            query[b].push_back(&#123;a, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无向图任选一个节点作为根节点</span></span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图">图</h1><h2 id="图的存储">图的存储</h2><p>​ <span class="math inline">\(n\)</span> 个顶点，无向图最多有 <spanclass="math inline">\(m=n(n-1)/2\)</span> 条边，有向图最多有 <spanclass="math inline">\(m=n(n-1)\)</span> 条边</p><ul><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span>​ 是一个数量级的——<strong>稀疏图</strong>eg：</li></ul><p><span class="math display">\[1 ≤ n,m ≤ 10^5\]</span></p><ul><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n^2\)</span>是一个数量级的——<strong>稠密图</strong> eg：</li></ul><p><span class="math display">\[1 ≤ n ≤ 500\\1 ≤ m ≤ 10^5\]</span></p><ul><li>如果题目<strong>说明边的数量范围</strong>（假设顶点的数量为1e5，边点的数量为 2e5）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无向图 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">2</span> * <span class="number">2e5</span> + <span class="number">5</span>;<span class="comment">// 注意一定要乘以 2</span></span><br><span class="line"><span class="comment">/* 有向图 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">2e5</span>;</span><br></pre></td></tr></table></figure><ul><li>如果题目<strong>没有说明边的数量范围</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无向图 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N * N / <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 有向图 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N * N;</span><br></pre></td></tr></table></figure><p>:taco:注意：<span class="math inline">\(M\)</span> 很可能超过 <spanclass="math inline">\(int\)</span>，因此在这种情况下，我们通常采用<strong>邻接矩阵</strong>存储图，这样我们就不需要关心边的范围了</p><span id="more"></span><h3 id="邻接矩阵">邻接矩阵</h3><ul><li><p><code>g[a][b]</code> 存储边 <code>a-&gt;b</code></p></li><li><p><strong>空间复杂度</strong>：<spanclass="math inline">\(O(n^2)\)</span>，适合存储<strong>稠密图</strong></p></li></ul><h4 id="无权图">无权图</h4><ul><li><strong>自己到自己的边长</strong> 以及 <strong>不存在的边长</strong>均为 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; g(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b</span></span><br><span class="line">g[a][b] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span>(g[a][b])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有权图">有权图</h4><ul><li><strong>自己到自己的边长</strong> 以及 <strong>不存在的边长</strong>均为 <code>INF</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化邻接矩阵</span></span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b，权重为c</span></span><br><span class="line">g[a][b] = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span> (g[a][b] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有边的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有边的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表">邻接表</h3><ul><li><p>除非题目交代为稠密图，我们更常用<strong>邻接表</strong></p></li><li><p><strong>空间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span>，适合存储<strong>稀疏图</strong></p></li></ul><h4 id="无权图-1">无权图</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点 k，开一个单链表，存储 k 所有可以走到的点</span></span><br><span class="line"><span class="comment">// h[k] 存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b</span></span><br><span class="line">g[a].<span class="built_in">push_back</span>(b);</span><br></pre></td></tr></table></figure><h4 id="有权图-1">有权图</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点 k，开一个单链表，存储 k 所有可以走到的点</span></span><br><span class="line"><span class="comment">// h[k] 存储这个单链表的头结点，w[] 存储边的权重</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b，权重为 c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a id="tude">图的遍历</a></h2><ul><li><p><strong>时间复杂度：</strong> <spanclass="math inline">\(O(n+m)\)</span>，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>连通图只需要<strong>任选一个节点</strong>进行遍历即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(1);</span><br><span class="line">bfs(1);</span><br></pre></td></tr></table></figure></li><li><p>非连通图遍历时要依次遍历所有节点，确保能够遍历所有连通分量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!st[i])</span><br><span class="line">    <span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!st[i])</span><br><span class="line">    <span class="built_in">bfs</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>图的遍历必须使用 <code>st[]</code> 数组，这里的 <code>st[]</code>有以下 <span class="math inline">\(2\)</span> 种作用：</p><ol type="1"><li>【必备】记录节点 <span class="math inline">\(i\)</span> 是否已被<span class="math inline">\(DFS/BFS\)</span>扫描过，否则会重复遍历某些节点</li><li>【可选】记录子问题的解（类似 <span class="math inline">\(DP\)</span>问题中的状态函数 <code>f[]</code>），此时通常在 <code>dfs()</code> /<code>bfs()</code> 最前面加一句<code>memset(st, -1, sizeof st);</code></li></ol></li></ul><h3 id="dfs-3"><a id="图的dfs">dfs</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bfs-3"><a id="图的bfs">bfs</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                st[j] = <span class="literal">true</span>; <span class="comment">// 表示点 j 已经被遍历过</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<font color ='red'><strong>入队</strong></font>的时候对<code>st[]</code>标记</li></ul><h3 id="例题-2">例题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8006099/">AcWing846. 树的重心 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8007322/">AcWing847. 图中点的层次 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8409456/">AcWing1207. 大臣的旅费（蓝桥杯辅导课） - AcWing</a></p></li></ul><h2 id="图的最短路">图的最短路</h2><p>图中任意两点之间可能存在<strong>多条最短路</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409021225570.png"alt="image-20240902122555570" /><figcaption aria-hidden="true">image-20240902122555570</figcaption></figure><ul><li>只要图中<strong>不存在负环</strong>，则某一点到另一点的最短路径<strong>一定不会经过某条边两次</strong></li></ul><h3 id="朴素dijkstra">朴素Dijkstra</h3><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406050000461.png" /></p><ul><li><p><strong>时间复杂度：</strong><spanclass="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</p></li><li><p>朴素 <span class="math inline">\(Dijkstra\)</span>算法适合于<strong>稠密图</strong>，而稠密图应采用<font color = 'red'><strong>邻接矩阵</strong></font>存储</p></li><li><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8010586/">AcWing849. Dijkstra求最短路 I - AcWing</a>】</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储 1 号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 1 号点到 n 号点的最短路，如果不存在则返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// st[1] = true;一定不能加这一行，否则就会跳过第一次更新（其余点到 1 号点的最短距离）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每循环一次，就会找到一条最短路径；循环 n - 1 次，最后一个的 dist 一定也是最短的；当然你写 n 也是完全没问题的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在还未确定最短路的点中(!st[j])，寻找距离最小的点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 t 更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">// 没有必要增加 !st[j] 的条件限制</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明最短路不存在（即非连通图）</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == INF)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆优化dijkstra">堆优化dijkstra</h3><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(mlogn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8046169/">AcWing850. Dijkstra求最短路 II - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                            <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储所有点到 1 号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点的【最短距离是否已求出&amp;&amp;已经更新过其它点的距离】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 1 号点到 n 号点的最短距离，如果不存在，则返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first 存储距离，second 存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保“基于该点遍历其余所有点并更新距离”只会进行一次</span></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 初始化时千万不要在第17行写 <code>st[1] = true;</code>否则会导致后面第一轮无法更新</p><p>​ 对 <code>pair</code> 排序首先根据 <code>first</code>，然后根据<code>second</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406050810792.png"alt="image-20240605081041043" /><figcaption aria-hidden="true">image-20240605081041043</figcaption></figure><p>​ 堆优化dijkstra 堆中可能存在相同点的不同距离，使用 <code>st[]</code>确保只会基于该点对其余所有点更新 <span class="math inline">\(1\)</span>次距离，当 <code>heap.top()</code>再次遇见该点时，该点最短距离已经求出了，没必要再次基于该点遍历其余所有点并更新距离，否则时间复杂度就不是是<span class="math inline">\(O(mlogn)\)</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407282131344.png"alt="image-20240728213119578" /><figcaption aria-hidden="true">image-20240728213119578</figcaption></figure><h3 id="bellman-ford">Bellman-Ford</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131128358.png" alt="image-20240313112833199" style="zoom:33%;" /></p><ul><li><p>如果图中存在负权回路，最短路<strong>不一定</strong>存在</p><ul><li>如果从 <span class="math inline">\(1\)</span> 号点到 <spanclass="math inline">\(n\)</span>号点的某条路径上存在负环，则不存在最短路</li><li>如果负环不在从 <span class="math inline">\(1\)</span> 号点到 <spanclass="math inline">\(n\)</span> 号点的路径上，就没有影响</li><li>如果题目限制了<strong>最短路边的个数</strong>（即不能无限转），则一定存在最短路径</li></ul></li><li><p>在使用<strong>备份数组</strong>避免发生串联更新的情况下，<spanclass="math inline">\(Bellman\ Ford\)</span> 算法迭代 <spanclass="math inline">\(k\)</span> 次，<span class="math inline">\(dist[]\)</span> 表示从 <span class="math inline">\(1\)</span>号点，最多经过<font color='red'><strong><spanclass="math inline">\(k\)</span>条边</strong></font>，走到每个点的最短距离</p></li><li><p>如果第 <span class="math inline">\(k\)</span> 次迭代更新了 <spanclass="math inline">\(dist[]\)</span>，</p><ul><li><p>且<strong>使用备份数组</strong>避免发生串联更新，则第 <spanclass="math inline">\(k\)</span> 次更新的最短路径的边数一定是 <spanclass="math inline">\(k\)</span></p></li><li><p><strong>不使用备份数组</strong>允许串联式更新，则第 <spanclass="math inline">\(k\)</span> 次更新的最短路径的边数一定 <spanclass="math inline">\(\ge k\)</span></p></li></ul><blockquote><p>因为我们是用上轮迭代的 <span class="math inline">\(dist[]\)</span>更新本轮迭代的 <span class="math inline">\(dist[]\)</span>，当本轮中<span class="math inline">\(dist[]\)</span> 发生更新，说明上轮迭代的<span class="math inline">\(dist[]\)</span> 一定发生了更新，而上轮迭代的<span class="math inline">\(dist[]\)</span> 更新有说明上上轮迭代的 <spanclass="math inline">\(dist[]\)</span>发生了更新，以此类推说明最短路径的边数为 <spanclass="math inline">\(k\)</span></p></blockquote></li><li><p><span class="math inline">\(Bellman\ Ford\)</span>算法可以判断图中<strong>是否存在负权回路</strong></p><ul><li>迭代 <span class="math inline">\(n\)</span> 次，如果第 <spanclass="math inline">\(n\)</span>次仍有最短距离更新的话，说明存在一条边数为 <spanclass="math inline">\(n\)</span> 的最短路径</li><li><span class="math inline">\(n\)</span> 个点最多有 <spanclass="math inline">\(n-1\)</span> 条边，所以一定存在一个负权回路</li></ul></li><li><p><strong>时间复杂度：</strong><spanclass="math inline">\(O(nm)\)</span>​</p></li></ul><blockquote><p><strong><font color='red'>由于 <span class="math inline">\(Bellman\Ford\)</span>算法只需要在每次循环中，对所有边进行遍历，因此我们可以采用结构体数组存储边的集合即可，不需要存储图</font></strong></p></blockquote><h4 id="有边数限制的bellman-ford">有边数限制的Bellman-Ford</h4><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8048290/">AcWing853. 有边数限制的最短路 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, k;   <span class="comment">// n 表示点数，m 表示边数，k 表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N];   <span class="comment">// dist[x]存储 1 到 x 的最短路距离</span></span><br><span class="line"><span class="type">int</span> backup[N]; <span class="comment">// back[x]存储上次循环中，1 到 x 的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;<span class="comment">// a 表示出点，b 表示入点，c 表示边的权重</span></span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 1 到 n 的最短路距离，如果无法从 1 走到 n，则返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 k 次，最短路最多经历 k 条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>last[]</code>是备份数组，用于存储上次迭代的结果，用上次迭代的结果更新当前的距离，防止发生串联。为什么需要使用<code>last[]</code> ?</li></ul><blockquote><p>​ 为了避免如下的串联情况（在一次迭代中更新更多条边）， 在边数限制为 1条的情况下，节点 3 的距离应该是 3，但是由于串联情况，利用本轮更新的节点2 更新了节点 3 的距离，所以现在节点 3 的距离是 2</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452123.png" alt="2.PNG" style="zoom:45%;" /></p><p>​ 正确做法是用<strong>上轮迭代</strong>中节点 2 的距离 +∞ 和节点 1的距离 0 来更新节点 3， 再取最小值，所以节点 3 离起点的距离是 3</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452285.png" alt="3.PNG" style="zoom:45%;" /></p><p>​特别注意：如果没有边数限制（即没有边数限制的Bellman-Ford），那么串联情况不需要考虑，因为串联情况相当于提前对下轮迭代进行更新，由于没有边数限制所以并不影响</p></blockquote><ul><li>为什么是<code>dist[n] &gt; 0x3f3f3f3f/2</code>，而不是<code>dist[n] &gt; 0x3f3f3f3f</code></li></ul><blockquote><p>​ 5 号节点距离起点的距离是无穷大，利用 5 号节点更新 n号节点距离起点的距离，将得到<spanclass="math inline">\(10^9-2\)</span>，虽然小于 <spanclass="math inline">\(10^9\)</span>，但并不存在最短路（在边数限制在k条的条件下）</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406051339329.png" alt="4.PNG" style="zoom: 50%;" /></p><h4 id="没有边数限制的bellman-ford">没有边数限制的Bellman-Ford</h4><ul><li>实际上是“有边数限制的 <span class="math inline">\(Bellman \Ford\)</span> 算法”的特殊情况，这是的边数限制是 <spanclass="math inline">\(n\)</span> ，但是不需要使用 <spanclass="math inline">\(backup[]\)</span> ，因为最短路上最多也就是 <spanclass="math inline">\(n\)</span> 个顶点，即使串联也没关系</li><li>可以用于判断是否存在负权路</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;    <span class="comment">// n表示点数，m表示边数，k表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;<span class="comment">// a 表示出点，b 表示入点，c 表示边的权重</span></span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 1 到 n 的最短路距离，如果无法从 1 走到 n，则返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第 n 次迭代仍然会松弛三角不等式，就说明存在一条长度是 n + 1 的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], dist[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa">spfa★</h3><p>​ spfa 算法是<strong>队列优化</strong>的<strong><spanclass="math inline">\(Bellman-Ford\)</span></strong>算法</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131416112.png"alt="image-20240313141627490" /><figcaption aria-hidden="true">image-20240313141627490</figcaption></figure><ul><li><strong>定理</strong>：对于<strong>所有</strong>的边 <spanclass="math inline">\((x,y,z)\)</span> ，都有 <spanclass="math inline">\(dist[y]\le dist[x]+z\)</span> 成立&lt;==&gt; <spanclass="math inline">\(dist[]\)</span> 数组是最短路</li><li><strong>基本思想：</strong><span class="math inline">\(Bellman\ford\)</span>​算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新。因此考虑到这一点，我们创建一个队列，每一次加入距离被更新的结点</li><li><strong>时间复杂度：</strong><ul><li><strong>平均</strong>情况下 <spanclass="math inline">\(O(m)\)</span></li><li><strong>最坏</strong>情况下 <spanclass="math inline">\(O(nm)\)</span></li><li>如果SPFA被出题人卡掉了，改用<strong>堆优化版dijkstra</strong>算法​</li></ul></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8050444/">AcWing851. spfa求最短路 - AcWing</a>】</li></ul><h4 id="写法1stl循环队列">写法1：STL循环队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 1 号点到 n 号点的最短路距离，如果从 1 号点无法走到 n 号点则返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">// 从队列中取出来之后该节点 st 被标记为false，之后该节点如果发生更新可再次入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果队列中已存在 j，则不需要将 j 重复插入</span></span><br><span class="line">                    q.<span class="built_in">push</span>(j), st[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写法2数组模拟循环队列">写法2：数组模拟循环队列★</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"><span class="type">int</span> q[N];<span class="comment">// 数组模拟循环队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 1 号点到 n 号点的最短路距离，如果从 1 号点无法走到 n 号点则返回 -1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spfa</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">q[tt ++] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// if(tt == N)tt = 0;第一次可以不用加</span></span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N)hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果队列中已存在 j，则不需要将 j 重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N)tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意">注意</h4><ul><li>如何求解最长路？</li></ul><blockquote><p>需要变动 <span class="math inline">\(3\)</span> 处，其余不变</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">// 初始化为 -INF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i])<span class="comment">// 修改为 &lt;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (dist[n] == <span class="number">-0x3f3f3f3f</span>)<span class="comment">// 修改为 -0x3f3f3f3f</span></span><br></pre></td></tr></table></figure></p></blockquote><ul><li>为什么 SPFA 使用<strong>循环队列</strong>？</li></ul><blockquote><p>​ 因为 <span class="math inline">\(SPFA\)</span>里面每个点进队不止一次，使用循环队列可以节省空间；且如果使用普通队列的话，我们不知道队列长度要开多大，最坏情况下要开<spanclass="math inline">\(n*m\)</span>​（通常会爆空间），为了解决这个问题，我们一般使用循环队列来做，就不需要考虑这些问题了</p><p>​ <span class="math inline">\(SPFA\)</span> 使用 <code>st[]</code>确保队列中一定不会有重复元素，所以队列当中最多有 <spanclass="math inline">\(n\)</span>个元素，因此如果使用数组模拟循环队列的话，所以我们只需要保证队列长度<span class="math inline">\(N\)</span> 严格大于 <spanclass="math inline">\(n\)</span> 即可<code>int q[N]</code>，也可以直接使用 <span class="math inline">\(C++ \STL\)</span> 中的循环队列 <code>queue&lt;&gt;</code></p></blockquote><ul><li>为什么 <span class="math inline">\(Bellman_ford\)</span> 算法里最后<code>return -1</code> 的判断条件写的是<code>dist[n] &gt; 0x3f3f3f3f/2</code>，而 <spanclass="math inline">\(spfa\)</span> 算法写的是<code>dist[n] == 0x3f3f3f3f</code>？</li></ul><blockquote><p>​ 原因在于 <span class="math inline">\(Bellman\_ford\)</span>算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是<span class="math inline">\(SPFA\)</span> 算法不一样，它相当于采用了<spanclass="math inline">\(BFS\)</span>，因此遍历到的结点都是与源点连通的，因此如果你要求的<span class="math inline">\(n\)</span>和源点不连通，它不会得到更新，还是保持的 <spanclass="math inline">\(0x3f3f3f3f\)</span></p></blockquote><ul><li><code>st</code> 数组的作用是什么？</li></ul><blockquote><p>​判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。</p><p>​ <code>st</code>数组是必须的，确保<font color = 'red'><strong>队列中一定不会有重复元素</strong></font>，有2 方面考虑：</p><ol type="1"><li>防止对队列中的重复元素进行更新导致 TLE</li><li>防止队列中重复元素过多，导致队列太长而造成 MLE</li></ol></blockquote><ul><li>SPFA 算法看上去和 <span class="math inline">\(Dijkstra\)</span>算法长得有一些像但是其中的意义还是相差甚远的:</li></ul><blockquote><ol type="1"><li>Dijkstra 算法中的 <code>st[]</code>数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true 后改变为 false)；SPFA 算法中的 <code>st[]</code>数组仅仅只是表示的当前发生过更新的点，且 spfa 中的 <code>st[]</code>数组可逆(可以在标记为 true 之后又标记为 false)。顺带一提的是 BFS 中的<code>st[]</code> 数组记录的是当前已经被遍历过的点。</li><li>Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构)，目的只是记录一下当前发生过更新的点。</li></ol></blockquote><ul><li><span class="math inline">\(Bellman ford\)</span>算法可以存在负权回路，是因为其循环的次数是有限制的，因此最终不会发生死循环。但是<font color='red'><strong>SPFA算法不可以存在负权回路</strong></font>，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路，请不要用SPFA ，否则会死循环</li><li>由于 <span class="math inline">\(SPFA\)</span> 算法是由 <spanclass="math inline">\(Bellman\ ford\)</span>算法优化而来，在最坏的情况下时间复杂度和 <spanclass="math inline">\(Bellman\ ford\)</span> 算法一样，时间复杂度为<spanclass="math inline">\(O(nm)\)</span>，但这种情况极为罕见（除非出题人变态，故意把<span class="math inline">\(SPFA\)</span>卡掉），因此如果题目时间允许时，优先考虑使用 <spanclass="math inline">\(SPFA\)</span> 求解最短路，如果 <spanclass="math inline">\(SPFA\)</span> 真的被卡掉了，我们再用堆优化 <spanclass="math inline">\(Dijkstra\)</span> （<spanclass="math inline">\(SPFA\)</span> 有点小小万能的感觉）</li></ul><h3 id="bfs最短路模型">BFS最短路模型</h3><p>​ 如果图中所有边的<strong><font color='red'>权重相同且 &gt;0</font></strong>，则可以使用 <strong><spanclass="math inline">\(BFS\)</span>最短路模型</strong>求解<strong>单源</strong>最短路</p><blockquote><p>证明：由于 <span class="math inline">\(BFS\)</span>的队列满足单调性、阶段性，因此 <span class="math inline">\(BFS\)</span>最短路模型可以转化为堆优化版的 <spanclass="math inline">\(dijkstra\)</span></p></blockquote><ul><li>时间复杂度：<span class="math inline">\(O(n+m)\)</span>​</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> q[N], hh =<span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设源点为 1 号点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    q[++ tt] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[t][i] &amp;&amp; dist[i] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://njfjnkm.github.io/2024/02/29/%5Bobject%20Object%5D/算法/【搜索】/">【搜索】-BFS最短路模型</a></p></blockquote><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8466405/">AcWing920. 最优乘车 - AcWing</a></li></ul><h3 id="双端队列bfs">双端队列BFS</h3><p>​如果图中所有边的<strong><font color='red'>权重=0/1</font></strong>，则可以使用<strong><span class="math inline">\(BFS\)</span>双端队列广搜</strong>求解<strong>单源</strong>最短路</p><blockquote><p>证明：由于使用双端队列广搜的<strong>队列</strong>满足单调性、阶段性，因此<span class="math inline">\(BFS\)</span>双端队列广搜求最短路模型可以转化为堆优化版的 <spanclass="math inline">\(dijkstra\)</span></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408032113333.jpg"alt="2ea00406fdaa9ce3c6fdbd8ec574a9b" /><figcaptionaria-hidden="true">2ea00406fdaa9ce3c6fdbd8ec574a9b</figcaption></figure><p>​<strong>双端队列广搜</strong>本质是<font color='purple'><strong>简化版的堆优化Dijkstra</strong></font>，<strong>双端队列</strong>就相当于<strong>简化版的堆</strong></p><ul><li>时间复杂度：<span class="math inline">\(O(n+m)\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设源点为 1 号点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.push_back(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();</span><br><span class="line">        q.pop_front();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (w[i])</span><br><span class="line">                    q.push_back(j);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    q.push_front(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8567662/">AcWing175. 电路维修 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8569870/">AcWing340. 通信线路 - AcWing</a></li></ul><h3 id="floyd">Floyd</h3><ul><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n^3)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p><span class="math inline">\(Floyd\)</span>算法的原理是<strong>动态规划</strong>，在代码实现的时候省去了第一维状态</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408042206434.png"alt="image-20240804220614680" /><figcaption aria-hidden="true">image-20240804220614680</figcaption></figure><blockquote><p>在计算第<code>k</code>层的<code>f[i, j]</code>时必须先将第<code>k - 1</code>层的所有状态计算出来，因此把<code>k</code>放在最外层循环</p></blockquote><ul><li><code>d[i][j]</code><ul><li>含义：<strong><font color='red'>从【顶点i 】到 【顶点j】的最短路径长度</font></strong></li><li>初值：<ul><li><code>d[i][i] = 0</code>【Caution!】</li><li>若 a -&gt; b 存在一条边，权重为 c，则 <code>d[a][b] = c</code></li><li>其余的 <code>d[i][i] = INF</code></li></ul></li></ul></li><li>先循环 <code>k</code> ，再循环 <code>i</code> 、 <code>j</code>（<code>i</code> 、 <code>j</code>顺序可以颠倒），每层循环遍历所有的顶点，下面的模板顶点编号从 1开始。如果顶点编号从 0 开始，每层循环从 <code>0 -&gt; n - 1</code>即可</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8055095/">AcWing854. Floyd求最短路 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    d[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="comment">/* 无向图 */</span></span><br><span class="line">    d[a][b] = d[b][a] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    <span class="comment">/* 有向图 */</span></span><br><span class="line">    d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示 a 到 b 的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d[a][b] &gt; INF / <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* a 与 b 之间不连通 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* a 与 b 之间连通 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么是 <code>d[a][b] &gt; INF / 2</code> 而非<code>d[a][b] == INF</code></p><p>——可能存在如下情况：<code>i</code> 和 <code>j</code>之间不连通，但由于负数边权的存在，<code>d[i][j]</code>可能被其他长度是正无穷的距离更新，跟INF /2比较可以处理这种情况。例如假设 <code>i</code> 和 <code>j</code>之间不连通， 某一时刻<code>dist[i][j] = INF, dist[i][k] = INF, dist[k][j] = -10</code>时，那么 <code>dist[i][j]</code> 就会被更新成<code>INF - 10</code>，但此时 <code>i</code> 和 <code>j</code>仍然是不连通的</p></blockquote><h3 id="拓扑dp与最短路"><a id="tuopuDP">拓扑DP与最短路</a></h3><blockquote><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/142564/">最短路与DP——01:51:45</a></p></blockquote><h4 id="dp最短路">DP=&gt;最短路</h4><p>【原理】<span class="math inline">\(DP\)</span>可以看作是在<strong>拓扑图（有向无环图）</strong>上的最短路问题</p><blockquote><p>以01背包为例，将所有的<strong>状态</strong>转化为图的<strong>顶点</strong>，所有的<strong>状态转移方程</strong>转化为图的<strong>边</strong>，01背包问题就转化为从<strong>起点集合</strong><spanclass="math inline">\(f[0][0],f[0][1],\cdots,f[0][m]\)</span>，到<strong>终点</strong><span class="math inline">\(f[n][m]\)</span>的<strong>最长</strong>路径</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408031122668.png"alt="image-20240803112243647" /><figcaption aria-hidden="true">image-20240803112243647</figcaption></figure><p>【应用】当一个 <span class="math inline">\(DP\)</span>问题<strong><font color='red'>没有</font>拓扑性质</strong>（存在<strong>环形依赖</strong>）时，无法使用<spanclass="math inline">\(DP\)</span>递推求解，此时可以将其转化为<strong>最短路</strong>问题</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408031131597.jpg"alt="204b2cb15a4e07011bc1bfd390adee5" /><figcaptionaria-hidden="true">204b2cb15a4e07011bc1bfd390adee5</figcaption></figure><h4 id="最短路dp">最短路=&gt;DP</h4><p>【原理】<strong>最短路</strong>问题本质上就是一个 <strong><spanclass="math inline">\(DP\)</span> 问题</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408031153744.jpg"alt="73a15cf9fee6065269f79fab00c9d5e" /><figcaptionaria-hidden="true">73a15cf9fee6065269f79fab00c9d5e</figcaption></figure><p>【应用】<strong>拓扑图</strong>中的<strong>最短路</strong>问题等价于按照<strong>拓扑序</strong>进行<strong><spanclass="math inline">\(DP\)</span>递推</strong></p><blockquote><p>因为按照<strong>拓扑序</strong>进行递推的话，能够保证在计算 <spanclass="math inline">\(f(i)\)</span> 的时候其依赖的所有状态 <spanclass="math inline">\(f(j)\)</span> 都已经计算过了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!topsort()) <span class="built_in">puts</span>(<span class="string">&quot;不存在拓扑序&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = q[i];<span class="comment">// 按照拓扑序进行DP递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = h[j]; ~ k; k = ne[k])</span><br><span class="line">            dist[e[k]] = max(dist[e[k]], dist[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8707496/">AcWing1175. 最大半连通子图 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8727551/">AcWing368. 银河 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8727813/">AcWing1192. 奖金 - AcWing</a></p></li></ul><h4 id="总结">总结★</h4><p>对于 𝐷𝑃 问题</p><ul><li>如果存在<strong>拓扑序</strong>（特别地，在图论 <spanclass="math inline">\(DP\)</span>中表现为<strong>有向无环图</strong>），按照拓扑序<strong>递推</strong>求解</li></ul><blockquote><p>图论DP：</p><p><ahref="https://www.acwing.com/activity/content/code/content/8707496/">AcWing1175. 最大半连通子图 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8727551/">AcWing368. 银河 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8727813/">AcWing1192. 奖金 - AcWing</a></p><p><ahref="https://www.acwing.com/activity/content/code/content/8819625/">AcWing164. 可达性统计 - AcWing</a></p><p><ahref="D:\downloads\hexo\blog\source_posts\算法【数学知识】.md#qiwang">【数学知识】-概率与期望</a></p><p>普通DP：见【动态规划】</p></blockquote><ul><li>如果存在<strong>环状依赖</strong>，即不存在拓扑序（特别地，在图论<span class="math inline">\(DP\)</span>中表现为<strong>非拓扑图</strong>），则转化为在图中求最短路，使用 <spanclass="math inline">\(SPFA\)</span> 算法（ 特别地，对于普通 <spanclass="math inline">\(DP\)</span>问题需要先建图转化为图中的最短路问题）</li></ul><blockquote><p>图论DP：</p><p><ahref="https://www.acwing.com/activity/content/code/content/8728197/">AcWing341. 最优贸易 - AcWing</a></p><p>普通DP：</p><p><ahref="https://www.acwing.com/activity/content/code/content/8731738/">AcWing1131. 拯救大兵瑞恩 - AcWing</a></p></blockquote><hr /><p>​ 对于<strong>普通</strong> <span class="math inline">\(DP\)</span>问题</p><ul><li>如果存在<strong>环状依赖</strong>，则转化为图论中的最短路问题求解</li></ul><blockquote></blockquote><ul><li>否则，正常通过递推求解</li></ul><blockquote></blockquote><h3 id="例题-3">例题</h3><h4 id="vanilla">vanilla</h4><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8463871/">AcWing1129. 热浪 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8464436/">AcWing1128. 信使 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8464584/">AcWing1127. 香甜的黄油 - AcWing</a></p></li></ul><h4 id="建图">建图</h4><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8466405/">AcWing920. 最优乘车 - AcWing</a></li></ul><h4 id="虚拟源点与虚拟终点">虚拟源点与虚拟终点</h4><p>如果要求从<strong>起点集合</strong>到<strong>终点集合</strong>的最短距离，可以</p><ul><li>构建虚拟源点：虚拟源点指向所有起点，边权为 <spanclass="math inline">\(0\)</span></li><li>构建虚拟终点，所有终点指向虚拟终点，边权为 <spanclass="math inline">\(0\)</span></li></ul><p>因此，求虚拟源点到虚拟终点的单源最短路，即为起点集合到终点集合的最短路</p><blockquote><ol type="1"><li><p>对于任意一条从虚拟源点到虚拟终点的路径，都唯一对应着一条从起点集合到终点集合的路径，且两者路径长度相等（去掉路径上头尾2 条边即可）</p></li><li><p>对于任意一条从起点集合到终点集合的路径，都唯一对应着一条从虚拟源点到虚拟终点的路径，且两者路径长度相等（加上虚拟源点-&gt;起点、终点-&gt;虚拟终点的2 条边即可）</p></li></ol><p>因此求起点集合到终点集合的最短路问题&lt;==&gt;求虚拟源点到虚拟终点的单源最短路问题</p></blockquote><p>:star:假设题目中图的最大点数为 <spanclass="math inline">\(x\)</span>，最大边数为 <spanclass="math inline">\(y\)</span>，则定义时最大边数要多加上顶点数，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = x + <span class="number">5</span>, M = x + y + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406101718091.jpg"alt="daab25d54babb177c533e6419dd90fe" /><figcaptionaria-hidden="true">daab25d54babb177c533e6419dd90fe</figcaption></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8472876/">AcWing903. 昂贵的聘礼 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8582183/">AcWing1137. 选择最佳线路 - AcWing</a></p></li></ul><h4 id="特殊最短路">特殊“最短路”</h4><p><ahref="https://www.acwing.com/blog/content/58615/">dijkstra/SPFA算法的正确性本质- AcWing</a></p><p>转化后使用 <span class="math inline">\(SPFA\)</span> 算法求解 <spanclass="math inline">\(DP\)</span> 状态转移通常是正确的</p><blockquote><p>因为 <span class="math inline">\(SPFA\)</span>本质是基于边数限制的，只要问题中最短路径的边数 <spanclass="math inline">\(\le n-1\)</span>，<spanclass="math inline">\(SPFA\)</span> 算法求解 <spanclass="math inline">\(DP\)</span> 状态转移都是正确的</p></blockquote><p>但使用 <span class="math inline">\(dijkstra\)</span>等其他最短路算法求解 <span class="math inline">\(DP\)</span>状态转移不一定正确，如<ahref="https://www.acwing.com/activity/content/code/content/8728197/">AcWing341. 最优贸易 - AcWing</a></p><hr /><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8467300/">AcWing1126. 最小花费 - AcWing</a>：边权乘积定义为“距离”——<spanclass="math inline">\(dijkstra\)</span></li><li><ahref="https://www.acwing.com/activity/content/code/content/8569870/">AcWing340. 通信线路 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8728197/">AcWing341. 最优贸易 -AcWing</a>：路径上最<strong>小/大</strong>边权定义为“距离”——只能用 <spanclass="math inline">\(SPFA\)</span>，不能用 <spanclass="math inline">\(dijkstra\)</span></li></ul><h4 id="综合运用">综合运用</h4><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8555876/">AcWing1135. 新年好 - AcWing</a></li></ul><h2 id="最小生成树">最小生成树</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405252147856.png"alt="image-20240313194446005" /><figcaption aria-hidden="true">image-20240313194446005</figcaption></figure><ul><li>最小生成树是针对<font color='blue'><strong>无向图</strong></font>的，<strong>无向连通图</strong>一定存在最小生成树</li><li><strong><span class="math inline">\(n\)</span></strong>个顶点的无向连通图，最小生成树的边数为 <strong><spanclass="math inline">\(n - 1\)</span>​​​</strong></li></ul><hr /><p><strong>定理</strong>：任意一棵最小生成树一定包含无向图中权值最小的边</p><blockquote><p>反证法。假设无向图 <span class="math inline">\(G=(V,E)\)</span>存在一棵最小生成树不包含权值最小的边。设 <spanclass="math inline">\(e=(x,y,z)\)</span> 是无向图中权值最小的边。把<span class="math inline">\(e\)</span> 添加到树中，<spanclass="math inline">\(e\)</span> 会和树上从 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span>的路径一起构成一个环，并且环上其他边的权值都比 <spanclass="math inline">\(z\)</span> 大。因此,用 <spanclass="math inline">\(e\)</span>​代替环上的其他任意一条边，会形成一棵权值和更小的生成树，与假设矛盾。故假设不成立，原命题成立</p></blockquote><p><strong>推论</strong>：给定一张无向图 <spanclass="math inline">\(G=(V,E)\)</span>，<spanclass="math inline">\(n=|V|\)</span>，<spanclass="math inline">\(m=|E|\)</span>。从 <spanclass="math inline">\(E\)</span> 中选出 <spanclass="math inline">\(k&lt;n-1\)</span> 条边构成 <spanclass="math inline">\(G\)</span> 的一个生成森林。若再从剩余的 <spanclass="math inline">\(m-k\)</span> 条边中选 <spanclass="math inline">\(n-1-k\)</span> 条添加到生成森林中，使其成为 <spanclass="math inline">\(G\)</span>的生成树，并且选出的边的权值之和最小，则该生成树一定包含这 <spanclass="math inline">\(m-k\)</span>条边中连接生成森林的两个不连通节点的权值最小的边</p><h3 id="kruskal">Kruskal★</h3><ul><li><span class="math inline">\(Kruskal\)</span>算法是基于上述推论的，<font color='red'><strong><spanclass="math inline">\(Kruskal\)</span>算法总是维护无向图的最小生成森林</strong></font></li></ul><blockquote><p>最初，可认为生成森林由 <span class="math inline">\(0\)</span>条边构成，每个节点各自构成一棵仅包含一个点的树。在任意时刻，<spanclass="math inline">\(Kruskal\)</span>​算法从剩余的边中选出一条权值最小的，并且这条边的两个端点属于生成森林中两棵不同的树（不连通），把该边加入生成森林，<font color='red'><strong>图中节点的连通情况可以用并查集维护</strong></font></p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403132026795.png" alt="image-20240313202628601" style="zoom: 33%;" /></p><blockquote><p>假设当前 <span class="math inline">\(Kruskal\)</span>算法已经循环完第 <span class="math inline">\(i\)</span>条边，则已经求出了由前 <span class="math inline">\(i\)</span>条边构成的所有连通块</p></blockquote><ul><li>适用于<strong>稀疏图</strong>，使用<font color='red'><strong>结构体数组</strong></font>存储<font color='red'><strong>边的集合</strong></font>，不需要存储图</li></ul><blockquote><p>由于 <span class="math inline">\(Kruskal\)</span>算法只需要在每次循环中，对<strong>所有边按照边权从小到大</strong>遍历，因此我们可以采用结构体数组存储<strong>边的集合</strong>即可，不需要存储图</p></blockquote><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​​ 表示边数</li></ul><h4 id="连通图最小生成树">连通图—最小生成树</h4><p>【模板题：<ahref="https://www.acwing.com/activity/content/code/content/8056398/">AcWing859. Kruskal算法求最小生成树 - AcWing</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m; <span class="comment">// n 是点数，m 是边数</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"><span class="type">int</span> h[N], e[<span class="number">2</span> * N], ne[<span class="number">2</span> * N], w[<span class="number">2</span> * N], idx;       <span class="comment">// 存储最小生成树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集核心操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m, [](Edge x, Edge y)</span><br><span class="line">         &#123; <span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memset(h, -1, sizeof h); // 邻接表存储最小生成树</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;<span class="comment">// res表示最小生成树的权重之和，cnt 表示最小生成树集合中边的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(edges[i].a), b = <span class="built_in">find</span>(edges[i].b), c = edges[i].c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b, res += c, cnt++;</span><br><span class="line">            <span class="comment">// add(a, b, c), add(b, a, c);// 构建最小生成树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的数量小于 n - 1，说明图是非连通图，不存在最小生成树</span></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非连通图最小生成森林">非连通图—最小生成森林</h4><p>在非联通图的每个连通块内，求一棵最小生成树（即求原图的“最小生成森林”）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kruskal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    </span><br><span class="line">    sort(edges, edges + m, [](Edge x, Edge y)</span><br><span class="line">         &#123; <span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">            p[a] = b, res += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prim">Prim</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131953561.png"alt="image-20240313195326359" /><figcaption aria-hidden="true">image-20240313195326359</figcaption></figure><ul><li>适用于<strong>稠密图</strong>，使用<strong>邻接矩阵</strong>存储图</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8055703/">AcWing858. Prim算法求最小生成树 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;       <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF, 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每循环一次，最小生成树就会增加一个节点；循环 n - 1 次，最后一个的 dist 一定也是最短的；当然你写 n 也是完全没问题的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在还未确定最短路的点中(!st[j])，寻找距离最小的点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[t] == INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1">总结</h3><ul><li><p><span class="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span>条无向边，边权为<font color='red'><strong>正数</strong></font>，求将所有点连通的最小边权和是多少?</p><p>——<font color='blue'><strong>最小生成树问题</strong></font></p></li><li><p><span class="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span>条无向边，边权为<font color='red'><strong>可正可负</strong></font>，求将所有点连通的最小边权和是多少?</p><p>——先将所有的<strong>负权边</strong>加入，再对剩余的<strong>正权边</strong>做<font color='blue'><span class="math inline">\(kruskal\)</span>​ 算法</font></p></li><li><p><span class="math inline">\(kruskal\)</span>算法的应用范围更广</p><ul><li>使用 <span class="math inline">\(prim\)</span>算法可以解决的问题，<span class="math inline">\(kruskal\)</span>算法一定也可以实现</li><li>但 <span class="math inline">\(kruskal\)</span>算法可以解决的问题，<span class="math inline">\(prim\)</span>算法未必能解决</li></ul></li></ul><hr /><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8540394/">AcWing1140. 最短网络 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8540486/">AcWing1141. 局域网 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8540931/">AcWing1142. 繁忙的都市 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8541231/">AcWing1143. 联络员 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8541559/">AcWing1144. 连接格点 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8542747/">AcWing1146. 新的开始 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8543088/">AcWing1145. 北极通讯网络 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8543811/">AcWing346. 走廊泼水节 - AcWing</a></p></li></ul><h2 id="次小生成树">次小生成树</h2><ul><li><strong>定义</strong>：有权无向图中，把图的所有生成树按<strong>权值之和</strong>从小到大排序，严格/非严格<strong>第二小</strong>的称为 严格/非严格 次小生成树</li></ul><blockquote><p>严格最小生成树的权值之和一定要大于最小生成树的权值之和</p><p>非严格最小生成树的权值之和可能等于最小生成树的权值之和</p></blockquote><h3 id="方法1">方法1</h3><ul><li><strong>步骤</strong>：<ul><li>求解最小生成树：<span class="math inline">\(O(mlogm)\)</span></li><li>依次枚举删除<strong>最小生成树中的边</strong>，在剩余边中使用 <spanclass="math inline">\(Kruskal\)</span> 算法再求一遍最小生成树：<spanclass="math inline">\(O(nm)\)</span></li></ul></li><li><strong>正确性证明</strong>：最小生成树和次小生成树至少有 <spanclass="math inline">\(1\)</span>条边不同。<strong>从集合的角度进行划分</strong>，根据生成树是否<strong>不包含</strong>最小生成树第 <span class="math inline">\(i\ (i=1,2,...,n-1)\)</span>条边，可以将所有<strong>除了最小生成树以外的所有生成树不漏</strong>（但重）地划分为<span class="math inline">\(n-1\)</span>​类，每一类的最小值就一定是次小生成树</li></ul><blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406091813492.jpg" alt="7b6e8858349385fcce88a4f0ba3a178" style="zoom:20%;" /></p></blockquote><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm+nm)\)</span>​</li><li><strong>适用范围</strong>：只能求解<strong>非严格</strong>最小生成树</li></ul><h3 id="方法2">方法2★</h3><ul><li><p><strong>适用范围</strong>：严格次小生成树和非严格次小生成树都可以求解</p></li><li><p><strong>思路</strong>：</p></li></ul><ol type="1"><li>求解最小生成树 <span class="math inline">\(sum\)</span>​</li></ol><blockquote><p>这里“树边”指的是最小生成树上的边，“树边”指的是图中除了最小生成树以外的其他便边</p></blockquote><ol start="3" type="1"><li>依次枚举<strong><font color = 'red'>非</font>树边<spanclass="math inline">\(a\xrightarrow{c}b\)</span></strong>：<ol type="1"><li>然后将该边加入树中</li><li>同时从树中去掉一条<font color='blue'><strong>最长</strong></font>边</li><li>更新最小值</li></ol></li></ol><h4 id="非严格次小生成树">非严格次小生成树</h4><h5 id="原版">原版</h5><ul><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm+n^2+m)\)</span></p></li><li><p><strong>步骤</strong>：</p></li></ul><ol type="1"><li><span class="math inline">\(Kruskal\)</span>求解最小生成树，同时标记图中的每条边是<strong>树边</strong>还是<strong>非树边</strong>：<spanclass="math inline">\(O(mlogm)\)</span></li></ol><blockquote><p>这里“树边”指的是最小生成树上的边，“树边”指的是图中除了最小生成树以外的其他便边</p></blockquote><ol start="2" type="1"><li><span class="math inline">\(dfs\)</span><strong>预处理</strong>最小生成树中，任意两点之间的<font color='red'><strong>最大边权</strong></font><code>dist[][]</code>：<span class="math inline">\(O(n^2)\)</span></li></ol><blockquote><p>无向树中任意 2 个节点之间的路径是唯一的</p></blockquote><ol start="3" type="1"><li>依次枚举<strong><font color = 'red'>非</font>树边</strong>，然后将该边加入树中，同时从树中去掉一条<font color='blue'><strong>最长</strong></font>边，即求解<code>min(sum + w - dist[a][b])</code>：<spanclass="math inline">\(O(m)\)</span></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="type">bool</span> f;         <span class="comment">// 标记图中某条边是否为树边</span></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"><span class="type">int</span> h[N], e[<span class="number">2</span> * N], ne[<span class="number">2</span> * N], w[<span class="number">2</span> * N], idx;       <span class="comment">// 存储最小生成树</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">        p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用：预处理最小生成树中任意两点之间路径上的最大边权 dist[][]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> maxd, <span class="type">int</span> d[])</span></span><br><span class="line">&#123;</span><br><span class="line">    d[u] = maxd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j != fa)</span><br><span class="line">            dfs(j, u, max(maxd, w[i]), d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal 构建最小生成树并返回边权之和 sum</span></span><br><span class="line">LL <span class="title function_">kruskal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    sort(edges, edges + m, [](Edge x, Edge y)&#123;<span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b =edges[i].b, c = edges[i].c;</span><br><span class="line">        <span class="type">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb, res += c, edges[i].f = <span class="literal">true</span>;</span><br><span class="line">            add(a, b, c), add(b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = kruskal();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dfs 预处理出来最小生成树中，任意两点之间的最大边权 dist[][]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        dfs(i, <span class="number">-1e9</span>, <span class="number">0</span>, dist[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次枚举非树边，然后将该边加入树中，同时从树中去掉一条最长边，即求解 min(sum + w - dist[a][b])</span></span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!edges[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line">            <span class="comment">// 这里的 c &gt;= dist[a][b]，否则与最小生成树 sum、Kruskal 算法违背</span></span><br><span class="line">            res = min(res, sum + c - dist[a][b]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化">优化</h5><ul><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm)\)</span></p></li><li><p><strong>步骤</strong>：</p></li></ul><ol type="1"><li><span class="math inline">\(Kruskal\)</span>求解最小生成树，同时标记图中的每条边是<strong>树边</strong>还是<strong>非树边</strong>：<spanclass="math inline">\(O(mlogm)\)</span>​</li><li><span class="math inline">\(BFS\)</span> 预处理得到 <spanclass="math inline">\(depth[\ ]\)</span>、<spanclass="math inline">\(fa[\ ][\ ]\)</span>、<spanclass="math inline">\(d[][]\)</span><ol type="1"><li><span class="math inline">\(depth[i]\)</span> 表示 <spanclass="math inline">\(i\)</span> 的深度，<spanclass="math inline">\(1\le i \le n\)</span></li><li><span class="math inline">\(fa\left[ i,j \right]\)</span> 表示从<span class="math inline">\(i\)</span> 开始向上走 <spanclass="math inline">\(2^j\)</span> 步到达的节点，<spanclass="math inline">\(0\le j \le logn\)</span></li></ol></li></ol><p><span class="math display">\[\begin{cases}    fa\left[ i,0 \right] =i\ \text{的父节点}\\    \\    fa\left[ i,j \right] =fa\left[ fa\left[ i,j-1 \right] ,j-1 \right],  1\le j\le logn\\\end{cases}\]</span></p><p>​ (c) <span class="math inline">\(d\left[ i,j \right]\)</span> 表示从<span class="math inline">\(i\)</span> 开始向上走 <spanclass="math inline">\(2^j\)</span>步的路径中<font color='blue'><strong>边权最大值</strong></font>，<spanclass="math inline">\(0\le j \le logn\)</span> <spanclass="math display">\[\begin{cases}    d\left[ i,0 \right] =i\ \text{到父节点的边权}\\    \\    d\left[ i,j \right] =max(d[i,j-1],d\left[ fa\left[ i,j-1 \right],j-1 \right]) ,  1\le j\le logn\\\end{cases}\]</span></p><ol start="3" type="1"><li>依次枚举<strong><font color = 'red'>非</font>树边<spanclass="math inline">\(a\xrightarrow{c}b\)</span></strong>：<spanclass="math inline">\(O(mlogn)\)</span>​<ol type="1"><li>将该边加入树中</li><li><span class="math inline">\(LCA\)</span>树上倍增 求解树中从 <spanclass="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span>路径上的<font color='blue'><strong>最长</strong></font>边 <spanclass="math inline">\(w\)</span>——<spanclass="math inline">\(O(logn)\)</span></li><li>更新 <code>res = min(res, sum + c - w)</code></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="type">bool</span> f;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;<span class="comment">// 存储最小生成树</span></span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">17</span>], d[N][<span class="number">17</span>];<span class="comment">// 17 = log(n) / log(2) 上取整</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal 构建最小生成树并返回边权之和 sum</span></span><br><span class="line">LL <span class="title function_">kruskal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    sort(edges, edges + m, [](Edge x, Edge y)&#123;<span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b =edges[i].b, c = edges[i].c;</span><br><span class="line">        <span class="type">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb, res += c, edges[i].f = <span class="literal">true</span>;</span><br><span class="line">            add(a, b, c), add(b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> root)</span></span><br><span class="line">&#123;</span><br><span class="line">    depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++ tt] = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!depth[j])</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 树型 DP 计算 fa[j][], d[j][k] */</span></span><br><span class="line">                fa[j][<span class="number">0</span>] = t, d[j][<span class="number">0</span>] = w[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>];</span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>];</span><br><span class="line">                    d[j][k] = max(d[j][k - <span class="number">1</span>], d[anc][k - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求从 a 到 b 路径上的最大边权 maxd</span></span><br><span class="line">    <span class="type">int</span> maxd = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            maxd = max(maxd, d[a][k]);</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                maxd = max(maxd, d[a][k]);</span><br><span class="line">                maxd = max(maxd, d[b][k]);</span><br><span class="line">                a = fa[a][k], b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        maxd = max(maxd, d[a][<span class="number">0</span>]);</span><br><span class="line">        maxd = max(maxd, d[b][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 c &gt;= dist[a][b]，否则与最小生成树 sum、Kruskal 算法违背，返回 c - dist</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt; maxd)</span><br><span class="line">        <span class="keyword">return</span> c - maxd;</span><br><span class="line">    <span class="keyword">return</span> INF;<span class="comment">// 要求最小值，因此返回 INF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = kruskal();</span><br><span class="line">    </span><br><span class="line">    bfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span> (!edges[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line">            res = min(res, sum + lca(a, b, c));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="严格次小生成树">严格次小生成树</h4><h5 id="原版-1">原版</h5><p>【<strong>模板题</strong>：<ahref="https://www.acwing.com/activity/content/code/content/8581058/">AcWing1148. 秘密的牛奶运输 - AcWing</a>】</p><ul><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm+n^2+m)\)</span></p></li><li><p><strong>步骤</strong>：</p></li></ul><ol type="1"><li>求解最小生成树，同时标记图中的每条边是<strong>树边</strong>还是<strong>非树边</strong>：<spanclass="math inline">\(O(mlogm)\)</span>​</li></ol><blockquote><p>这里“树边”指的是最小生成树上的边，“树边”指的是图中除了最小生成树以外的其它边</p></blockquote><ol start="2" type="1"><li><span class="math inline">\(dfs\)</span>预处理最小生成树中，任意两点之间的<font color='red'><strong>最大</strong></font>边权<code>dist1[][]</code>和<font color='red'><strong>严格次大</strong></font>边权<code>dist2[][]</code>：<span class="math inline">\(O(n^2)\)</span></li></ol><blockquote><p>无向树中任意 2 个节点之间的路径是唯一的</p></blockquote><ol start="3" type="1"><li>依次枚举<strong><font color = 'red'>非</font>树边</strong> <spanclass="math inline">\(a\xrightarrow{c}b\)</span>，然后将该边加入树中，同时从树中去掉一条<font color='blue'><strong>最长</strong></font>边/ <font color='blue'><strong>严格次长</strong></font>边</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c &gt; dist1[a][b])</span><br><span class="line">    min(sum + c - dist1[a][b])</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c &gt; dist2[a][b])</span><br><span class="line">    min(sum + c - dist2[a][b])</span><br></pre></td></tr></table></figure><blockquote><p>由于题目确保一定存在严格次小生成树，因此上面的更新操作至少会发生<span class="math inline">\(1\)</span>​ 次</p></blockquote><hr /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="type">bool</span> f;         <span class="comment">// 标记图中某条边是否为树边</span></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> dist1[N][N], dist2[N][N];</span><br><span class="line"><span class="type">int</span> h[N], e[<span class="number">2</span> * N], ne[<span class="number">2</span> * N], w[<span class="number">2</span> * N], idx;       <span class="comment">// 存储最小生成树</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">        p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用：预处理最小生成树中任意两点之间路径上的最大边权 dist1[][] 和严格次大边权 dist2[][]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> maxd1, <span class="type">int</span> d1[], <span class="type">int</span> maxd2, <span class="type">int</span> d2[])</span></span><br><span class="line">&#123;</span><br><span class="line">    d1[u] = maxd1, d2[u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j != fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; maxd1)</span><br><span class="line">                dfs(j, u, w[i], d1, maxd1, d2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[i] != maxd1 &amp;&amp; w[i] &gt; maxd2)    <span class="comment">// 注意，由于我们要求的是严格次小值，因此 w[i] 不仅要大于 max2，还不能等于 max1</span></span><br><span class="line">                dfs(j, u, maxd1, d1, w[i], d2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dfs(j, u, maxd1, d1, maxd2, d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal 构建最小生成树并返回边权之和 sum</span></span><br><span class="line">LL <span class="title function_">kruskal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    sort(edges, edges + m, [](Edge x, Edge y)&#123;<span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b =edges[i].b, c = edges[i].c;</span><br><span class="line">        <span class="type">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb, res += c, edges[i].f = <span class="literal">true</span>;</span><br><span class="line">            add(a, b, c), add(b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = kruskal();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dfs 预处理出来最小生成树中，任意两点之间的最大边权 dist1[][] 和严格次大边权 dist2[][]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        dfs(i, <span class="number">-1</span>, <span class="number">-1e9</span>, dist1[i], <span class="number">-1e9</span>, dist2[i]); <span class="comment">// 初始值必须是最小值 -1e9，否则 res = min(res, sum + c - dist2[a][b]); 更新会有误</span></span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!edges[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line">            <span class="comment">// 这里的 c &gt;= dist[a][b]，否则与最小生成树 sum、Kruskal 算法违背</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt; dist1[a][b])</span><br><span class="line">                res = min(res, sum + c - dist1[a][b]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt; dist2[a][b])</span><br><span class="line">                res = min(res, sum + c - dist2[a][b]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406100925018.png"alt="image-20240610092503546" /><figcaption aria-hidden="true">image-20240610092503546</figcaption></figure><h5 id="优化-1">优化</h5><p>【<strong>模板题</strong>：<ahref="https://www.acwing.com/activity/content/code/content/8581989/">AcWing356. 次小生成树 - AcWing</a>】</p><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm)\)</span></li><li><strong>步骤</strong>：</li></ul><ol type="1"><li><p><span class="math inline">\(Kruskal\)</span>求解最小生成树，同时标记图中的每条边是<strong>树边</strong>还是<strong>非树边</strong>：<spanclass="math inline">\(O(mlogm)\)</span></p></li><li><p><span class="math inline">\(BFS\)</span> 预处理得到 <spanclass="math inline">\(depth[\ ]\)</span>、<spanclass="math inline">\(fa[\ ][\ ]\)</span>、<spanclass="math inline">\(d[][]\)</span></p><ol type="1"><li><span class="math inline">\(depth[i]\)</span> 表示 <spanclass="math inline">\(i\)</span> 的深度，<spanclass="math inline">\(1\le i \le n\)</span></li><li><span class="math inline">\(fa\left[ i,j \right]\)</span> 表示从<span class="math inline">\(i\)</span> 开始向上走 <spanclass="math inline">\(2^j\)</span> 步到达的节点，<spanclass="math inline">\(0\le j \le logn\)</span></li></ol></li></ol><p><span class="math display">\[\begin{cases}    fa\left[ i,0 \right] =i\ \text{的父节点}\\    \\    fa\left[ i,j \right] =fa\left[ anc ,j-1 \right] ,  1\le j\le logn,\\\end{cases}\]</span></p><p>​ (c) <span class="math inline">\(d1\left[ i,j \right]\)</span> 和<span class="math inline">\(d2[i,j]\)</span> 分别表示从 <spanclass="math inline">\(i\)</span> 开始向上走 <spanclass="math inline">\(2^j\)</span>步的路径中边权<font color='blue'><strong>最大值</strong></font>和边权<font color='blue'><strong>严格次大值</strong></font>，<spanclass="math inline">\(0\le j \le logn\)</span> <spanclass="math display">\[\begin{cases}    d1\left[ i,0 \right] =i\ \text{到父节点的边权}\\    \\    d1\left[ i,j \right] =max(d1[i,j-1],d1\left[ fa\left[ i,j-1 \right],j-1 \right]) ,  1\le j\le logn\\\end{cases}\]</span></p><p><span class="math display">\[\begin{cases}    d2\left[ i,0 \right] =-\infty\\    \\    d2\left[ i,j \right] =\left\{ d1\left[ i,j-1 \right] ,d1\left[anc,j-1 \right] ,d2\left[ i,j-1 \right] ,d2\left[ anc,j-1 \right]\right\} , 1\leqslant j\leqslant \log n\\    \\    anc=fa\left[ i,j-1 \right]\end{cases}\]</span></p><ol start="3" type="1"><li><p>依次枚举<strong>非树边 <spanclass="math inline">\(a\xrightarrow{c}b\)</span></strong>：<spanclass="math inline">\(O(mlogn)\)</span>​</p><ol type="1"><li>将该边加入树中</li><li><font color='blue'><spanclass="math inline">\(LCA\)</span>树上倍增</font> 求解树中从 <spanclass="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span>路径上<font color='red'><strong>最大</strong></font>边权 <spanclass="math inline">\(dist1\)</span>和<font color='red'><strong>严格次大</strong></font>边权 <spanclass="math inline">\(dist2\)</span>：<spanclass="math inline">\(O(logn)\)</span>​</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c &gt; dist1)</span><br><span class="line">    <span class="keyword">return</span> c - dist1;</span><br><span class="line"><span class="keyword">if</span> (c &gt; dist2)</span><br><span class="line">    <span class="keyword">return</span> c - dist2;</span><br><span class="line"><span class="keyword">return</span> INF;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>更新 <code>res = min(res, sum + c - w)</code></li></ol></li></ol><hr /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="type">bool</span> f;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;<span class="comment">// 存储最小生成树</span></span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">17</span>], d1[N][<span class="number">17</span>], d2[N][<span class="number">17</span>];<span class="comment">// 17 = log(n) / log(2) 上取整</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal 构建最小生成树并返回边权之和 sum</span></span><br><span class="line">LL <span class="title function_">kruskal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    sort(edges, edges + m, [](Edge x, Edge y)&#123;<span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b =edges[i].b, c = edges[i].c;</span><br><span class="line">        <span class="type">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb, res += c, edges[i].f = <span class="literal">true</span>;</span><br><span class="line">            add(a, b, c), add(b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> root)</span></span><br><span class="line">&#123;</span><br><span class="line">    depth[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++ tt] = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!depth[j])</span><br><span class="line">            &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t, d1[j][<span class="number">0</span>] = w[i], d2[j][<span class="number">0</span>] = -INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">16</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> anc = fa[j][k - <span class="number">1</span>];</span><br><span class="line">                    fa[j][k] = fa[anc][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> distance[<span class="number">4</span>] = &#123;d1[j][k - <span class="number">1</span>], d1[anc][k - <span class="number">1</span>], d2[j][k - <span class="number">1</span>], d2[anc][k - <span class="number">1</span>]&#125;;</span><br><span class="line">                    </span><br><span class="line">                    d1[j][k] = d2[j][k] = -INF;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">int</span> d = distance[u];</span><br><span class="line">                        <span class="keyword">if</span> (d &gt; d1[j][k])</span><br><span class="line">                            d2[j][k] = d1[j][k], d1[j][k] = d;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (d != d1[j][k] &amp;&amp; d &gt; d2[j][k])</span><br><span class="line">                            d2[j][k] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> distance[N * <span class="number">2</span>], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">        &#123;</span><br><span class="line">            distance[cnt++] = d1[a][k];</span><br><span class="line">            distance[cnt++] = d2[a][k];</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">16</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">            &#123;</span><br><span class="line">                distance[cnt++] = d1[a][k];</span><br><span class="line">                distance[cnt++] = d2[a][k];</span><br><span class="line">                distance[cnt++] = d1[b][k];</span><br><span class="line">                distance[cnt++] = d2[b][k];</span><br><span class="line">                a = fa[a][k], b = fa[b][k];</span><br><span class="line">            &#125;</span><br><span class="line">        distance[cnt++] = d1[a][<span class="number">0</span>];</span><br><span class="line">        distance[cnt++] = d1[b][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求从 a 到 b 路径上的最大边权 dist1 和次大边权 dist2</span></span><br><span class="line">    <span class="type">int</span> dist1 = -INF, dist2 = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = distance[i];</span><br><span class="line">        <span class="keyword">if</span> (d &gt; dist1)</span><br><span class="line">            dist2 = dist1, dist1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d != dist1 &amp;&amp; d &gt; dist2)</span><br><span class="line">            dist2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 c &gt;= dist[a][b]，否则与最小生成树 sum、Kruskal 算法违背，返回 c - dist</span></span><br><span class="line">    <span class="keyword">if</span> (c &gt; dist1)</span><br><span class="line">        <span class="keyword">return</span> c - dist1;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; dist2)</span><br><span class="line">        <span class="keyword">return</span> c - dist2;</span><br><span class="line">    <span class="keyword">return</span> INF;<span class="comment">// 要求最小值，因此返回 INF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL sum = kruskal();</span><br><span class="line">    </span><br><span class="line">    bfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span> (!edges[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line">            res = min(res, sum + lca(a, b, c));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确性证明">正确性证明</h3><ul><li><strong>定义</strong>：<ul><li>设 <span class="math inline">\(T\)</span> 为图 <spanclass="math inline">\(G\)</span> 的一棵生成树，对于非树边 <spanclass="math inline">\(a\)</span> 和树边 <spanclass="math inline">\(b\)</span>，插入边 <spanclass="math inline">\(a\)</span>，并删除边 <spanclass="math inline">\(b\)</span> 的操作记为 <strong><spanclass="math inline">\((+a,-b)\)</span></strong></li><li>如果 <span class="math inline">\(T(+a,-b)\)</span>后，仍然是一棵生成树，称 <span class="math inline">\((+a,-b)\)</span> 是<span class="math inline">\(T\)</span>的一个<strong>可行交换</strong></li><li>称由 <span class="math inline">\(T\)</span>进行一次可行变换所得到的新的生成树集合称为 <spanclass="math inline">\(T\)</span>​ 的<strong>邻集</strong></li></ul></li><li><strong>定理</strong>：次小生成树一定在最小生成树的邻集中，即一定存在一颗次小生成树，且其与最小生成树只有一条边不同</li></ul><blockquote><p>:star:该定理对<font color='blue'><strong>严格最小生成树</strong></font>和<font color='blue'><strong>非严格最小生成树</strong></font>都成立</p></blockquote><ul><li>证明：假设存在一个图，其次小生成树与最小生成树至少有2条边不同</li></ul><blockquote><p>（1）非严格次小生成树的证明</p><p>将最小生成树的边从小到大的顺序排序，找到第一个不在次小生成树中的边假设为a-&gt;b。则按照 Kruskal 算法，当枚举到a-&gt;b这条边时，a 和 b 一定在 2个不同的连通分量中，次小生成树中不包含这条边，次小生成树中一定存在 从 a到 b 的其他路径，由于我们是按照从小到大的顺序枚举的所有边，当前a 和b不连通，之后联通了，而且没有使用 a-&gt;b 这条边，则次小生成树中 a 和 b连通路径上一定用了这条边之后的一条边，即为c-&gt;d，由于我们是按照从小到大的顺序枚举的所有边，则 c-&gt;d这条边的权值一定大于等于 a-&gt;b 这条边的权值，将次小生成树去掉 c-&gt;d加上a-&gt;b，得到的一定也是一颗新的生成树，且权值之和小于等于原来的次小生成树，且与最小生成树不一样的边数减少了1，不断重复上述过程，直到次小生成树和最小生成树只差一条边</p><p>（2）严格次小生成树证明</p><p>将最小生成树的边从小到大的顺序排序，找到第一个不在次小生成树中的边假设为a-&gt;b。则按照 Kruskal 算法，当枚举到a-&gt;b这条边时，a 和 b 一定在 2个不同的连通分量中，次小生成树中不包含这条边，次小生成树中一定存在 从 a到 b 的其他路径，由于我们是按照从小到大的顺序枚举的所有边，当前a 和b不连通，之后联通了，而且没有使用 a-&gt;b 这条边，则次小生成树中 a 和 b连通路径上一定用了这条边之后的一条边，即为c-&gt;d，由于我们是按照从小到大的顺序枚举的所有边，则 c-&gt;d这条边的权值一定大于等于 a-&gt;b 这条边的权值</p><p>[1] c-&gt;d 这条边的权值等于 a-&gt;b 这条边的权值，则将次小生成树去掉c-&gt;d 加上a-&gt;b，得到的仍然是一颗生成树，且与原来的次小生成树权值之和相等，我们就得到了一颗新的次小生成树，且与原来次小生成树不一样的边数减少了1</p><p>[2] c-&gt;d 这条边的权值严格大于 a-&gt;b这条边的权值，则将次小生成树去掉 c-&gt;d 加上a-&gt;b，得到的仍然是一颗生成树，但权值之和小于原来的次小生成树权值之和，这与严格次小生成树的定义矛盾</p></blockquote><h2 id="拓扑排序">拓扑排序</h2><ul><li>在<strong>拓扑序列</strong>中，所有的边都是<strong>从前往后</strong>指的，并非所有图都有拓扑排序：<ul><li>具有拓扑排序的图称为<strong>拓扑图</strong></li><li>没有拓扑排序的图一定存在回路</li><li><font color='red'><strong>有向无环图</strong></font>一定有拓扑排序（<strong>拓扑图</strong>&lt;==&gt;<font color='red'><strong>有向无环图</strong></font>）</li></ul></li><li><strong>应用：</strong><ul><li>判断一个有向图<font color='blue'><strong>是否有环</strong></font></li><li>得到<strong>拓扑序列</strong>，满足所有的边都是<strong>从前往后</strong>指的</li></ul></li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8010400/">AcWing848. 有向图的拓扑序列 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界矩阵存储</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// din[i] 存储点 i 的入度</span></span><br><span class="line"><span class="type">int</span> q[N], din[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始时：所有入度为零的点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!din[i])</span><br><span class="line">            q[++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 t 的所有出边，并更新入度d[], 队列q[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- din[j] == <span class="number">0</span>)</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图的同时初始化 din[]</span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">add</span>(a, b);</span><br><span class="line">    din[b] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在拓扑排序，输出-1；否则输出其中的一个拓扑排序</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">toposort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);<span class="comment">// 队列中的元素就是拓朴排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:green_apple:一个图的拓扑排序可能不唯一，如果要求输出<strong>字典序最小的拓扑排序</strong>，则将上面的普通队列改为<strong>优先队列(小根堆)</strong>即可</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8758054/">LeetCode802. 找到最终的安全状态 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8529803/">AcWing1191. 家谱树 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8727813/">AcWing1192. 奖金 - AcWing</a></li></ul><h2 id="判断负环">判断负环</h2><ul><li><p><strong>求负环一般使用 <span class="math inline">\(SPFA\)</span>算法</strong>：用一个 <code>cnt[i]</code> 记录从源点到 <code>i</code>号点的最短路 <code>dist[i]</code> 所经过的边数</p><ul><li><p>一个点被更新一次就 <spanclass="math inline">\(+1\)</span></p></li><li><p>一旦有点到源点的边数达到了 <span class="math inline">\(n\)</span>，就说明存在了负环</p></li></ul></li><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(nm)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8051410/">AcWing852. spfa判断负环 - AcWing</a>】</p></li></ul><h3 id="写法1stl循环队列-1">写法1：STL循环队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];              <span class="comment">// dist[x] 存储 1 号点到 x 的最短距离，cnt[x] 存储 1 到 x 的最短路中经过的边数</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化 dist 数组（因为如果存在负环，那么 dist 不管初始化为多少，都会被更新）</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有 n 个点（除了自己），那么加上自己之后一共有 n + 1 个点，由抽屉原理一定有两个点相同，所以存在环</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 该题是判断是否存在负环，并非判断是否存在从 1 开始的负环，因此需要将所有的点都加入队列中，更新周围的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])<span class="comment">// 判断正环修改为 &lt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果从 1 号点到 x 的最短路中包含至少 n 个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写法2数组模拟循环队列-1">写法2：数组模拟循环队列★</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];              <span class="comment">// dist[x] 存储 1 号点到 x 的最短距离，cnt[x] 存储 1 到 x 的最短路中经过的边数</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"><span class="type">int</span> q[N];<span class="comment">// 数组模拟循环队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">spfa</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化 dist 数组（因为如果存在负环，那么 dist 不管初始化为多少，都会被更新）</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有 n 个点（除了自己），那么加上自己之后一共有 n + 1 个点，由抽屉原理一定有两个点相同，所以存在环</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 该题是判断是否存在负环，并非判断是否存在从 1 开始的负环，因此需要将所有的点都加入队列中，更新周围的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[tt ++] = i;</span><br><span class="line">        <span class="comment">// if(tt == N)tt = 0;第一次不用判断</span></span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N)hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])<span class="comment">// 判断正环修改为 &lt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果从 1 号点到 x 的最短路中包含至少 n 个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N)tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1">注意</h3><ul><li>判断正环只需要将上述代码第 <span class="math inline">\(31\)</span>行变换一下符号即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i])</span><br></pre></td></tr></table></figure><ul><li><p>如果 <span class="math inline">\(SPFA\)</span> 判断负环 <spanclass="math inline">\(TLE\)</span>，尝试以下 <spanclass="math inline">\(2\)</span> 种优化方法（玄学 <spanclass="math inline">\(trick\)</span>），具体请参考 <ahref="https://www.acwing.com/activity/content/code/content/8575645/">AcWing1165. 单词环 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8576615/">AcWing1169. 糖果 - AcWing</a></p><ul><li><p>当所有点的入队次数超过 <span class="math inline">\(2n\)</span>或某一数值时，我们就认为图中存在负环</p></li><li><p>将 <span class="math inline">\(SPFA\)</span>​算法中的<strong>队列替换为栈</strong>，只需将第 <spanclass="math inline">\(24\)</span> 行修改一下即可</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = q[tt --];</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202406061744134.png"alt="image-20240606174418670" /><figcaption aria-hidden="true">image-20240606174418670</figcaption></figure><ul><li>为什么初始时要将所有点入队?</li></ul><blockquote><p>​<strong>首先在原图中，所有的负环并非都可以从源点走到</strong>。为此我们可以假设一个虚拟源点<span class="math inline">\(0\)</span>​点，从虚拟源点向原图中的所有顶点连一条权值是 <spanclass="math inline">\(0\)</span>​的边，这个新图其实是和原图等价的，原图上有负环等价于新图上有负环，而新图中的所有负环都可以从源点走到</p><p>​ 因此我们在新图中做 <span class="math inline">\(spfa\)</span>的时候首先把源点 <span class="math inline">\(0\)</span>入队，第一次迭代的时候会把 <span class="math inline">\(0\)</span>出队，然后把和 <span class="math inline">\(0\)</span>点相连的点全部入队，那么就相当于把 <spanclass="math inline">\(1\)</span> ~ <spanclass="math inline">\(n\)</span>的所有点入队，所以我们直接把所有点入队，效果是一样的，相当于自己手动迭代了一次<span class="math inline">\(spfa\)</span></p><p>​ 因为我们检验的回路不一定以1号点为起点，所以要把他们都加进来。如果 1与负环回路不连通，那么如果只以 1 为起点，根据 spfa的原理，负环回路将得不到更新，从而判断失误</p><p>​<strong>如果只判断从源点出发是否可以到达负环，或者已知源点出发可以到达所有顶点，那么初始时只需要将源点入队即可</strong></p></blockquote><ul><li>在<strong>初始时所有点已经入队</strong>的前提下，<code>dist[]</code>初始化为什么值都无所谓</li></ul><blockquote><p>​ <span class="math inline">\(SPFA\)</span>算法中，假设存在负环，那么负环上的点到虚拟源点 <spanclass="math inline">\(0\)</span> 的距离一定是 <spanclass="math inline">\(-INF\)</span>，因为我可以在负环上跑无限次，每次都能把我到 <spanclass="math inline">\(0\)</span>点的距离减小。然后因为边上的权值都是有限值，所以每次在负环上跑一圈就相当于<code>dist[]</code>减去一个有限值，最终<code>dist[] == -INF</code>，所以意味着会减无限次（简单明了的说就是我们在负环上跑无限次，就可以把我到<span class="math inline">\(0\)</span> 点的距离减成 <spanclass="math inline">\(-INF\)</span>）。重点来了，<code>dist[]</code>初值肯定是一个有限值，一个有限值每次减一个有限值（负环上跑一次），然后减无限次，最终<code>dist[]</code>减成<spanclass="math inline">\(-INF\)</span>。即<code>dist[]</code>初值是多少都无所谓，因为会减无限次有限值，你再大的数减无限次有限值肯定减成<spanclass="math inline">\(-INF\)</span>。我们只要用抽屉原理保证迭代超过<span class="math inline">\(n\)</span> 次的时候，说明路径上有起码 <spanclass="math inline">\(n + 1\)</span>​个点，说明有重复点，即有负环就行，<code>dist[]</code>的初值并不影响SPFA算法判断负环</p></blockquote><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8574338/">AcWing904. 虫洞 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8575194/">AcWing361. 观光奶牛 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8575645/">AcWing1165. 单词环 - AcWing</a></p></li></ul><h2 id="有向图的强连通分量">有向图的强连通分量</h2><ul><li><p><strong>连通分量</strong>：分量中任意两个点之间都是互通的</p></li><li><p><strong>强连通分量（SCC）</strong>：极大连通分量</p></li><li><p><strong>应用场景</strong>：</p></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407261526536.png" alt="image-20240726152622910" style="zoom: 25%;" /></p><ol type="1"><li>求出图中的所有强连通分量</li><li>将所有强连通分量缩成一个点【缩点】，将有向图转化为有向无环图/拓扑图（DAG）</li><li>在拓扑图上解决问题会更加简单</li></ol><h3 id="tarjan算法求scc">tarjan算法求SCC</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407261525091.png"alt="image-20240726151659348" /><figcaption aria-hidden="true">image-20240726151659348</figcaption></figure><ul><li><p><strong>时间复杂度</strong>：<spanclass="math display">\[O(n+m)\]</span></p></li><li><p>对每个点定义两个时间戳：</p><ul><li><p><code>dfn[u]</code> 遍历点 <span class="math inline">\(u\)</span>的编号</p></li><li><p><code>low[u]</code> 从 <span class="math inline">\(u\)</span>开始走，所能遍历到的最小编号</p></li></ul><p><span class="math inline">\(u\)</span> 是其所在强连通分量的最高点&lt;==&gt; <code>dfn[u] == low[u]</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="type">int</span> id[N], sz[N], scc_cnt;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="type">bool</span> in_stk[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">    stk[++ tt] = u, in_stk[u] = <span class="literal">true</span>; <span class="comment">// 注意这个地方的栈中存储的是该强连通分量中所有点和第一个不为强连通分量中的点的点集. 可能存在横叉边.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[j]) <span class="comment">// 未被遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(j);                    <span class="comment">// 遍历该点</span></span><br><span class="line">            low[u] = min(low[u], low[j]); <span class="comment">// j能走到的祖先节点, u也一定能走到, 更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j])               <span class="comment">// 在当前这个强连通分量里 强连通分量中u能走到的点, 不一定是属于该SCC(因为该点不一定就能到u), 只有在栈中的才属于</span></span><br><span class="line">            low[u] = min(low[u], dfn[j]); <span class="comment">// 用u能到的祖先节点更新u能走到的最小编号(注意不是最小层)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) <span class="comment">// 第一个非强连通分量中的点, 加入该连通分量就非连通分量了, 该连通分量为强连通分量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        scc_cnt ++;<span class="comment">// 缩点下标（强连通分量编号）从 1 开始</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = stk[tt --];</span><br><span class="line">            in_stk[y] = <span class="literal">false</span>;</span><br><span class="line">            id[y] = scc_cnt; <span class="comment">// 强连通分量编号</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (y != u)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有点，求出每个点所在的强连通分量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">        tarjan(i);</span><br></pre></td></tr></table></figure><h3 id="缩点建dag">缩点建DAG</h3><p>重新建立由缩点构成的图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], hs[N], e[M], ne[M], w[M], idx;<span class="comment">// h[] 是旧图，hs[] 是新图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = e[j];</span><br><span class="line">        <span class="keyword">if</span> (id[i] != id[k])</span><br><span class="line">            add(id[i], id[k]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="dfs求拓扑序">DFS求拓扑序</h3><p>:smile:tarjan算法求SCC后，<strong>强连通分量编号递减的顺序一定是拓扑序</strong>，以拓扑DP求最短路为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = scc_cnt; i; i -- )<span class="comment">// 缩点后新图的拓扑序列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = hs[i]; ~j; j = ne[j])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = e[j];</span><br><span class="line">        dist[k] = max(dist[k], dist[i] + w[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><spanclass="math inline">\(tarjan\)</span>算法是将一张连通图中的所有 SCC都跑一遍就都找出来</li><li><spanclass="math inline">\(tarjan\)</span>算法的顺序与DFS求拓扑序相同，当我们跑到了这张图的尾节点，for循环才退出，然后才判断该点是否为当前SCC的起点并不断回溯，并直到找到起点后在从栈中将scc弹出，并给上标号。所以我们说<code>scc_cnt</code>倒序为拓扑序，因为最后一个scc被赋予的<code>scc_cnt = 1</code></li></ol><h3 id="例题-4">例题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8706972/">AcWing1174. 受欢迎的牛 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8707165/">AcWing367. 学校网络 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8707496/">AcWing1175. 最大半连通子图 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8727551/">AcWing368. 银河 - AcWing</a></p></li></ul><h2 id="无向图的连通分量">无向图的连通分量</h2><p>无向图使用<span class="math inline">\(DFS\)</span>/<spanclass="math inline">\(BFS\)</span>即可求出所有的连通分量，具体参考<ahref="#tude">图的遍历</a></p><h2 id="二分图">二分图</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131944501.png"alt="image-20240313194459355" /><figcaption aria-hidden="true">image-20240313194459355</figcaption></figure><p>如果一张<strong>无向图</strong>的 <spanclass="math inline">\(N\)</span> 个节点（<spanclass="math inline">\(N\ge 2\)</span>）可以分成 <spanclass="math inline">\(A,B\)</span> 两个非空集合（其中 $AB=<spanclass="math inline">\(）且&lt;fontcolor=&#39;red&#39;&gt;**在同一集合内部点之间没有边相连**&lt;/font&gt;，那么称这张无向图为一张**二分图**。\)</span>A,B$分别称为二分图的左部和右部</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fda429e87f533fa6e6677b6f69ed7b8a.png" alt="img" style="zoom:33%;" /></p><blockquote><p>注意：二分图不一定是连通图</p></blockquote><h3 id="判断是否为二分图染色法">判断是否为二分图——染色法</h3><p>【<strong>定理</strong>】三角等价</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409050101686.png"alt="image-20240905010114590" /><figcaption aria-hidden="true">image-20240905010114590</figcaption></figure><blockquote><p>奇数环：边数为奇数的环</p></blockquote><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/8056401/">AcWing860. 染色法判定二分图 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;                   <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];               <span class="comment">// 表示每个点的颜色，0 表示未染色，1 表示白色，2 表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数：u表示当前节点，c表示当前点的颜色 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">// u 点染成颜色 c</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j])<span class="comment">// 相邻的点没有颜色,则递归处理这个相邻点</span></span><br><span class="line">        <span class="comment">/* 不能省略 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c))<span class="comment">// （3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）</span></span><br><span class="line">                                <span class="comment">// （3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 不能省略 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="comment">// 如果已经染色，判断颜色是否为 c</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 作用：染色法判断是否为二分图 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二分图不一定是连通图，所以要依次对每个点遍历判断，而不能直接 dfs(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>)) <span class="comment">// 第一次染色的一定是某个连通分量中的第一个点，所以染成颜色 1/2 都可以，然后调用dfs即可将其所在连通分量的所以点染色</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意上面的代码第13、17行的 <code>&#123;&#125;</code> 不能省略，否则下面的<code>else if</code> 错位接到离他最近的 <code>if</code> 分支</p></blockquote><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8820986/">AcWing1293. 夏洛克和他的女朋友 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8822994/">AcWing257. 关押罪犯 - AcWing</a></p></li></ul><h3id="求二分图的最大匹配匈牙利算法">求二分图的最大匹配——匈牙利算法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409050018354.gif"alt="Rec_2024-09-05_0002(2)" /><figcaption aria-hidden="true">Rec_2024-09-05_0002(2)</figcaption></figure><p>相关概念</p><ul><li><strong>匹配</strong>是“任意两条边都没有公共端点”的<strong>边的集合</strong>；<strong>最大匹配</strong>是包含边数最多的一组匹配</li><li>对于任意一组匹配 <span class="math inline">\(S\)</span>（<spanclass="math inline">\(S\)</span> 是一个边集），属于 <spanclass="math inline">\(S\)</span>的边被称为“<strong>匹配边</strong>”，不属于 <spanclass="math inline">\(S\)</span>的边被称为“<strong>非匹配边</strong>”。匹配边的端点被称为“<strong>匹配点</strong>”，其他节点被称为“<strong>非匹配点</strong>”。如果在二分图中存在一条连接两个非匹配点的路径<span class="math inline">\(path\)</span>，使得非匹配边与匹配边在 <spanclass="math inline">\(path\)</span> 上交替出现，那么称 <spanclass="math inline">\(path\)</span> 是匹配 <spanclass="math inline">\(S\)</span>的<strong>增广路</strong>，也称<strong>交错路</strong></li></ul><blockquote><p>增广路即<strong>非匹配点</strong>—非匹配边—匹配边—非匹配边— <spanclass="math inline">\(\cdots \cdots\)</span>—匹配边—非匹配边—<strong>非匹配点</strong></p></blockquote><ul><li><p>增广路显然具有以下性质：</p><ol type="1"><li>路径边数 <span class="math inline">\(len\)</span>是<strong>奇数</strong></li><li>路径上第 <span class="math inline">\(1,3,5,…,len\)</span>条边是非匹配边，第 <span class="math inline">\(2,4,6,…,len-1\)</span>条边是匹配边（非匹配边的数量比匹配边的数量多 <spanclass="math inline">\(1\)</span>）</li></ol><p>正因为以上性质，如果我们把路径上所有边的状态取反，原来的匹配边变成非匹配的，原来的非匹配边变成匹配的，那么得到的新的边集<span class="math inline">\(S’\)</span>仍然是一组匹配，并且匹配边数增加了 <spanclass="math inline">\(1\)</span>。进一步可以得到推论：</p><p><strong>二分图的一组匹配 <span class="math inline">\(S\)</span>是最大匹配，当且仅当图中不存在 <span class="math inline">\(S\)</span>的增广路</strong></p></li></ul><p><strong>匈牙利算法</strong>只能求解<strong>二分图</strong>的最大匹配问题，不能求解一般图的最大匹配问题</p><p>【<strong>时间复杂度</strong>】<spanclass="math inline">\(O(mn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数、<spanclass="math inline">\(m\)</span> 表示边数</p><p>【<strong>模板题</strong>】<ahref="https://www.acwing.com/activity/content/code/content/8060126/">AcWing861. 二分图的最大匹配 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;                 <span class="comment">// n1 表示第一个集合中男生人数，n2 表示第二个集合中女生人数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];               <span class="comment">// match[i] 表示第二个集合中点 i 当前匹配的第一个集合中的点</span></span><br><span class="line"><span class="type">bool</span> st[N];                 <span class="comment">// 表示第二个集合中的每个点是否已经被考虑过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~ i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果妹子还没有匹配任何男生 或者 匹配的那个男生可以更换妹子</span></span><br><span class="line">            <span class="keyword">if</span> (!match[j] || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;<span class="comment">// 一定要修改对应的匹配，否则之后的匹配会出错</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求最大匹配数 */</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 依次枚举第一个集合中的每个点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="comment">// 第一个集合中的点 i 能在第二个集合中找到对应的匹配</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">        res ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8824385/">AcWing372. 棋盘覆盖 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/252844/">AcWingT1. 棋子 - AcWing</a></p></li></ul><h2 id="差分约束">差分约束</h2><blockquote><p>视频讲解：<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/154827/">3.5差分约束 - AcWing</a></p></blockquote><h3 id="原理">原理</h3><p>对于<strong>任意一条<font color ='red'>有向边</font></strong>（假设为<span class="math inline">\(j\xrightarrow{c}i\)</span>）</p><ul><li>在求完<strong>单源最短路</strong>之后，均存在下面的“三角不等式”：</li></ul><p><span class="math display">\[dist\left[ i \right] \leqslant dist\left[ j \right] +c\]</span></p><blockquote><p>否则如果存在 <span class="math inline">\(dist\left[ i \right] &gt;dist\left[ j \right] +c\)</span> ，就一定可以用 <spanclass="math inline">\(dist\left[ j \right] +c\)</span> 更新 <spanclass="math inline">\(dist\left[ i\right]\)</span>，与单源最短路矛盾</p></blockquote><ul><li>在求完<strong>单源最长路</strong>之后，均存在下面的“三角不等式”：</li></ul><p><span class="math display">\[dist\left[ i \right] \geqslant dist\left[ j \right] +c\]</span></p><blockquote><p>否则如果存在 <span class="math inline">\(dist\left[ i \right] &lt;dist\left[ j \right] +c\)</span> ，就一定可以用 <spanclass="math inline">\(dist\left[ j \right] +c\)</span> 更新 <spanclass="math inline">\(dist\left[ i\right]\)</span>，与单源最长路矛盾</p></blockquote><p>因此，<strong>单源最短/长路</strong>问题与<strong>差分约束</strong>问题<font color='blue'><strong>等价</strong></font></p><blockquote><p>注：最短路问题与最长路本质也是一致的</p></blockquote><h3 id="源点条件">源点条件</h3><p>⭐<strong>源点</strong>需要满足的条件：从源点出发，一定可以走到<font color='red'><strong>所有的边</strong></font></p><blockquote><ul><li>否则：用单源最短路做的话，如果有一条边走不到，则该边对应的不等式就无法满足</li><li>某一个点<code>x[i]</code>走不到无所谓（某个点走不到表明它不受任何限制，取任何数都可以）</li><li>如果从源点出发可以走到所有顶点，则必然也可以到达所有边（反过来不成立，因为可能有孤立点）</li></ul></blockquote><h3 id="应用1求可行解">应用1：求可行解</h3><h4 id="问题">问题</h4><p><strong>差分约束</strong>可以求解如下不等式组的<strong>一组可行解</strong>：<span class="math display">\[x\left[ i \right] &lt;=x\left[ j \right] +c\left[ k \right],\ \ \ \ \i,j,k=1,2,...\ \ \ 其中c[j] 为常数\]</span></p><h4 id="步骤">步骤</h4><ol type="1"><li>把 <span class="math inline">\(x\left[ i \right] &lt;=x\left[ j\right] +c\left[ k \right]\)</span> 转化为 <spanclass="math inline">\(j\xrightarrow{c_\left[k\right]}i\)</span></li><li>然后在这个图上<strong>随便</strong>找一个<strong>超级源点</strong>，使得该源点一定可以遍历到<font color='red'><strong>所有边</strong></font></li><li>从<strong>超级源点</strong>求一遍<strong>单源最短路</strong></li><li>求完单源最短路之后：<ol type="1"><li>存在负环 &lt;=&gt; 不等式无解</li><li>没有负环 &lt;=&gt; <span class="math inline">\(dist[]\)</span>即一个可行解</li></ol></li></ol><blockquote><p>最长路类似，在此不予阐述</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">如果图中存在负权回路，最短路不一定存在，假如存在如下的负环：</span><br><span class="line">  x[<span class="number">1</span>]→x[<span class="number">2</span>]→x[<span class="number">3</span>]→x[<span class="number">4</span>]</span><br><span class="line">    ↑ c1   c2   c3 ↓</span><br><span class="line">      ← ← ← ← ← ← </span><br><span class="line">          c4</span><br><span class="line">其中 c[<span class="number">1</span>] + c[<span class="number">2</span>] + c[<span class="number">3</span>] + c[<span class="number">4</span>] &lt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">2</span>] ≤ x[<span class="number">1</span>] + c[<span class="number">1</span>]</span><br><span class="line">x[<span class="number">3</span>] ≤ x[<span class="number">2</span>] + c[<span class="number">2</span>]</span><br><span class="line">x[<span class="number">4</span>] ≤ x[<span class="number">3</span>] + c[<span class="number">3</span>]</span><br><span class="line">x[<span class="number">1</span>] ≤ x[<span class="number">4</span>] + c[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">对第一个不等式用后面的不等式一直做松弛</span><br><span class="line">x[<span class="number">2</span>] ≤ x[<span class="number">1</span>] + c[<span class="number">1</span>]</span><br><span class="line">     ≤ x[<span class="number">4</span>] + c[<span class="number">4</span>] + c[<span class="number">1</span>]</span><br><span class="line">     ≤ x[<span class="number">3</span>] + c[<span class="number">3</span>] + c[<span class="number">4</span>] + c[<span class="number">1</span>]</span><br><span class="line">     ≤ x[<span class="number">2</span>] + c[<span class="number">2</span>] + c[<span class="number">3</span>] + c[<span class="number">4</span>] + c[<span class="number">1</span>]</span><br><span class="line">     ≤ x[<span class="number">2</span>] + (小于零的Σc[i])</span><br><span class="line">x[<span class="number">2</span>] &lt; x[<span class="number">2</span>] 矛盾</span><br><span class="line"></span><br><span class="line">得出结论：不等式无解 &lt;=&gt; 存在负环</span><br></pre></td></tr></table></figure><h3 id="应用2求最小值">应用2：求最小值</h3><h4 id="问题-1">问题</h4><ul><li>求<strong>每个变量 <span class="math inline">\(x[i],i=1,2,…\)</span></strong>的<strong>最小值</strong>（使用<strong>最长路</strong>）</li></ul><p><span class="math display">\[\left\{ \begin{array}{l}    x\left[ i \right] \geqslant x\left[ j \right] +c\left[ j \right]\\    x\left[ k \right] \geqslant c\left[ k \right]\text{或 }x[k]=c[k]\\\end{array}, i/j=1,2,... \right. \text{其中}c\left[ 1,2,... \right],k\text{为常数}\]</span></p><blockquote><ol type="1"><li>如果 <span class="math inline">\(x[k]=c[k]\)</span> ，则转化为 <spanclass="math inline">\(x[k]\ge c[k],\quad x[k]\le c[k]\)</span></li><li>多了一个绝对关系不等式 <span class="math inline">\(x\left[ k \right]\geqslant c\left[ k\right]\)</span>，否则所有变量减去任意常数仍然是不等式的一组解</li></ol></blockquote><h4 id="步骤-1">步骤</h4><ul><li><p>建立<strong>超级源点</strong>（假设为 <strong><spanclass="math inline">\(0\)</span> 号点</strong>），则 <spanclass="math inline">\(x[0] =0\)</span><strong>【绝对关系】</strong></p></li><li><p>把 <span class="math inline">\(x[k] \ge c\)</span> 转化为 <spanclass="math inline">\(0\xrightarrow{c}k\)</span>，<spanclass="math inline">\(x[k] \le c\)</span> 转化为 <spanclass="math inline">\(k\xrightarrow{-c}0\)</span></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[k] ≥ c&lt;=&gt;x[k] ≥ x[<span class="number">0</span>] + c, </span><br><span class="line">x[k] ≤ c&lt;=&gt;x[<span class="number">0</span>] ≥ x[k] - c, </span><br></pre></td></tr></table></figure><ul><li>把 <span class="math inline">\(x[i]\ge x[j] + c[k]\)</span> 转化为<spanclass="math inline">\(j\xrightarrow{c_\left[k\right]}i\)</span></li><li>求源点 <span class="math inline">\(0\)</span>号点到其余所有点的<font color='red'><strong>最长</strong></font>路径，<spanclass="math inline">\(dist[]\)</span> 即为最大值</li></ul><h3 id="应用3求最大值">应用3：求最大值</h3><h4 id="问题-2">问题</h4><ul><li>求<strong>每个变量 <span class="math inline">\(x[i],i=1,2,…\)</span></strong>的<strong>最大值</strong>（使用<strong>最短路</strong>）</li></ul><p><span class="math display">\[\left\{ \begin{array}{l}    x\left[ i \right] \leqslant x\left[ j \right] +c\left[ j \right]\\    x\left[ k \right] \leqslant c\left[ k \right]\text{或 }x[k]=c[k]\\\end{array}, i/j=1,2,... \right. \text{其中}c\left[ 1,2,... \right],k\text{为常数}\]</span></p><blockquote><ol type="1"><li>如果 <span class="math inline">\(x[k]=c[k]\)</span> ，则转化为 <spanclass="math inline">\(x[k]\ge c[k],\quad x[k]\le c[k]\)</span></li><li>多了一个绝对关系不等式 <span class="math inline">\(x\left[ k \right]\leqslant c\left[ k \right]\)</span></li></ol></blockquote><h4 id="步骤-2">步骤</h4><ul><li>建立<strong>超级源点</strong>（假设为 <strong><spanclass="math inline">\(0\)</span> 号点</strong>），则 <spanclass="math inline">\(x[0] =0\)</span><strong>【绝对关系】</strong></li><li>把 <span class="math inline">\(x[k] \le c\)</span> 转化为 <spanclass="math inline">\(0\xrightarrow{c}k\)</span>，<spanclass="math inline">\(x[k] \ge c\)</span> 转化为 <spanclass="math inline">\(k\xrightarrow{-c}0\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[k] ≤ c&lt;=&gt;x[k] ≤ x[<span class="number">0</span>] + c</span><br><span class="line">x[k] ≥ c&lt;=&gt;x[<span class="number">0</span>] ≤ x[k] - c</span><br></pre></td></tr></table></figure><ul><li>把 <span class="math inline">\(x[i] ≤ x[j] + c[k]\)</span>转化为一条从 <span class="math inline">\(j\)</span> 号点走到 <spanclass="math inline">\(i\)</span> 号点、长度为 <spanclass="math inline">\(c[k]\)</span> 的有向边</li><li>求源点 <span class="math inline">\(0\)</span>号点到其余所有点的<font color='red'><strong>最短</strong></font>路径，<spanclass="math inline">\(dist[]\)</span> 即为最小值</li></ul><h4 id="原理-1">原理</h4><p>以求<strong>每个变量 <spanclass="math inline">\(x[i],i=1,2,…\)</span></strong>的<strong>最大值</strong>为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">3</span> → <span class="number">5</span> → ... → i</span><br><span class="line">  c1  c3  c5       ci<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">1</span>] ≤ x[<span class="number">0</span>] + c[<span class="number">1</span>] </span><br><span class="line">x[<span class="number">3</span>] ≤ x[<span class="number">1</span>] + c[<span class="number">3</span>] </span><br><span class="line">x[<span class="number">5</span>] ≤ x[<span class="number">3</span>] + c[<span class="number">5</span>]</span><br><span class="line">...</span><br><span class="line">x[i] ≤ x[i<span class="number">-1</span>] + c[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">则</span><br><span class="line">x[i] ≤ x[i<span class="number">-1</span>] + c[i] </span><br><span class="line">     ≤ x[i<span class="number">-3</span>] + c[i<span class="number">-3</span>] + c[i]</span><br><span class="line">     ...</span><br><span class="line">     ≤ x[<span class="number">0</span>] + c[<span class="number">1</span>] + c[<span class="number">3</span>] + c[i<span class="number">-3</span>] + c[i<span class="number">-1</span>] = c[<span class="number">1</span>] + c[<span class="number">3</span>] + c[i<span class="number">-3</span>] + c[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">我们发现：</span><br><span class="line">(<span class="number">1</span>) 不等式链得到的某个上界，就是从<span class="number">0</span>→i的条路径长度</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 从<span class="number">0</span>→i的一条路径长度，就是不等式链得到的某个上界</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) 因此x[i]的某个上界 &lt;=&gt; 从<span class="number">0</span>→i的条路径长度</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">    求x[i]最大值</span><br><span class="line">        &lt;=&gt;</span><br><span class="line">    求所有上界的最小值</span><br><span class="line">        &lt;=&gt;</span><br><span class="line">    求所有从<span class="number">0</span>→i的路径长度的最小值</span><br><span class="line">        &lt;=&gt;</span><br><span class="line">    最短路求dist[i]</span><br><span class="line"></span><br><span class="line">举例 x[i] ≤ <span class="number">5</span></span><br><span class="line">     x[i] ≤ <span class="number">2</span></span><br><span class="line">     x[i] ≤ <span class="number">3</span></span><br><span class="line">     max(x[i]) = min(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">同理:</span><br><span class="line">求x[i]最小值</span><br><span class="line">        &lt;=&gt;</span><br><span class="line">    求所有下界的最大值</span><br><span class="line">        &lt;=&gt;</span><br><span class="line">    求所有从<span class="number">0</span>→i的路径长度的最大值</span><br><span class="line">        &lt;=&gt;</span><br><span class="line">    最长路求dist[i]</span><br><span class="line"></span><br><span class="line">举例 x[i] ≥ <span class="number">5</span></span><br><span class="line">     x[i] ≥ <span class="number">2</span></span><br><span class="line">     x[i] ≥ <span class="number">3</span></span><br><span class="line">     min(x[i]) = max(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>) = <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="总结-2">总结★</h3><p>差分约束问题：</p><ul><li>求最小值要用最长路，存在正环说明无解</li></ul><table><colgroup><col style="width: 9%" /><col style="width: 11%" /><col style="width: 21%" /><col style="width: 57%" /></colgroup><thead><tr class="header"><th>条件</th><th>算法</th><th>时间复杂度</th><th>例题</th></tr></thead><tbody><tr class="odd"><td>边权无限制</td><td><span class="math inline">\(SPFA\)</span></td><td>平均<span class="math inline">\(O(m)\)</span> 最坏<spanclass="math inline">\(O(nm)\)</span></td><td><ahref="https://www.acwing.com/activity/content/code/content/8576615/">AcWing1169. 糖果 - AcWing</a><br /><ahref="https://www.acwing.com/activity/content/code/content/8577036/">AcWing362. 区间 - AcWing</a><br /><ahref="https://www.acwing.com/activity/content/code/content/8577767/">AcWing393. 雇佣收银员 - AcWing</a></td></tr><tr class="even"><td>边权<span class="math inline">\(\ge0\)</span></td><td><span class="math inline">\(tarjan-SCC\)</span></td><td><span class="math inline">\(O(n+m)\)</span></td><td><ahref="https://www.acwing.com/activity/content/code/content/8727551/">AcWing368. 银河 - AcWing</a></td></tr><tr class="odd"><td>边权<span class="math inline">\(&gt;0\)</span></td><td>拓扑排序</td><td><span class="math inline">\(O(n+m)\)</span></td><td><ahref="https://www.acwing.com/activity/content/code/content/8727813/">AcWing1192. 奖金 - AcWing</a></td></tr></tbody></table><ul><li>求最大值要用最短路，存在负环说明无解</li></ul><table><colgroup><col style="width: 9%" /><col style="width: 11%" /><col style="width: 21%" /><col style="width: 57%" /></colgroup><thead><tr class="header"><th>条件</th><th>算法</th><th>时间复杂度</th><th>例题</th></tr></thead><tbody><tr class="odd"><td>边权无限制</td><td><span class="math inline">\(SPFA\)</span></td><td>平均<span class="math inline">\(O(m)\)</span> 最坏<spanclass="math inline">\(O(nm)\)</span></td><td><ahref="https://www.acwing.com/activity/content/code/content/8577333/">AcWing1170. 排队布局 - AcWing</a></td></tr><tr class="even"><td>边权<span class="math inline">\(\le0\)</span></td><td><span class="math inline">\(tarjan-SCC\)</span></td><td><span class="math inline">\(O(n+m)\)</span></td><td></td></tr><tr class="odd"><td>边权<span class="math inline">\(&lt;0\)</span></td><td>拓扑排序</td><td><span class="math inline">\(O(n+m)\)</span></td><td></td></tr></tbody></table><h2 id="欧拉路径与欧拉回路">欧拉路径与欧拉回路</h2><h3 id="定义">定义</h3><ul><li><strong>欧拉路径</strong>：也叫“<strong>一笔画</strong>”路径，指从某一点出发，经过图中的<strong>所有边</strong>，且<strong>每条边仅经过一次</strong>的路径</li><li><strong>欧拉回路</strong>：<font color='red'><strong>起点等于终点</strong></font>的<strong>欧拉路径</strong></li></ul><h3 id="定理">定理</h3><ol type="1"><li>对于无向图，且<strong>所有边都是连通的</strong>，则<ol type="1"><li>存在欧拉路径的充要条件：度数为奇数的点只能有0个或2个（起点和终点）</li><li>存在欧拉回路的充要条件：度数为奇数的点只能有0个</li></ol></li></ol><blockquote><p>无向图且度数为奇数的点只有0个：此时从任何一个点出发均存在一条欧拉回路</p><p>无向图且度数为奇数的点只有2个：这两个点一个是起点，一个是终点</p></blockquote><ol start="2" type="1"><li>对于有向图，且<strong>所有边都是连通的</strong>，则<ol type="1"><li>存在欧拉路径的充要条件：要么所有点的出度均等于入度；要么除了两个点之外，其余所有点的出度等于入度，剩余的两个点：一个满足出度比入度多1（起点），另一个满足入度比出度多1（终点）</li><li>存在欧拉回路的充要条件：所有点的出度均等于入度</li></ol></li></ol><blockquote><p>无论是有向图还是无向图，存在欧拉路径和欧拉回路的必要条件是，<strong>所有的边都是连通的</strong>（即存在某一点，使得从该点出发，可以经过图中所有边）</p></blockquote><h3 id="例题-5">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8813292/">AcWing1123. 铲雪车 - AcWing</a></li></ul><h2 id="分层图">分层图</h2><p>​分层图是一种将点拆开，<strong>复制多层图</strong>，并利用<strong>特殊构造的边</strong>（例如权值为<span class="math inline">\(0\)</span>的边）将<strong>各层相连</strong>的建图方法，一般用于<strong>边</strong>/<strong>点</strong>有<strong>特殊限制</strong>的问题（如<strong>重复经过次数，多种价值可选，删掉一些边</strong>等）</p><h3 id="模板">模板</h3><p>​ 以<a href="https://www.acwing.com/solution/content/252600/">AcWing2953. 飞行路线 -AcWing</a>为例：我们把免费操作转化成零边，如果进行免费操作，就进入下一层，蓝边就是零边，建<span class="math inline">\(k + 1\)</span>层图，如果执行免费操作就进入下一层。总共有 <span class="math inline">\(k+ 1\)</span> 层，对应 <span class="math inline">\(k\)</span> 次操作</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409021819041.jpg"alt="e3ab3fec7f419ad4998c82a1388b1bf" /><figcaptionaria-hidden="true">e3ab3fec7f419ad4998c82a1388b1bf</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n, m 分别为原图顶点数和边数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建立第 j 层的边</span></span><br><span class="line">        <span class="built_in">add</span>(a + j * n, b + j * n, c);</span><br><span class="line">        <span class="built_in">add</span>(b + j * n, a + j * n, c);</span><br><span class="line">        <span class="comment">// 建立从第 j - 1 层到第 j 层的单向边【不能建方向边】</span></span><br><span class="line">        <span class="built_in">add</span>(a + (j - <span class="number">1</span>) * n, b + j * n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(b + (j - <span class="number">1</span>) * n, a + j * n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每两个相邻层的汇点 t 之间连接一条权值为 0 的【某些题目不能将汇点相连】</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">    <span class="built_in">add</span>(t + (i - <span class="number">1</span>) * n, t + i * n, <span class="number">0</span>);<span class="comment">// 单向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终结果为 dist[t + k * n]</span></span><br><span class="line">cout &lt;&lt; dist[t + k * n] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>​ 由于最多（而非必须）进行 <span class="math inline">\(k\)</span>次免费操作，因为问题就等价为求从<strong>第 <spanclass="math inline">\(0\)</span> 层的源点</strong>（ <spanclass="math inline">\(s\)</span> 号节点）到第 <spanclass="math inline">\(0\sim k\)</span> <strong>任意一层汇点</strong>（<span class="math inline">\(t\)</span>号节点）的最短距离。为了方便求解，我们在每<strong>相邻层的汇点</strong>之间连接一条<strong>权值为<span class="math inline">\(0\)</span>的边</strong>，这样问题就等价为求从 <spanclass="math inline">\(0\)</span> 层的 <spanclass="math inline">\(s\)</span> 号节点到第 <spanclass="math inline">\(k\)</span> 层的 <spanclass="math inline">\(t\)</span> 号节点的最短距离</p><blockquote><p>当最短路径上的总边数小于 <spanclass="math inline">\(k\)</span>（eg：总边数 <spanclass="math inline">\(m\)</span> 小于 <spanclass="math inline">\(k\)</span>），也就是说可能最短路径在中间某层的汇点就已经达到了<spanclass="math inline">\(0\)</span>，再向下走反而会使总路径增大。为了避免这种情况，我们可以在每两个相邻层的汇点之间连接一条权值为<span class="math inline">\(0\)</span> 的边。</p></blockquote><h3 id="正确性证明-1">正确性证明</h3><p>只要图中不存在负环，则某一点到另一点的最短路径一定不会经过某条边两次，因此</p><h3 id="注意-2">注意</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> K = <span class="number">10</span>, N = (K + <span class="number">1</span>) * (<span class="number">1e5</span> + <span class="number">5</span>), M = (<span class="number">2</span> * K + <span class="number">1</span>) * (<span class="number">5e4</span> + <span class="number">5</span>);<span class="comment">// k 为最大层数</span></span><br></pre></td></tr></table></figure><p>分层图建立了 <span class="math inline">\(k+1\)</span> 层图</p><ul><li>顶点数是原来的 <span class="math inline">\(K+1\)</span> 倍</li><li>边数是原来的 <span class="math inline">\(2 * K+1\)</span> 倍</li></ul><p>空间复杂度为 <span class="math inline">\(O(k(n+m))\)</span>，因此当顶点数 <span class="math inline">\(n\)</span> 、边数 <spanclass="math inline">\(m\)</span> 、层数 <spanclass="math inline">\(k\)</span> 较多时，分层图可能会 <spanclass="math inline">\(MLE\)</span></p><h3 id="例题-6">例题</h3><ul><li><p><a href="https://www.acwing.com/solution/content/252600/">AcWing2953. 飞行路线 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/252605/">HDUSDUT 2493. Constructing Roads - AcWing</a>、<ahref="https://www.acwing.com/solution/content/252609/">AcWing 3095. 冻结- AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8569870/">AcWing340. 通信线路 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8728197/">AcWing341. 最优贸易 - AcWing</a></p></li></ul><h1 id="技巧">技巧</h1><h2 id="重边自环">重边、自环</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101605409.jpeg" style="zoom:20%;" /></p><ul><li><p>自环对算法没有影响</p></li><li><p>重边对适用邻接矩阵求最短路算法有影响</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用邻接表存储图——无任何影响</span></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    add(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用邻接矩阵存储图——输入修改</span></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    g[a][b] = min(g[a][b], c);<span class="comment">// 用来处理重边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多组测试数据">多组测试数据</h2><h3 id="邻接表初始化">邻接表初始化</h3><p>​如果题目中有<strong>多组测试用例</strong>，每个测试用例都需要重新建立树/图，则每次<strong>只需要对<code>idx</code>、 <code>h[]</code> 重新初始化</strong>，以<ahref="https://www.acwing.com/activity/content/code/content/8500326/">AcWing323. 战略游戏 - AcWing</a>为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">bool</span> has_fa[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重新初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h), idx = <span class="number">0</span>;;</span><br><span class="line">    <span class="built_in">memset</span>(has_fa, <span class="number">0</span>, <span class="keyword">sizeof</span> has_fa);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, cnt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:(%d)&quot;</span>, &amp;a, &amp;cnt);</span><br><span class="line">        <span class="keyword">while</span>(cnt --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">            add(a, b);</span><br><span class="line">            has_fa[b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="st-dist-初始化"><code>st[], dist[]</code> 初始化</h3><p>如果多组测试用例每个测试用例都要使用 <spanclass="math inline">\(dijkstra\)</span>，那么切记在 <spanclass="math inline">\(dijkstra\)</span> 使用前对<code>st[], dist[]</code> 初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);<span class="comment">// 切记 st 也要初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ........................*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建立新图反向图">建立新图/反向图</h2><p>​ 假设原图的 <span class="math inline">\(1\le N\le 10^5,1\le M\le10^6\)</span> ，此时求完SCC并缩点之后需要建立新图（<ahref="https://www.acwing.com/activity/content/code/content/8727551/">AcWing368. 银河 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8707496/">AcWing1175. 最大半连通子图 -AcWing</a>），或者需要建立原图的反向图（即将所有边反向，<ahref="https://www.acwing.com/activity/content/code/content/8728197/">AcWing341. 最优贸易 - AcWing</a>），需要注意以下3点</p><ol type="1"><li>将邻接表的最大边数<spanclass="math inline">\(M\)</span>的范围增大到原来的<spanclass="math inline">\(2\)</span>倍，最大顶点数<spanclass="math inline">\(N\)</span>不变</li><li>建立<span class="math inline">\(2\)</span>个表头：<spanclass="math inline">\(hs[]\)</span>是原图的表头，<spanclass="math inline">\(ht[]\)</span>是新图的表头，<spanclass="math inline">\(e[M], ne[M],w[M],idx\)</span>可以共用</li><li>加边函数多一个数组参数<span class="math inline">\(int\h[]\)</span>，用于指定是向原图<spanclass="math inline">\(hs[]\)</span>插入还是向新图<spanclass="math inline">\(ht[]\)</span>插入</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h[N], hs[N], e[M], ne[M], w[M], idx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="st作用总结">st[]作用总结</h2><ul><li><spanclass="math inline">\(SPFA\)</span>中：标记节点是否<strong>入队/在队列中</strong></li><li><spanclass="math inline">\(dijkstra\)</span>：标记节点的<strong>最短路</strong>是否<strong>已经求出</strong></li><li><span class="math inline">\(DFS\)</span>/<spanclass="math inline">\(BFS\)</span>：标记节点是否<strong>已经遍历过</strong></li><li><spanclass="math inline">\(Targan-LCA\)</span>：标记节点类型——已遍历且回溯、已遍历未回溯、未遍历</li><li>匈牙利算法：标记第二个集合中的每个点是否已经被考虑过</li></ul><h2 id="tle">TLE</h2><p>大概率是你忘记初始化 <span class="math inline">\(h[]\)</span>数组了，或者多组测试数据你忘记初始化 <spanclass="math inline">\(h[]\)</span> 数组 + <code>idx = 0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【贪心】</title>
      <link href="/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/"/>
      <url>/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心">贪心</h1><p>​ 对于贪心问题，不要太关注过程或者方法，而应该关注结果的数据。</p><h2 id="区间问题">区间问题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8193086/">AcWing905. 区间选点 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8201655/">AcWing908. 最大不相交区间数量 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8200554/">AcWing906. 区间分组 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8203105/">AcWing907. 区间覆盖 - AcWing</a></li></ul><span id="more"></span><h2 id="huffman算法">Huffman算法</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206166/">AcWing148. 合并果子 - AcWing</a></li></ul><h2 id="排序不等式">排序不等式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206351/">AcWing913. 排队打水 - AcWing</a></li></ul><h2 id="绝对值不等式">绝对值不等式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206765/">AcWing104. 货仓选址 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8451512/">AcWing122. 糖果传递 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8451279/">AcWing105. 七夕祭 - AcWing</a></li></ul><h2 id="邻项交换推公式">邻项交换/推公式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8208811/">AcWing125. 耍杂技的牛 - AcWing</a>、<ahref="https://www.acwing.com/solution/content/252163/">AcWing 114.国王游戏 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8802847/">AcWing734. 能量石 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8421970/">AcWing1010. 拦截导弹 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8423647/">AcWing187. 导弹防御系统 - AcWing</a></li></ul><h2id="贪心缩小最优解集合空间">贪心缩小<font color='red'>最优解集合</font>空间</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8733217/">AcWing4966. 填充（蓝桥杯辅导课） - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/250074/">AcWing1055. 股票买卖 II - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/251068/">AcWing1326. 军训队列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8802847/">AcWing734. 能量石 - AcWing</a></p></li></ul><h2 id="贪心策略">贪心策略</h2><ul><li><ahref="https://www.acwing.com/solution/content/249453/">信息学奥赛一本通1229. 电池的寿命 - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/251600/">AcWing531. 铺设道路 - AcWing</a></li></ul><h2 id="其他">其他</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8732976/">AcWing1349. 修理牛棚（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8733096/">AcWing4965. 三国游戏（蓝桥杯辅导课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8733154/">AcWing5395. 平均（蓝桥杯辅导课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8733536/">LeetCode763. 划分字母区间 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/250070/">AcWing1054. 股票买卖 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8739471/">LeetCode55. 跳跃游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8739552/">LeetCode45. 跳跃游戏 II - AcWing</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode经典系列</title>
      <link href="/2024/02/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%8ALeetCode%E7%BB%8F%E5%85%B8%E7%B3%BB%E5%88%97%E3%80%8B/"/>
      <url>/2024/02/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%8ALeetCode%E7%BB%8F%E5%85%B8%E7%B3%BB%E5%88%97%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode经典系列">LeetCode经典系列</h1><h2 id="股票买卖">股票买卖</h2><ul><li><p><a href="https://www.acwing.com/solution/content/250070/">AcWing1054. 股票买卖 - AcWing</a>——只能进行<spanclass="math inline">\(1\)</span>次交易【贪心】</p></li><li><p><a href="https://www.acwing.com/solution/content/250074/">AcWing1055. 股票买卖 II - AcWing</a>——交易次数不限【贪心/状态机DP】</p></li><li><p><a href="https://www.acwing.com/solution/content/250083/">AcWing1056. 股票买卖 III - AcWing</a>——只能进行<spanclass="math inline">\(2\)</span>次交易【前后缀分解/状态机DP】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8532860/">AcWing1057. 股票买卖 IV - AcWing</a>——只能进行<spanclass="math inline">\(k\)</span>次交易【状态机DP】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8534682/">AcWing1058. 股票买卖 V - AcWing</a>——交易次数不限+冷冻期【状态机DP】</p></li><li><p><a href="https://www.acwing.com/solution/content/250097/">AcWing1059. 股票买卖 VI - AcWing</a>——交易次数不限+手续费【状态机DP】</p></li></ul><h2 id="跳跃游戏">跳跃游戏</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8739471/">LeetCode55. 跳跃游戏 - AcWing</a>——【贪心】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8739552/">LeetCode45. 跳跃游戏 II - AcWing</a>——【区间划分】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8739683/">LeetCode1306. 跳跃游戏 III - AcWing</a>——【DFS/BFS】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8740059/">LeetCode1345. 跳跃游戏 IV - AcWing</a>——【BFS最短路模型+优化】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8740899/">LeetCode1340. 跳跃游戏 V - AcWing</a>——【DFS+记忆化搜索】</p></li></ul><h2 id="字符串">字符串</h2><h3 id="模拟">模拟</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8783413/">LeetCode551. 学生出勤记录 I - AcWing</a></li></ul><h3 id="回文串">回文串</h3><ul><li><p><a href="https://www.acwing.com/solution/content/251832/">AcWing1106. 区间回文数 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/251830/">AcWing5508. 回文数 - AcWing</a>——【高精度加法】</p></li><li><p><a href="https://www.acwing.com/solution/content/250172/">AcWing1524. 最长回文子串 - AcWing</a>——【从集合角度考虑问题】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8742429/">LeetCode647. 回文子串 - AcWing</a>——【从集合角度考虑问题】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8742768/">LeetCode131. 分割回文串 - AcWing</a>——【DFS递归+优化】</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8742773/">LeetCode132. 分割回文串 II - AcWing</a>——【线性DP】</p></li></ul><blockquote><p>此题与<ahref="https://www.acwing.com/activity/content/code/content/8741637/">LeetCode139. 单词拆分 - AcWing</a>基本一致</p></blockquote><h2 id="排列">排列</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8791535/">LeetCode31. 下一个排列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8342624/">AcWing94. 递归实现排列型枚举/全排列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8791677/">LeetCode47. 全排列 II - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8791751/">LeetCode60. 第k个排列 - AcWing</a></p></li></ul><h2 id="丑数">丑数</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8813784/">LeetCode263. 丑数 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8813940/">LeetCode264. 丑数 II - AcWing</a>：3路归并+堆优化</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8814292/">LeetCode1201. 丑数 III - AcWing</a>：二分+容斥原理</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8814662/">LeetCode313. 超级丑数 - AcWing</a>、<ahref="https://www.acwing.com/activity/content/code/content/8815328/">AcWing1378. 谦虚数字 - AcWing</a>：多路归并+堆优化</p></li></ul><h2 id="矩阵">矩阵</h2><h3 id="矩阵置零"><ahref="https://leetcode.cn/problems/set-matrix-zeroes/">矩阵置零</a></h3><p>​ 给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为<strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong>。请使用 <strong><ahref="http://baike.baidu.com/item/原地算法">原地</a></strong> 算法</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403270920185.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403270920199.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>​我们可以用<strong>两个标记数组</strong>分别记录<strong>每一行和每一列是否有零出现</strong>。具体地：</p><ol type="1"><li>我们首先遍历该数组一次，如果某个元素为 0，那么就将该元素所在的行和列所对应标记数组的位置置为<code>true</code></li><li>最后我们再次遍历该数组，用标记数组更新原数组即可</li></ol><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n)</span>, <span class="title">col</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                    row[i] = col[j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j])</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="矩阵旋转">矩阵旋转</h3><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code>表示一个图像。请你将图像顺时针旋转 90 度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402241658478.png"alt="image-20240224165826279" /><figcaption aria-hidden="true">image-20240224165826279</figcaption></figure><p><strong>分析：</strong></p><p>原地旋转90度：</p><ol type="1"><li><p>沿主对角线所有元素交换</p></li><li><p>沿着垂直中轴线方向所有元素交换</p></li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/* 1.沿主对角线所有元素交换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2.沿着垂直中轴线方向所有元素交换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[i][n - <span class="number">1</span> - j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵">螺旋矩阵</h3><h4 id="螺旋矩阵-pat"><ahref="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805275146436608?type=7&amp;page=0">螺旋矩阵-PAT</a></h4><p>​ 本题要求将给定的 <em>N</em>个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 <em>m</em> 行<em>n</em> 列，满足条件：<em>m</em>×<em>n</em> 等于<em>N</em>；<em>m</em>≥<em>n</em>；且 <em>m</em>−<em>n</em>取所有可能值中的最小值。</p><p><strong>输入格式：</strong></p><p>输入在第 1 行中给出一个正整数 <em>N</em>，第 2 行给出 <em>N</em>个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。</p><p><strong>输出格式：</strong></p><p>输出螺旋矩阵。每行 <em>n</em> 个数字，共 <em>m</em> 行。相邻数字以 1个空格分隔，行末不得有多余空格。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">37 76 20 98 76 42 53 95 60 81 58 93</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">98 95 93</span><br><span class="line">42 37 81</span><br><span class="line">53 20 76</span><br><span class="line">58 60 76</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>填充时按层数填充，一个包裹矩阵的口字型为一层，计算螺旋矩阵的层数<code>level</code></li><li>如果 m 的值为偶数，层数为<code>m / 2</code>，如果 m为奇数，层数为<code>m / 2 + 1</code>，所以<code>level = m / 2 + m % 2</code></li><li>因为是从左上角第 1 个格子开始，按顺时针螺旋方向填充，所以外层 for循环控制层数 i 从 0 到 level，内层 for循环按左上到右上、右上到右下、右下到左下、左下到左上的顺序一层层填充，注意内层for循环中还要控制<code>t &lt;= N – 1</code>，因为如果螺旋矩阵中所有的元素已经都填充完毕，就不能再重复填充～</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402261637178.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">         &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算m、n</span></span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">for</span> (n = (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="built_in">double</span>(N)); n &gt;= <span class="number">1</span>; n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N % n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m = N / n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵赋值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">b</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> level = m / <span class="number">2</span> + m % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; N; j++)</span><br><span class="line">            b[i][j] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; N; j++)</span><br><span class="line">            b[j][n - <span class="number">1</span> - i] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - i - <span class="number">1</span>; j &gt;= i &amp;&amp; t &lt; N; j--)</span><br><span class="line">            b[m - <span class="number">1</span> - i][j] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; N; j--)</span><br><span class="line">            b[j][i] = a[t++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j != n - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="螺旋矩阵-i"><ahref="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵 I</a></h4><p>​ 给你一个 <code>m</code> 行 <code>n</code> 列的矩阵<code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252318668.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252318904.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(m * n)</span></span>;</span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">max</span>(m, n) / <span class="number">2</span> + <span class="built_in">max</span>(m, n) % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                res[t++] = matrix[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                res[t++] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                res[t++] = matrix[m - <span class="number">1</span> - i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                res[t++] = matrix[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="螺旋矩阵-ii"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h4><p>​ 给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的<code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252321434.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>分析：按照⼀个个矩阵的边框输入：<strong>x为矩阵的下界，n为矩阵的上界</strong>，每次输出这个围成的矩阵的<strong>第一行</strong>——<strong>最后一列</strong>——<strong>最后⼀行</strong>——<strong>第一列</strong>，然后将<strong>x⾃增1，m⾃减1</strong>～注意：为了避免重复输出，<strong>当x和n相等的时候，就输入一次第一行就可以，不用重复输入最后一行</strong>～</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402261132564.png" alt="image-20240226113203373" style="zoom:33%;" /></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> level = n / <span class="number">2</span> + n % <span class="number">2</span>, t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt;= n * n; j++)</span><br><span class="line">                res[i][j] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">2</span> - i &amp;&amp; t &lt;= n * n; j++)</span><br><span class="line">                res[j][n - <span class="number">1</span> - i] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt;= n * n; j--)</span><br><span class="line">                res[n - <span class="number">1</span> - i][j] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt;= n * n; j--)</span><br><span class="line">                res[j][i] = t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="螺旋矩阵-iv"><ahref="https://leetcode.cn/problems/spiral-matrix-iv/">螺旋矩阵IV</a></h4><p>给你两个整数：<code>m</code> 和 <code>n</code>，表示矩阵的维数。另给你一个整数链表的头节点 <code>head</code>。请你生成一个大小为 <code>m x n</code>的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵<strong>左上角</strong> 开始、<strong>顺时针</strong> 按<strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用<code>-1</code> 填充。返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262137159.jpeg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]</span><br><span class="line">输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何排布的。</span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262137279.jpeg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 1, n = 4, head = [0,1,2]</span><br><span class="line">输出：[[0,1,2,-1]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。 </span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode* head) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n * m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; k &lt; n * m) &#123;</span><br><span class="line">            nums[k++] = head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">max</span>(m, n) / <span class="number">2</span> + <span class="built_in">max</span>(m, n) % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                matrix[i][j] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                matrix[m - <span class="number">1</span> - i][j] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                matrix[j][i] = nums[t++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组">数组</h2><h3 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h3><pre><code>给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。</code></pre><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="除自身以外数组的乘积"><ahref="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h3><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code>，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除<code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><ul><li><p>题目数据 <strong>保证</strong> 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32位</strong> 整数范围内。</p></li><li><p>请 <strong>不要使用除法，</strong> 且在 <code>O(*n*)</code>时间复杂度内完成此题。</p></li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析</span></span><br><span class="line"><span class="comment">1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]</span></span><br><span class="line"><span class="comment">2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]  */</span></span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right */</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right = right * nums[i + <span class="number">1</span>];</span><br><span class="line">            v[i] *= right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="巧妙算法">巧妙算法</h2><h3 id="投票算法">投票算法</h3><p><ahref="https://www.acwing.com/activity/content/code/content/8759293/">LeetCode169. 多数元素 - AcWing</a>给定一个大小为 <code>n</code> 的数组<code>nums</code>，返回其中的<strong>多数元素</strong>。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code>的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> r, c = <span class="number">0</span>;<span class="comment">// r 表示物品，c 表示库存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums)</span><br><span class="line">            <span class="keyword">if</span> (!c) r = x, c = <span class="number">1</span>;<span class="comment">// 更换物品</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r == x) c ++ ;<span class="comment">// 库存加1</span></span><br><span class="line">            <span class="keyword">else</span> c -- ;   <span class="comment">// 库存减1</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【线性表】</title>
      <link href="/2024/02/22/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/"/>
      <url>/2024/02/22/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一预备知识">一:预备知识</h1><h2 id="头插法">头插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>头指针</strong>为L，指针<code>t</code>指向待插入的新结点</p><h3 id="若单链表含有头结点">若单链表含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = t;</span><br></pre></td></tr></table></figure><h3 id="若单链表不含有头结点">若单链表不含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head;</span><br><span class="line">head = t;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="尾插法">尾插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>尾指针</strong>为tail，指针<code>t</code>指向待插入的新结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail-&gt;next = t;</span><br><span class="line">tail = t;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>头插法</font></strong>会改变<strong><font color='red'>原先顺序</font></strong>，<strong><font color='blue'>尾插法</font></strong>不会改变<strong><font color='blue'>原先顺序</font></strong></p></blockquote><h2 id="头节点">头节点</h2><p><strong>头节点(head node)</strong> == <strong>哑节点（dummynode）</strong></p><h3 id="头结点的作用">头结点的作用</h3><ol type="1"><li><strong>使插入操作和删除操作统一</strong>，在<strong><font color='blue'>第一个结点之前插入结点</font></strong>或<strong><font color='blue'>删除第一个结点</font></strong>时不必另作判断</li><li>不论链表是否为空，<strong>头指针不变，始终指向头结点</strong></li></ol><h3 id="没有头节点的链表">没有头节点的链表</h3><p>对于不带头结点的链表，要考虑</p><ol type="1"><li><strong><font color='red'>尾插法</font></strong>插入结点时，<strong><font color='blue'>链表是否为空</font></strong>【头插法插入结点时，不必考虑】</li><li>是否在<strong><font color='blue'>第一个结点前插入新结点</font></strong></li><li>是否<strong><font color='blue'>删除</font></strong>结点后<strong><font color='blue'>链表为空</font></strong></li></ol><h2 id="sunny应用sunny">:sunny:应用:sunny:</h2><p>​ 对于没有头节点的链表：</p><ul><li>如果不存在上面我们需要考虑的情况：正常写即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">func</span><span class="params">(ListNode *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果可能存在 3.2节的情况，对于无头节点的链表：我们就先构造一个头节点<code>h</code>，在函数最后返回的时候<code>return h-&gt;next</code>，其余部分按照含有头结点的链表写即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">func</span><span class="params">(ListNode *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以下内容如果没有写2种方案，均按照没有头结点的情况实现，当有头结点时，直接<code>return h</code>即可</p><h1 id="二链表">二:链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;*List;</span><br></pre></td></tr></table></figure><h2 id="链表复制">链表复制</h2><h3 id="带头结点">带头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">copyList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = L-&gt;next, *q = h;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        q-&gt;next = t;</span><br><span class="line">        q = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sunny:2者在第4、12行有所不同</p><h3 id="不带头结点">不带头结点</h3><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">copyList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = L, *q = h;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        q-&gt;next = t;</span><br><span class="line">        q = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sunny:2者在第4、12行有所不同</p><h2 id="链表逆转">链表逆转</h2><h3 id="带头结点-1">带头结点</h3><h4 id="改变链表结构">改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 版本一 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode* &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本二 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不改变链表结构">不改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *reverse_L = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        t-&gt;next = reverse_L-&gt;next;</span><br><span class="line">        reverse_L-&gt;next = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse_L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不带头结点-1">不带头结点</h3><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><h4 id="改变链表结构-1">改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 版本一 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode* &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本二 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不改变链表结构-1">不改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *reverse_L = <span class="literal">NULL</span>, *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        t-&gt;next = reverse_L;</span><br><span class="line">        reverse_L = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse_L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例一">例一</h3><p><strong>1025 反转链表</strong></p><p>给定一个常数 <em>K</em> 以及一个单链表 <em>L</em>，请编写程序将<em>L</em> 中每 <em>K</em> 个结点反转。例如：给定 <em>L</em> 为1→2→3→4→5→6，<em>K</em> 为 3，则输出应该为 3→2→1→6→5→4；如果 <em>K</em>为 4，则输出应该为 4→3→2→1→5→6，即最后不到 <em>K</em> 个元素不反转。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em>(≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code>是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>];             <span class="comment">//地址为5位数,模拟内存存储；     </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t; </span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  注意：不一定所有的输入的结点都是有用的，把链表储存在L数组中</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">    n=L.<span class="built_in">size</span>();             <span class="comment">//符合要求的节点个数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line">res.<span class="built_in">resize</span>(n);                  <span class="comment">//必须设定大小，否则res【i】出错</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-n%k;i++)        <span class="comment">//sum-sum%k是除去了最后不能反转的</span></span><br><span class="line">res[i]=L[k<span class="number">-1</span>-i%k+i/k*k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-n%k;i&lt;n;i++)</span><br><span class="line">        res[i]=L[i];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    输出     </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)   <span class="comment">//最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line">    </span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;    </span><br><span class="line"><span class="comment">//     法二</span></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;n-n%k;i+=k)</span></span><br><span class="line"><span class="comment">//         reverse(L.begin()+i,L.begin()+i+k);    //需要头文件algorithm</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// //    输出     </span></span><br><span class="line"><span class="comment">// for(int i=1;i&lt;n;i++)            //最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d %05d\n&quot;,L[i-1],A[L[i-1]].data,L[i]);</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d -1&quot;,L.back(),A[L.back()].data);    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二">例二</h3><p><strong>1075 链表元素分类</strong></p><p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而[0, K] 区间内的元素都排在大于 K的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为-4→-6→-2→7→0→5→10→18→11。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K(≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址；<code>Data</code>是该结点保存的数据，为 [−105,105] 区间内的整数；<code>Next</code>是下一结点的地址。题目保证给出的链表不为空。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00100 9 10</span><br><span class="line">23333 10 27777</span><br><span class="line">00000 0 99999</span><br><span class="line">00100 18 12309</span><br><span class="line">68237 -6 23333</span><br><span class="line">33218 -4 00000</span><br><span class="line">48652 -2 -1</span><br><span class="line">99999 5 68237</span><br><span class="line">27777 11 48652</span><br><span class="line">12309 7 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">33218 -4 68237</span><br><span class="line">68237 -6 48652</span><br><span class="line">48652 -2 12309</span><br><span class="line">12309 7 00000</span><br><span class="line">00000 0 99999</span><br><span class="line">99999 5 23333</span><br><span class="line">23333 10 00100</span><br><span class="line">00100 18 27777</span><br><span class="line">27777 11 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理多余节点   </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&lt;<span class="number">0</span>)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;=<span class="number">0</span>&amp;&amp;A[L[i]].data&lt;=k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例三">例三</h3><p><strong>区块反转</strong></p><p>给定一个单链表 <em>L</em>，我们将每 <em>K</em>个结点看成一个<strong>区块</strong>（链表最后若不足 <em>K</em>个结点，也看成一个区块），请编写程序将 <em>L</em>中所有区块的链接反转。例如：给定 <em>L</em> 为1→2→3→4→5→6→7→8，<em>K</em> 为 3，则输出应该为 7→8→4→5→6→1→2→3。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em>(≤<em>N</em>)，即区块的大小。结点的地址是 5 位非负整数，NULL 地址用 −1表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code>是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00100 8 3</span><br><span class="line">71120 7 88666</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 71120</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">88666 8 -1</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">71120 7 88666</span><br><span class="line">88666 8 00000</span><br><span class="line">00000 4 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 00100</span><br><span class="line">00100 1 12309</span><br><span class="line">12309 2 33218</span><br><span class="line">33218 3 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100001</span>];</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;L,res,block[<span class="number">100001</span>];<span class="comment">//当n=100000，k=1时区块最多 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vector&lt;int&gt;L,res,block[100001];//放在局部变量会导致溢出，只能放在全局变量</span></span><br><span class="line"><span class="comment">//  故申请大内存时最好放在全局变量里面</span></span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">block[t].<span class="built_in">push_back</span>(L[i]);</span><br><span class="line"><span class="keyword">if</span>(cnt%k==<span class="number">0</span>&amp;&amp;t!=n<span class="number">-1</span>)        <span class="comment">//Attention！if(cnt%k==0) 也对</span></span><br><span class="line">t++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : block[i]) </span><br><span class="line">            res.<span class="built_in">push_back</span>(it);        </span><br><span class="line"><span class="comment">//等价   for(int j=0;j&lt;block[i].size();j++)</span></span><br><span class="line"><span class="comment">// res.push_back(block[i][j]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表合并">链表合并</h2><h3id="两个升序链表合并为一个升序链表">两个升序链表合并为一个升序链表</h3><ul><li>用两个指针p1、p2分别遍历L1和L2，用一个尾指针永远指向新链表的最后一个节点</li><li>比较两个指针指向的节点的大小，将数据域较小的节点用==<strong><font color='red'>尾插法</font></strong>==接在新链表后面</li><li>尾指针后移，p1或者p2后移</li><li>当有一个为空时另一个还会有剩余节点没有加入新链表，将剩下的直接接在新链表后面</li></ul><h4 id="不改变链表结构-2">不改变链表结构</h4><h5 id="带头节点">带头节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode *h = new ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != nullptr &amp;&amp; p2 != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、28行</p><h5 id="不带头节点">不带头节点</h5><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、28行</p><h4 id="改变链表结构-2">改变链表结构</h4><h5 id="带头节点-1">带头节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、26行</p><h5 id="不带头节点-1">不带头节点</h5><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、26行</p><h3id="两个升序链表合并为一个降序链表">两个升序链表合并为一个降序链表</h3><ul><li>用两个指针p1，p2分别遍历L1和L2，用指针s每次指向待插入的节点</li><li>将新链表的头结点的指针域置空</li><li>开始遍历并用==<strong><font color='red'>头插法</font></strong>==开始插入节点</li><li>退出循环后对未遍历完的节点用头插法将剩余节点插入新链表</li></ul><h4 id="不改变链表结构-3">不改变链表结构</h4><h5 id="带头节点-2">带头节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode *h = new ListNode;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != nullptr &amp;&amp; p2 != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            t-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            t-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">        t-&gt;next = h;</span><br><span class="line">        h = t;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h5 id="不带头节点-2">不带头节点</h5><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            t-&gt;next = h;</span><br><span class="line">            h = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            t-&gt;next = h;</span><br><span class="line">            h = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">        t-&gt;next = h;</span><br><span class="line">        h = t;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h4 id="改变链表结构-3">改变链表结构</h4><h5 id="带头节点-3">带头节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = p1;</span><br><span class="line">            p1 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = p2;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = h-&gt;next;</span><br><span class="line">        h-&gt;next = p1;</span><br><span class="line">        p1 = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h5 id="不带头节点-3">不带头节点</h5><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = h;</span><br><span class="line">            h = p1;</span><br><span class="line">            p1 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = h;</span><br><span class="line">            h = p2;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = h;</span><br><span class="line">        h = p1;</span><br><span class="line">        p1 = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h3 id="例一-1">例一</h3><p><strong>List Concatenation</strong></p><p>Concatenation of lists is an operation where the elements of one listare added at the end of another list. For example, if we have a linkedlist <code>L1</code>→1→2→3 and another one <code>L2</code>→4→5→6. Thefunction <code>ListConcat</code> is to return the head pointer of thelist L→4→5→6→1→2→3.</p><p><strong>The list structure is defined as the following:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br></pre></td></tr></table></figure><p><strong>Please fill in the blanks.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">ListConcat</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Tmp = L2;</span><br><span class="line">    <span class="keyword">if</span> ( !L2 ) <span class="keyword">return</span> L1;</span><br><span class="line">    <span class="keyword">while</span> ( Tmp-&gt;Next )</span><br><span class="line">________________;【<span class="number">4</span>分】</span><br><span class="line">______________;【<span class="number">4</span>分】</span><br><span class="line">    <span class="keyword">return</span> __________;【<span class="number">4</span>分】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><p>【1】<code>Tmp=Tmp-&gt;Next</code></p><p>【2】<code>Tmp-&gt;Next=L1</code>//注：<code>Tmp-&gt;Next=L1-&gt;Next</code>错误</p><p>【3】<code>L2</code></p><blockquote><p>该链表是一个不带头结点的单链表，从两个角度判断</p><ol type="1"><li>第4行代码 <code>if ( !L2 ) return L1;</code>//链表L2为空，则返回，说明不带头结点<ul><li>带头结点应写为<code>if ( !L2-&gt;next ) return L1;</code></li></ul></li><li>题干 L1→1→2→3 , L2→4→5→6 和 L→4→5→6→1→2→3.</li></ol></blockquote><h2 id="链表分解">链表分解</h2><h3 id="例一-2">例一</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为<strong><font color='red'>奇数</font></strong>的元素；B链表中含有原链表A中序号为<strong><font color='red'>偶数</font></strong>的元素。<strong><font color='blue'>保持原来的相对顺序。</font></strong></p><blockquote><blockquote><p>因为要保持原来相对位置不变，所以要采用Lb和Lb采用<strong><font color='red'>尾插法</font></strong>,尾指针分别为<strong><code>rear1和rear2</code></strong></p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二-1">例二</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为<strong><font color='red'>偶数</font></strong>的元素；B链表中含有原链表A中序号为<strong><font color='red'>奇数</font></strong>的元素。<strong><font color='blue'>保持原来的相对顺序。</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两两交换链表节点"><ahref="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表节点</a></h2><p>​给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262245395.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281656470.gif"alt="Rec_2024-02-26_0001(2)" /><figcaption aria-hidden="true">Rec_2024-02-26_0001(2)</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281739850.jpg"alt="7236b067d914444ca3a0afe66b74809" /><figcaptionaria-hidden="true">7236b067d914444ca3a0afe66b74809</figcaption></figure><p><strong>代码：</strong></p><p>法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *t = dummyHead, *p = head, *q = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            t-&gt;next = q;</span><br><span class="line">            t = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* t = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (t-&gt;next != <span class="literal">nullptr</span> &amp;&amp; t-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *p = t-&gt;next, *q = t-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            t-&gt;next = q;</span><br><span class="line">            t = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="排序链表"><ahref="https://leetcode.cn/problems/sort-list/">排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong>排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281833020.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281833014.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            num.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            p-&gt;val = num[k++];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="随机链表的复制"><a id="shenkaobei"><ahref="https://leetcode.cn/problems/copy-list-with-random-pointer/">随机链表的复制</a></a></h2><p>给你一个长度为 <code>n</code>的链表，每个节点包含一个额外增加的随机指针 <code>random</code>，该指针可以指向链表中的任何节点或空节点。构造这个链表的 <strong><ahref="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin">深拷贝</a></strong>。深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong>节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code> 指针和 <code>random</code>指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>。</p><p>​ 例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中<code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点<code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code>。</p><p>​ 返回复制链表的头节点。</p><p>用一个由 <code>n</code>个节点组成的链表来表示输入/输出中的链表。每个节点用一个<code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从<code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为<code>null</code> 。</li></ul><p>​ 你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code>作为传入参数。</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942322.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942294.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942306.png"alt="img" /></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>需要<strong>2次遍历链表</strong>：</p><ul><li>首先<strong>对所有节点进行拷贝</strong>：遍历原始链表，每遍历到一个节点，就重新创建一个拷贝节点，然后用Hash表存储原节点与新节点的映射关系</li><li>然后<strong>拷贝点与点之间的关系</strong>：遍历原始链表，每遍历到一个节点，我们都从Hash表中查询到对应的拷贝节点，然后把拷贝节点根据原始节点的关系进行连接就可以了</li></ul><blockquote><p><ahref="https://www.bilibili.com/video/BV1Bv4y1A7Aq/?buvid=XY3CA67352B7F82D3CAB27E191FA025EB4053&amp;from_spmid=main.my-history.0.0&amp;is_story_h5=false&amp;mid=ivlqRrACJE6aj0QtF6a%2FzA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=a1cae467-a3b0-4af5-a2fb-841d5a3ffb7a&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1709393487&amp;unique_k=SMN7Y8h&amp;up_id=320530935&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】138. 复制带随机指针的链表 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p></blockquote><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; h;</span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">            h[p] = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">                h[p]-&gt;next = h[p-&gt;next];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">                h[p]-&gt;random = h[p-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同类型：<ahref="D:\downloads\hexo\blog\source_posts\数据结构【图】.md#kelong">图的深拷贝</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希腊字母表</title>
      <link href="/2024/01/27/%5Bobject%20Object%5D/others/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/"/>
      <url>/2024/01/27/%5Bobject%20Object%5D/others/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母表">希腊字母表</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202401271612976.png"alt="GreekAlphabet" /><figcaption aria-hidden="true">GreekAlphabet</figcaption></figure><p>:gift_heart:读音：<ahref="https://www.bilibili.com/video/BV11b411t7Fn/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">50秒完全学会希腊字母读法~高中理科生的福音_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【IO输入】</title>
      <link href="/2024/01/27/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90IO%E8%BE%93%E5%85%A5%E3%80%91/"/>
      <url>/2024/01/27/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90IO%E8%BE%93%E5%85%A5%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="io输入">IO输入</h1><h2 id="空白字符">空白字符</h2><p>​ <strong>空格，回车，制表符</strong> 称为空白字符</p><h2 id="scanf函数">scanf函数</h2><ul><li><code>%s</code>为输入字符串，在输入时<font color='red'><strong>以非空白字符开始</strong></font>，以<font color='red'><strong>第一个非空白字符结束</strong></font>。字符串会自动以<code>\0</code> 为最后一个字符，输入格式为：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="comment">// 注意s为数组变量不带取值符</span></span><br></pre></td></tr></table></figure><ul><li><code>%c</code>为输入单个字符，包括空白字符，格式为：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c); <span class="comment">// 需要取值符</span></span><br></pre></td></tr></table></figure><h2 id="cin函数">cin函数</h2><p><code>cin&gt;&gt;</code>读入时有一个好处——就是会<font color = 'red'><strong>自动过滤掉空白字符</strong></font></p><ul><li>功能：从缓冲区<strong>第一个非空白字符开始</strong>读取（cin会将前面的空白字符全部从缓冲区中删除），直到遇到空白字符停止，并自动将</li></ul><span id="more"></span><h2 id="输入读取">输入读取</h2><p>:smile:由于 <code>%c</code> 会将空格，回车，制表符这 3种空白字符吸入，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c#&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1输入：空格</span></span><br><span class="line"><span class="comment">//输出： #</span></span><br><span class="line"><span class="comment">//2输入：回车</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//输出:#</span></span><br><span class="line"><span class="comment">//3输入：tab制表符</span></span><br><span class="line"><span class="comment">//输出：    #</span></span><br></pre></td></tr></table></figure><p>而 <code>%s</code>则不会吸入这些空白字符，而会跳过他们自动吸入有效字符串，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s#&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1输入： abcde</span></span><br><span class="line"><span class="comment">//输出：abcde#</span></span><br><span class="line"><span class="comment">//2输入：    abcde    </span></span><br><span class="line"><span class="comment">//输出：abcde#</span></span><br></pre></td></tr></table></figure><p>因此，当我们需要使用 scanf 读取单个字符时，不建议使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而建议使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">2</span>]; <span class="comment">// 多一个 字符串结束符&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line"><span class="keyword">if</span> (*c == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在后续操作中只需要使用 <code>*</code>即可访问字符元素，同时又可以避免读入空白字符</p><blockquote><p>在算法竞赛中经常会出现某些坑爹的输入样例——每一行多给你个空格/回车</p></blockquote><p>:fish:切记：</p><ul><li>如果你想输入 <span class="math inline">\(n\)</span>个字符，字符数组的长度一定要定义为 <spanclass="math inline">\(n+1\)</span>，因为输入会自带 <spanclass="math inline">\(1\)</span> 个字符串结束符<code>\0</code></li><li><code>scanf("%s", str);</code>输入字符串时，会<strong>从非空白字符开始，到空白字符结束，最后再加 <spanclass="math inline">\(1\)</span> 个 <code>\0</code></strong>，以<code>str</code> 为起始地址，依次向后赋值</li></ul><h2 id="缓冲区">缓冲区</h2><p>大家知道，一般我们正常的输入都是先进入到缓冲区中，那么什么时候会将缓冲区的数据打到屏幕上呢？</p><ul><li><p>遇到了换行符</p></li><li><p>缓冲区满</p></li><li><p>程序正常推出</p></li></ul><p>这三种情况便会刷新数据，而平时我们所打的回车便会在缓冲区打入一个换行符，从而引起刷新。</p><h2 id="cincout-vs-scanfprintf">cin/cout vs scanf/printf</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081335856.png"alt="image-20240308133556727" /><figcaption aria-hidden="true">image-20240308133556727</figcaption></figure><ul><li>算法竞赛，cin/cout 要比 scanf/printf 慢2~10倍</li><li>cin/cout 提速：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">// 取消 C函数 与 C++函数 的缓冲区同步</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 提速后，cin/cout 和 scanf/printf一样快（甚至在某些情况下比scanf/printf还要快），但是开启上述优化后，由于取消了同步，不能再使用scanf/printf ，只能使用 cin/cout，scanf和cin混用，或cout和printf混用时，就会可能发生<code>错误</code></p><h2 id="printf">printf</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081351507.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="scanf">scanf</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081352693.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="经验">经验</h2><ul><li>数据规模超过100万（<spanclass="math inline">\(10^6\)</span>），建议采用scanf、printf</li><li>数据规模在100万（<spanclass="math inline">\(10^6\)</span>）以下，scanf、printf/cin、cout都可以</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>classification_report</title>
      <link href="/2024/01/27/%5Bobject%20Object%5D/python/%E3%80%90sklearn%E3%80%91/classification_report/"/>
      <url>/2024/01/27/%5Bobject%20Object%5D/python/%E3%80%90sklearn%E3%80%91/classification_report/</url>
      
        <content type="html"><![CDATA[<h1 id="classification_report">classification_report</h1><h2 id="简介">简介</h2><p>​说来惭愧，好久不写博客，让我动笔的竟然是sklearn一个小小的api功能，以前评价模型用的都是总体的准确率，第一次用sklearn提供的分类报告功能竟然搞不懂是怎么计算的，怎么还分类别。就像下面这样：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403011632622.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>嗯，这都啥呀？老实说第一次看我只看懂了准确率即accuracy是怎么计算的。。。</p><span id="more"></span><h2 id="计算">计算</h2><p>首先y_true是真实结果，y_pred是预测出的标签，它们分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y_true</span><br><span class="line">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,</span><br><span class="line">       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y_pred</span><br><span class="line">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1,</span><br><span class="line">       0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,</span><br><span class="line">       0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 闲着没事干的可以自己数数，这边统计出来的结果是： -<strong>实际情况中，前68个样本为0类别，后32个样本为1类别</strong> -<strong>预测中，前68个样本中有11个被预测为了1类别，后32个样本中有8个被预测为了0类别</strong></p><hr /><p><strong>那么我们先说分类报告中最右边的support为什么是68和32。</strong>support意思为支持，也就是说真实结果中有多少是该类别。那么有68个为0类别，32个为1类别。<strong>在左边的召回率里，分母为support个数。</strong></p><hr /><p><strong>那么0类别里召回率即recall的计算为：</strong>(68-11)/68=0.8382，保留两位小数为0.84。 同理1类别中： (32-8)/32=0.75。<strong>意思为 实际为x的类别中，有多少预测为x。</strong></p><hr /><p><strong>而精准率即precision的区别在于分母不同：</strong>此时的分母为预测样本分类。 0类别： 57/65=0.8769，保留两位小数为0.88。1类别： 24/35=0.6857，保留两位小数为0.69。 <strong>意思为预测为x的样本中，有多少被正确预测为x。</strong></p><hr /><p>解决了这两个，剩下的就很好懂了。 <strong>F1分数=2 * precision *recall /(precision+recall)。</strong><strong>accuracy=(100-11-8)/100。</strong></p><ul><li>注：准确率(accuracy)即全部样本里被分类正确的比例。</li></ul><p><strong>macro avg = 上面类别各分数的直接平均</strong></p><ul><li>注：如精准率的macro avg=(0.88+0.69)/2约等于0.78。</li></ul><p><strong>weightedavg=上面类别各分数的加权（权值为support）平均</strong></p><ul><li>注：如精准率的weighted avg=（0.88x68+0.69*32）/100约等于0.82。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPython Notebook高级技巧</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/IPython%20Notebook%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/IPython%20Notebook%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="ipython-notebook高级技巧">IPython Notebook高级技巧</h1><p>IPython Notebook（现称为<ahref="https://so.csdn.net/so/search?q=Jupyter%20Notebook&amp;spm=1001.2101.3001.7020">JupyterNotebook</a>）是一种强大的工具，广泛用于数据科学、机器学习、科学计算和教育等领域。除了基本功能外，IPythonNotebook还提供了许多高级功能和技巧，可以显著提升用户的效率和体验。本文将详细介绍这些高级使用技巧，帮助你更好地利用IPythonNotebook</p><hr /><h2 id="魔法命令">魔法命令</h2><p>IPython提供了一些“魔法命令”，这些命令以百分号（%）或两个百分号（%%）开头，用于执行特定任务。这些魔法命令可以分为行级（以%开头）和单元级（以%%开头）。</p><h3 id="行级魔法命令">行级魔法命令</h3><p>行级魔法命令用于单行操作，最常见的包括：</p><ul><li><code>%time</code>: 测量单行代码的执行时间。</li><li><code>%timeit</code>: 多次运行代码以获取平均执行时间。</li><li><code>%run</code>: 运行Python脚本文件。</li><li><code>%debug</code>: 启动调试器。</li><li><code>%matplotlib inline</code>:在Notebook内嵌入Matplotlib图表。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time <span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><h3 id="单元级魔法命令">单元级魔法命令</h3><p>单元级魔法命令用于整个单元格的操作，最常见的包括：</p><ul><li><code>%%time</code>: 测量整个单元格的执行时间。</li><li><code>%%timeit</code>: 多次运行单元格代码以获取平均执行时间。</li><li><code>%%writefile</code>: 将单元格内容写入文件。</li><li><code>%%bash</code>:在Notebook内嵌入Matplotlib图表，并且可以省略掉plt.show()这一步。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">    total += i</span><br></pre></td></tr></table></figure><h2 id="丰富的文本格式">丰富的文本格式</h2><p>IPython Notebook 支持 Markdown 和LaTeX，可以用于创建格式丰富的文档。</p><h3 id="markdown">Markdown</h3><p>Markdown是一种轻量级标记语言，可以通过简单的标记语法创建格式化的文本。常见的语法包括：</p><ul><li><strong>标题</strong>：使用 <code>#</code> 表示标题级别，例如<code># 一级标题</code>，<code>## 二级标题</code>。</li><li><strong>列表</strong>：使用 <code>-</code> 或 <code>*</code>表示无序列表，使用数字表示有序列表。</li><li><strong>强调</strong>：使用 <code>*</code> 或 <code>_</code>表示斜体，使用 <code>**</code> 或 <code>__</code> 表示粗体。</li><li><strong>链接</strong>：使用 <code>[文本](链接)</code>表示链接。</li><li><strong>图片</strong>：使用 <code>![文本](图片链接)</code>表示图片。</li></ul><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 无序列表项</span><br><span class="line"><span class="bullet">-</span> 无序列表项</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 有序列表项</span><br><span class="line"><span class="bullet">2.</span> 有序列表项</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*斜体*</span> <span class="strong">**粗体**</span></span><br><span class="line"></span><br><span class="line">[<span class="string">链接文本</span>](<span class="link">http://example.com</span>)</span><br><span class="line">![<span class="string">图片描述</span>](<span class="link">http://example.com/image.png</span>)</span><br></pre></td></tr></table></figure><h3 id="latex">LaTeX</h3><p>IPython Notebook 支持LaTeX语法，可以用于创建复杂的数学公式。LaTeX语法通常使用美元符号 <code>$</code> 包围，例如：</p><ul><li>行内公式：<code>$公式$</code></li><li>行间公式：<code>$$公式$$</code></li></ul><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这是一个行内公式 $E = mc^2$。</span><br><span class="line"></span><br><span class="line">这是一个行间公式：</span><br><span class="line">$$</span><br><span class="line">\int<span class="emphasis">_&#123;a&#125;^&#123;b&#125; f(x) \,dx</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><h2 id="扩展与插件">扩展与插件</h2><p>IPython Notebook的功能可以通过扩展和插件进行扩展。以下是一些常见的扩展和插件：</p><h3 id="jupyter-notebook-extensions">Jupyter Notebook Extensions</h3><p>Jupyter Notebook Extensions是一组可以增强Notebook功能的扩展，例如代码折叠、表格内容导出、代码格式化等。安装步骤如下：</p><ol type="1"><li><p>安装<code>jupyter_contrib_nbextensions</code>包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure></li><li><p>启用扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jupyter contrib nbextension install --user</span><br><span class="line">jupyter nbextensions_configurator <span class="built_in">enable</span> --user</span><br></pre></td></tr></table></figure></li><li><p>在Notebook界面中，导航到<code>Nbextensions</code>选项卡，启用所需的扩展。</p></li></ol><h3 id="ipython-magic-functions">IPython Magic Functions</h3><p>IPython Magic Functions是一组特殊命令，可以简化常见任务，例如执行shell命令、计时、调试等。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用%lsmagic查看可用的魔法命令</span></span><br><span class="line">%lsmagic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用%timeit计时</span></span><br><span class="line">%timeit <span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h2 id="调试与错误处理">调试与错误处理</h2><p>调试是编程的重要部分，IPython Notebook提供了一些强大的调试工具和技巧。</p><h3 id="使用debug魔法命令">使用%debug魔法命令</h3><p>%debug魔法命令可以启动交互式调试器，在代码抛出异常后立即启动调试。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buggy_function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line">buggy_function(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment"># 这将抛出一个ZeroDivisionError</span></span><br></pre></td></tr></table></figure><p>在错误发生后，输入<code>%debug</code>启动调试器，可以查看变量状态、堆栈跟踪并逐步调试代码。</p><h3 id="使用pdb调试">使用pdb调试</h3><p>pdb（PythonDebugger）是Python内置的调试器。可以在代码中插入断点并逐步调试。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buggy_function</span>(<span class="params">a, b</span>):</span><br><span class="line">    pdb.set_trace()</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line">buggy_function(<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在调试过程中，pdb 提供了以下常用命令：</p><ul><li><code>n</code>（next）：执行下一行代码。</li><li><code>c</code>（continue）：继续执行代码直到下一个断点。</li><li><code>q</code>（quit）：退出调试器。</li></ul><h3 id="使用pdb自动调试">使用%pdb自动调试</h3><p>%pdb魔法命令可以启用自动调试模式，在代码抛出异常时自动启动调试器。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%pdb on</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buggy_function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line">buggy_function(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment"># 这将自动启动调试器</span></span><br></pre></td></tr></table></figure><h2 id="性能优化">性能优化</h2><p>在处理大规模数据或复杂计算时，性能优化是一个重要的考虑因素。以下是一些常见的性能优化技巧：</p><h3 id="使用timeit和timeit魔法命令">使用%timeit和%%timeit魔法命令</h3><p>%timeit 和 %%timeit魔法命令可以帮助你测量代码的执行时间，找到性能瓶颈。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用%timeit测量单行代码的执行时间</span></span><br><span class="line">%timeit <span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用%%timeit测量整个单元格代码的执行时间</span></span><br><span class="line">%%timeit</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    total += i</span><br></pre></td></tr></table></figure><h3 id="使用cython">使用Cython</h3><p>Cython是一个优化编译器，可以将Python代码编译为C扩展，以提高性能。以下是使用Cython的基本步骤：</p><ol type="1"><li><p>安装 Cython：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install cython</span><br></pre></td></tr></table></figure></li><li><p>在Notebook中使用<code>%%cython</code>魔法命令编写Cython代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%load_ext cython</span><br><span class="line"></span><br><span class="line">%%cython</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_cython</span>(<span class="params"><span class="built_in">int</span> n</span>):</span><br><span class="line">    cdef <span class="built_in">int</span> total = <span class="number">0</span></span><br><span class="line">    cdef <span class="built_in">int</span> i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        total += i</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">%timeit sum_cython(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="并行计算">并行计算</h3><p>Python 的 <code>multiprocessing</code>模块允许你并行执行任务，以提高性能。以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;工作线程函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Worker: <span class="subst">&#123;num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><h2 id="版本控制与合作">版本控制与合作</h2><p>版本控制和协作是开发过程中的重要部分。IPython Notebook 支持与 Git结合进行版本控制和协作。</p><h3 id="使用git进行版本控制">使用Git进行版本控制</h3><ol type="1"><li><p><strong>初始化Git仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p><strong>添加和提交Notebook文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add notebook.ipynb</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>推送到远程仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-repository-URL&gt;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用nbdime进行notebook差异">使用nbdime进行Notebook差异</h3><p>比较</p><p>nbdime 是一个用于比较和合并 Jupyter Notebook文件的工具。以下是基本使用步骤：</p><ol type="1"><li><p><strong>安装nbdime</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install nbdime</span><br></pre></td></tr></table></figure></li><li><p><strong>配置Git使用nbdime进行差异比较</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbdime config-git --<span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li><li><p><strong>比较两个Notebook文件的差异</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbdiff notebook1.ipynb notebook2.ipynb</span><br></pre></td></tr></table></figure></li></ol><h3 id="合作开发">合作开发</h3><p>使用 Git 和 GitHub等平台，可以轻松实现多人合作开发。以下是一些基本步骤：</p><ol type="1"><li><p><strong>创建和克隆远程仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;remote-repository-URL&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建和切换分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new-feature</span><br></pre></td></tr></table></figure></li><li><p><strong>提交和推送代码</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add notebook.ipynb</span><br><span class="line">git commit -m <span class="string">&quot;Add new feature&quot;</span></span><br><span class="line">git push origin new-feature</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Pull Request</strong>：在GitHub上创建PullRequest，进行代码审查和合并。</p></li></ol><h2 id="集成与部署">集成与部署</h2><p>IPython Notebook可以与多种工具和平台集成，并将Notebook部署到生产环境中。</p><h3 id="与docker集成">与Docker集成</h3><p>使用Docker可以轻松创建和管理Notebook环境。以下是基本步骤：</p><ol type="1"><li><p><strong>编写Dockerfile</strong>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> jupyter/base-notebook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装额外的Python包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install numpy pandas matplotlib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制Notebook文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /home/jovyan/work</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构建Docker镜像</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-notebook .</span><br></pre></td></tr></table></figure></li><li><p><strong>运行Docker容器</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8888:8888 my-notebook</span><br></pre></td></tr></table></figure></li></ol><h3 id="部署到云平台">部署到云平台</h3><p>可以将IPythonNotebook部署到云平台，例如AWS、GCP和Azure。以下是使用AmazonSageMaker部署的基本步骤：</p><ol type="1"><li><p><strong>创建SageMakerNotebook实例</strong>：在AWS管理控制台中，导航到SageMaker服务，并创建一个Notebook实例。</p></li><li><p><strong>上传Notebook文件</strong>：将Notebook文件上传到SageMaker实例中。</p></li><li><p><strong>运行和管理Notebook</strong>：在SageMaker实例中运行和管理Notebook，进行数据分析和模型训练。</p></li></ol><h2 id="数据可视化">数据可视化</h2><p>IPython Notebook支持多种数据可视化工具，可以创建丰富的交互式图表。</p><h3 id="使用matplotlib">使用Matplotlib</h3><p>Matplotlib 是一个常用的绘图库，可以用于创建各种类型的图表。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">y = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建图表</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X轴&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y轴&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;示例图表&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="使用seaborn">使用Seaborn</h3><p>Seaborn是基于Matplotlib的高级绘图库，可以用于创建更加美观的图表。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">data = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>: [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建图表</span></span><br><span class="line">sns.lineplot(data=data, x=<span class="string">&#x27;x&#x27;</span>, y=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X轴&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y轴&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;示例图表&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="使用plotly">使用Plotly</h3><p>Plotly是一个支持交互式图表的绘图库，可以用于创建动态和互动的图表。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>: [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建图表</span></span><br><span class="line">fig = px.line(df, x=<span class="string">&#x27;x&#x27;</span>, y=<span class="string">&#x27;y&#x27;</span>, title=<span class="string">&#x27;示例图表&#x27;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><h2 id="自动化与脚本化">自动化与脚本化</h2><p>IPython Notebook支持自动化和脚本化操作，可以用于批量处理任务和自动化分析。</p><h3id="使用papermill进行参数化notebook">使用Papermill进行参数化Notebook</h3><p>Papermill 是一个用于参数化和执行JupyterNotebook的工具。以下是基本使用步骤：</p><ol type="1"><li><p><strong>安装Papermill</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install papermill</span><br></pre></td></tr></table></figure></li><li><p><strong>编写参数化Notebook</strong>：在Notebook中定义参数单元格，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parameters</span></span><br><span class="line">param1 = <span class="string">&quot;default_value&quot;</span></span><br><span class="line">param2 = <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>运行参数化Notebook</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">papermill input_notebook.ipynb output_notebook.ipynb -p param1 new_value -p param2 20</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用nbconvert转换notebook">使用nbconvert转换Notebook</h3><p>nbconvert是一个将Notebook转换为多种格式的工具，包括HTML、PDF、Markdown等。</p><ol type="1"><li><p><strong>安装nbconvert</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install nbconvert</span><br></pre></td></tr></table></figure></li><li><p><strong>转换Notebook</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jupyter nbconvert --to html notebook.ipynb</span><br><span class="line">jupyter nbconvert --to pdf notebook.ipynb</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用调度工具定时运行notebook">使用调度工具定时运行Notebook</h3><p>可以使用调度工具（如cron或Windows任务计划程序）定时运行Notebook。</p><h4id="使用cron定时运行notebooklinuxmacos">使用cron定时运行Notebook（Linux/MacOS）</h4><ol type="1"><li><p><strong>编辑cron任务</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure></li><li><p><strong>添加cron任务</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * jupyter nbconvert --to notebook --execute /path/to/notebook.ipynb</span><br></pre></td></tr></table></figure></li></ol><h4id="使用任务计划程序定时运行notebookwindows">使用任务计划程序定时运行Notebook（Windows）</h4><ol type="1"><li><p><strong>打开任务计划程序</strong>：在开始菜单中搜索“任务计划程序”并打开。</p></li><li><p><strong>创建基本任务</strong>：选择“创建基本任务”，按照提示设置任务名称、触发器和操作。</p></li><li><p><strong>设置操作</strong>：在操作中选择“启动程序”，并填写以下内容：</p><ul><li>程序/脚本：<code>jupyter</code></li><li>添加参数：<code>nbconvert --to notebook --execute "C:\path\to\notebook.ipynb"</code></li></ul></li></ol><h2 id="安全性与隐私">安全性与隐私</h2><p>在使用IPythonNotebook时，安全性和隐私也是重要的考虑因素。以下是一些常见的安全实践：</p><h3 id="使用密码保护notebook服务器">使用密码保护Notebook服务器</h3><p>可以为Jupyter Notebook服务器设置密码，防止未经授权的访问。</p><ol type="1"><li><p><strong>生成密码哈希</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure></li><li><p><strong>修改配置文件</strong>：在<code>jupyter_notebook_config.py</code>文件中添加以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.password = <span class="string">&#x27;生成的密码哈希&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用ssltls加密通信">使用SSL/TLS加密通信</h3><p>可以为JupyterNotebook服务器配置SSL/TLS，以加密客户端和服务器之间的通信。</p><ol type="1"><li><p><strong>生成证书和私钥</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout mykey.key -out mycert.pem</span><br></pre></td></tr></table></figure></li><li><p><strong>修改配置文件</strong>：在<code>jupyter_notebook_config.py</code>文件中添加以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.certfile = <span class="string">&#x27;/path/to/mycert.pem&#x27;</span></span><br><span class="line">c.NotebookApp.keyfile = <span class="string">&#x27;/path/to/mykey.key&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="隐藏敏感信息">隐藏敏感信息</h3><p>在Notebook中处理敏感信息时，可以使用环境变量或配置文件来隐藏敏感数据。</p><ol type="1"><li><p><strong>使用环境变量</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">api_key = os.getenv(<span class="string">&#x27;API_KEY&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用配置文件</strong>：将敏感信息存储在配置文件中，并在Notebook中读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">&#x27;config.ini&#x27;</span>)</span><br><span class="line">api_key = config[<span class="string">&#x27;DEFAULT&#x27;</span>][<span class="string">&#x27;API_KEY&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结">总结</h2><p>通过本文的介绍，我们详细探讨了IPythonNotebook的高级使用技巧，包括魔法命令、丰富的文本格式、扩展与插件、调试与错误处理、性能优化、版本控制与合作、集成与部署、数据可视化、自动化与脚本化，以及安全性与隐私等方面。掌握这些技巧，可以显著提高你的工作效率和Notebook的使用体验，希望本文对你有所帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda命令</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Anaconda%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Anaconda%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="anaconda命令">Anaconda命令</h1><h2 id="前言">前言</h2><p>Conda是Anaconda中一个强大的包和环境管理工具，可以在Windows的AnacondaPrompt命令行使用，也可以在macOS或者Linux系统的终端窗口(terminalwindow)的命令行使用。</p><p>本文简单介绍conda的一些常用命令（对于大多数人来说掌握了这些就基本上能够‘生活自理’了吧）命令。当然，本文假定你已经安装了Anaconda，并且在Windows条件下使用AnacondaPrompt或者在Linux下使用terminal window。</p><p>本文根据<ahref="https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html"title="conda-getting-started">conda-getting-started</a>编译而成，喜欢阅读英文的伙伴们可以直接去读英文说明。</p><p>conda命令的一些选项开关有两种指定方式，一种两个连接号“--”后跟选项名全程，一种是一个连接号“-”后跟简称。比如说"-n"和"--name"是等价的。但是要注意有些例外，比如说，“--version”对应的是“-V”（大写的V而不是小写的v）</p><h2 id="管理conda自身">管理conda自身</h2><h3 id="查看conda版本">查看conda版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><h3 id="查看conda的环境配置">查看conda的环境配置</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">config</span> <span class="comment">--show</span></span><br></pre></td></tr></table></figure><p>运行结果示例（只是截取了最前面一小段） </p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/97c985eda8927c60f1226d5fda425dc7.png" /></p><h3 id="设置镜像">设置镜像</h3><p>        conda有时候安装软件会非常慢。设置国内镜像的话可以使安装更快捷一些。设置方法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置清华镜像</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line"><span class="comment">#设置bioconda</span></span><br><span class="line">conda config --add channels bioconda</span><br><span class="line">conda config --add channels conda-forge</span><br><span class="line"><span class="comment">#设置搜索时显示通道地址</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><h3 id="更新conda">更新conda</h3><p>将conda自身更新到最新版本，it is recommended to always keep condaupdated to the latest version.         </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h3 id="更新anaconda整体">更新Anaconda整体</h3><p>将整个Anaconda都更新到确保稳定性和兼容性的最新版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update Anaconda</span><br></pre></td></tr></table></figure><h3 id="查询某个命令的帮助">查询某个命令的帮助 </h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h2 id="管理环境">管理环境</h2><p>        Conda允许你创建相互隔离的独立环境，这些环境被称之为虚拟环境</p><p>（VirtualEnvironment），这些环境各自包含属于自己的文件、包以及他们的依存关系，并且不会相互干扰。</p><p>        Anaconda有一个缺省的名为base的环境。但是不建议把程序放在base环境中，应该创建不同的虚拟环境分别管理不同的开发项目。这个涉及到一个根本的问题：为什么我们需要虚拟环境呢？举一个简单的例子，想象一下你有多个项目要开发，每个项目中都有一些包要依赖于某个共同的包，但是各自的所需要的版本不一致，有一些需要低版本的，有些需要高版本的。然后你就陷入了众口难调的困境。为不同的项目创建虚拟环境就可以把不同项目隔离开来，各自使用自己所需要的软件环境。</p><h3 id="创建虚拟环境">创建虚拟环境</h3><p>        使用conda创建虚拟环境的命令格式为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_name python=3.8</span><br></pre></td></tr></table></figure><p>        这表示创建python版本为3.8、名字为env_name的虚拟环境。</p><p>        创建后，env_name文件可以在Anaconda安装目录envs文件下找到。在不指定python版本时，自动创建基于最新python版本的虚拟环境.     </p><h3id="创建虚拟环境的同时安装必要的包">创建虚拟环境的同时安装必要的包</h3><p>        但是并不建议这样做，简化每一条命令的任务在绝大多数时候都是明智的（一个例外是需要反复执行的脚本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_name numpy matplotlib python=3.8</span><br></pre></td></tr></table></figure><h3 id="查看有哪些虚拟环境">查看有哪些虚拟环境</h3><p>        以下三条命令都可以。注意最后一个是”--”，而不是“-”.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line">conda info -e</span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>      所显示的列表中，前面带星号“*“的表示当前活动环境。比如说当前我的环境列表：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/2e9b84cb928a22895fa02439c8ca659e.png" /></p><p>         星号的位置表示我现在在base环境下工作。注意，也有不是显示base而显示root的，root是因为是以系统管理身份作业（？待确认）</p><h3 id="激活虚拟环境">激活虚拟环境</h3><p>        使用如下命令即可激活创建的虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure><p>        此时使用python--version可以检查当前python版本是否为所想要的（即虚拟环境的python版本）。</p><p>        在4.6版本以前需要使用如下命令：</p><p>        Linux:  source activate your_env_name</p><p>        Windows: activate your_env_name</p><p>        但是为什么要停留在过去（4.6以前的版本）呢？毕竟现在至少已经有4.10版本了，所以如果你不是最新版本，运行一下"condaupdate conda"吧</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/a17d49147c4ec49ea7df667382e6b3cb.png" /></p><h3 id="退出虚拟环境">退出虚拟环境</h3><p>        使用如下命令即可退出当前工作的虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>        有意思的是，以上两条命令只中任一条都会让你回到baseenvironment，它们从不同的角度出发到达了同一个目的地。可以这样理解，activate的缺省值是base，deactivate的缺省值是当前环境，因此它们最终的结果都是回到base</p><p>       这个只适用于4.6及以后版本。如果你还在4.6以前的话，参见上一条说明。</p><h3 id="删除虚拟环境">删除虚拟环境</h3><p>        执行以下命令可以将该指定虚拟环境及其中所安装的包都删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name env_name --all</span><br></pre></td></tr></table></figure><p>        如果只删除虚拟环境中的某个或者某些包则是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name env_name  package_name</span><br></pre></td></tr></table></figure><h3 id="导出环境">导出环境 </h3><p>        很多的软件依赖特定的环境，我们可以导出环境，这样方便自己在需要时恢复环境，也可以提供给别人用于创建完全相同的环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获得环境中的所有配置</span></span><br><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> --name myenv &gt; myenv.yml</span><br><span class="line"><span class="comment">#重新还原环境</span></span><br><span class="line">conda <span class="built_in">env</span> create -f  myenv.yml</span><br></pre></td></tr></table></figure><h2 id="包package的管理">包（Package）的管理</h2><h3 id="查询包的安装情况">查询包的安装情况</h3><p>        查询看当前环境中安装了哪些包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><p>        查询当前Anaconda repository中是否有你想要安装的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search package_name</span><br></pre></td></tr></table></figure><p>        当然与互联网的连接是执行这个查询操作乃至后续安装的前提条件.</p><h3 id="查询是否有安装某个包">查询是否有安装某个包</h3><p>        (2023-08-17 added)</p><p>        用condalist后跟package名来查找某个指定的包是否已安装，而且支持*通配模糊查找。</p><blockquote><p>conda list pkgname        </p><p>conda list pkgname*        </p></blockquote><p>如下所示：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/f12c04a613ded77e1889dbd252b2d7c1.png" /></p><p>        当然如果你确认是否有某个包的目的是要对其进行更新的话，那就直接执行condaupdatepkgname即可，如果该包没有安装的话，conda会报告PackageNotInstalledError错误（然后改用condainstall即可），比如：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/9ee678390c31d07a5314593413288b55.png" /></p><h3 id="包的安装和更新">包的安装和更新</h3><p>        在当前（虚拟）环境中安装一个包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure><p>      当然也可以如上所述在创建虚拟环境的同时安装包，但是并不建议。安装完一个包后可以执行condalist确认现在列表中是否已经包含了新安装的包。</p><p>        也可以以以下命令安装某个特定版本的包(以下例为安装0.20.3版本的numpy)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy=0.20.3</span><br></pre></td></tr></table></figure><p>        可以用以下命令将某个包更新到它的最新版本 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">update</span> numpy</span><br></pre></td></tr></table></figure><p>        安装包的时候可以指定从哪个channel进行安装，比如说，以下命令表示不是从缺省通道，而是从conda_forge安装某个包。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pkg_name <span class="operator">-</span><span class="built_in">c</span> conda_forge</span><br></pre></td></tr></table></figure><h3 id="conda卸载包">conda卸载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall package_name</span><br></pre></td></tr></table></figure><p>        这样会将依赖于这个包的所有其它包也同时卸载。</p><p>        如果不想删除依赖其当前要删除的包的其他包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall package_name --force</span><br></pre></td></tr></table></figure><p>     但是并不建议用这种方式卸载，因为这样会使得你的环境支离破碎，如以下（condamanual  description原文）所述：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/f826d9fc385641d4393e9d57e6cca4a4.png" /></p><p>        一个直观的理解就是，如果一个包A被删除了，而依赖于它的包B、C等却没有删除，但是那些包其实也已经不可用了。另一方面，之后你又安装了A的新版本，而不幸的是，B、C却与新版本的A不兼容因此依然是不可用的。</p><h3 id="清理anaconda缓存">清理anaconda缓存</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda clean -p      <span class="comment"># 删除没有用的包 --packages</span></span><br><span class="line">conda clean -t      <span class="comment"># 删除tar打包 --tarballs</span></span><br><span class="line">conda clean -y -<span class="built_in">all</span> <span class="comment"># 删除所有的安装包及cache(索引缓存、锁定文件、未使用过的包和tar包)</span></span><br></pre></td></tr></table></figure><p>        关于清除命令的更详细的说明，可以执行以下命令进行查询：</p><blockquote><p>&gt;&gt;conda clean -h</p></blockquote><p>输出结果如下（一部分）： </p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/17fb23b144756184e73ef00683637054.png" /></p><p>        [2023-05-07] </p><p>       conda就像个守财奴一样，把每个历史安装包都会好好保存。。。好处是可以很方便地恢复到旧的历史版本，坏处是占内存空间。。。前两天由于安装一个新的包，系统报告“CondaMemoryError:The conda process ran out of memory. Increase system memory and/or tryagain.”，执行"conda -y -all"清除了约30G的空间！</p><h2 id="python版本的管理">Python版本的管理</h2><p>       除了上面在创建虚环境时可以指定python版本外，Anaconda基环境的python版本也可以根据需要进行更改。</p><h3 id="将版本变更到指定版本">将版本变更到指定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install python=3.5</span><br></pre></td></tr></table></figure><p>更新完后可以用以下命令查看变更是否符合预期。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python <span class="comment">--version</span></span><br></pre></td></tr></table></figure><h3 id="将python版本更新到最新版本">将python版本更新到最新版本</h3><p>        如果你想将python版本更新到最新版本，可以使用以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">update</span> python</span><br></pre></td></tr></table></figure><h2 id="conda-install-vs-pip-install">conda install vs pip install </h2><h3 id="有什么区别">有什么区别？</h3><ol type="1"><li>conda可以管理非python包，pip只能管理python包。</li><li>conda自己可以用来创建环境，pip不能，需要依赖virtualenv之类的。</li><li>conda安装的包是编译好的二进制文件，安装包文件过程中会自动安装依赖包；pip安装的包是wheel或源码，装过程中不会去支持python语言之外的依赖项。</li><li>conda安装的包会统一下载到一个目录文件中，当环境B需要下载的包，之前其他环境安装过，就只需要把之间下载的文件复制到环境B中，下载一次多次安装。pip是直接下载到对应环境中。</li><li>conda只能在conda管理的环境中使用，例如比如conda所创建的虚环境中使用。pip可以在任何环境中使用，在conda创建的环境 中使用pip命令，需要先安装pip（<strong>condainstall pip ），</strong>然后可以 环境A 中使用pip 。conda安装的包，pip可以卸载，但不能卸载依赖包，pip安装的包，只能用pip卸载。</li></ol><p>        比如说，在某个环境中安装一个包，会出现以下打印信息： </p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/be9d22515eec97b121bee7ebec81b291.png" /></p><p>        这里“Using cached jupyter...” 的意思就是jupyter安装包已经（在base环境或者别的环境中）之前安装过了，在缓存中有安装包，所以就不会重新下载，而是直接利用了。</p><p>        pip和conda在安装软件包时，在依赖关系方面的处理机制不同。pip在递归的串行循环中安装依赖项，不会确保同时满足所有软件包的依赖关系，如果按顺序较早安装的软件包相对于按顺序较晚安装的软件包具有不兼容的依赖项版本，则可能导致环境以微妙的方式被破坏掉；conda使用SAT（satisfiability）solver来验证是否满足环境中安装的所有软件包的所有要求，只要有关依赖项的软件包元数据正确，conda就会按预期产生可用的环境。</p><h3 id="能否混用">能否混用？</h3><p>       首先，不建议混用。混用容易导致库的依赖关系出现混乱，然后突然哪天环境可能就崩了，安装不了新的包，无法进行condaupdate之类的。[2023-05-07]刚刚这两天遭遇了一次这样的事件，由于要安装一个新的包，各种各样的稀奇古怪的事情层出不穷，比如说：</p><blockquote><p>&gt;&gt; conda install packagename</p><p>....</p><p>CondaMemoryError: The conda process ran out of memory. Increasesystem memory and/or try again.</p></blockquote><blockquote><p>&gt;&gt; conda update conda<br />  - defaults/win-64::_anaconda_depends==2020.07=py38_0<br />  - defaults/win-64::_ipyw_jlab_nb_ext_conf==0.1.0=py38_0<br />failed with repodata from current_repodata.json, will retry with nextrepodata source.<br />Solving environment: failed with repodata from current_repodata.json,will retry with next repodata<br />source.<br />Collecting package metadata (repodata.json): failed</p></blockquote><blockquote><p>RemoveError: 'requests' is a dependency of conda and cannot beremoved from<br />conda's operating environment. </p></blockquote><p>        上天入地各种官方民间偏方的试，搞不定，最后只好卸载重新安装Anaconda完事。。。</p><p>       其次，由于conda的库确实不如pip的库丰富{很多包只在 <code>pip</code> 有：<ahref="https://so.csdn.net/so/search?q=PYPI&amp;spm=1001.2101.3001.7020"title="PYPI">PYPI</a>有15万可用包，而Anacondarepository中（使用conda命令安装）提供了1,500多个软件包，Anacondacloud上（使用conda-forge或bioconda命令安装）的几千种其他软件包。}，所以有时候可能迫不得已要使用pip安装。切记，只有在condainstall搞不定时才使用pipintall。 而且，最后使用虚拟环境进行环境隔离。</p><h3 id="安装在哪里">安装在哪里？</h3><ul><li>conda installxxx：这种方式安装的库都会放在<code>anaconda3/pkgs</code>目录下，这样的好处就是，当在某个环境下已经下载好了某个库，再在另一个环境中还需要这个库时，就可以直接从pkgs目录下将该库复制至新环境而不用重复下载。</li><li>pip installxxx：分两种情况，一种情况就是当前conda环境的python是conda安装的，和系统的不一样，那么xxx会被安装到<code>anaconda3/envs/current_env/lib/python3.x/site-packages</code>文件夹中，如果当前conda环境用的是系统的python，那么xxx会通常会被安装到<code>~/.local/lib/python3.x/site-packages</code>文件夹中 </li></ul><h3id="如何判断conda中某个包是通过conda还是pip安装的">如何判断conda中某个包是通过conda还是pip安装的？</h3><p>       执行​ <code>conda list</code> ，用pip安装的包显示的build项目为pypi。如下图所示：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/0683ece3320fa827cfc98736e9f0fc4b.png" /></p><h2 id="conda-configuration">conda configuration</h2><p>       conda的配置文件为".condarc"，该文件在安装时不是缺省存在的。但是当你第一次运行condaconfig命令时它就被自动创建了。".condarc"配置文件遵循简单的YAML语法。</p><h3 id="condarc文件在哪儿">.condarc文件在哪儿？ </h3><p>        执行conda info，会有信息显示如下所示：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/a7df6041e9908acf3535b0e6f8da9232.png" /></p><h3 id="channel管理">Channel管理</h3><p>        追加conda-forge channel:</p><blockquote><p>conda config --add channels conda-forge</p></blockquote><p>        移除conda-forge channel:</p><blockquote><p>conda config --remove channels conda-forge</p></blockquote><p>        查询当前配置中包含哪些channels</p><blockquote><p>conda config --get channels</p></blockquote><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/7ecd021208e7bb69e7ea2c6181a8fdfa.png" /></p><h2 id="常见错误">常见错误</h2><ul><li><ahref="https://blog.csdn.net/laoxue123456/article/details/124371958">conda报错-Collectingpackage metadata (current_repodata.json): failed_conda collectingpackage metadata repodata.json 连接-CSDN博客</a></li></ul><p>Ref1：<a href="https://cloud.tencent.com/developer/article/1035806"title="Conda：误解与迷思">Conda：误解与迷思</a></p><p>Ref2: <ahref="https://docs.conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html"title="Using the .condarc conda configuration file">Using the .condarcconda configuration file</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux命令">Linux命令</h1><h2 id="windows与linux的区分">windows与linux的区分</h2><ol type="1"><li>linux下<strong>文件名区分大小写</strong>，而windows下<strong>文件名不区分大小写</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">ABC</span><br><span class="line">aBc</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>linux下路径分隔符为<code>/</code>，而windows下路径分隔符为<code>\</code></strong></li></ol><h2 id="linux的目录结构">Linux的目录结构</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309122142813.png"alt="20221027214128_clear_compress" /><figcaptionaria-hidden="true">20221027214128_clear_compress</figcaption></figure><span id="more"></span><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>/home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><blockquote><p>/： 根目录，操作系统的启示路径跟路径</p><p>/bin： 可执行二进制文件的目录</p><p>/etc： 系统配置文件存放的目录</p><p>/home：普通用户的家目录</p><p>/root： 管理员家目录</p><p>/dev： device设备 设备文件存放目录</p><p>/boot： 引导 主引导目录 独立的分区 启动菜单 内核</p><p>/media：光驱的挂载目录</p><p>/mnt： 临时设备挂载目录</p><p>/proc： 里面的数据都在内存中，进程的所有目录</p><p>/tmp： 临时文件存放目录</p><p>/usr： 软件的安装目录</p><p>/var： 常变文件存放目录，如日志文件，邮件文件</p></blockquote><h2 id="lsb_release命令">lsb_release命令</h2><p>功能：查看linux的发行版本信息</p><p>语法：<code>lsb_release -a</code></p><h2 id="ls命令">ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小</li><li>-a，显示隐藏文件</li></ul><blockquote><p><strong>隐藏文件/文件夹</strong></p><ul><li><p>在Linux中以<code>.</code>开头的，均是隐藏的文件/文件夹</p></li><li><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p></li></ul></blockquote><h2 id="pwd命令">pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令">cd命令</h2><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="home目录">HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径绝对路径">相对路径、绝对路径</h2><ul><li><p>相对路径，==非==<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，==以==<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符">特殊路径符</h2><ul><li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="mkdir命令">mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径</li><li>选项：-p，可选，表示创建前置路径</li></ul><h2 id="touch命令">touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h2 id="cat命令">cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令">more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li></ul></li></ul><h2 id="cp命令">cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test/，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令">mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令">rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><h2 id="which命令">which命令</h2><p>功能：查看命令的程序本体文件路径</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令">find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符*，比如：<code>*</code>test表示搜索任意以test结尾的文件</li></ul><h2 id="grep命令">grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令">wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符">管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cata.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><h2 id="echo命令">echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容</li></ul><h2 id="反引号">`反引号</h2><p>功能：<strong>被两个反引号包围的内容，会作为命令执行</strong></p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="tail命令">tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f -n] 参数</code></p><ul><li>参数：被查看的文件路径</li><li>选项：-f，持续跟踪文件修改</li><li>选项：-n，表示查看尾部多少行，不填默认10行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 100 filename</span><br></pre></td></tr></table></figure><h2 id="head命令">head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="重定向符">重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p><ul><li><code>&gt;</code>，表示覆盖输出</li><li><code>&gt;&gt;</code>，表示追加输出</li></ul><h2 id="nano编辑器">nano编辑器</h2><p><ahref="https://blog.csdn.net/fuzhang_android/article/details/87873661?spm=1001.2014.3001.5506">nano简单使用介绍_nano的用法_fuzhang_android的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/WalterBrien/article/details/125836576?spm=1001.2014.3001.5506">nano编辑器的使用_SudekiMing的博客-CSDN博客</a></p><h2 id="vi编辑器">vi编辑器</h2><h3 id="命令模式快捷键">命令模式快捷键</h3><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215841.png"alt="image-20221027215841573" /><figcaption aria-hidden="true">image-20221027215841573</figcaption></figure><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215846.png"alt="image-20221027215846581" /><figcaption aria-hidden="true">image-20221027215846581</figcaption></figure><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215849.png"alt="image-20221027215849668" /><figcaption aria-hidden="true">image-20221027215849668</figcaption></figure><h3 id="底线命令快捷键">底线命令快捷键</h3><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215858.png"alt="image-20221027215858967" /><figcaption aria-hidden="true">image-20221027215858967</figcaption></figure><h2 id="命令的选项">命令的选项</h2><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p><p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I-k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X-1等选项，可以发现选项是极其多的。</p><p>课程中，并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</p><p>课程中，会对常见的选项进行讲解，足够满足绝大多数的学习、工作场景。</p><h3 id="查看命令的帮助">查看命令的帮助</h3><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220005.png"alt="image-20221027220005610" /><figcaption aria-hidden="true">image-20221027220005610</figcaption></figure><h3 id="查看命令的详细手册">查看命令的详细手册</h3><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220010.png"alt="image-20221027220009949" /><figcaption aria-hidden="true">image-20221027220009949</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Linux%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Linux%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="linux操作">Linux操作</h1><h2 id="软件安装">软件安装</h2><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><span id="more"></span><h2 id="systemctl">systemctl</h2><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h2 id="软链接">软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><h2 id="日期">日期</h2><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y 年%y 年份后两位数字 (00..99)</li><li>%m 月份 (01..12)</li><li>%d 日 (01..31)</li><li>%H 小时 (00..23)</li><li>%M 分钟 (00..59)</li><li>%S 秒 (00..60)</li><li>%s 自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354525.png"alt="image-20221027220514640" /><figcaption aria-hidden="true">image-20221027220514640</figcaption></figure></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354546.png"alt="image-20221027220525625" /><figcaption aria-hidden="true">image-20221027220525625</figcaption></figure></li><li><p>-d选项日期计算</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354538.png"alt="image-20221027220429831" /><figcaption aria-hidden="true">image-20221027220429831</figcaption></figure><ul><li><p>支持的时间标记为：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354567.png"alt="image-20221027220449312" /><figcaption aria-hidden="true">image-20221027220449312</figcaption></figure></li></ul></li></ul><h2 id="时区">时区</h2><p>修改时区为中国时区</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354572.png"alt="image-20221027220554654" /><figcaption aria-hidden="true">image-20221027220554654</figcaption></figure><h2 id="ntp">ntp</h2><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h2 id="ip地址">ip地址</h2><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h2 id="主机名">主机名</h2><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h2 id="配置vmware固定ip">配置VMware固定IP</h2><ol type="1"><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;# 改为static，固定IP</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=&quot;192.168.88.131&quot;# IP地址，自己设置，要匹配网络范围</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;# 子网掩码，固定写法255.255.255.0</span><br><span class="line">GATEWAY=&quot;192.168.88.2&quot;# 网关，要和VMware中配置的一致</span><br><span class="line">DNS1=&quot;192.168.88.2&quot;# DNS1服务器，和网关一致即可</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="ps命令">ps命令</h2><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><p><strong>举例</strong>：在Linux上，我想查看：用户为ycxie，执行命令为python3的所有进程信息，应使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;ycxie.*python3&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="kill命令">kill命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354615.png"alt="image-20221027221303037" /><figcaption aria-hidden="true">image-20221027221303037</figcaption></figure><h2 id="nmap命令">nmap命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354218.png"alt="image-20221027221241123" /><figcaption aria-hidden="true">image-20221027221241123</figcaption></figure><h2 id="netstat命令">netstat命令</h2><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h2 id="ping命令">ping命令</h2><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354289.png"alt="image-20221027221129782" /><figcaption aria-hidden="true">image-20221027221129782</figcaption></figure><h2 id="wget命令">wget命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354323.png"alt="image-20221027221148964" /><figcaption aria-hidden="true">image-20221027221148964</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354349.png"alt="image-20230830233213202" /><figcaption aria-hidden="true">image-20230830233213202</figcaption></figure><h2 id="curl命令">curl命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354388.png"alt="image-20221027221201079" /><figcaption aria-hidden="true">image-20221027221201079</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354464.png"alt="image-20221027221210518" /><figcaption aria-hidden="true">image-20221027221210518</figcaption></figure><h2 id="top命令">top命令</h2><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354904.png"alt="image-20221027221340729" /><figcaption aria-hidden="true">image-20221027221340729</figcaption></figure><p>交互式模式中，可用快捷键：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354037.png"alt="image-20221027221354137" /><figcaption aria-hidden="true">image-20221027221354137</figcaption></figure><h2 id="df命令">df命令</h2><p>查看磁盘占用</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354055.png"alt="image-20221027221413787" /><figcaption aria-hidden="true">image-20221027221413787</figcaption></figure><h2 id="iostat命令">iostat命令</h2><p>查看CPU、磁盘的相关信息</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354200.png"alt="image-20221027221439990" /><figcaption aria-hidden="true">image-20221027221439990</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354117.png"alt="image-20221027221514237" /><figcaption aria-hidden="true">image-20221027221514237</figcaption></figure><h2 id="sar命令">sar命令</h2><p>查看网络统计</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354176.png"alt="image-20221027221545822" /><figcaption aria-hidden="true">image-20221027221545822</figcaption></figure><h2 id="环境变量">环境变量</h2><ul><li>临时设置：export 变量名=变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h3 id="path变量">PATH变量</h3><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h2 id="符号">$符号</h2><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p><h2 id="压缩解压">压缩解压</h2><h3 id="压缩">压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354586.png"alt="image-20221027221906247" /><figcaption aria-hidden="true">image-20221027221906247</figcaption></figure><h3 id="解压">解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354703.png"alt="image-20221027221939899" /><figcaption aria-hidden="true">image-20221027221939899</figcaption></figure><h2 id="bgp-dump命令">BGP-dump命令</h2><ul><li><p>打开任意终端，输入bgpdump，可查看参数。</p></li><li><p>MRT格式的RIB可从route view project官网下载：<ahref="http://archive.routeviews.org/">route view projectarchive</a>。</p></li><li><p>常用指令：bgpdump -m xxx.bz2 &gt; output.txt</p></li></ul><h2 id="su命令">su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354737.png"alt="image-20221027222021619" /><figcaption aria-hidden="true">image-20221027222021619</figcaption></figure><h2 id="sudo命令">sudo命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354874.png"alt="image-20221027222035337" /><figcaption aria-hidden="true">image-20221027222035337</figcaption></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itheima ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="chmod命令">chmod命令</h2><p>修改文件、文件夹权限</p><p>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354864.png"alt="image-20221027222157276" /><figcaption aria-hidden="true">image-20221027222157276</figcaption></figure></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令">chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354954.png"alt="image-20221027222326192" /><figcaption aria-hidden="true">image-20221027222326192</figcaption></figure><h2 id="用户组管理">用户组管理</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354190.png"alt="image-20221027222354498" /><figcaption aria-hidden="true">image-20221027222354498</figcaption></figure><h2 id="用户管理">用户管理</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354334.png"alt="image-20221027222407618" /><figcaption aria-hidden="true">image-20221027222407618</figcaption></figure><h2 id="genenv命令">genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354405.png"alt="image-20221027222446514" /><figcaption aria-hidden="true">image-20221027222446514</figcaption></figure></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354510.png"alt="image-20221027222512274" /><figcaption aria-hidden="true">image-20221027222512274</figcaption></figure></li></ul><h2 id="env命令">env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p><h2 id="nano命令">nano命令</h2><p><ahref="https://blog.csdn.net/WalterBrien/article/details/125836576?ops_request_misc=%7B%22request%5Fid%22%3A%22169508811116777224443235%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169508811116777224443235&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125836576-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=nano&amp;spm=1018.2226.3001.4187">nano编辑器的使用_SudekiMing的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/carefree2005/article/details/129042788?ops_request_misc=%7B%22request%5Fid%22%3A%22169508802416800182147582%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169508802416800182147582&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-129042788-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=nano命令&amp;spm=1018.2226.3001.4187">Linux命令之nano命令_恒悦sunsite的博客-CSDN博客</a></p><h2 id="nohup命令">nohup命令</h2><p><code>nohup python3 -u test.py &gt; nohup.out 2&gt;&amp;1 &amp;</code></p><p><ahref="https://blog.csdn.net/jiangyu1013/article/details/81476184?ops_request_misc=%7B%22request%5Fid%22%3A%22169018276616800184180892%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169018276616800184180892&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-81476184-null-null.142%5Ev90%5Econtrol_2,239%5Ev3%5Einsert_chatgpt&amp;utm_term=nohup命令&amp;spm=1018.2226.3001.4187">(139条消息)linux 中的 nohup 命令（设置后台进程）： nohup: ignoring input andappending output to ‘nohup.out’_nohup: ignoring input and appendingoutput to 'noh_微风--轻许--的博客-CSDN博客</a></p><h2 id="ping命令-1">ping命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">用法: ping [-t] [-a] [-n count] [-l size] [-f] [-i TTL] [-v TOS]</span><br><span class="line">            [-r count] [-s count] [[-j host-list] | [-k host-list]]</span><br><span class="line">            [-w <span class="built_in">timeout</span>] [-R] [-S srcaddr] [-c compartment] [-p]</span><br><span class="line">            [-4] [-6] target_name</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">    -t             Ping 指定的主机，直到停止。</span><br><span class="line">                   若要查看统计信息并继续操作，请键入 Ctrl+Break；</span><br><span class="line">                   若要停止，请键入 Ctrl+C。</span><br><span class="line">    -a             将地址解析为主机名。</span><br><span class="line">    -n count       要发送的回显请求数。</span><br><span class="line">    -l size        发送缓冲区大小。</span><br><span class="line">    -f             在数据包中设置“不分段”标记(仅适用于 IPv4)。</span><br><span class="line">    -i TTL         生存时间。</span><br><span class="line">    -v TOS         服务类型(仅适用于 IPv4。该设置已被弃用，</span><br><span class="line">                   对 IP 标头中的服务类型字段没有任何</span><br><span class="line">                   影响)。</span><br><span class="line">    -r count       记录计数跃点的路由(仅适用于 IPv4)。</span><br><span class="line">    -s count       计数跃点的时间戳(仅适用于 IPv4)。</span><br><span class="line">    -j host-list   与主机列表一起使用的松散源路由(仅适用于 IPv4)。</span><br><span class="line">    -k host-list    与主机列表一起使用的严格源路由(仅适用于 IPv4)。</span><br><span class="line">    -w <span class="built_in">timeout</span>     等待每次回复的超时时间(毫秒)。</span><br><span class="line">    -R             同样使用路由标头测试反向路由(仅适用于 IPv6)。</span><br><span class="line">                   根据 RFC 5095，已弃用此路由标头。</span><br><span class="line">                   如果使用此标头，某些系统可能丢弃</span><br><span class="line">                   回显请求。</span><br><span class="line">    -S srcaddr     要使用的源地址。</span><br><span class="line">    -c compartment 路由隔离舱标识符。</span><br><span class="line">    -p             Ping Hyper-V 网络虚拟化提供程序地址。</span><br><span class="line">    -4             强制使用 IPv4。</span><br><span class="line">    -6             强制使用 IPv6。</span><br></pre></td></tr></table></figure><h2 id="traceroute命令">traceroute命令</h2><ul><li>traceroute的用法为:<code>Traceroute [options] [data size]</code></li><li><code>[options]</code>的内容有:</li></ul><p><code>[-n]</code>：显示的地址是用数字表示而不是符号<code>[-v]</code>：长输出 <code>[-p]</code>：UDP端口设置（缺省为33434）<code>[-q]</code>：设置TTL测试数目（缺省为3）<code>[-t]</code>：设置测包的服务类型<code>[data size]</code>：每次测试包的数据字节长度（缺省为38）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Others</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Others/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Others/</url>
      
        <content type="html"><![CDATA[<h1 id="others">Others</h1><h2 id="降低python版本">降低Python版本</h2><ol type="1"><li>使用conda降低Python版本：如果你使用的是conda，你可以使用以下命令降低Python版本</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install python=<span class="number">3.6</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用pip降低Python版本：如果你使用的是pip，你可以使用以下命令降低Python版本</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python==3.6</span><br></pre></td></tr></table></figure><h2 id="不是内部或外部命令也不是可运行的程序或批处理文件">'.'不是内部或外部命令，也不是可运行的程序或批处理文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Document\lab\federated-learning\Codes\leaf-master\data\femnist&gt;./preprocess.sh -s niid --sf 1.0 -k 0 -t sample</span><br><span class="line"><span class="string">&#x27;.&#x27;</span> 不是内部或外部命令，也不是可运行的程序或批处理文件。</span><br></pre></td></tr></table></figure><p>这个错误信息表明你正在尝试在Windows的命令提示符（CMD）或PowerShell中运行一个为Unix或Linux系统（如bashshell）编写的shell脚本（<code>preprocess.sh</code>）。Windows默认不支持直接运行<code>.sh</code>脚本，因为它使用的是不同的命令解释器。</p><p>要在Windows上运行这个脚本，你有几个选项：</p><ol type="1"><li><strong>使用Windows Subsystem for Linux (WSL):</strong><ol type="1"><li>如果你已经安装了WSL（Windows Subsystem forLinux），你可以在WSL的bash shell中运行这个脚本。</li><li>确保你的脚本和所有依赖项都在WSL环境中正确安装和配置。</li></ol></li><li><strong>使用Git Bash或Cygwin:</strong><ol type="1"><li>如果你没有安装WSL，但安装了GitBash或Cygwin，这些工具也提供了一个bash环境，你可以在其中运行<code>.sh</code>脚本。</li></ol></li><li><strong>重写脚本为Windows批处理文件:</strong><ol type="1"><li>你可以将<code>preprocess.sh</code>脚本中的命令转换为WindowsCMD命令，并将它们保存为<code>.bat</code>文件。但是，这可能需要大量的工作，特别是如果脚本很复杂或使用了许多Unix特有的命令和工具。</li></ol></li><li><strong>使用Docker（如果适用）:</strong><ol type="1"><li>如果你的项目支持Docker，并且有一个为Unix环境配置的Dockerfile，你可以在Docker容器中运行你的脚本。这通常是在Windows上运行Unix脚本的最简单和最可靠的方法之一。</li></ol></li><li><strong>使用虚拟机</strong>:<ol type="1"><li>你可以设置一个虚拟机来运行一个完整的Linux发行版，然后在那个环境中运行你的脚本。</li></ol></li></ol><p>对于你的具体情况，如果你已经安装了WSL或GitBash，你可以尝试在这些环境中导航到<code>D:\Document\lab\federated-learning\Codes\leaf-master\data\femnist</code>目录（注意，在WSL中，你可能需要挂载你的Windows文件系统或使用与Windows路径相对应的Linux路径），然后运行<code>./preprocess.sh -s niid --sf 1.0 -k 0 -t sample</code>命令。</p><p>如果你选择使用WSL或GitBash，并且你的脚本仍然无法运行，那么可能是因为脚本中使用了某些在Windows环境中不可用的Unix命令或工具。在这种情况下，你可能需要修改脚本以适应Windows环境，或者寻找替代的命令或工具来完成相同的任务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows命令</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Windows%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/Windows%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="windows命令">Windows命令</h1><p>[TOC]</p><h2 id="前言">前言</h2><p><strong>cmd</strong>是<strong>command</strong>的缩写.即命令行</p><p>虽然随着计算机产业的发展，<strong>Windows</strong> <ahref="https://so.csdn.net/so/search?q=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020">操作系统</a>的应用越来越广泛，<strong>DOS</strong>面临着被淘汰的命运，但是因为它运行安全、稳定，有的用户还在使用，所以一般Windows的各种版本都与其兼容，用户可以在<strong>Windows</strong>系统下运行<strong>DOS</strong>，<ahref="https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%87%E7%89%88&amp;spm=1001.2101.3001.7020">中文版</a><strong>WindowsXP</strong>中的命令提示符进一步提高了与DOS下操作命令的兼容性，用户可以在命令提示符直接输入中文调用文件。</p><p>作为一个开发者，我们用的最多的就是<strong>windows</strong>，但是对于<strong>cmd</strong>，我不知道大家熟不熟，反正我是一直不怎么熟悉。平时操作<strong>linux</strong>比较多，反而忽视了<strong>cmd</strong>相关命令，这里大致总结一些常用的命令，作为记录。</p><h2 id="常用命令">常用命令</h2><h3 id="cd命令">cd命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//进入d盘</span><br><span class="line">D:</span><br><span class="line">//进入F盘</span><br><span class="line">F:</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /?     //获取使用帮助</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> \       //跳转到硬盘的根目录</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> C:\WINDOWS  //跳转到当前硬盘的其他文件</span><br><span class="line"></span><br><span class="line">d:        //跳转到其他硬盘</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /d e:\software    //跳转到其他硬盘的其他文件夹，注意此处必须加/d参数。否则无法跳转。</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>..      //跳转到上一层目录</span><br></pre></td></tr></table></figure><h3 id="查看目录文件">查看目录文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看当前目录下的文件，类似于linux下的ls</span></span><br><span class="line">dir</span><br></pre></td></tr></table></figure><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/6d32b8f9d3c430b3109f79934177110e.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>如果是需要查看隐藏文件的或者更多操作的话，可以使用<code>dir /?</code>来查看其它用法，cmd这点挺好的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /?</span><br></pre></td></tr></table></figure><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/86514d160b01bdc6daba3c5fe238bd2e.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="创建目录和删除目录">创建目录和删除目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建目录</span><br><span class="line">md 目录名（文件夹）</span><br><span class="line">//删除目录</span><br><span class="line">rd 目录名（文件夹）</span><br></pre></td></tr></table></figure><h3 id="查看本机ip">查看本机ip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><h3 id="清除屏幕">清除屏幕</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure><p>类似于linux下的clear</p><h3 id="复制文件">复制文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 路径\文件名 路径\文件名 ：把一个文件拷贝到另一个地方。 </span><br></pre></td></tr></table></figure><h3 id="移动文件">移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move 路径\文件名 路径\文件名 ：把一个文件移动（就是剪切+复制）到另一个地方。 </span><br></pre></td></tr></table></figure><h3 id="创建文件">创建文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> nul &gt;test.txt</span><br></pre></td></tr></table></figure><h3 id="删除文件">删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个是专门删除文件的，不能删除文件夹</span><br><span class="line">del 文件名</span><br></pre></td></tr></table></figure><h3 id="ping">ping</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//用来测试网络是否畅通</span><br><span class="line">ping ip(主机名)</span><br></pre></td></tr></table></figure><h3 id="taskkill">taskkill</h3><p><strong>列出所有任务及进程号，杀进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskkill</span><br><span class="line"></span><br><span class="line">taskkill /?  获取使用帮助</span><br></pre></td></tr></table></figure><p><strong>taskkill</strong>是用来终止进程的。具体的命令规则如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TASKKILL [/S system [/U username [/P [password]]]]</span><br><span class="line">&#123; [/FI filter] [/PID processid | /IM imagename] &#125; [/F] [/T]</span><br></pre></td></tr></table></figure><p><strong>描述:</strong></p><p>这个<ahref="https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7&amp;spm=1001.2101.3001.7020">命令行工具</a>可用来结束至少一个进程。</p><p>可以根据进程 id 或映像名（Image）来结束进程。</p><p><strong>参数列表:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/S system 指定要连接到的远程系统。</span><br><span class="line">/U [domain\]user 指定应该在哪个用户上下文</span><br></pre></td></tr></table></figure><p>执行这个命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/P [password] 为提供的用户上下文指定密码。如果忽略，提示输入。</span><br><span class="line">/F 指定要强行终止的进程。</span><br><span class="line">/FI filter 指定筛选进或筛选出查询的的任务。</span><br><span class="line">/PID process <span class="built_in">id</span> 指定要终止的进程的PID。</span><br><span class="line">/IM image name 指定要终止的进程的映像名称。通配符 <span class="string">&#x27;*&#x27;</span>可用来指定所有映像名。</span><br><span class="line">/T Tree <span class="built_in">kill</span>: 终止指定的进程和任何由此启动的子进程。</span><br><span class="line">/? 显示帮助/用法。</span><br></pre></td></tr></table></figure><p><strong>例如:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TASKKILL /S system /F /IM notepad.exe /T</span><br><span class="line">TASKKILL /PID 1230 /PID 1241 /PID 1253 /T</span><br><span class="line">TASKKILL /F /IM QQ.exe</span><br><span class="line">TASKKILL /F /IM notepad.exe /IM mspaint.exe</span><br><span class="line">TASKKILL /F /FI <span class="string">&quot;PID ge 1000&quot;</span> /FI <span class="string">&quot;WINDOWTITLE ne untitle*&quot;</span></span><br><span class="line">TASKKILL /F /FI <span class="string">&quot;USERNAME eq NT AUTHORITY\SYSTEM&quot;</span> /IM notepad.exe</span><br></pre></td></tr></table></figure><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/9acbacf431c4d3c528cb627f68a775a1.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="netstat-查看网络连接状态">netstat 查看网络连接状态</h3><p>显示协议统计信息和当前 <strong>TCP/IP</strong>网络连接。该命令可以查看当前机器建立的所有网络链接状态，以及对应哪个进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -<span class="built_in">help</span> 获取命令行使用帮助信息</span><br><span class="line"></span><br><span class="line">netstat -ano  //查看网络连接、状态以及对应的进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-a或--all：显示所有连线中的Socket；</span><br><span class="line">-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址；</span><br><span class="line">-c或--continuous：持续列出网络状态；</span><br><span class="line">-C或--cache：显示路由器配置的快取信息；</span><br><span class="line">-e或--extend：显示网络其他相关信息；</span><br><span class="line">-F或--fib：显示FIB；</span><br><span class="line">-g或--<span class="built_in">groups</span>：显示多重广播功能群组组员名单；</span><br><span class="line">-h或--<span class="built_in">help</span>：在线帮助；</span><br><span class="line">-i或--interfaces：显示网络界面信息表单；</span><br><span class="line">-l或--listening：显示监控中的服务器的Socket；</span><br><span class="line">-M或--masquerade：显示伪装的网络连线；</span><br><span class="line">-n或--numeric：直接使用ip地址，而不通过域名服务器；</span><br><span class="line">-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；</span><br><span class="line">-o或--timers：显示计时器；</span><br><span class="line">-p或--programs：显示正在使用Socket的程序识别码和程序名称；</span><br><span class="line">-r或--route：显示Routing Table；</span><br><span class="line">-s或--statistice：显示网络工作信息统计表；</span><br><span class="line">-t或--tcp：显示TCP传输协议的连线状况；</span><br><span class="line">-u或--udp：显示UDP传输协议的连线状况；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-V或--version：显示版本信息；</span><br><span class="line">-w或--raw：显示RAW传输协议的连线状况；</span><br><span class="line">-x或--unix：此参数的效果和指定<span class="string">&quot;-A unix&quot;</span>参数相同；</span><br><span class="line">--ip或--inet：此参数的效果和指定<span class="string">&quot;-A inet&quot;</span>参数相同。</span><br></pre></td></tr></table></figure><h3 id="find">find</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find /？获取使用帮助</span><br><span class="line"></span><br><span class="line">netstat -ano|find <span class="string">&quot;.8&quot;</span>   //使用管道符，进行模糊查询</span><br></pre></td></tr></table></figure><h3 id="tracert">tracert</h3><p><strong>tracert</strong>也被称为<strong>Windows</strong>路由跟踪实用程序，在命令提示符（cmd）中使用<strong>tracert</strong>命令可以用于确定IP数据包访问目标时所选择的路径。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409301704376.png"alt="image-20240930170410256" /><figcaption aria-hidden="true">image-20240930170410256</figcaption></figure><h2 id="查看cmd下的命令">查看cmd下的命令</h2><p><strong>1、使用help命令，查看所有的dos命令</strong></p><p>使用这个命令之后，我们可以看到所有的dos命令，并且后面还有中文的解释。简直不要太赞，这样我们就可以根据自己的需求要找到想要使用的命令。</p><p><strong>2、找到命令之后，使用 命令+/?来查看该命令下的其他属性</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 -<span class="built_in">help</span>    //第1种形式的使用帮助</span><br><span class="line"></span><br><span class="line">命令  /?       //第2种形式的使用帮助</span><br></pre></td></tr></table></figure><p><strong>注意：这些字符只能是英文的</strong></p><h2 id="辅助符号或命令">辅助符号或命令</h2><h3 id="section">‘|’</h3><p><strong>“|”cmd命令中|代表前一个的输出代表后一个的输入</strong></p><p>查找特定ip的网络连接及进程号：<code>netstat -ano|find "192.168.1.10"</code></p><h3 id="重定向输出符号">重定向输出符号&gt; &gt;&gt;</h3><p>将原本输出到命令窗口的内容，转存到文件中，如<code>jstack 12912 &gt;d:/s.txt</code>打印线程到指定文件</p><p><strong>cmd &gt;</strong> 重定向输出并覆盖源文件。</p><p><strong>例如</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt;c:\1.txt  // 1.txt的文件内容先被清空，然后写入hello。</span><br></pre></td></tr></table></figure><p><strong>cmd &gt;&gt;重定向输出追加到文件末尾</strong></p><p><strong>例如：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt;&gt;c:\1.txt  // 在1.txt文件末尾加上hello</span><br></pre></td></tr></table></figure><h3 id="重定向输入符号">重定向输入符号&lt; &lt;&lt;</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &lt; file</span><br></pre></td></tr></table></figure><p>使cmd命令从file读入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &lt;&lt; <span class="string">text</span></span><br></pre></td></tr></table></figure><p><strong>从命令行读取输入，直到一个与text相同的行结束。</strong></p><p>除非使用引号把输入括起来，此模式将对输入内容进行<strong>shell</strong>变量替换。</p><p>如果使用 &lt;&lt;-，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考后面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &lt;&lt;&lt; <span class="string">word</span></span><br></pre></td></tr></table></figure><p>把word（而不是文件word）和后面的换行作为输入提供给cmd。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &lt;&gt; file</span><br></pre></td></tr></table></figure><p>以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd &gt;| file</span><br></pre></td></tr></table></figure><p>功能同&gt;，但即便在设置了noclobber时也会覆盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。</p><h3 id="终止一直在运行的命令ctrlc">终止一直在运行的命令ctrl+c</h3><p>有时某个命令一直打印输出结果(如<code>ping 192.168.1.10 -t</code>)，我们想终止这个命令的执行，直接按<code>ctrl+c</code>即可。</p><h3 id="清空cmd窗口内容命令cls">清空cmd窗口内容命令cls</h3><p>有时cmd内容太多，滚动费尽，需要清空屏幕内容，直接输入cls即可</p><p><strong>cmd命令中，按键盘的向上箭头可以直接复制前一个命令</strong></p><h3 id="常用工具">常用工具</h3><p><strong>ProcessExplorer</strong>，查询进程的详细信息，如查询java进程启动参数，运行环境，线程信息、网络连接信息、使用了哪些dll，打开了什么句柄。包含注册表、Socket、文件等等。</p><p><strong>下载地址</strong>：<code>https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer</code></p><h2 id="快捷键">快捷键</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">win+E                 打开文件管器</span><br><span class="line"></span><br><span class="line">win+D                 显示桌面</span><br><span class="line"></span><br><span class="line">win+L                 锁计算机</span><br><span class="line"></span><br><span class="line">alt+F4                 关闭当前程序</span><br><span class="line"></span><br><span class="line">ctrl+<span class="built_in">shift</span>+Esc    打开任务管理器（或者ctrl+alt+delete）</span><br><span class="line"></span><br><span class="line">ctrl+F                  在一个文本或者网页里面查找，相当实用（退出一般按ESC）</span><br><span class="line"></span><br><span class="line">ctrl+A                  选中所有文本</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali命令</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/kali%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/kali%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="kali命令">kali命令</h1><p>账号：kali</p><p>密码：kali</p><p>切换为root：sudo su</p><p>开机自启动ssh：updata -rc.d ssh enable</p><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo操作</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/mongo%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/mongo%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="mongo操作">mongo操作</h1><h2 id="错误">错误</h2><h3 id="mongo-无法连接">mongo 无法连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/ycxie/data/mongo/mongodb-linux-x86_64-ubuntu2004-4.4.16/bin/mongod --config /home/ycxie/data/mongo/conf/mongo.conf</span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034003.png" /></p><h3 id="syntaxerror">SyntaxError</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> mongodump <span class="comment">--db pfx2as_new --out /home/ycxie/data/cly/pfx2as/;</span></span><br><span class="line"><span class="number">2023</span><span class="number">-09</span><span class="number">-02</span>T20:<span class="number">55</span>:<span class="number">05.215</span><span class="operator">+</span><span class="number">0800</span> E QUERY    [thread1] SyntaxError: missing ; before statement @(shell):<span class="number">1</span>:<span class="number">12</span></span><br></pre></td></tr></table></figure><p>退出 mongo 环境，该命令要放在终端执行</p><h2 id="连接-mongo-数据库">连接 mongo 数据库</h2><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034005.png" /></p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034006.png" /></p><h2 id="修改">修改</h2><h3 id="修改集合名称">修改集合名称</h3><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034007.png" /></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(&quot;2023/07/15&quot;).renameCollection(&quot;20230715&quot;);</span><br></pre></td></tr></table></figure><h3 id="修改集合字段名">修改集合字段名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 MongoDB</span></span><br><span class="line">client = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">database = client[<span class="string">&quot;your_database_name&quot;</span>]</span><br><span class="line">collection = database[<span class="string">&quot;your_collection_name&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行更新操作</span></span><br><span class="line">collection.update_many(&#123;&#125;, &#123;<span class="string">&quot;$rename&quot;</span>: &#123;<span class="string">&quot;old_field&quot;</span>: <span class="string">&quot;new_field&quot;</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 MongoDB 连接</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><h2 id="查询">查询</h2><h3 id="查询所有">查询所有</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(&quot;集合名称&quot;).find()</span><br></pre></td></tr></table></figure><h3 id="查询指定字段">查询指定字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection(&quot;集合名称&quot;).find(&#123; 键: 值 &#125;);</span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034008.png" /></p><h3 id="查找所有数据库">查找所有数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><h3 id="查找数据库下的所有集合">查找数据库下的所有集合</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> collections;</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><h3 id="删除集合">删除集合</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.[集合名称].<span class="keyword">drop</span>()</span><br></pre></td></tr></table></figure><h3 id="删除集合某一字段">删除集合某一字段</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_from_ pymongo _import_ MongoClient</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 连接到MongoDB_</span></span><br><span class="line">client = MongoClient(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 选择数据库和集合_</span></span><br><span class="line">db = client[<span class="string">&#x27;ASrank&#x27;</span>]</span><br><span class="line">collection = db[<span class="string">&#x27;ASes&#x27;</span>]</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 使用update操作符和$unset更新操作符删除字段_</span></span><br><span class="line">collection.update_many(&#123;&#125;, &#123;<span class="string">&quot;$unset&quot;</span>: &#123;<span class="string">&quot;adjacency&quot;</span>: <span class="string">&quot;&quot;</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">_<span class="comment"># 关闭MongoDB连接_</span></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><strong>删除数据库</strong></h3><p>先切换到指定数据库，然后执行以下命令</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db<span class="selector-class">.dropDatabase</span>()</span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034010.jpeg" /></p><h3 id="删除指定记录">删除指定记录</h3><p>Q：{ "_id" : ObjectId("657c3f29fb0e8f89c5079e02"), "AS1" : "AS1","AS2" : "AS2", "relationship" : "relationship" }如何删除这个记录？</p><p>ChatGPT</p><p>要删除 MongoDB 中的记录，你可以使用 <code>deleteOne</code>命令。以下是在 MongoDB Shell 中删除给定 "_id" 的记录的详细步骤：</p><ol type="1"><li>连接到 MongoDB Shell：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><ol type="1"><li>选择数据库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use AS-relationship</span><br></pre></td></tr></table></figure><ol type="1"><li>选择集合：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db[<span class="string">&#x27;P2P&amp;P2C&#x27;</span>]</span><br></pre></td></tr></table></figure><ol type="1"><li>执行删除操作：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var recordId = ObjectId(<span class="string">&quot;657c3f29fb0e8f89c5079e02&quot;</span>);</span><br><span class="line">db[<span class="string">&#x27;P2P&amp;P2C&#x27;</span>].deleteOne(&#123; <span class="string">&quot;_id&quot;</span>: recordId &#125;);</span><br></pre></td></tr></table></figure><p>请确保将 <code>recordId</code> 替换为你实际要删除的记录的 "_id"值。上述步骤将在指定的集合中删除包含给定 "_id" 的记录</p><h2 id="数据库备份">数据库备份</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump <span class="comment">--db 想要备份的数据库名称 --out 导出路径 --forceTableScan -d 想要备份的数据库名称</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034011.png" /></p><h2 id="数据库恢复">数据库恢复</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore <span class="comment">--db 想要恢复的数据库名称 导出路径/想要备份的数据库名称</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202409300034012.png" /></p><h2 id="导入-json-文件">导入 json 文件</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport <span class="comment">--db &lt;database_name&gt; --collection &lt;collection_name&gt; --file &lt;file_path&gt; --jsonArray</span></span><br></pre></td></tr></table></figure><ul><li><code>--db</code>：指定要导入的数据库名称</li><li><code>--collection</code>：指定要导入的集合名称</li><li><code>--file</code>：指定要导入的 JSON 文件路径</li><li><code>--jsonArray</code>：表示导入的 JSON 文件是一个 JSON 数组</li></ul><p>假设我们要导入的数据库名称为 <code>testdb</code>，集合名称为<code>users</code>，JSON 文件路径为<code>data.json</code>，那么导入命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoimport --db testdb --collection users --file data.json --jsonArray</span><br></pre></td></tr></table></figure><p>执行上述命令后，MongoDB 将会将 <code>data.json</code> 中的数据导入到<code>testdb</code> 数据库的 <code>users</code> 集合中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件路径中/、&#92;和&#92;&#92;的区别</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E4%B8%AD%60%60%E3%80%81%60%60%E5%92%8C%60%60%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E4%B8%AD%60%60%E3%80%81%60%60%E5%92%8C%60%60%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1id="文件路径中和的区别">文件路径中<code>/</code>、<code>\</code>和<code>\\</code>的区别</h1><p>1、C 程序文件路径用双斜杠 <code>//</code></p><p>因为反单斜杠 <code>\</code> 在 C/C++/C# 中是转义前导字符，例如<code>\n</code> 代表换行。为了避免歧义，路径中的 <code>\</code> 必须用<code>//</code></p><p>2、Windows 的路径中用反单斜杠 <code>\</code>，Unix/Linux路径中用单斜杠 <code>/</code></p><p>3、绝对路径和相对路径</p><ul><li><p>相对路径：相当于当前文件的路径</p></li><li><p>绝对路径：你的主页上的文件或目录在硬盘上真正的路径</p></li></ul><p>几个特殊符号：</p><p><code>./</code>：代表目前所在的目录</p><p><code>../</code>：代表上一层目录</p><p><code>/</code> 开头：代表根目录</p>]]></content>
      
      
      
        <tags>
            
            <tag> 命令操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typedef</title>
      <link href="/2023/12/19/%5Bobject%20Object%5D/C++/typedef/"/>
      <url>/2023/12/19/%5Bobject%20Object%5D/C++/typedef/</url>
      
        <content type="html"><![CDATA[<h1 id="typedef">typedef</h1><h2 id="介绍">介绍</h2><pre><code>使用关键字`typedef`可以为数据类型起一个新的别名</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br><span class="line">newName a,b;</span><br></pre></td></tr></table></figure><ul><li><code>oldName</code> 是类型原来的名字，</li><li><code>newName</code> 是类型新的名字</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure><p>==<code>typedef</code>去掉，<code>oldname</code>保留，<code>newname</code>换成a,b==</p></blockquote><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldName a,b;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol type="1"><li>typedef是赋予<strong>现有类型</strong>一个<strong>新的名字</strong>，而==<strong>不是创建新的类型</strong>==。</li><li>为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。</li><li>==<font color='red'><strong>最后的分号<code>;</code>不要忘记</strong></font>==</li></ol></blockquote><span id="more"></span><h2 id="定义">定义</h2><ol type="1"><li>typedef给如<code>int</code>，<code>double</code>，<code>char</code>，<code>long</code>，<code>float</code>等类型定义别名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br></pre></td></tr></table></figure><hr /><ol start="2" type="1"><li><strong>typedef 给数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> array[<span class="number">20</span>];</span><br><span class="line">array a1, a2, s1, s2;</span><br></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><blockquote><p>注：数组也是有类型的。例如char a1[20];定义了一个数组 a1，它的类型就是==<strong>char [20]</strong>==。</p></blockquote><hr /><ol start="3" type="1"><li><strong>typedef 给结构体类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure><p><code>stu</code> 是 <code>struct node</code> 的别名，可以用<code>stu</code> 定义结构体变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu x;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> x;</span><br></pre></td></tr></table></figure><hr /><ol start="4" type="1"><li><strong>typedef 给结构数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li><strong>typedef 给指针类型定义别名</strong></li></ol><ul><li>例一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_ARR)</span>[4]</span>;</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR是类型<code>int [4] *</code>的别名，它是一个==<strong>二维数组指针</strong>==类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><hr /><ul><li>例二</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * PTR_TO_ARR [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR是类型<code>int * [4]</code>的别名，它是一个==<strong>元素指向整形数据的指针数组</strong>==类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><ol start="6" type="1"><li><strong>typedef为函数指针类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">PTR_TO_FUNC pfunc;</span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*PTR_TO_ARR)</span>[30]</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">3</span>][<span class="number">30</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;百度搜索引擎&quot;</span>,</span><br><span class="line">    <span class="string">&quot;C-Language&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PTR_TO_ARR parr = str;</span><br><span class="line">    PTR_TO_FUNC pfunc = max;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max: %d\n&quot;</span>, (*pfunc)(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str[%d]: %s\n&quot;</span>, i, *(parr+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max: <span class="number">20</span></span><br><span class="line">str[<span class="number">0</span>]: http:<span class="comment">//www.baidu.com</span></span><br><span class="line">str[<span class="number">1</span>]: 百度搜索引擎</span><br><span class="line">str[<span class="number">2</span>]: C-Language</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向与纵向</title>
      <link href="/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E6%A8%AA%E5%90%91%E4%B8%8E%E7%BA%B5%E5%90%91/"/>
      <url>/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E6%A8%AA%E5%90%91%E4%B8%8E%E7%BA%B5%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="官方版">官方版</h2><ul><li>纵向课题是指：从国家、部委和省市纳入财政计划的科研拨款中直接获得经费的“项目”，熟知有973863、自然基金、社会科学基金、军口“项目”、“科技计划项目”、各部委的“项目”等。</li><li>横向课题就是通过技术合作获得研发经费的课题。横向课题一般都是具体部门、具体企业为了解决工作中难题和技术难关，而制定的项目，通过提供项目经费与研发酬劳而实现的项目委托方与受托方的直接合作。</li><li>横向课题多是由地方政府委托一些机构，企业委托专门机构或研发单位进行科技难题攻关或者针对某一方面工作作为项目委托实施。</li></ul><h2 id="简明版">简明版</h2><ul><li>纵向课题经费来自政府的财政计划</li><li>横向课题经费来自企业、研究所</li></ul><h2 id="面向学生版">面向学生版</h2><p>都是学生在低价/免费打工</p><ul><li>纵向课题，为老板的帽子、前途打工。</li><li>横向课题，为老板的钱途打工，你获得几百补贴。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研帽子</title>
      <link href="/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E7%A7%91%E7%A0%94%E5%B8%BD%E5%AD%90/"/>
      <url>/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E7%A7%91%E7%A0%94%E5%B8%BD%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403280931551.png"alt="科研等级" /><figcaption aria-hidden="true">科研等级</figcaption></figure><p><strong>四青人才</strong></p><ol type="1"><li>优青：国家自然科学基金委设立的<strong>优秀青年科学基金项目</strong></li><li>青长：长江学者奖励计划中的<strong>青年长江学者</strong></li><li>青拔：万人计划中的<strong>青年选拔人才</strong></li><li>青千：千人计划中的<strong>青年千人计划</strong></li></ol><p><strong>杰青</strong></p><p>​杰青，全称是“<strong>国家杰出青年科学基金</strong>”，是国家自然科学基金委为了促进青年科学和技术人才的成长，鼓励海外学者回国工作，加速培养造就一批进入世界科技前沿的优秀学术带头人而特别设立的科学基金。</p><p><strong>长江</strong></p><p>​长江学者是指获得“<strong>长江学者奖励计划</strong>”的科研工作者。“长江学者奖励计划”是中华人民共和国教育部与香港李嘉诚基金会为提高中国高等学校学术地位，振兴中国高等教育，于1998年共同筹资设立的专项高层次人才计划，该计划包括实行<strong>特聘教授岗位制度</strong>和<strong>长江学者成就奖</strong>两项内容。</p><p>​“长江学者奖励计划”是国家重大人才工程的重要组成部分。长江学者奖励计划分为<strong>特聘教授</strong>和<strong>讲座教授</strong>项目，每年支持聘任150名特聘教授，50名讲座教授；特聘教授聘期5年，讲座教授聘期为3年。</p><p><strong>千人</strong></p><p>​“<strong>千人计划</strong>”，全称是“<strong>海外高层次人才引进计划</strong>”。从2008年开始，中央决定围绕国家发展战略目标，用5-10年的时间，在国家重点创新项目、重点学科和重点实验室和各种企业等，引进并重点支持一批海外高层次人才回国创新创业。“千人计划”分为创新型人才和创业型人才，前者是高等院校、研究机构引进的人才，后者是企业引进的人才。</p><p>​除此之外，中央还施行了“<strong>青年千人计划</strong>“，即“<strong>海外高层次人才引进计划青年项目</strong>”。与“千人计划”不同的是，“青千”主要是引进在国外获得博士学位或者进行过博后研究，愿意回国发展的青年人才。“千人计划”一般俗称“大千人”，而“青年千人”俗称“小千人”。</p><p>​“千人计划”主要面向国外的高层次人才，吸引他们回国创业。截至目前，“千人计划”已经分批引进6000余名高层次人才，成为创新型国家建设的一批重要生力军。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经验贴</title>
      <link href="/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://yirannn.com/beyond_tech/baoyan.html">计算机-末九Rank50%-入北计清深-北计直博]- yyi's Blog (yirannn.com)</a></p><p>6 罗英伟 直博 系统软件、计算机体系结构 lyw@pku.edu.cn</p><p>9 汪小林 直博 系统软件、计算机体系结构 wxl@pku.edu.cn</p><p>15 张杰 直博 存储系统和专用处理器 jiez@pku.edu.cn</p><p>16 张铭 直博 文本挖掘、知识图谱、图神经网络、计算机教育研究mzhang@net.pku.edu.cn</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机研究方向</title>
      <link href="/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A0%94%E7%A9%B6%E7%94%9F%E5%90%84%E4%B8%93%E4%B8%9A%E6%96%B9%E5%90%91%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91/"/>
      <url>/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A0%94%E7%A9%B6%E7%94%9F%E5%90%84%E4%B8%93%E4%B8%9A%E6%96%B9%E5%90%91%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AF%B9%E5%BA%94%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1id="计算机研究生各专业方向简介及对应就业方向">计算机研究生各专业方向简介及对应就业方向</h1><p>​计算机作为当下热门专业，其下有着多个不同的分支方向，不同的方向涉及不同的知识储备、思维模式及应用领域，每位有意于学习计算机的小可爱有必要了解各个方向的全貌，来找到最适合自己的领域。下面就让岛主来带大家详细了解一下。</p><h2 id="人工智能">人工智能</h2><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/0baf5e3132187594f17495426f4e66e5.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>简介</strong>：人工智能是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的科学，是数学、系统学、控制学、计算机科学、认知科学等学科交叉形成的综合性学科<br /><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/cae180d04354f6e20265c7d78340ee0b.png#pic_center"alt="在这里插入图片描述" /></p><p><strong>特点</strong>：当下最热门专业，与各领域都有交叉，相关会议众多，实验室和工业界实习机会多，对数学能力要求较高，常见的对口岗位是算法工程师，薪资较高</p><h2 id="软件工程">软件工程</h2><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/b21ceca322aa59df590e05b82800c1f3.png#pic_center"alt="在这里插入图片描述" /><strong>简介</strong>：设计、开发和测试操作系统级软件、编译器和网络分布式软件，用于医疗、工业、军事、通信、航空航天、商业、科学等常见计算应用<imgsrc="https://i-blog.csdnimg.cn/blog_migrate/578224f6a53b7ce3dd879a72791e44de.png#pic_center"alt="在这里插入图片描述" /><br /><strong>特点</strong>：软件工程相对CS其他专业来说偏向文科，概念性强，同时也偏工程化，以最终结果要开发一个完整产品为目的，研究以工程的概念、原理、技术和方法来开发与维护软件。入行门槛跨度大，薪酬跨度也大，常见岗位有软件运维工程师、软件测试工程师等</p><h2 id="图形学">图形学</h2><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/16d51489eaaf690ba81a5605df29aa43.png#pic_center"alt="在这里插入图片描述" /><br /><strong>简介</strong>：图形学是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法<br /><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/f755f191aeb6ff9161691d3a7575684b.png#pic_center"alt="在这里插入图片描述" /><br /><strong>特点</strong>：计算机图形学主要包含：建模、渲染、动画和人机交互，用途广泛，就业面广，对数学能力要求较高，同时因为任何一个CG的渲染的计算量都很大，图形学对算法的空间复杂度和时间复杂度的分析的要求很高，对硬件相关的认识的要求也很高</p><h2 id="信息安全">信息安全</h2><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/e6137ad85804871b5a2b60d030719169.png#pic_center"alt="在这里插入图片描述" /><br /><strong>简介</strong>：信息安全旨在培养能够在政府机关、企事业单位、金融、证券、通信等领域从事信息安全系统维护、网络安全系统管理与维护、网络安全管理与评估等工作，也可以在IT领域从事网络设备安装与调试、网络系统项目的分析与设计、网络服务配置与管理等操作能力的高素质技能型专门人才。<br /><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/8dc010ddabd41d61aa28d44761785685.png#pic_center"alt="在这里插入图片描述" /><br /><strong>特点</strong>：信息安全行业的就业需求以年均30%的速度递增。无论是职业前景、受重视程度、提升空间还是薪酬基数、薪酬增长预期等较其它行业都更为优越。常见的岗位有网络安全工程师、渗透测试工程师等。</p><h2 id="大数据">大数据</h2><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/3e520481e99fbb28b96e8ffd24ed6c13.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>简介</strong>：数据科学与大数据技术专业基于大数据时代巨大人才需求的背景下设立的新专业，旨在培养具有良好的科学素养和社会责任感与使命感，具有宽广的国际视野，具有从事数据科学与大数据相关的软硬件及网络的研究、设计、开发以及综合应用的高级工程技术人才。<br /><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/cb58bce994a0663b7deb0a1064b5dbea.png#pic_center"alt="在这里插入图片描述" /><br /><strong>特色</strong>：大数据专业主要从数据管理、系统开发、海量数据分析与挖掘三个层面设置相关课程与学习，目的是让学习者系统地掌握大数据应用中的各种典型问题的解决办法，包括实现和分析协同过滤算法、运行和学习分类算法、分布式Hadoop集群的搭建和基准测试、分布式Hbase集群的搭建和基准测试、实现一个基于、Mapreduce的并行算法、部署Hive并实现一个的数据操作等等，实际提升企业解决实际问题的能力。大数据专业和人工智能、物联网、信息安全等具有很强的联动性，需求广泛，薪资较高，常见的岗位有大数据系统架构师、大数据系统分析师、.数据挖掘工程师、大数据可视化工程师等</p><h5 id="六计算机体系结构">六、计算机体系结构</h5><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/f1e89c357340649e64868fe1db5079d8.png#pic_center"alt="在这里插入图片描述" /><br /><strong>简介</strong>：计算机体系结构是指根据属性和功能不同而划分的计算机理论组成部分及计算机基本工作原理、理论的总称。本专业培养具有坚实的计算机科学与技术基础理论、掌握计算机系统结构与系统软件有关理论、计算机应用技术方面的专门知识的人才<br /><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/755c7fe15342bd643081a6cffa9e6f39.png#pic_center"alt="在这里插入图片描述" /><br /><strong>特色</strong>：计算机体系结构是软硬件结合的方向，包括计算机组织和计算机实现技术、芯片级的微体系结构、网络级的网络计算体系结构等分支，详细讨论计算机系统结构定量、定性的分析方法、设计方法和研究方法。着力于研究计算机系统架构的优化以及在硬件、软件界面划分的权衡策略，建立完整的、系统的计算机软硬件整体概念。该专业理论性较强，适合科研与深造</p><h4 id="结语">结语</h4><p>以上就是计算机专业热门方向的综合概述，相信大家看完以后对计算机的具体分<br />支有了更加深入和全貌的了解，希望以上总结能打破可能存在的固有印象，构建<br />更加科学的计算机体系框架，助于大家从中找到自己的定位。可能还有一些较为<br />冷门的分支没有列出来，大家可以按照上述模式自己总结。不管怎样，兴趣是<br />最好的老师，希望大家能由此主动地深入了解自己的意向方向，在计算机的海洋<br />上掌舵远航！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2023/11/26/%5Bobject%20Object%5D/others/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/11/26/%5Bobject%20Object%5D/others/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><span id="more"></span><h1 id="markdown语法">Markdown语法</h1><p><strong>==参考视频：<ahref="https://www.bilibili.com/video/BV1hG411p7fX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">Markdown语法讲解</a>==</strong></p><h2 id="简要介绍"><a id="tag">😂 简要介绍</a></h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以<code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于<strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 <spanclass="math inline">\(\LaTeX\)</span>, 并不是最淳朴的那种"所见即所得".它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服,语法简单, 尤其在处理纯文本上有很大的优势.</p><p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用,不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用<strong>Markdown</strong> 语法. 如 <strong>Github</strong>(等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀(等一系列笔记平台).</p><h2 id="实际应用">📐 实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p><p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰,层次分明.</p><p>像我大一的时候就用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告,代码的 <code>README.md</code> ... 包括本教程文档.</p><h2 id="工具">🍴 工具</h2><p>Markdown 只是一种语法. 那么用来写 Markdown 的文本编辑器呢? 我推荐的是<strong>Typora</strong> 或者 <strong>VS Code</strong></p><h3 id="typora">Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将<code>.md</code> 导出成多种文件, 如 <code>.pdf</code>,<code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p><p>但是现在 Typora 已经发布正式版并且变为收费软件. 中文官网在此 <ahref="https://typoraio.cn/">Typora 官方中文站</a>.</p><p>我当然是推荐大家都用正版啦. 不过价格是永久版￥89,好在可以用在3台设备上. 如果和你的两位同学/舍友均摊一下, 每人就只要￥30,和一张游戏月卡差不多.</p><p>至于盗版以及破解方法<ahref="https://www.only4.work/blog/?id=379">在此随便找一种改注册表时间方法的</a><del>不介绍(还挺多的其实)</del>.</p><p><del>还有一种免费白嫖的方法就是安装测试版/Beta版.官网有历史版本的下载链接 <ahref="https://typoraio.cn/windows/dev_release.html">Typora历史版本下载页</a></del></p><p>白嫖Beta版已经寄了, 要么支持正版要么去学习一下破解方法吧(还是忍不住啦, 看上面的链接👆)</p><h3 id="vs-code">VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VSCode 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All inOne</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p><h3 id="其他">其他</h3><p>大部分IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法,在此不多赘述.</p><p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora所包含的扩展语法.</p><h2 id="基础教程">🍭 基础教程</h2><p>当有多种标记方法时我会倾向其中一种.</p><p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的VS Code <strong>本地生效</strong>,在大多数平台上<strong>并不认可</strong>.</p><h3 id="写-markdown-的第零步">写 Markdown 的第零步</h3><p>我们写文本的时候大多写的是中文,可是输入法在输中文时使用的标点为全角标点, 如<code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的,也是无法转义的.</p><p>我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如<code>,.?!()[]:;""</code>. 且每个半角标点在文本使用时加上后置空格,符合英文标点的书写规范, 也更加美观.</p><p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> +<code>.(这是个句号)</code>, 切换标点的全角与半角.这样即可中文输入+半角标点.</p><h3 id="标题-数个-空格-前置">标题 [数个 "#" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>标题会在目录与大纲分级显示, 可以跳转.</p><p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为<code>#标题</code>, 应为 <code># 标题</code>.</p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.</p><h3 id="强调-用-或-__-包围">强调 [用 "**" 或 "__" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**欢迎报考南京大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考南京大学!__</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>.</p><p>E.G.</p><p><strong>欢迎报考南京大学!</strong></p><h3 id="斜体-用-或-_-包围">斜体 [用 "*" 或 "_" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*欢迎大佬来浇浇我各种知识* (我喜欢用这种)</span><br><span class="line">_欢迎大佬来浇浇我各种知识_</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>.</p><p>E.G.</p><p><em>欢迎大佬来浇浇我各种知识</em></p><p>(P.S. <strong><em>斜体并强调</em></strong> [用 "***" 或 "___"包围])</p><h3 id="删除线-用-包围">删除线 [用 "~~" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我宣布个事儿, 我是Sabiyary!~~</span><br></pre></td></tr></table></figure><p>E.G.</p><p><del>我宣布个事儿, 我是Sabiyary!</del></p><h3 id="高亮-用-包围">*高亮 [用 "==" 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==我喜欢黄色, 也喜欢绿色==</span><br></pre></td></tr></table></figure><p>E.G.</p><p>==我喜欢黄色, 也喜欢绿色==</p><h3 id="代码-用-包围">代码 [用 "`" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo rm -rf /*`</span><br></pre></td></tr></table></figure><p>E.G.</p><p><code>sudo rm -rf /*</code> (没事别乱敲这个! )</p><p><del>"请输入管理员密码: (闪烁的光标)"</del></p><h3 id="代码块-按三个-并敲回车">代码块 [按三个 "`" 并敲回车]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment">// 这里就可以开始输入你要的代码了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    print（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    retrun O;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">``` // (这三个&quot;</span>`<span class="string">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></span><br></pre></td></tr></table></figure><p>(我之前都是用这个来展示各种语法的, 应该不用举例了吧)</p><p>要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项.</p><p>代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后,<code>```</code> 会变为 <code>````</code> + <code>对应语言</code>.</p><h3 id="引用-空格-前置">引用 ["&gt;" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 24岁, 是学生.</span><br><span class="line">&gt; &gt; 学生特有的无处不在(恼)</span><br></pre></td></tr></table></figure><p>引用是可以嵌套的!</p><p>E.G.</p><blockquote><p>24岁, 是学生.</p><blockquote><p>学生特有的无处不在(恼)</p></blockquote></blockquote><h3 id="无序列表---或-空格-前置">无序列表 ["-" 或 "+" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一颗是枣树 (我喜欢用这种)</span><br><span class="line">+ 另一颗还是枣树</span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure><p>三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号,敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><ul><li>一颗是枣树</li><li>另一颗还是枣树</li></ul><h3 id="有序列表-数字-.-空格-前置">有序列表 [数字 + "." + 空格前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我来这里就为了三件事:</span><br><span class="line">1. 公平</span><br><span class="line">2. 公平</span><br><span class="line">3. 还是tm的公平!</span><br></pre></td></tr></table></figure><p>敲回车会自动补全, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><p>我来这里就为了三件事:</p><ol type="1"><li><p>公平</p></li><li><p>公平</p></li><li><p>还是tm的公平!</p></li></ol><h3 id="上标-用-包围">*上标 [用 "^" 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure><p>E.G.</p><p>C语言中 <code>int</code> 的上限是 2<sup>31</sup> - 1 = 2147483647</p><h3 id="下标-用-包围">*下标 [用 "~" 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure><p>E.G.</p><p>H<sub>2</sub>O 是剧毒的!</p><h3 id="注释-后置">*注释 ["[^]" 后置]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure><p>需要在文末写上注释对应的内容</p><p>E.G.</p><blockquote><p>今日我们相聚于此, 是为了学习 Markdown 的使用,它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励!<a href="#fn1"class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></blockquote><h3 id="链接-常用-分别包围文本与链接">链接 [常用 "[ ]" + "( )"分别包围文本与链接]</h3><p><strong>(注意: 文内跳转为扩展用法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)</span><br><span class="line">[基础教程: 12. 下标](#12. 下标 [用 &quot;~&quot; 包围])</span><br></pre></td></tr></table></figure><p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并<code>单击鼠标左键</code> 即可跳转.</p><p>E.G.</p><p><a href="https://github.com/Sakiyary">来看看我贫瘠的仓库罢</a></p><p>[基础教程: 12. 下标](#12. 下标 [用 "~" 包围])</p><h3 id="任务列表---空格-前置">任务列表 ["- [ ]" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TodoList:</span><br><span class="line">- [ ] 刷B站</span><br><span class="line">- [ ] 写代码</span><br><span class="line">- [x] 起床</span><br></pre></td></tr></table></figure><p>用 <code>x</code> 代替 <code>[ ]</code> 中的空格来勾选任务列表. 在Typora 中可以直接用鼠标左键单击勾选框.</p><p>E.G. TodoList:</p><ul class="task-list"><li><label><input type="checkbox" />刷B站</label></li><li><label><input type="checkbox" />写代码</label></li><li><label><input type="checkbox" checked="" />起床</label></li></ul><h3 id="表格-用-绘制表格边框">表格 [用 "|" 绘制表格边框]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 学号 | 姓名  | 年龄 |</span><br><span class="line">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class="line">|114514|田所|24|</span><br><span class="line">|1919810|浩三|25|</span><br></pre></td></tr></table></figure><p>第一行为表头, 并由第二行分割线决定对齐方式与长度,第三行及之后即表格数据</p><p>E.G.</p><table><thead><tr class="header"><th style="text-align: left;">学号</th><th style="text-align: center;">姓名</th><th style="text-align: right;">年龄</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">114514</td><td style="text-align: center;">田所</td><td style="text-align: right;">24</td></tr><tr class="even"><td style="text-align: left;">1919810</td><td style="text-align: center;">浩三</td><td style="text-align: right;">25</td></tr></tbody></table><h3 id="图片-直接拖进来或者复制粘贴">图片 [直接拖进来或者复制粘贴]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片](图片的位置)</span><br></pre></td></tr></table></figure><p>我还是会选择拖进来或者复制粘贴啦~ 在 Typora的设置里也可以改图片的储存方式.</p><h3 id="分割线-按三个-或---或-_-并敲回车">分割线 [按三个 "*" 或 "-" 或"_" 并敲回车]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">--- (我喜欢用这种)</span><br><span class="line">___</span><br><span class="line">// (其实按三个及以上都可以)</span><br></pre></td></tr></table></figure><p>由于 <code>*</code> 与 <code>_</code> 均会自动补全, 所以我觉得<code>-</code> 最为方便.</p><p>E.G.</p><hr /><hr /><hr /><h3 id="emoji表情-前置">Emoji表情 [":" 前置]</h3><p><strong>(注意: 英文输入为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sweat_smile: </span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br></pre></td></tr></table></figure><p>这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji的英文名.</p><p>E.G.</p><p>:sweat_smile: :drooling_face: :clown_face:</p><p>对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来,这是直接<strong>硬编码</strong>的 (<del>刻进DNA里</del>)</p><p>E.G.</p><p>😅🤤🤡</p><p>用好这个功能可以让你的文本非常的可爱! <del>太抽象了</del></p><p>这里分享一个可以复制<ahref="https://emojipedia.org/apple/">全Emoji的网站</a>, 非常好用!我之前的C语言大作业也是从这里下载的资源!</p><h2 id="进阶教程">🔥 进阶教程</h2><h3 id="目录-自动生成">目录 [自动生成]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure><p>若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code的<code>命令面板</code> (即 <ahref="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">VSCode Command Palette</a>) 输入 <code>Create Table of Contents</code>自动生成目录, 且可在扩展设置中细调目录参数.</p><h3 id="内联-html-代码-用-包围">内联 HTML 代码 [用 "&lt;&gt; &lt;/&gt;"包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">  &lt;font style=&quot;color:red&quot;&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>只要你会写, 你完全可以把 Markdown 当作 <strong>HTML</strong>来写.</p><p>同时, <code>.md</code> 文件可以直接导出成一个网页.</p><p>下划线可以选中想要下划的文字按下 <code>Ctrl</code> +<code>U</code>.</p><p>E.G.</p><div style="text-align:center"><p><font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font></p></div><center>简单的文字居中也可以这样</center><p><u>我差点忘了还有下划线这东西...</u></p><h3 id="内联-latex-公式-用-包围">内联 <spanclass="math inline">\(\LaTeX\)</span> 公式 [用 "$" 包围]</h3><p><strong>(注意: 部分编译器会不识别部分符号)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class="line"></span><br><span class="line">$a^n+b^n=c^n$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">%\usepackage&#123;unicode-math&#125;</span><br><span class="line">\displaystyle \ointctrclockwise\mathcal&#123;D&#125;[x(t)]</span><br><span class="line">\sqrt&#123;\frac&#123;\displaystyle3\uppi^2-\sum_&#123;q=0&#125;^&#123;\infty&#125;(z+\hat L)^&#123;q&#125;</span><br><span class="line">\exp(\symrm&#123;i&#125;q^2 \hbar x)&#125;&#123;\displaystyle (\symsfup&#123;Tr&#125;\symbfcal&#123;A&#125;)</span><br><span class="line">\left(\symbf\Lambda_&#123;j_1j_2&#125;^&#123;i_1i_2&#125;\Gamma_&#123;i_1i_2&#125;^&#123;j_1j_2&#125;</span><br><span class="line">\hookrightarrow\vec D\cdot \symbf P \right)&#125;&#125;</span><br><span class="line">=\underbrace&#123;\widetilde&#123;\left\langle \frac&#123;\notin \emptyset&#125;</span><br><span class="line">&#123;\varpi\alpha_&#123;k\uparrow&#125;&#125;\middle\vert</span><br><span class="line">\frac&#123;\partial_\mu T_&#123;\mu\nu&#125;&#125;&#123;2&#125;\right\rangle&#125;&#125;_&#123;\mathrm&#123;K&#125;_3</span><br><span class="line">\mathrm&#123;Fe&#125;(\mathrm&#123;CN&#125;)_6&#125; ,\forall z \in \mathbb&#123;R&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>用 <code>$</code> 包围为单条公式, 按下两个 <code>$</code>并敲回车即生成公式块.</p><p>E.G.</p><p><span class="math inline">\(\LaTeX\)</span> 是最好用的论文排版语言!不信你看!</p><p><span class="math inline">\(a^n+b^n=c^n\)</span></p><p><span class="math display">\[%\usepackage{unicode-math}\displaystyle \ointctrclockwise\mathcal{D}[x(t)]\sqrt{\frac{\displaystyle3\uppi^2-\sum_{q=0}^{\infty}(z+\hat L)^{q}\exp(\symrm{i}q^2 \hbar x)}{\displaystyle (\symsfup{Tr}\symbfcal{A})\left(\symbf\Lambda_{j_1j_2}^{i_1i_2}\Gamma_{i_1i_2}^{j_1j_2}\hookrightarrow\vec D\cdot \symbf P \right)}}=\underbrace{\widetilde{\left\langle \frac{\notin \emptyset}{\varpi\alpha_{k\uparrow}}\middle\vert\frac{\partial_\mu T_{\mu\nu}}{2}\right\rangle}}_{\mathrm{K}_3\mathrm{Fe}(\mathrm{CN})_6} ,\forall z \in \mathbb{R}\]</span></p><h3 id="网络图床">*网络图床</h3><p>(这是学长给我的网络图床教程, 我并未实践过...)</p><p>分享一个 Typora 搭配腾讯云COS/阿里云OSS图床的<ahref="https://blog.csdn.net/guo_ridgepole/article/details/108257277">例子</a>.新用户免费试用6个月, 另外还可选择七牛云或者路过图床.</p><h3 id="typora-的常用快捷键">*Typora 的常用快捷键</h3><table><colgroup><col style="width: 26%" /><col style="width: 21%" /><col style="width: 26%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th style="text-align: center;">按键</th><th style="text-align: center;">效果</th><th style="text-align: center;">按键</th><th style="text-align: center;">效果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>D</code></td><td style="text-align: center;">选中当前词</td><td style="text-align: center;"><code>Ctrl</code> + <code>L</code></td><td style="text-align: center;">选中当前句/行</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>E</code></td><td style="text-align: center;">选中当前区块</td><td style="text-align: center;"><code>Ctrl</code> + <code>F</code></td><td style="text-align: center;">搜索当前选中</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>B</code></td><td style="text-align: center;">加粗当前选中</td><td style="text-align: center;"><code>Ctrl</code> + <code>H</code></td><td style="text-align: center;">替换当前选中</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>I</code></td><td style="text-align: center;">倾斜当前选中</td><td style="text-align: center;"><code>Ctrl</code> + <code>U</code></td><td style="text-align: center;">下划当前选中</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>K</code></td><td style="text-align: center;">将当前选中生成链接</td><td style="text-align: center;"><code>Ctrl</code> + <code>J</code></td><td style="text-align: center;">滚动屏幕将选中滚至顶部</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>W</code></td><td style="text-align: center;">关闭当前窗口</td><td style="text-align: center;"><code>Ctrl</code> + <code>N</code></td><td style="text-align: center;">打开新窗口</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>O</code></td><td style="text-align: center;">打开文件</td><td style="text-align: center;"><code>Ctrl</code> + <code>P</code></td><td style="text-align: center;">搜索文件并打开</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> +<code>回车</code></td><td style="text-align: center;">表格下方插入行</td><td style="text-align: center;"><code>Ctrl</code> + <code>,</code></td><td style="text-align: center;">打开偏好设置</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>.</code></td><td style="text-align: center;">切换全角/半角标点</td><td style="text-align: center;"><code>Ctrl</code> + <code>/</code></td><td style="text-align: center;">切换正常/源代码视图</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>Shift</code> +<code>-</code></td><td style="text-align: center;">缩小视图缩放</td><td style="text-align: center;"><code>Ctrl</code> + <code>Shift</code> +<code>+</code></td><td style="text-align: center;">放大视图缩放</td></tr></tbody></table><p>还有一些不常用的/三键的快捷键不在此列出.</p><h3 id="typora-的主题样式与检查元素">*Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的Markdown, 故Typora的主题样式本质就是 CSS 文件.</p><p>可以下载各种好看的主题给 Typora换上, 同时也可以自己调整对应的 CSS文件, 或者自己手搓.</p><p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开<code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML来编辑.</p><h3 id="页面跳转">页面跳转</h3><h4 id="同一文档内跳转">同一文档内跳转</h4><ul><li><p>跳转到的位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;tag&quot;&gt;......&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>原位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...](#tag)</span><br></pre></td></tr></table></figure></li><li><p>举例：跳转到本文档的第一小节</p><p><a href="#tag">同一文档内跳转</a></p></li></ul><h4 id="不同文档跳转">不同文档跳转</h4><ul><li><p>跳转到的位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;tag&quot;&gt;......&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>原位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...](路径#tag)</span><br></pre></td></tr></table></figure></li><li><p>举例：跳转到<code>D:\downloads\hexo\blog\source\_posts\数据结构\【图】.md</code>的例题部分</p><p><ahref="D:\downloads\hexo\blog\source_posts\数据结构【图】.md#liti">不同文档跳转</a></p></li></ul><h3 id="html语法">html语法</h3><ul><li><p>要想在typora直接使html语法生效，就应该直接将html代码粘贴到文档里，而不应该以html代码块的形式插入</p></li><li><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072245307.png"alt="image-20240307224553215" /><figcaption aria-hidden="true">image-20240307224553215</figcaption></figure></li><li><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072247006.png"alt="image-20240307224713725" /><figcaption aria-hidden="true">image-20240307224713725</figcaption></figure></li></ul><h3 id="插入本地视频">插入本地视频</h3><p>html语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;&quot;</span> <span class="attr">preload</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">id</span>=<span class="string">&quot;mp4&quot;</span> <span class="attr">src</span>=<span class="string">&quot;C:\Users\Lenovo\Videos\青年\1.mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的mp4视频文件可以是本地文件路径如："C:\1.mp4"，也可以是网页mp4文件路径"https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072217736.mp4"</p></blockquote><h3 id="插入b站视频">插入B站视频</h3><p>html语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">allowfullscreen</span>=<span class="string">&quot;allowfullscreen&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sandbox</span>=<span class="string">&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的src应该从 B站视频下方选择<code>分享 -&gt; 嵌入代码</code>，然后从中取出src部分即可完成。其余部分保持不变</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072249425.png" alt="image-20240307224904283" style="zoom: 25%;" /></p><h3 id="图片增加标题">图片增加标题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;!--块级封装--&gt;</span><br><span class="line">    &lt;center&gt;&lt;!--将图片和文字居中--&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;图片路径放这里&quot;</span></span><br><span class="line">         style=<span class="string">&quot;zoom:这里写图片的缩放百分比&quot;</span>/&gt;</span><br><span class="line">    &lt;br&gt;&lt;!--换行--&gt;</span><br><span class="line">    这里是图片的标题&lt;!--标题--&gt;</span><br><span class="line">    &lt;/center&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922927.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图1 横向联邦学习示例，横向联邦使训练样本量增大    &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="总结">💯 总结</h2><p>至此, <strong>Markdown + Typora / VSCode</strong>的手册教程也告一段落.</p><p>不知你看完这么长的教程/手册, 是否能体会到 Markdown的精妙简洁之处呢?</p><p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown之后对于理解 HTML 也有帮助, 对于用 <spanclass="math inline">\(\LaTeX\)</span> 来写论文也有帮助.标记语言正是为了摆脱 Word 那种虽然"所见即所得", 但又过于花哨浮华,很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的"所写即所得"时,你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>沃兹·基·硕德 改编自「公鸡」普契涅拉.<a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex公式</title>
      <link href="/2023/11/26/%5Bobject%20Object%5D/others/LaTeX%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/11/26/%5Bobject%20Object%5D/others/LaTeX%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="希腊字母">希腊字母</h2><p><span class="math display">\[\delta,\lambda\\\Delta,\Lambda\\\Alpha\Beta\\\phi,\varphi\\\epsilon,\varepsilon\\π\]</span></p><h2 id="上下标">上下标</h2><p><span class="math display">\[a^2,a_1\\x^{y+z},p_{ij},p_ij\\x_i,x_{\text i}\\\text{A B},\rm{A B}\\\text A B,\rm A B\\{\rm A} B\\\text{e},\text{i}\]</span></p><span id="more"></span><h2 id="分式与根式">分式与根式</h2><p><span class="math display">\[\frac{1}{2},\frac 1 2,\\\frac 1 {x+y}\\\frac {\dfrac 1 x + 1}{y + 1}\]</span></p><p><span class="math display">\[\sqrt 2,\sqrt{x+y},\sqrt[3]x\]</span></p><h2 id="普通运算符">普通运算符</h2><p><span class="math display">\[+-\\\times,\cdot,\div\\\pm,\mp\\&gt;&lt;,\ge,\le,\gg,\ll,\ne,\approx,\equiv\\\cap,\cup,\in,\notin,\subseteq,\subsetneqq,\varnothing\\\forall,\exists,\nexists\\\because,\therefore\\\mathbb R,\R,\Q,\N,\Z_+\\\mathcal F,\mathscr F\]</span></p><p><span class="math display">\[\cdots,\vdots,\ddots\]</span></p><p><span class="math display">\[\infty,\partial,∂,\nabla,\propto,\degree\]</span></p><p><span class="math display">\[\sin x,\sec x,\cosh x\\\log_2 x, \ln x,\lg x\\\lim\limits_{x \to 0} \frac { x}{\sin x}\\\max x\]</span></p><p><span class="math display">\[\text{MSE}(x)\]</span></p><h2 id="大型运算符">大型运算符</h2><p><span class="math display">\[\sum,\prod\\\sum_i,\sum_{i=0}^N\\\frac{\sum\limits_{i=1}^n x_i}{\prod\limits_{i=1}^n x_i}\]</span></p><p><span class="math display">\[\int,\iint,\iiint,\oint,\oiint\\\int_{-\infty}^0 f(x)\,\text d x\]</span></p><p><span class="math display">\[a\, a\\a\ a\\a\quad a\\a\qquad a\]</span></p><h2 id="标注符号">标注符号</h2><p><span class="math display">\[\vec x,\overrightarrow {AB}\\\bar x,\overline{AB}\]</span></p><h2 id="箭头">箭头</h2><p><span class="math display">\[\leftarrow,\Rightarrow,\Leftrightarrow,\longleftarrow\]</span></p><h2 id="括号与定界符">括号与定界符</h2><p><span class="math display">\[([])\{ \}\\\lceil,\rceil,\lfloor,\rfloor,||\\\left(0,\frac 1 a\right]\\\left.\frac {∂f}{∂x}\right|_{x=0}\]</span></p><h2 id="多行公式">多行公式</h2><p>$$ <span class="math display">\[\begin{align}a&amp;=b+c+d\\&amp;=e+f\end{align}\]</span> $$</p><h2 id="大括号">大括号</h2><p>$$ f(x)=</p><span class="math display">\[\begin{cases}\sin x, &amp; -π\le x \le π\\0,&amp; \text{其他}\end{cases}\]</span><p>$$</p><h2 id="矩阵">矩阵</h2>$$<span class="math display">\[\begin{matrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{matrix}\]</span><p>$$</p>$$<span class="math display">\[\begin{bmatrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{bmatrix}\]</span><span class="math display">\[\begin{pmatrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{pmatrix}\]</span><span class="math display">\[\begin{vmatrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{vmatrix}\]</span><p>$$</p><p><span class="math display">\[\bf A,\bf B^{\rm T}\]</span></p><h2 id="实战演练">实战演练</h2><p><span class="math display">\[f(x) = \frac 1 {\sqrt{2\pi} \sigma} {\rm e} ^ {-\frac{(x-\mu)^2}{2\sigma ^ 2}}\\f(x) = \frac 1 {\sqrt{2\pi} \sigma} \exp \left[ {-\frac{(x-\mu)^2}{2\sigma ^ 2}}\right]\]</span></p><p><span class="math display">\[\lim\limits_{N\to \infty} P \left\{ \left| \frac {I\left( \alpha_i\right)}{N} - H(s) \right| &lt; \varepsilon  \right\} = 1\]</span></p><p>$$ x(n) = {2} _{-π} ^ π X( {} ^</p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scanf返回值</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/C++/scanf%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/C++/scanf%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p># scanf返回值</p><h2 id="返回值">返回值</h2><p><code>scanf()</code>的返回值是：输入的数据与<strong>格式字符串</strong>中匹配次数</p><blockquote><ul><li><p>简单来说，就是返回已成功赋值的数据项数；出错时则返回 <spanclass="math inline">\(EOF\)</span></p></li><li><p>文件结束符 EOF(End Of File) 是一个预定义的常量，等于 <spanclass="math inline">\(-1\)</span></p></li></ul></blockquote><span id="more"></span><h2 id="举例">举例</h2><p>例如，可以通过以下程序<strong>证实</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*证实函数scanf()的返回值*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b; </span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取scanf函数的返回值*/</span></span><br><span class="line">    input = <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input = %d&quot;</span>,input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此例中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若输入：<span class="number">1</span> <span class="number">2</span>↙</span><br><span class="line"></span><br><span class="line">输出：input = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">说明：成功输入了两个整数.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若输入：<span class="number">1</span> a↙</span><br><span class="line"></span><br><span class="line">输出：input = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">说明：仅仅匹配了变量a，而整型变量b无法得到字符‘a’，依旧是一个未赋值前不确定的值.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若输入：a b↙</span><br><span class="line"></span><br><span class="line">输出：input = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">说明：均未成功读入.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">若输入：^Z ^Z↙</span><br><span class="line"></span><br><span class="line">会得到：input = -1</span><br><span class="line"></span><br><span class="line">说明：输入出错，返回值为-1.</span><br></pre></td></tr></table></figure><blockquote><p>（注：ctrl+z输入代表输入文件结束符EOF）</p></blockquote><hr /><h2 id="应用">应用</h2><p>例如，在ACM中，一道入门题“A+B for Input-Output Practice (I)”中可以用到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*计算a + b*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="comment">/*当输入不非法的时候不断读取a,b*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a, &amp;b) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a+b);</span><br><span class="line">    &#125;       </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>另做参考：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">int</span> input = <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">while</span>(input != <span class="number">2</span>)<span class="comment">/*直到两整型变量a,b同时读入整数时才跳出循环*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);<span class="comment">/*清除缓冲区*/</span></span><br><span class="line">        input = <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d&quot;</span>,a,b,a + b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>​ 总之，我们可以通过运用函数scanf()的返回值的意义（即“所输入的数据与格式字符串中匹配次数”），来把控我们的输入格式的正确性.</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sscanf&amp;&amp;sprintf</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/C++/sscanf&amp;&amp;ssprintf/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/C++/sscanf&amp;&amp;ssprintf/</url>
      
        <content type="html"><![CDATA[<h1 id="sscanfsprintf">sscanf&amp;&amp;sprintf</h1><h2 id="前言">前言</h2><p><code>sscanf</code>和<code>sprintf</code>在处理<ahref="https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020">字符串</a>问题上很有用！（<code>sscanf</code>和<code>sprintf</code>可以从字面意思上分别理解为string+scanf和string+printf）</p><h2 id="头文件">头文件</h2><ol type="1"><li><code>C++</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><code>C</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="正文">正文</h2><p>简单举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sscanf与sprintf </span></span><br><span class="line"><span class="comment">sscanf(str,&quot;%d&quot;,&amp;n) 其实就是把字符串str的内容以&quot;%d&quot;的格式写入到int::n中（从左到右）</span></span><br><span class="line"><span class="comment">同理 sprintf(str,&quot;%d&quot;,n)就是把int::n以&quot;%d&quot;的格式写入到字符串str （从右到左） </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;666&quot;</span>;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line"><span class="built_in">sprintf</span>(str1,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str1); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述输出结果为</p><blockquote><p>666 666</p></blockquote><p>处理上述例子，还可以使用较为复杂的格式，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="type">double</span> date;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>],str2[<span class="number">100</span>]=<span class="string">&quot;2020:7.2:go!&quot;</span>,str3[<span class="number">100</span>]=<span class="string">&quot;woo~&quot;</span>; </span><br><span class="line"><span class="built_in">sscanf</span>(str2,<span class="string">&quot;%d:%lf:%s&quot;</span>,&amp;year,&amp;date,str1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;========sscanf========\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;year=%d,date=%.1f,str1=%s\n&quot;</span>,year,date,str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;========sprintf========\n&quot;</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(str1,<span class="string">&quot;%d:%.1f:%s&quot;</span>,year,date,str3); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下图所示： <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311111729191.png"alt="在这里插入图片描述" /></p><h2 id="应用">应用</h2><blockquote><p><code>sscanf</code>和<code>sprintf</code>应用如下：（以下例题为蓝桥杯模拟题）一般都是使用sprinf将整型数据写入到字符串数组，再将字符串数组转为<code>string</code>，从而使用<code>string</code>的方法函数</p></blockquote><h3 id="例一">例一：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在1至2019中，有多少个数的数位中包含数字9？</span></span><br><span class="line"><span class="comment">注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算时只是算一个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2019</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;<span class="comment">//char数组转string</span></span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">find</span>(<span class="string">&#x27;9&#x27;</span>) != string::npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二">例二：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。</span><br><span class="line">给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？</span><br><span class="line">*/</span><br><span class="line">char str[1000001];</span><br><span class="line">bool check(string num)&#123;</span><br><span class="line">int len=num.size();</span><br><span class="line">for(int i=0;i&lt;len-1;i++)&#123;</span><br><span class="line">if(num[i]&gt;num[i+1])return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125; </span><br><span class="line">//整型数转字符串 </span><br><span class="line">string toStr(int i)&#123;</span><br><span class="line">sprintf(str,&quot;%d&quot;,i);</span><br><span class="line">string num(str);</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,count=0;</span><br><span class="line">string num;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">num=toStr(i);</span><br><span class="line">if(check(num))count++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码表</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/C++/ASCII%E7%A0%81%E8%A1%A8/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/C++/ASCII%E7%A0%81%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ascii码表">ASCII码表</h1><h2 id="基本zifu">基本zi'fu</h2><table><colgroup><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 13%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">NUL</td><td style="text-align: center;">32</td><td style="text-align: center;">(space)</td><td style="text-align: center;">64</td><td style="text-align: center;">@</td><td style="text-align: center;">96</td><td style="text-align: center;">、</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">SOH</td><td style="text-align: center;">33</td><td style="text-align: center;">！</td><td style="text-align: center;">65</td><td style="text-align: center;">A</td><td style="text-align: center;">97</td><td style="text-align: center;">a</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">STX</td><td style="text-align: center;">34</td><td style="text-align: center;">”</td><td style="text-align: center;">66</td><td style="text-align: center;">B</td><td style="text-align: center;">98</td><td style="text-align: center;">b</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">ETX</td><td style="text-align: center;">35</td><td style="text-align: center;">#</td><td style="text-align: center;">67</td><td style="text-align: center;">C</td><td style="text-align: center;">99</td><td style="text-align: center;">c</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">EOT</td><td style="text-align: center;">36</td><td style="text-align: center;">$</td><td style="text-align: center;">68</td><td style="text-align: center;">D</td><td style="text-align: center;">100</td><td style="text-align: center;">d</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">ENQ</td><td style="text-align: center;">37</td><td style="text-align: center;">%</td><td style="text-align: center;">69</td><td style="text-align: center;">E</td><td style="text-align: center;">101</td><td style="text-align: center;">e</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">ACK</td><td style="text-align: center;">38</td><td style="text-align: center;">&amp;</td><td style="text-align: center;">70</td><td style="text-align: center;">F</td><td style="text-align: center;">102</td><td style="text-align: center;">f</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">BEL</td><td style="text-align: center;">39</td><td style="text-align: center;">'</td><td style="text-align: center;">71</td><td style="text-align: center;">G</td><td style="text-align: center;">103</td><td style="text-align: center;">g</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">BS</td><td style="text-align: center;">40</td><td style="text-align: center;">(</td><td style="text-align: center;">72</td><td style="text-align: center;">H</td><td style="text-align: center;">104</td><td style="text-align: center;">h</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">HT</td><td style="text-align: center;">41</td><td style="text-align: center;">)</td><td style="text-align: center;">73</td><td style="text-align: center;">I</td><td style="text-align: center;">105</td><td style="text-align: center;">i</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">LF</td><td style="text-align: center;">42</td><td style="text-align: center;">*</td><td style="text-align: center;">74</td><td style="text-align: center;">J</td><td style="text-align: center;">106</td><td style="text-align: center;">j</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">VT</td><td style="text-align: center;">43</td><td style="text-align: center;">+</td><td style="text-align: center;">75</td><td style="text-align: center;">K</td><td style="text-align: center;">107</td><td style="text-align: center;">k</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;">FF</td><td style="text-align: center;">44</td><td style="text-align: center;">,</td><td style="text-align: center;">76</td><td style="text-align: center;">L</td><td style="text-align: center;">108</td><td style="text-align: center;">l</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;">CR</td><td style="text-align: center;">45</td><td style="text-align: center;">-</td><td style="text-align: center;">77</td><td style="text-align: center;">M</td><td style="text-align: center;">109</td><td style="text-align: center;">m</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;">SO</td><td style="text-align: center;">46</td><td style="text-align: center;">.</td><td style="text-align: center;">78</td><td style="text-align: center;">N</td><td style="text-align: center;">110</td><td style="text-align: center;">n</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;">SI</td><td style="text-align: center;">47</td><td style="text-align: center;">/</td><td style="text-align: center;">79</td><td style="text-align: center;">O</td><td style="text-align: center;">111</td><td style="text-align: center;">o</td></tr><tr class="odd"><td style="text-align: center;">16</td><td style="text-align: center;">DLE</td><td style="text-align: center;">48</td><td style="text-align: center;">0</td><td style="text-align: center;">80</td><td style="text-align: center;">P</td><td style="text-align: center;">112</td><td style="text-align: center;">p</td></tr><tr class="even"><td style="text-align: center;">17</td><td style="text-align: center;">DCI</td><td style="text-align: center;">49</td><td style="text-align: center;">1</td><td style="text-align: center;">81</td><td style="text-align: center;">Q</td><td style="text-align: center;">113</td><td style="text-align: center;">q</td></tr><tr class="odd"><td style="text-align: center;">18</td><td style="text-align: center;">DC2</td><td style="text-align: center;">50</td><td style="text-align: center;">2</td><td style="text-align: center;">82</td><td style="text-align: center;">R</td><td style="text-align: center;">114</td><td style="text-align: center;">r</td></tr><tr class="even"><td style="text-align: center;">19</td><td style="text-align: center;">DC3</td><td style="text-align: center;">51</td><td style="text-align: center;">3</td><td style="text-align: center;">83</td><td style="text-align: center;">X</td><td style="text-align: center;">115</td><td style="text-align: center;">s</td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;">DC4</td><td style="text-align: center;">52</td><td style="text-align: center;">4</td><td style="text-align: center;">84</td><td style="text-align: center;">T</td><td style="text-align: center;">116</td><td style="text-align: center;">t</td></tr><tr class="even"><td style="text-align: center;">21</td><td style="text-align: center;">NAK</td><td style="text-align: center;">53</td><td style="text-align: center;">5</td><td style="text-align: center;">85</td><td style="text-align: center;">U</td><td style="text-align: center;">117</td><td style="text-align: center;">u</td></tr><tr class="odd"><td style="text-align: center;">22</td><td style="text-align: center;">SYN</td><td style="text-align: center;">54</td><td style="text-align: center;">6</td><td style="text-align: center;">86</td><td style="text-align: center;">V</td><td style="text-align: center;">118</td><td style="text-align: center;">v</td></tr><tr class="even"><td style="text-align: center;">23</td><td style="text-align: center;">TB</td><td style="text-align: center;">55</td><td style="text-align: center;">7</td><td style="text-align: center;">87</td><td style="text-align: center;">W</td><td style="text-align: center;">119</td><td style="text-align: center;">w</td></tr><tr class="odd"><td style="text-align: center;">24</td><td style="text-align: center;">CAN</td><td style="text-align: center;">56</td><td style="text-align: center;">8</td><td style="text-align: center;">88</td><td style="text-align: center;">X</td><td style="text-align: center;">120</td><td style="text-align: center;">x</td></tr><tr class="even"><td style="text-align: center;">25</td><td style="text-align: center;">EM</td><td style="text-align: center;">57</td><td style="text-align: center;">9</td><td style="text-align: center;">89</td><td style="text-align: center;">Y</td><td style="text-align: center;">121</td><td style="text-align: center;">y</td></tr><tr class="odd"><td style="text-align: center;">26</td><td style="text-align: center;">SUB</td><td style="text-align: center;">58</td><td style="text-align: center;">:</td><td style="text-align: center;">90</td><td style="text-align: center;">Z</td><td style="text-align: center;">122</td><td style="text-align: center;">z</td></tr><tr class="even"><td style="text-align: center;">27</td><td style="text-align: center;">ESC</td><td style="text-align: center;">59</td><td style="text-align: center;">;</td><td style="text-align: center;">91</td><td style="text-align: center;">[</td><td style="text-align: center;">123</td><td style="text-align: center;">{</td></tr><tr class="odd"><td style="text-align: center;">28</td><td style="text-align: center;">FS</td><td style="text-align: center;">60</td><td style="text-align: center;">&lt;</td><td style="text-align: center;">92</td><td style="text-align: center;">\</td><td style="text-align: center;">124</td><td style="text-align: center;">|</td></tr><tr class="even"><td style="text-align: center;">29</td><td style="text-align: center;">GS</td><td style="text-align: center;">61</td><td style="text-align: center;">=</td><td style="text-align: center;">93</td><td style="text-align: center;">]</td><td style="text-align: center;">125</td><td style="text-align: center;">}</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;">RS</td><td style="text-align: center;">62</td><td style="text-align: center;">&gt;</td><td style="text-align: center;">94</td><td style="text-align: center;">^</td><td style="text-align: center;">126</td><td style="text-align: center;">~</td></tr><tr class="even"><td style="text-align: center;">31</td><td style="text-align: center;">US</td><td style="text-align: center;">63</td><td style="text-align: center;">?</td><td style="text-align: center;">95</td><td style="text-align: center;">—</td><td style="text-align: center;">127</td><td style="text-align: center;">DEL</td></tr></tbody></table><span id="more"></span><p><strong>注意</strong></p><blockquote><ol type="1"><li><strong>ASCII中的<code>0</code>~<code>31</code>为控制字符；<code>32</code>~<code>126</code>为打印字符；<code>127</code>为Delete(删除)命令</strong>，下表为控制字符释义</li></ol><table><colgroup><col style="width: 15%" /><col style="width: 18%" /><col style="width: 15%" /><col style="width: 15%" /><col style="width: 18%" /><col style="width: 18%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">00</td><td style="text-align: center;">空</td><td style="text-align: center;">16</td><td style="text-align: center;">10</td><td style="text-align: center;">数据链路转意</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">01</td><td style="text-align: center;">头标开始</td><td style="text-align: center;">17</td><td style="text-align: center;">11</td><td style="text-align: center;">设备控制 1</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">02</td><td style="text-align: center;">正文开始</td><td style="text-align: center;">18</td><td style="text-align: center;">12</td><td style="text-align: center;">设备控制 2</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">03</td><td style="text-align: center;">正文结束</td><td style="text-align: center;">19</td><td style="text-align: center;">13</td><td style="text-align: center;">设备控制 3</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">04</td><td style="text-align: center;">传输结束</td><td style="text-align: center;">20</td><td style="text-align: center;">14</td><td style="text-align: center;">设备控制 4</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">05</td><td style="text-align: center;">查询</td><td style="text-align: center;">21</td><td style="text-align: center;">15</td><td style="text-align: center;">反确认</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">06</td><td style="text-align: center;">确认</td><td style="text-align: center;">22</td><td style="text-align: center;">16</td><td style="text-align: center;">同步空闲</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">07</td><td style="text-align: center;">震铃</td><td style="text-align: center;">23</td><td style="text-align: center;">17</td><td style="text-align: center;">传输块结束</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">08</td><td style="text-align: center;">backspace</td><td style="text-align: center;">24</td><td style="text-align: center;">18</td><td style="text-align: center;">取消</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">09</td><td style="text-align: center;">水平制表符</td><td style="text-align: center;">25</td><td style="text-align: center;">19</td><td style="text-align: center;">媒体结束</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">0A</td><td style="text-align: center;">换行/新行</td><td style="text-align: center;">26</td><td style="text-align: center;">1A</td><td style="text-align: center;">替换</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">0B</td><td style="text-align: center;">竖直制表符</td><td style="text-align: center;">27</td><td style="text-align: center;">1B</td><td style="text-align: center;">转意</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;">0C</td><td style="text-align: center;">换页/新页</td><td style="text-align: center;">28</td><td style="text-align: center;">1C</td><td style="text-align: center;">文件分隔符</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;">0D</td><td style="text-align: center;">回车</td><td style="text-align: center;">29</td><td style="text-align: center;">1D</td><td style="text-align: center;">组分隔符</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;">0E</td><td style="text-align: center;">移出</td><td style="text-align: center;">30</td><td style="text-align: center;">1E</td><td style="text-align: center;">记录分隔符</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;">0F</td><td style="text-align: center;">移入</td><td style="text-align: center;">31</td><td style="text-align: center;">1F</td><td style="text-align: center;">单元分隔符</td></tr></tbody></table></blockquote><h2 id="扩展字符">扩展字符</h2><p>​<strong>ASCII扩展字符——（为了适应更多字符）<code>128</code>~<code>255</code>/<code>-128</code>~<code>-1</code>，其中，<code>-128</code>对应<code>128</code>，依次递增对应</strong></p><table><colgroup><col style="width: 16%" /><col style="width: 20%" /><col style="width: 13%" /><col style="width: 16%" /><col style="width: 20%" /><col style="width: 13%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">128</td><td style="text-align: center;">80</td><td style="text-align: center;">Ç</td><td style="text-align: center;">192</td><td style="text-align: center;">C0</td><td style="text-align: center;">└</td></tr><tr class="even"><td style="text-align: center;">129</td><td style="text-align: center;">81</td><td style="text-align: center;">ü</td><td style="text-align: center;">193</td><td style="text-align: center;">C1</td><td style="text-align: center;">┴</td></tr><tr class="odd"><td style="text-align: center;">130</td><td style="text-align: center;">82</td><td style="text-align: center;">é</td><td style="text-align: center;">194</td><td style="text-align: center;">C2</td><td style="text-align: center;">┬</td></tr><tr class="even"><td style="text-align: center;">131</td><td style="text-align: center;">83</td><td style="text-align: center;">â</td><td style="text-align: center;">195</td><td style="text-align: center;">C3</td><td style="text-align: center;">├</td></tr><tr class="odd"><td style="text-align: center;">132</td><td style="text-align: center;">84</td><td style="text-align: center;">ä</td><td style="text-align: center;">196</td><td style="text-align: center;">C4</td><td style="text-align: center;">─</td></tr><tr class="even"><td style="text-align: center;">133</td><td style="text-align: center;">85</td><td style="text-align: center;">à</td><td style="text-align: center;">197</td><td style="text-align: center;">C5</td><td style="text-align: center;">┼</td></tr><tr class="odd"><td style="text-align: center;">134</td><td style="text-align: center;">86</td><td style="text-align: center;">å</td><td style="text-align: center;">198</td><td style="text-align: center;">C6</td><td style="text-align: center;">╞</td></tr><tr class="even"><td style="text-align: center;">135</td><td style="text-align: center;">87</td><td style="text-align: center;">ç</td><td style="text-align: center;">199</td><td style="text-align: center;">C7</td><td style="text-align: center;">╟</td></tr><tr class="odd"><td style="text-align: center;">136</td><td style="text-align: center;">88</td><td style="text-align: center;">ê</td><td style="text-align: center;">200</td><td style="text-align: center;">C8</td><td style="text-align: center;">╚</td></tr><tr class="even"><td style="text-align: center;">137</td><td style="text-align: center;">89</td><td style="text-align: center;">ë</td><td style="text-align: center;">201</td><td style="text-align: center;">C9</td><td style="text-align: center;">╔</td></tr><tr class="odd"><td style="text-align: center;">138</td><td style="text-align: center;">8A</td><td style="text-align: center;">è</td><td style="text-align: center;">202</td><td style="text-align: center;">CA</td><td style="text-align: center;">╩</td></tr><tr class="even"><td style="text-align: center;">139</td><td style="text-align: center;">8B</td><td style="text-align: center;">ï</td><td style="text-align: center;">203</td><td style="text-align: center;">CB</td><td style="text-align: center;">╦</td></tr><tr class="odd"><td style="text-align: center;">140</td><td style="text-align: center;">8C</td><td style="text-align: center;">î</td><td style="text-align: center;">204</td><td style="text-align: center;">CC</td><td style="text-align: center;">╠</td></tr><tr class="even"><td style="text-align: center;">141</td><td style="text-align: center;">8D</td><td style="text-align: center;">ì</td><td style="text-align: center;">205</td><td style="text-align: center;">CD</td><td style="text-align: center;">═</td></tr><tr class="odd"><td style="text-align: center;">142</td><td style="text-align: center;">8E</td><td style="text-align: center;">Ä</td><td style="text-align: center;">206</td><td style="text-align: center;">CE</td><td style="text-align: center;">╬</td></tr><tr class="even"><td style="text-align: center;">143</td><td style="text-align: center;">8F</td><td style="text-align: center;">Å</td><td style="text-align: center;">207</td><td style="text-align: center;">CF</td><td style="text-align: center;">╧</td></tr><tr class="odd"><td style="text-align: center;">144</td><td style="text-align: center;">90</td><td style="text-align: center;">É</td><td style="text-align: center;">208</td><td style="text-align: center;">D0</td><td style="text-align: center;">╨</td></tr><tr class="even"><td style="text-align: center;">145</td><td style="text-align: center;">91</td><td style="text-align: center;">æ</td><td style="text-align: center;">209</td><td style="text-align: center;">D1</td><td style="text-align: center;">╤</td></tr><tr class="odd"><td style="text-align: center;">146</td><td style="text-align: center;">92</td><td style="text-align: center;">Æ</td><td style="text-align: center;">210</td><td style="text-align: center;">D2</td><td style="text-align: center;">╥</td></tr><tr class="even"><td style="text-align: center;">147</td><td style="text-align: center;">93</td><td style="text-align: center;">ô</td><td style="text-align: center;">211</td><td style="text-align: center;">D3</td><td style="text-align: center;">╙</td></tr><tr class="odd"><td style="text-align: center;">148</td><td style="text-align: center;">94</td><td style="text-align: center;">ö</td><td style="text-align: center;">212</td><td style="text-align: center;">D4</td><td style="text-align: center;">Ô</td></tr><tr class="even"><td style="text-align: center;">149</td><td style="text-align: center;">95</td><td style="text-align: center;">ò</td><td style="text-align: center;">213</td><td style="text-align: center;">D5</td><td style="text-align: center;">╒</td></tr><tr class="odd"><td style="text-align: center;">150</td><td style="text-align: center;">96</td><td style="text-align: center;">û</td><td style="text-align: center;">214</td><td style="text-align: center;">D6</td><td style="text-align: center;">╓</td></tr><tr class="even"><td style="text-align: center;">151</td><td style="text-align: center;">97</td><td style="text-align: center;">ù</td><td style="text-align: center;">215</td><td style="text-align: center;">D7</td><td style="text-align: center;">╫</td></tr><tr class="odd"><td style="text-align: center;">152</td><td style="text-align: center;">98</td><td style="text-align: center;">ÿ</td><td style="text-align: center;">216</td><td style="text-align: center;">D8</td><td style="text-align: center;">╪</td></tr><tr class="even"><td style="text-align: center;">153</td><td style="text-align: center;">99</td><td style="text-align: center;">Ö</td><td style="text-align: center;">217</td><td style="text-align: center;">D9</td><td style="text-align: center;">┘</td></tr><tr class="odd"><td style="text-align: center;">154</td><td style="text-align: center;">9A</td><td style="text-align: center;">Ü</td><td style="text-align: center;">218</td><td style="text-align: center;">DA</td><td style="text-align: center;">┌</td></tr><tr class="even"><td style="text-align: center;">155</td><td style="text-align: center;">9B</td><td style="text-align: center;">¢</td><td style="text-align: center;">219</td><td style="text-align: center;">DB</td><td style="text-align: center;">█</td></tr><tr class="odd"><td style="text-align: center;">156</td><td style="text-align: center;">9C</td><td style="text-align: center;">£</td><td style="text-align: center;">220</td><td style="text-align: center;">DC</td><td style="text-align: center;">▄</td></tr><tr class="even"><td style="text-align: center;">157</td><td style="text-align: center;">9D</td><td style="text-align: center;">¥</td><td style="text-align: center;">221</td><td style="text-align: center;">DD</td><td style="text-align: center;">▌</td></tr><tr class="odd"><td style="text-align: center;">158</td><td style="text-align: center;">9E</td><td style="text-align: center;">?</td><td style="text-align: center;">222</td><td style="text-align: center;">DE</td><td style="text-align: center;">?</td></tr><tr class="even"><td style="text-align: center;">159</td><td style="text-align: center;">9F</td><td style="text-align: center;">ƒ</td><td style="text-align: center;">223</td><td style="text-align: center;">DF</td><td style="text-align: center;">?</td></tr><tr class="odd"><td style="text-align: center;">160</td><td style="text-align: center;">A0</td><td style="text-align: center;">á</td><td style="text-align: center;">224</td><td style="text-align: center;">E0</td><td style="text-align: center;">α</td></tr><tr class="even"><td style="text-align: center;">161</td><td style="text-align: center;">A1</td><td style="text-align: center;">í</td><td style="text-align: center;">225</td><td style="text-align: center;">E1</td><td style="text-align: center;">ß</td></tr><tr class="odd"><td style="text-align: center;">162</td><td style="text-align: center;">A2</td><td style="text-align: center;">ó</td><td style="text-align: center;">226</td><td style="text-align: center;">E2</td><td style="text-align: center;">Γ</td></tr><tr class="even"><td style="text-align: center;">163</td><td style="text-align: center;">A3</td><td style="text-align: center;">ú</td><td style="text-align: center;">227</td><td style="text-align: center;">E3</td><td style="text-align: center;">π</td></tr><tr class="odd"><td style="text-align: center;">164</td><td style="text-align: center;">A4</td><td style="text-align: center;">ñ</td><td style="text-align: center;">228</td><td style="text-align: center;">E4</td><td style="text-align: center;">Σ</td></tr><tr class="even"><td style="text-align: center;">165</td><td style="text-align: center;">A5</td><td style="text-align: center;">Ñ</td><td style="text-align: center;">229</td><td style="text-align: center;">E5</td><td style="text-align: center;">σ</td></tr><tr class="odd"><td style="text-align: center;">166</td><td style="text-align: center;">A6</td><td style="text-align: center;">ª</td><td style="text-align: center;">230</td><td style="text-align: center;">E6</td><td style="text-align: center;">µ</td></tr><tr class="even"><td style="text-align: center;">167</td><td style="text-align: center;">A7</td><td style="text-align: center;">º</td><td style="text-align: center;">231</td><td style="text-align: center;">E7</td><td style="text-align: center;">τ</td></tr><tr class="odd"><td style="text-align: center;">168</td><td style="text-align: center;">A8</td><td style="text-align: center;">¿</td><td style="text-align: center;">232</td><td style="text-align: center;">E8</td><td style="text-align: center;">Φ</td></tr><tr class="even"><td style="text-align: center;">169</td><td style="text-align: center;">A9</td><td style="text-align: center;">?</td><td style="text-align: center;">233</td><td style="text-align: center;">E9</td><td style="text-align: center;">Θ</td></tr><tr class="odd"><td style="text-align: center;">170</td><td style="text-align: center;">AA</td><td style="text-align: center;">¬</td><td style="text-align: center;">234</td><td style="text-align: center;">EA</td><td style="text-align: center;">Ω</td></tr><tr class="even"><td style="text-align: center;">171</td><td style="text-align: center;">AB</td><td style="text-align: center;">½</td><td style="text-align: center;">235</td><td style="text-align: center;">EB</td><td style="text-align: center;">δ</td></tr><tr class="odd"><td style="text-align: center;">172</td><td style="text-align: center;">AC</td><td style="text-align: center;">¼</td><td style="text-align: center;">236</td><td style="text-align: center;">EC</td><td style="text-align: center;">∞</td></tr><tr class="even"><td style="text-align: center;">173</td><td style="text-align: center;">AD</td><td style="text-align: center;">¡</td><td style="text-align: center;">237</td><td style="text-align: center;">ED</td><td style="text-align: center;">φ</td></tr><tr class="odd"><td style="text-align: center;">174</td><td style="text-align: center;">AE</td><td style="text-align: center;">«</td><td style="text-align: center;">238</td><td style="text-align: center;">EE</td><td style="text-align: center;">ε</td></tr><tr class="even"><td style="text-align: center;">175</td><td style="text-align: center;">AF</td><td style="text-align: center;">»</td><td style="text-align: center;">239</td><td style="text-align: center;">EF</td><td style="text-align: center;">∩</td></tr><tr class="odd"><td style="text-align: center;">176</td><td style="text-align: center;">B0</td><td style="text-align: center;">?</td><td style="text-align: center;">240</td><td style="text-align: center;">F0</td><td style="text-align: center;">≡</td></tr><tr class="even"><td style="text-align: center;">177</td><td style="text-align: center;">B1</td><td style="text-align: center;">?</td><td style="text-align: center;">241</td><td style="text-align: center;">F1</td><td style="text-align: center;">±</td></tr><tr class="odd"><td style="text-align: center;">178</td><td style="text-align: center;">B2</td><td style="text-align: center;">▓</td><td style="text-align: center;">242</td><td style="text-align: center;">F2</td><td style="text-align: center;">≥</td></tr><tr class="even"><td style="text-align: center;">179</td><td style="text-align: center;">B3</td><td style="text-align: center;">│</td><td style="text-align: center;">243</td><td style="text-align: center;">F3</td><td style="text-align: center;">≤</td></tr><tr class="odd"><td style="text-align: center;">180</td><td style="text-align: center;">B4</td><td style="text-align: center;">┤</td><td style="text-align: center;">244</td><td style="text-align: center;">F4</td><td style="text-align: center;">?</td></tr><tr class="even"><td style="text-align: center;">181</td><td style="text-align: center;">B5</td><td style="text-align: center;">╡</td><td style="text-align: center;">245</td><td style="text-align: center;">F5</td><td style="text-align: center;">?</td></tr><tr class="odd"><td style="text-align: center;">182</td><td style="text-align: center;">B6</td><td style="text-align: center;">╢</td><td style="text-align: center;">246</td><td style="text-align: center;">F6</td><td style="text-align: center;">÷</td></tr><tr class="even"><td style="text-align: center;">183</td><td style="text-align: center;">B7</td><td style="text-align: center;">╖</td><td style="text-align: center;">247</td><td style="text-align: center;">F7</td><td style="text-align: center;">≈</td></tr><tr class="odd"><td style="text-align: center;">184</td><td style="text-align: center;">B8</td><td style="text-align: center;">╕</td><td style="text-align: center;">248</td><td style="text-align: center;">F8</td><td style="text-align: center;">≈</td></tr><tr class="even"><td style="text-align: center;">185</td><td style="text-align: center;">B9</td><td style="text-align: center;">╣</td><td style="text-align: center;">249</td><td style="text-align: center;">F9</td><td style="text-align: center;">?</td></tr><tr class="odd"><td style="text-align: center;">186</td><td style="text-align: center;">BA</td><td style="text-align: center;">║</td><td style="text-align: center;">250</td><td style="text-align: center;">FA</td><td style="text-align: center;">·</td></tr><tr class="even"><td style="text-align: center;">187</td><td style="text-align: center;">BB</td><td style="text-align: center;">╗</td><td style="text-align: center;">251</td><td style="text-align: center;">FB</td><td style="text-align: center;">√</td></tr><tr class="odd"><td style="text-align: center;">188</td><td style="text-align: center;">BC</td><td style="text-align: center;">╝</td><td style="text-align: center;">252</td><td style="text-align: center;">FC</td><td style="text-align: center;">?</td></tr><tr class="even"><td style="text-align: center;">189</td><td style="text-align: center;">BD</td><td style="text-align: center;">╜</td><td style="text-align: center;">253</td><td style="text-align: center;">FD</td><td style="text-align: center;">²</td></tr><tr class="odd"><td style="text-align: center;">190</td><td style="text-align: center;">BE</td><td style="text-align: center;">╛</td><td style="text-align: center;">FE</td><td style="text-align: center;">■</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">191</td><td style="text-align: center;">BF</td><td style="text-align: center;">┐</td><td style="text-align: center;">255</td><td style="text-align: center;">FF</td><td style="text-align: center;">ÿ</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/C++/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/C++/static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="static">static</h1><p>[TOC]</p><span id="more"></span><hr /><h2 id="前言">前言</h2><blockquote><p>       <strong>static</strong>，中文意思是<strong>静态的</strong>，作为<strong>C/C++</strong>中常用关键字中的一个很重要的<strong>关键字</strong>，其中用法多样且复杂难以理解，用起来总是丈二和尚摸不着头脑，把我折磨的一头雾水（主要是博主很菜😂）</p><p>       也许大家对于这些知识都是一知半解（除过一些大佬），没有真正的搞透澈，一问我都会（这就是我），但是真正引用的时候，就会出现很多问题，而且百度的时候，大部分都讲得不是很清楚，所以为了帮助大家解决这个问题（实际上是自己不会），在这里进行一个全面的static介绍和总结。</p><p>       <strong>本文将会循序渐进，先从C语言</strong>的static讲起，慢慢延申到<strong>C++</strong>，从易到难，每一步都会举一些通俗易懂的例子帮助大家理解**（帮助自己理解，怕忘记😂），好了开始整活！</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/4a00220175de6957e32e2b8b3393429a.png" /></p></blockquote><h2 id="static关键字是什么"> static关键字是什么？</h2><blockquote><p>        <strong>static</strong>是C/C++中的<strong>关键字</strong>之一，<strong>是常见的函数与变量（C++中还包括类）的修饰符</strong>，它常被用来<strong>控制变量的存储方式和作用范围</strong>。在众多高级语言中都有其作为关键字或函数出现，所以这也是应当被程序员熟知其各种含义的一个单词</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/6f40ae980fb42b3343969791610d2f33.png" /></p></blockquote><h2id="static关键字修饰的对象是什么">static关键字修饰的对象是什么？</h2><blockquote><p><strong>1.局部变量</strong></p><p><strong>2.全局变量</strong></p><p><strong>3.函数</strong></p></blockquote><h2 id="c-语言中的-static">C 语言中的 static</h2><h3 id="static的c用法"> 🍎static的C用法</h3><blockquote><p>    <strong>1️⃣: 修饰局部变量（称为静态局部变量）</strong></p><p>   <strong>2️⃣:</strong> <strong>修饰全局变量（称为静态全局变量）</strong></p><p>    <strong>3️⃣: 修饰函数（称为静态函数）</strong></p></blockquote><h3 id="static的重点概念"> <strong>🍉static的重点概念</strong></h3><blockquote><p><strong>1️⃣：在函数中声明变量时， static关键字指定变量只初始化一次，并在之后调用该函数时保留其状态。<br />2️⃣：在声明变量时，变量具有静态持续时间，并且除非您指定另一个值。<br />3️⃣ ：在全局和/或命名空间范围 (在单个文件范围内声明变量或函数时) static关键字指定变量或函数为内部链接，即外部文件无法引用该变量或函数<br />4️⃣：static 关键字 没有赋值时，默认赋值为 0</strong> </p><p><strong>5️⃣：static修饰局部变量时，会改变局部变量的存储位置，从而使得局部变量的生命周期变长。</strong></p><p><strong>⭐：接下来，将重点讲解上面三个作用个五点概念的理解，和应用</strong></p></blockquote><h3 id="static修饰局部变量"> <strong>🍐static修饰局部变量</strong></h3><blockquote><p><strong>1️⃣：在函数中声明变量时， static关键字指定变量只初始化一次，并在之后调用该函数时保留其状态。<br />5️⃣：static修饰局部变量时，会改变局部变量的存储位置，从而使得局部变量的生命周期变长。</strong></p><p>接下来用们用一段代码来进行解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">x++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        这段代码中每次调用test（）函数时创建局部变量x赋值为0，每次局部变量x出了test（）函数后都会自行销毁。<br />        所以可以很容易得到输出结果为：1 1 1 1 1 1 1 1 1 1</p><hr /><p>        接着我们用上<strong>static关键字</strong>来修饰 <strong>test（）</strong>函数中的局部变量 <strong>x</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">x++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        输出结果变成了：1 2 3 4 5 6 7 8 9 10<br />       <strong>原因是static修饰了局部变量x，令局部变量x变成静态的，且只能初始化一次，使得每次test（）函数结束时局部变量x都不销毁，再次进入test（）函数时则保留原有数值运行，因此x++数值越来越大。</strong><br /><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/17fdf3379a7b6c275debcb031e2472d3.png" /></p><p><strong>⭐总结：</strong></p><p><strong>（1）static关键字修饰局部变量不改变作用域，但是生命周期变长。</strong></p><p><strong>（2）本质上，static关键字修饰局部变量，改变了局部变量的存储位置，因为存储位置的差异，使得执行效果不一样。普通的局部变量放在栈区，这种局部变量进入作用域创建，出作用域释放。局部变量被static修饰后成为静态局部变量，这种变量放在静态区，创建好后，直到程序结束后才释放。</strong></p></blockquote><blockquote><p><strong>4️⃣：static 关键字 没有赋值时，默认赋值为 0</strong> </p><p>接下来用们用一段代码来进行解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer: %d; string: (begin)%s(end)\n&quot;</span>, a, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        在这段代码中，我们并没有对全局变量 a 和字符串数组 str进行赋值，所以在输出时会出现<strong>随机值的现象</strong>。所以很容易得到如下的结果：</p><p><strong>输出：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">integer</span>: <span class="number">0</span>; string: (<span class="keyword">begin</span>)烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫攼l(<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p><strong>⚠ 注意：a 输出为 0 是因为 此时 a是全局变量，也存放在静态区，所以可以默认值为 0 .</strong></p><hr /><p>        <strong>接着我们用上 static关键字 来修饰 全局变量 a和字符串数组 str</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer: %d; string: (begin)%s(end)\n&quot;</span>, a, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>输出：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">integer</span>: <span class="number">0</span>; string: (<span class="keyword">begin</span>)(<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>       <strong>⭐总结：</strong></p><p>        <strong>static的另一个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’。</strong></p></blockquote><h4id="static在修饰局部变量和函数的作用"> <strong>💦static在修饰局部变量和函数的作用</strong></h4><blockquote><p> <strong>⭐作用：</strong></p><p>        <strong>保持变量内容的持久</strong></p><ul><li>static的第一个作用是<strong>保持变量内容的持久</strong>，即static变量中的记忆功能和全局生存期。</li><li>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。之后再次运行到含有static关键字的初始化语句时不会再执行该语句。共有两种变量存储在静态存储区：全局变量和static 变量，只不过和全局变量比起来，static可以控制变量的可见范围。</li></ul></blockquote><h3id="static修饰全局变量和函数"> <strong>🍓static修饰全局变量和函数</strong></h3><blockquote><p><strong>3️⃣ ：在全局和/或命名空间范围(在单个文件范围内声明变量或函数时) static关键字指定变量或函数为内部链接，即外部文件无法引用该变量或函数。</strong></p><p>        针对上面这个概念的理解我们一次来解析以下：<br />1.首先说一下全局变量，全局变量的作用域十分的广，只要在一个源文件中定义后，这个程序中的所有源文件、对象以及函数都可以调用，生命周期更是贯穿整个程序。文件中的全局变量想要被另一个文件使用时就需要进行<strong>外部声明</strong>（以下用extern关键字进行声明）。----<strong>-也即是说全局变量既可以在源文件中使用，也可以在其他文件中使用（只需要使用extern外部链接以下即可）</strong></p><p>2.static修饰<strong>全局变量和函数</strong>时，<strong>会改变全局变量和函数的链接属性-------变为只能在内部链接，从而使得全局变量的作用域变小。</strong></p><p>  接着我们用代码进行解析：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/72b3381b5375d6641148b69aa4d42f53.png" /></p><p>首先，在Hello.c文件中定义一个全局变量 char a 和函数PrintfHello()，之后在test.c文件中进行extern 进行外部链接，运行代码：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/338afd968911fa176bac517322520701.png" /></p><p>之后我们进入正题 <strong>在全局变量和函数之前用static进行修饰</strong>，看看效果：</p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/70f44192a6e4e5079b63d46128b9fe00.png" /></p><p>       会发现生成错误，<strong>无法解析外部符号a和PrintfHello()等</strong>，全局变量a和PrintfHello()不能被test.c文件调用了。所以我们可以很容易看出<strong>static修饰后让全局变量a和PrintfHello()的作用域变小了，令全局变量a和PrintfHello()无法被其他文件调用。</strong></p><p><strong>⭐总结：</strong></p><p>1.<strong>全局变量和函数</strong>本身是具有<strong>外部链接属性</strong>的，在Hello.c文件中定义的全局变量和函数，在test.c文件中可以通过<strong>【链接】</strong>来使用；</p><p>2.但如果全局变量被static修饰，那这个外部链接属性就会被修改成<strong>内部链接属性</strong>，<strong>此时这个全局变量就只能在自己的源文件中使用；</strong></p></blockquote><h4id="static在修饰全局变量和函数的作用">💦static在修饰全局变量和函数的作用</h4><blockquote><p><strong>⭐作用：</strong><br />        如果加了 static，就会对其它源文件隐藏。例如在 a 和 printHello的定义前加上 static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。<strong>static可以修饰函数和变量，将其对其他源文件隐藏起来，从而避免命名冲突。对于函数来讲，static的作用仅限于该隐藏功能。</strong></p></blockquote><h2 id="c中的-static"><strong>C++中的 static</strong></h2><blockquote><p>        本小节主要介绍在<strong>C++中引入了面向对象的特性（类）</strong>之后，static关键字的一些用途。当然C++ 是兼容 C 语言的，所以<strong>C语言中的 static在C++中也是成立的</strong>。</p></blockquote><h3 id="static的c用法-1"> <strong>🍌static的C++用法</strong></h3><blockquote><p> 声明为static的类成员称为类的静态成员，分为如下两类：</p><ul><li>用static修饰的成员变量，称之为<strong>静态成员变量</strong></li><li>用static修饰的成员函数，称之为<strong>静态成员函数</strong></li></ul><p><strong>静态的成员变量一定要在类外进行初始化</strong></p></blockquote><h3 id="static在c中的重点概念">🍊static在C++中的重点概念</h3><blockquote><p><strong>1️⃣：静态成员为所有类对象所共享，不属于某个具体的实例<br />2️⃣：静态成员变量必须在类外定义，定义时不添加static关键字<br />3️⃣：静态成员函数没有隐藏的this指针，不能访问任何非静态成员<br />4️⃣：访问静态成员变量的特殊方式</strong></p><p><strong>5️⃣：静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值</strong></p><p><strong>⭐：接下来，将重点讲解上面三个作用个五点概念的理解，和应用</strong></p></blockquote><h4id="静态成员为所有类对象所共享不属于某个具体的实例"> <strong>💦静态成员为所有类对象所共享，不属于某个具体的实例</strong></h4><blockquote><p>请看如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _n;</span><br><span class="line"><span class="type">int</span> _k;</span><br><span class="line"><span class="type">char</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">//8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>       这里的运行结果为<strong>8</strong>，这里的计算规则是按照C语言那套计算结构体大小的规则。<strong>并没有把我静态成员变量_n考虑进去，因为静态成员变量属于整个类，是类的所以对象，所以静态变量成员不计入总大小。</strong></p></blockquote><h4id="静态成员变量必须在类外定义定义时不添加static关键字"> <strong>💦静态成员变量必须在类外定义，定义时不添加static关键字</strong></h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _n;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="type">int</span> A::_n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> A::_k = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></blockquote><h4id="静态成员函数没有隐藏的this指针不能访问任何非静态成员"> <strong>💦静态成员函数没有隐藏的this指针，不能访问任何非静态成员</strong></h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; ret &lt;&lt; endl;  <span class="comment">// err错误，访问了非静态成员，因为无this指针</span></span><br><span class="line">cout &lt;&lt; _k &lt;&lt; endl; <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="type">int</span> A::_k = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></blockquote><h4id="访问静态成员变量的特殊方式"> <strong>💦访问静态成员变量的特殊方式</strong></h4><blockquote><p><strong>当静态成员变量为公有时，可有如下三种进行访问：</strong></p><ol type="1"><li>通过对象.静态成员来访问</li><li>通过类名::静态成员来行访问</li><li>通过匿名对象突破类域进行访问</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="type">int</span> A::_k = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; a._k &lt;&lt; endl;  <span class="comment">//通过对象.静态成员来访问</span></span><br><span class="line">cout &lt;&lt; A::_k &lt;&lt; endl; <span class="comment">//通过类名::静态成员来行访问</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">A</span>()._k &lt;&lt; endl;<span class="comment">//通过匿名对象突破类域进行访问</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当静态成员变量变成私有时，可采用如下方式：</strong></p><ol type="1"><li>通过对象.静态成员函数来访问</li><li>通过类名::静态成员函数来行访问</li><li>通过匿名对象调用成员函数进行访问</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::_k = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">GetK</span>() &lt;&lt; endl; <span class="comment">//通过对象.静态成员函数来访问</span></span><br><span class="line">cout &lt;&lt; A::<span class="built_in">GetK</span>() &lt;&lt; endl;<span class="comment">//通过类名::静态成员函数来行访问</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">A</span>().GetK &lt;&lt; endl; <span class="comment">//通过匿名对象调用成员函数进行访问</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4id="静态成员和类的普通成员一样也有publicprotectedprivate3种访问级别也可以具有返回值"> <strong>💦</strong>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值</h4><blockquote><ul><li><strong>1、静态成员函数可以调用非静态成员函数吗？</strong></li></ul><p>答案：不可以，因为静态成员函数是没有this指针的，无法调用非静态成员函数。<br /> </p><ul><li>2、非静态成员函数可以调用类的静态成员函数吗？</li></ul><p>答案：可以，因为静态成员为所有类对象所共享，不受访问限制<br /> </p></blockquote><h2 id="static面试题">static面试题</h2><blockquote><p><strong>搞清楚了static的特性，来看几道道面试题：</strong></p><p><strong>面试题1：</strong></p><p>实现一个类，计算中程序中创建出了多少个类对象。</p><ul><li>思路：</li></ul><p>假设命名该类为A，那么A类型的对象一定是经过<strong>构造函数或拷贝构造</strong>的，那么我们就可以分别定义<strong>两个静态成员变量</strong>，在构造函数和拷贝构造里++变量，这样，每创建一次对象，变量就++一次，自然就好求了。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">++_count1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; aa)</span><br><span class="line">&#123;</span><br><span class="line">++_count2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _count1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _count2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _count1; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _count2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::_count1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> A::_count2 = <span class="number">0</span>;</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">copy</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a1;</span><br><span class="line">A a2 = <span class="built_in">Func</span>(a1);</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; a1.<span class="built_in">GetCount1</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; a2.<span class="built_in">GetCount2</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">cout &lt;&lt; A::<span class="built_in">GetCount1</span>() + A::<span class="built_in">GetCount2</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：</li></ul><p>        A a1 调用了一次构造函数；a2 = Func(a1)，调用了一次拷贝构造；Acopy(a)，调用了一次拷贝构造；return copy返回的时候，copy会销毁，所以提前需要进行拷贝构造进行拷贝保存。所用总共四次。</p></blockquote><h2 id="static-oj面试题">static OJ面试题</h2><blockquote><p>  1、求1+2+3+...+n</p><p> * 题目：</p><p> <imgsrc="https://i-blog.csdnimg.cn/blog_migrate/2a52e40fbe771bca18934f68b7d4cc2d.png" /></p><p> * <strong>链接直达：</strong></p><p>  [求1+2+3+...+n](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" 求1+2+3+...+n")</p><p> * 思路：</p><p> 这里我可以自己单独定义一个Sum类，专门进行求和，我定义n个对象，它就会调用n次构造函数，此时就可以在构造函数内实现累加，为了实现累加，<strong>需要在Sum类里设定两个静态成员变量，</strong>因为静态成员属于整个类，以此确保每次访问的变量都是同一个，最后，返回累加的值即可。</p><p> * 注意：</p><p> 如若不支持变长数组，我们只能用new来完成，在获取返回的累加值时，可以单独在类内写个函数返回私有成员变量，该函数可以是静态成员函数，这样就可以指定类域去调用，不需要借助对象了。也可以借助友元。</p><p> * 代码：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Sum</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Sum</span>() <span class="comment">//构造函数内实现累加</span></span><br><span class="line">     &#123;</span><br><span class="line">         _ret += _i;</span><br><span class="line">         _i++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">GetRet</span><span class="params">()</span>  <span class="comment">//static int GetRet() 也可以是静态成员函数</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> _ret;  <span class="comment">//返回获取的求和值</span></span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="comment">//静态成员变量类内声明</span></span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> _i;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> _ret;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//静态成员变量类外定义</span></span><br><span class="line"> <span class="type">int</span> Sum::_i = <span class="number">1</span>;</span><br><span class="line"> <span class="type">int</span> Sum::_ret = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">         Sum a[n]; <span class="comment">//支持变长数组可以这样写</span></span><br><span class="line">         <span class="keyword">return</span> a[<span class="number">1</span>].<span class="built_in">GetRet</span>(); <span class="comment">//注意通过对象去调用成员函数</span></span><br><span class="line">         <span class="comment">//return Sum::GetRet();静态成员函数支持用类域访问</span></span><br><span class="line">         <span class="comment">/* 如若不支持变长数组，就用new来开辟n个空间</span></span><br><span class="line"><span class="comment">         Sum* ptr = new Sum[n];</span></span><br><span class="line"><span class="comment">         return ptr-&gt;GetRet(); </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h2 id="共勉">共勉</h2><p>         <strong>以下就是我对C/C++static关键字的理解，如果有不懂和发现问题的小伙伴，请在评论区说出来哦，同时我还会继续更新对C++类和对象的理解，请持续关注我哦！！！</strong>  </p><p><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/5c60e95b67e479b38e6f32ef256e40de.png" /> </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组作为函数参数传递</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/C++/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/C++/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h1 id="数组作为函数参数传递">数组作为函数参数传递</h1><h2 id="总结">总结</h2><ul><li>数组在声明、定义的时候，最多只能省略<strong>第一维的长度</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404121955805.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404121956274.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><span id="more"></span><h2 id="举例">举例</h2><p>​ 求解多维数组中的最大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_value</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[][<span class="number">4</span>])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">23</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max value is %d\n&quot;</span>, max_value(b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_value</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[][<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, max;</span><br><span class="line">    max = <span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; max)</span><br><span class="line">                max = <span class="built_in">array</span>[i][j];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 实际工程里面应该将行数作为形似参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_value</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[][<span class="number">4</span>], <span class="type">int</span>)</span>; <span class="comment">// 实际工程里面应该将行数作为形似参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">23</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max value is %d\n&quot;</span>, max_value(b, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_value</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[][<span class="number">4</span>], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, max;</span><br><span class="line">    max = <span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; max)</span><br><span class="line">                max = <span class="built_in">array</span>[i][j];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意大坑">注意大坑</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span> a); <span class="comment">// 注意：这里返回 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span> a); <span class="comment">// 注意：这里返回 15 * 4</span></span><br><span class="line"></span><br><span class="line">    demo(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.cpp: In function &#x27;void demo(int (*)[5])&#x27;:</span><br><span class="line">2.cpp:5:27: warning: &#x27;sizeof&#x27; on array function parameter &#x27;a&#x27; will return size of &#x27;int (*)[5]&#x27; [-Wsizeof-array-argument]</span><br><span class="line">     printf(&quot;%d\n&quot;, sizeof a); // 注意：这里返回 15 * 4</span><br><span class="line">2.cpp:3:15: note: declared here</span><br><span class="line"> void demo(int a[3][5])</span><br><span class="line">           ~~~~^~~~~~~</span><br><span class="line">60</span><br><span class="line">8</span><br></pre></td></tr></table></figure><ul><li><p>问题出现在：当你声明一个<strong>函数参数为数组</strong>时，如<code>void demo(int a[3][5])</code>，实际上<font color = 'red'><strong>在函数内部，数组会退化为指向其第一个元素的指针</strong></font></p></li><li><p>因此，在 <code>void demo(int a[3][5])</code> 函数中<code>sizeof a</code>实际返回的是<font color = 'blue'><strong>指针大小</strong>——<spanclass="math inline">\(8B\)</span></font></p></li><li><p>所以，千万不要在函数内部对 数组形参 使用<code>sizeof</code></p></li><li><p><font color = 'green'><strong>在C++中，对于数组作为函数参数传递时，sizeof将返回指针的大小，而不是数组的大小</strong></font></p></li></ul><blockquote><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/9601067/">C++数组作为函数参数传递带来的一个问题- AcWing</a></p></blockquote><p>例如：</p><ul><li><a href="https://www.acwing.com/video/517/">AcWing 1135.新年好（算法提高课） - AcWing</a></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Special Judge</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/others/Special%20Judge/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/others/Special%20Judge/</url>
      
        <content type="html"><![CDATA[<h1 id="special-judge">Special Judge</h1><p>本页面主要介绍部分评测工具/OJ 的 spj 编写方法。</p><h2 id="简介">简介</h2><p><strong>SpecialJudge</strong>（简称：spj，别名：checker）是当一道题有多组解时，用来判断答案合法性的程序。</p><details class="warning" data-original-document-end="355" data-original-document-start="99" open style="box-sizing: inherit; background-color: var(--md-admonition-bg-color); border: 0.075rem solid rgb(255, 145, 0); border-radius: 0.2rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); display: flow-root; font-size: 0.64rem; margin: 1.5625em 0px; padding: 0px 0.6rem; break-inside: avoid; transition: box-shadow 125ms; overflow: visible; font-family: &quot;Fira Sans&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; background-color: rgba(255, 145, 0, 0.1); border-top: none; border-right: none; border-bottom: none; border-left: 0.2rem none; border-image: initial; font-weight: 700; margin: 0px -0.6rem; padding: 0.4rem 1.8rem 0.4rem 2rem; position: relative; cursor: pointer; display: block; min-height: 1rem; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Warning</summary><p style="box-sizing: border-box;">spj还应当判断文件尾是否有多余内容，及输出格式是否正确（如题目要求数字间用一个空格隔开，而选手却使用了换行）。但是，目前前者只有Testlib 可以方便地做到这一点，而后者几乎无人去特意进行这种判断。</p><p style="box-sizing: border-box;">判断浮点数时应注意 NaN。不合理的判断方式会导致输出 NaN 即可 AC 的情况。</p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">在对选手文件进行读入操作时应该要检查是否正确读入了所需的内容，防止造成spj 的运行错误。（部分 OJ 会将 spj 的运行错误作为系统错误处理）</p></details><details class="note" data-original-document-end="436" data-original-document-start="357" open style="box-sizing: inherit; background-color: var(--md-admonition-bg-color); border: 0.075rem solid rgb(68, 138, 255); border-radius: 0.2rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); display: flow-root; font-size: 0.64rem; margin: 1.5625em 0px; padding: 0px 0.6rem; break-inside: avoid; transition: box-shadow 125ms; overflow: visible; font-family: &quot;Fira Sans&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; background-color: rgba(68, 138, 255, 0.1); border-top: none; border-right: none; border-bottom: none; border-left: 0.2rem none; border-image: initial; font-weight: 700; margin: 0px -0.6rem; padding: 0.4rem 1.8rem 0.4rem 2rem; position: relative; cursor: pointer; display: block; min-height: 1rem; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Note</summary><p style="box-sizing: border-box; margin-bottom: 0.6rem;">以下均以 C++ 作为编程语言，以「要求标准答案与选手答案差值小于1e-3，文件名为 num，单个测试点满分为 10 分」为例。</p></details><span id="more"></span><h2 id="testlib">Testlib</h2><p>参见：<ahref="https://oi-wiki.org/tools/testlib/">Testlib/简介</a>，<ahref="https://oi-wiki.org/tools/testlib/checker/">Testlib/Checker</a></p><p>Testlib 是一个 C++ 的库，用于辅助出题人使用 C++ 编写算法竞赛题。</p><p>必须使用 Testlib 作为 spj 的 评测工具/OJ：Codeforces、洛谷、UOJ等。</p><p>可以使用 Testlib 作为 spj 的 评测工具/OJ：LibreOJ (<ahref="https://github.com/lyrio-dev">Lyrio</a>)、Lemon、牛客网等。</p><p>SYZOJ 2 所需的修改版 Testlib 托管于 <ahref="https://pastebin.com/3GANXMG7">pastebin</a><ahref="https://oi-wiki.org/tools/special-judge/#fn:1">1</a>，但此修改版并未修改交互模式。<ahref="https://github.com/syzoj/testlib">syzoj/testlib</a>处托管了一份可以在 SYZOJ 2 上使用交互模式的 Testlib。</p><p>Lemon 所需的修改版 Testlib 托管于 <ahref="https://github.com/GitPinkRabbit/Testlib-for-Lemons">GitHub -GitPinkRabbit/Testlib-for-Lemons</a>。注意此版本 Testlib 注册 checker时应使用 <code>registerLemonChecker()</code>，而非<code>registerTestlibCmd()</code>。此版本继承自 <ahref="https://paste.ubuntu.com/p/JsTspHHnmB/">matthew99的旧版</a>，添加了一些 Testlib 的新功能。</p><p>DOMJudge 所需的修改版 Testlib 托管于 <ahref="https://github.com/cn-xcpc-tools/testlib-for-domjudge">cn-xcpc-tools/testlib-for-domjudge</a>。此版本Testlib 同时可作为 Special Judge 的 checker 和交互题的 interactor。</p><p>Arbiter 所需的修改版 Testlib 托管于 <ahref="https://github.com/HeRaNO/ChickenRibs/tree/master/testlib-for-arbiter">testlib-for-arbiter</a>。</p><p>其他评测工具/OJ 大部分需要按照其 spj 编写格式修改 Testlib，并将testlib.h 与 spj 一同上传；或将 testlib.h 置于 include 目录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * inf：输入</span></span><br><span class="line"><span class="comment">   * ouf：选手输出</span></span><br><span class="line"><span class="comment">   * ans：标准输出</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">registerTestlibCmd</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans = ouf.<span class="built_in">readDouble</span>(), jans = ans.<span class="built_in">readDouble</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>)</span><br><span class="line">    <span class="built_in">quitf</span>(_ok, <span class="string">&quot;Good job\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">quitf</span>(_wa, <span class="string">&quot;Too big or too small, expected %f, found %f\n&quot;</span>, jans, pans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lemon">Lemon</h2><details class="note" open style="box-sizing: inherit; background-color: var(--md-admonition-bg-color); border: 0.075rem solid rgb(68, 138, 255); border-radius: 0.2rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); display: flow-root; font-size: 0.64rem; margin: 1.5625em 0px; padding: 0px 0.6rem; break-inside: avoid; transition: box-shadow 125ms; overflow: visible; font-family: &quot;Fira Sans&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; background-color: rgba(68, 138, 255, 0.1); border-top: none; border-right: none; border-bottom: none; border-left: 0.2rem none; border-image: initial; font-weight: 700; margin: 0px -0.6rem; padding: 0.4rem 1.8rem 0.4rem 2rem; position: relative; cursor: pointer; display: block; min-height: 1rem; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Note</summary><p style="box-sizing: border-box; margin-bottom: 0.6rem;">Lemon有现成的修改版<span> </span><a href="https://oi-wiki.org/tools/special-judge/#testlib" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: var(--md-typeset-a-color); text-decoration: none; word-break: break-word; transition: color 125ms;">Testlib</a>，建议使用Testlib。</p></details><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * argv[1]：输入</span></span><br><span class="line"><span class="comment">   * argv[2]：选手输出</span></span><br><span class="line"><span class="comment">   * argv[3]：标准输出</span></span><br><span class="line"><span class="comment">   * argv[4]：单个测试点分值</span></span><br><span class="line"><span class="comment">   * argv[5]：输出最终得分 (0 ~ argv[4])</span></span><br><span class="line"><span class="comment">   * argv[6]：输出错误报告</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fin = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fscore = <span class="built_in">fopen</span>(argv[<span class="number">5</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  FILE* freport = <span class="built_in">fopen</span>(argv[<span class="number">6</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;%s&quot;</span>, argv[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(freport, <span class="string">&quot;Good job\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(freport, <span class="string">&quot;Too big or too small, expected %f, found %f\n&quot;</span>, jans,</span><br><span class="line">            pans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cena">Cena</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * FILENAME.in：输入</span></span><br><span class="line"><span class="comment">   * FILENAME.out：选手输出</span></span><br><span class="line"><span class="comment">   * argv[1]：单个测试点分值</span></span><br><span class="line"><span class="comment">   * argv[2]：标准输出</span></span><br><span class="line"><span class="comment">   * score.log：输出最终得分 (0 ~ argv[1])</span></span><br><span class="line"><span class="comment">   * report.log：输出错误报告</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fin = <span class="built_in">fopen</span>(<span class="string">&quot;num.in&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(<span class="string">&quot;num.out&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fscore = <span class="built_in">fopen</span>(<span class="string">&quot;score.log&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  FILE* freport = <span class="built_in">fopen</span>(<span class="string">&quot;report.log&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;%s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(freport, <span class="string">&quot;Good job\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(freport, <span class="string">&quot;Too big or too small, expected %f, found %f\n&quot;</span>, jans,</span><br><span class="line">            pans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ccr">CCR</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * stdin：输入</span></span><br><span class="line"><span class="comment">   * argv[2]：标准输出</span></span><br><span class="line"><span class="comment">   * argv[3]：选手输出</span></span><br><span class="line"><span class="comment">   * stdout:L1：输出最终得分比率 (0 ~ 1)</span></span><br><span class="line"><span class="comment">   * stdout:L2：输出错误报告</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good job\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Too big or too small, expected %f, found %f\n&quot;</span>, jans, pans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="arbiter">Arbiter</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * argv[1]：输入</span></span><br><span class="line"><span class="comment">   * argv[2]：选手输出</span></span><br><span class="line"><span class="comment">   * argv[3]：标准输出</span></span><br><span class="line"><span class="comment">   * /tmp/_eval.score:L1：输出错误报告</span></span><br><span class="line"><span class="comment">   * /tmp/_eval.score:L2：输出最终得分</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fscore = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/_eval.score&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;Good job\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;%d&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;Too big or too small, expected %f, found %f\n&quot;</span>, jans,</span><br><span class="line">            pans);</span><br><span class="line">    <span class="built_in">fprintf</span>(fscore, <span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hustoj">HUSTOJ</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WA 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * argv[1]：输入</span></span><br><span class="line"><span class="comment">   * argv[2]：标准输出</span></span><br><span class="line"><span class="comment">   * argv[3]：选手输出</span></span><br><span class="line"><span class="comment">   * exit code：返回判断结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fin = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(argv[<span class="number">3</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>)</span><br><span class="line">    <span class="keyword">return</span> AC;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> WA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="qduoj">QDUOJ</h2><p>相较之下，QDUOJ 略为麻烦。它带 spj 的题目没有标准输出，只能把 std写进 spj，待跑出标准输出后再判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WA 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * argv[1]：输入</span></span><br><span class="line"><span class="comment">   * argv[2]：选手输出</span></span><br><span class="line"><span class="comment">   * exit code：返回判断结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fin = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line"></span><br><span class="line">  jans = <span class="built_in">solve</span>(...);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>)</span><br><span class="line">    <span class="keyword">return</span> AC;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> WA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="syzoj-2">SYZOJ 2</h2><details class="note" data-original-document-end="5943" data-original-document-start="5824" open style="box-sizing: inherit; background-color: var(--md-admonition-bg-color); border: 0.075rem solid rgb(68, 138, 255); border-radius: 0.2rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); display: flow-root; font-size: 0.64rem; margin: 1.5625em 0px; padding: 0px 0.6rem; break-inside: avoid; transition: box-shadow 125ms; overflow: visible; font-family: &quot;Fira Sans&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; background-color: rgba(68, 138, 255, 0.1); border-top: none; border-right: none; border-bottom: none; border-left: 0.2rem none; border-image: initial; font-weight: 700; margin: 0px -0.6rem; padding: 0.4rem 1.8rem 0.4rem 2rem; position: relative; cursor: pointer; display: block; min-height: 1rem; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Note</summary><p style="box-sizing: border-box;">SYZOJ 2有现成的修改版<span> </span><a href="https://oi-wiki.org/tools/special-judge/#testlib" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: var(--md-typeset-a-color); text-decoration: none; word-break: break-word; transition: color 125ms;">Testlib</a>，建议使用Testlib。</p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">LibreOJ 的最新版本已不再基于SYZOJ，而是基于<span> </span><a href="https://github.com/lyrio-dev/lyrio" target="_blank" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: var(--md-typeset-a-color); text-decoration: none; word-break: break-word; transition: color 125ms;">Lyrio</a>。Lyrio支持使用原版 Testlib 编写评测器，这也是更加通用且推荐的做法。</p></details><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * in：输入</span></span><br><span class="line"><span class="comment">   * user_out：选手输出</span></span><br><span class="line"><span class="comment">   * answer：标准输出</span></span><br><span class="line"><span class="comment">   * code：选手代码</span></span><br><span class="line"><span class="comment">   * stdout：输出最终得分 (0 ~ 100)</span></span><br><span class="line"><span class="comment">   * stderr：输出错误报告</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fin = <span class="built_in">fopen</span>(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(<span class="string">&quot;user_out&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(<span class="string">&quot;answer&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fcode = <span class="built_in">fopen</span>(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Good job\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Too big or too small, expected %f, found %f\n&quot;</span>, jans,</span><br><span class="line">            pans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客网">牛客网</h2><details class="note" open style="box-sizing: inherit; background-color: var(--md-admonition-bg-color); border: 0.075rem solid rgb(68, 138, 255); border-radius: 0.2rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); display: flow-root; font-size: 0.64rem; margin: 1.5625em 0px; padding: 0px 0.6rem; break-inside: avoid; transition: box-shadow 125ms; overflow: visible; font-family: &quot;Fira Sans&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; background-color: rgba(68, 138, 255, 0.1); border-top: none; border-right: none; border-bottom: none; border-left: 0.2rem none; border-image: initial; font-weight: 700; margin: 0px -0.6rem; padding: 0.4rem 1.8rem 0.4rem 2rem; position: relative; cursor: pointer; display: block; min-height: 1rem; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Note</summary><p style="box-sizing: border-box; margin-bottom: 0.6rem;">牛客网有现成的修改版<span> </span><a href="https://oi-wiki.org/tools/special-judge/#testlib" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: var(--md-typeset-a-color); text-decoration: none; word-break: break-word; transition: color 125ms;">Testlib</a>，建议使用Testlib。</p></details><p>参见：<a href="https://www.nowcoder.com/discuss/84666">如何在牛客网出Special Judge 的编程题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WA 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * input：输入</span></span><br><span class="line"><span class="comment">   * user_output：选手输出</span></span><br><span class="line"><span class="comment">   * output：标准输出</span></span><br><span class="line"><span class="comment">   * exit code：返回判断结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fin = <span class="built_in">fopen</span>(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fout = <span class="built_in">fopen</span>(<span class="string">&quot;user_output&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(<span class="string">&quot;output&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">fscanf</span>(fout, <span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>)</span><br><span class="line">    <span class="keyword">return</span> AC;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> WA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="domjudge">DOMJudge</h2><details class="note" data-original-document-end="7424" data-original-document-start="7370" open style="box-sizing: inherit; background-color: var(--md-admonition-bg-color); border: 0.075rem solid rgb(68, 138, 255); border-radius: 0.2rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); display: flow-root; font-size: 0.64rem; margin: 1.5625em 0px 0px; padding: 0px 0.6rem; break-inside: avoid; transition: box-shadow 125ms; overflow: visible; font-family: &quot;Fira Sans&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; background-color: rgba(68, 138, 255, 0.1); border-top: none; border-right: none; border-bottom: none; border-left: 0.2rem none; border-image: initial; font-weight: 700; margin: 0px -0.6rem; padding: 0.4rem 1.8rem 0.4rem 2rem; position: relative; cursor: pointer; display: block; min-height: 1rem; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Note</summary><p style="box-sizing: border-box;">DOMJudge 支持任何语言编写的spj，参见：<a href="https://www.problemarchive.org/wiki/index.php/Output_validator" target="_blank" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: var(--md-typeset-a-color); text-decoration: none; word-break: break-word; transition: color 125ms;">problemarchive.orgoutput validator 格式</a>。</p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">DOMJudge有现成的修改版<span> </span><a href="https://oi-wiki.org/tools/special-judge/#testlib" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: var(--md-typeset-a-color); text-decoration: none; word-break: break-word; transition: color 125ms;">Testlib</a>，建议使用Testlib。</p></details><p>DOMJudge 使用的 Testlib 及导入 Polygon题目包方式的文档：https://github.com/cn-xcpc-tools/testlib-for-domjudge</p><p>DOMJudge 的 <ahref="https://github.com/Kattis/problemtools/blob/master/support/default_validator/">默认比较器</a>自带了浮点数带精度比较，只需要在题目配置的 <code>validator_flags</code>中添加 <code>float_tolerance 1e-3</code> 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WA 43</span></span><br><span class="line"><span class="type">char</span> reportfile[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * argv[1]: 输入</span></span><br><span class="line"><span class="comment">   * argv[2]: 标准输出</span></span><br><span class="line"><span class="comment">   * argv[3]: 评测信息输出的文件夹</span></span><br><span class="line"><span class="comment">   * stdin: 选手输出</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  FILE* fin = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  FILE* fstd = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(reportfile, <span class="string">&quot;%s/judgemessage.txt&quot;</span>, argv[<span class="number">3</span>]);</span><br><span class="line">  FILE* freport = <span class="built_in">fopen</span>(reportfile, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> pans, jans;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;pans);</span><br><span class="line">  <span class="built_in">fscanf</span>(fstd, <span class="string">&quot;%lf&quot;</span>, &amp;jans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span>(pans - jans) &lt; <span class="number">1e-3</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(freport, <span class="string">&quot;Good job\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> AC;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(freport, <span class="string">&quot;Too big or too small, expected %f, found %f\n&quot;</span>, jans,</span><br><span class="line">            pans);</span><br><span class="line">    <span class="keyword">return</span> WA;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 Kattis Problem Tools 提供的头文件 <ahref="https://github.com/Kattis/problemtools/blob/master/examples/different/output_validators/different_validator/validate.h">validate.h</a>编写，以实现更加复杂的功能。</p><h2 id="参考资料">参考资料</h2><p><a href="https://loj.ac/article/124">LibreOJ 支持 testlib检查器啦！</a> <ahref="https://oi-wiki.org/tools/special-judge/#fnref:1">↩︎</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>argc、argv</title>
      <link href="/2023/11/03/%5Bobject%20Object%5D/C++/argc,argv/"/>
      <url>/2023/11/03/%5Bobject%20Object%5D/C++/argc,argv/</url>
      
        <content type="html"><![CDATA[<h1 id="argcargv">argc、argv</h1><h2 id="int-mainint-argcchar-argv">int main(int argc,char *argv [])</h2><p><code>int argc</code> 和 <code>char *argv[]</code> 是通常在 C 和 C++中用于处理命令行参数的两个参数，它们用于从命令行获取程序启动时传递给程序的参数信息。</p><ol type="1"><li><code>int argc</code>（ArgumentCount）：表示命令行参数的数量，即在程序启动时传递给程序的参数的个数。参数至少包括了程序名称本身，因此至少为1。</li><li><code>char *argv[]</code>（ArgumentVector）：是一个指向字符指针数组的指针，用于存储命令行参数的字符串。每个字符串表示一个命令行参数。<strong><code>argv[0]</code>通常存储程序的名称</strong>，而<code>argv[1]</code>、<code>argv[2]</code>等存储传递给程序的其他参数。</li></ol><span id="more"></span><h2 id="实例">实例</h2><p><strong><code>a.cpp</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// argc 表示参数的数量，包括程序名称本身</span></span><br><span class="line">    <span class="comment">// argv 是一个指向参数字符串的数组</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;argc = &quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印每个命令行参数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;argv[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户不提供参数">1. 用户不提供参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\a.exe</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311032300431.png"alt="image-20231103230027354" /><figcaption aria-hidden="true">image-20231103230027354</figcaption></figure><h3 id="用户提供参数">2. 用户提供参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\a.exe 0 1 2</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311032301519.png"alt="image-20231103230121475" /><figcaption aria-hidden="true">image-20231103230121475</figcaption></figure><blockquote><ul><li><strong><code>argv[0]</code>由OS自动赋值，存储程序的名称</strong></li><li><strong><code>argc≥1</code></strong></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型的精度及范围</title>
      <link href="/2023/10/20/%5Bobject%20Object%5D/C++/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E5%BA%A6%E5%8F%8A%E8%8C%83%E5%9B%B4/"/>
      <url>/2023/10/20/%5Bobject%20Object%5D/C++/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E5%BA%A6%E5%8F%8A%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310200836229.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="基本数据类型的精度及范围">基本数据类型的精度及范围</h1><h2 id="整型">整型</h2><table style="width:100%;"><colgroup><col style="width: 26%" /><col style="width: 5%" /><col style="width: 26%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">字节数</th><th style="text-align: center;">取值范围1</th><th style="text-align: center;">取值范围2</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>char</code></td><td style="text-align: center;">1</td><td style="text-align: center;"><spanclass="math display">\[-2^{7}\]</span> ~ <spanclass="math display">\[2^{7}-1\]</span></td><td style="text-align: center;">-128 ~ 127</td></tr><tr class="even"><td style="text-align: center;"><code>unsigned char</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{8}-1\]</span></td><td style="text-align: center;">0 ~ 255</td></tr><tr class="odd"><td style="text-align: center;"><code>short</code></td><td style="text-align: center;">2</td><td style="text-align: center;"><spanclass="math display">\[-2^{15}\]</span> ~ <spanclass="math display">\[2^{15}-1\]</span></td><td style="text-align: center;"><span class="math display">\[-3.2\times10^{4}\]</span> ~ <span class="math display">\[3.2\times10^{4}\]</span></td></tr><tr class="even"><td style="text-align: center;"><code>unsigned short</code></td><td style="text-align: center;">2</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{16}-1\]</span></td><td style="text-align: center;">0 ~ <spanclass="math display">\[6.5\times 10^{4}\]</span></td></tr><tr class="odd"><td style="text-align: center;"><code>int</code>/<code>long</code></td><td style="text-align: center;">4</td><td style="text-align: center;"><spanclass="math display">\[-2^{31}\]</span> ~ <spanclass="math display">\[2^{31}-1\]</span></td><td style="text-align: center;"><span class="math display">\[-2.1\times10^{9}\]</span> ~ <span class="math display">\[2.1\times10^{9}\]</span></td></tr><tr class="even"><tdstyle="text-align: center;"><code>unsigned int</code>/<code>unsigned long</code></td><td style="text-align: center;">4</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{32}-1\]</span></td><td style="text-align: center;">0 ~ <spanclass="math display">\[4.2\times 10^{9}\]</span></td></tr><tr class="odd"><td style="text-align: center;"><code>long long</code></td><td style="text-align: center;">8</td><td style="text-align: center;"><spanclass="math display">\[-2^{63}\]</span> ~ <spanclass="math display">\[2^{63}-1\]</span></td><td style="text-align: center;"><span class="math display">\[-9.2\times10^{18}\]</span> ~ <span class="math display">\[9.2\times10^{18}\]</span></td></tr><tr class="even"><td style="text-align: center;"><code>unsigned long long</code></td><td style="text-align: center;">8</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{64}-1\]</span></td><td style="text-align: center;">0 ~ <spanclass="math display">\[1.8\times 10^{19}\]</span></td></tr></tbody></table><h2 id="浮点型">浮点型</h2><table><colgroup><col style="width: 16%" /><col style="width: 7%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">字节数</th><th style="text-align: center;">取值范围（绝对值）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>float</code></td><td style="text-align: center;">4</td><td style="text-align: center;"><spanclass="math display">\[1.17549\times 10^{-38}\]</span> ~ <spanclass="math display">\[3.40282\times 10^{38}\]</span></td></tr><tr class="even"><td style="text-align: center;"><code>double</code></td><td style="text-align: center;">8</td><td style="text-align: center;"><spanclass="math display">\[2.22507\times 10^{-308}\]</span> ~ <spanclass="math display">\[1.79769\times 10^{308}\]</span></td></tr><tr class="odd"><td style="text-align: center;"><code>long double</code></td><td style="text-align: center;">12</td><td style="text-align: center;"><spanclass="math display">\[2.22507\times 10^{-308}\]</span> ~ <spanclass="math display">\[1.79769\times 10^{308}\]</span></td></tr></tbody></table><span id="more"></span><blockquote><p><ahref="https://blog.csdn.net/qq_52911954/article/details/125528446">C语言——数据类型、基本数据类型的取值范围_c语言数据类型取值范围_Lydialyy的博客-CSDN博客</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2023/10/15/%5Bobject%20Object%5D/C++/%E6%8C%87%E9%92%88/"/>
      <url>/2023/10/15/%5Bobject%20Object%5D/C++/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="指针">指针</h2><h3 id="用法一">用法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> *p; <span class="comment">// p是空指针，没有分配内存单元</span></span><br><span class="line"><span class="comment">//*p=4错误</span></span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><h3 id="用法二">用法二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// p分配了内存单元，存有内存单元的地址</span></span><br><span class="line">*p = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑代数</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/others/%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/others/%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑代数">逻辑代数</h1><h2 id="基本逻辑运算">基本逻辑运算</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301150172.png"alt="image-20240430115038841" /><figcaption aria-hidden="true">image-20240430115038841</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301152471.png"alt="image-20240430115252271" /><figcaption aria-hidden="true">image-20240430115252271</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301153245.png"alt="image-20240430115321044" /><figcaption aria-hidden="true">image-20240430115321044</figcaption></figure><span id="more"></span><h2 id="复合逻辑运算">复合逻辑运算</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301155101.png"alt="image-20240430115523925" /><figcaption aria-hidden="true">image-20240430115523925</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301155685.png"alt="image-20240430115553499" /><figcaption aria-hidden="true">image-20240430115553499</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301156087.png"alt="image-20240430115613884" /><figcaption aria-hidden="true">image-20240430115613884</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301156374.png"alt="image-20240430115633198" /><figcaption aria-hidden="true">image-20240430115633198</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301156608.png"alt="image-20240430115658399" /><figcaption aria-hidden="true">image-20240430115658399</figcaption></figure><h2 id="逻辑运算基本公式">逻辑运算基本公式</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301157228.png"alt="image-20240430115750051" /><figcaption aria-hidden="true">image-20240430115750051</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404301158370.png"alt="image-20240430115810190" /><figcaption aria-hidden="true">image-20240430115810190</figcaption></figure><h2 id="根据逻辑代数编写条件语句">根据逻辑代数编写条件语句</h2><p>​ 比如，我们希望 <code>A == 0</code> 且 <code>B == 0</code> 且<code>C == 0</code> 时条件成立，其余情况均不成立，则有以下 3 种写法</p><ul><li>原始写法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A == <span class="number">0</span> &amp;&amp; B == <span class="number">0</span> &amp;&amp; C == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>逻辑代数写法1</li></ul><p><span class="math display">\[\bar{A}\bar{B}\bar{C}\]</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!A &amp;&amp; !B &amp;&amp; !C)</span><br></pre></td></tr></table></figure><ul><li>逻辑代数写法2</li></ul><p><span class="math display">\[\bar{A}\bar{B}\bar{C}=\overline{A+B+C}\]</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(A || B || C))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/ERROR/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/ERROR/</url>
      
        <content type="html"><![CDATA[<h1 id="算法error">算法Error</h1><ul><li><p><strong><code>AC</code></strong>——Accepted 答案正确/通过</p></li><li><p><strong><code>WA</code></strong>——Wrong Answer 答案错误</p><ul><li><p><font color = 'red'><strong>局部变量定义后一定要初始化，尤其是数组</strong></font>，否则变量初始值就是<strong>随机数</strong>，会出现各种奇葩的问题，例如</p><ul><li>Wrong Answer 答案错误</li><li>同一代码，同一测试样例，多次运行结果不一样</li><li>Segmentation Fault</li></ul><p>因此建议将<font color = 'red'><strong>所有变量（尤其是数组）都定义为全局变量</strong></font>，如果数组定义为局部变量，记得一定要初始化（eg：<code>int a[3][5] = &#123;0&#125;</code>）</p></li><li><p><code>LL</code> 错误使用 <code>%d</code> 输出，必须使用<code>%ld</code> 输出</p></li><li><p><code>if</code> / <code>while</code> /<code>for</code>后面错误加上 <code>;</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(check(x));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++);</span><br><span class="line"><span class="keyword">while</span>(n --);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>RE</code></strong>——Runtime Error运行时错误</p></li><li><p><strong><code>CE</code></strong>——Complie Error 编译错误</p><ul><li>语法有问题</li></ul></li><li><p><strong><code>TLE</code></strong>——Time Limit Exceed 运行超时</p><ul><li><span class="math inline">\(dfs\)</span>​ 无限递归，导致超时</li><li>邻接表未初始化 <code>memset(h, -1, sizeof h);</code></li><li>多组测试样例最后忘写 <code>!= -1</code>了<code>while(scanf("%s%s", s, t) != -1)</code></li></ul></li><li><p><strong><code>MLE</code></strong>——Memory Limit Exceed超出内存限制</p><ul><li><p><span class="math inline">\(dfs\)</span>无限递归，导致栈溢出</p></li><li><p>超出 <span class="math inline">\(1.6 * 10^7\)</span>的最大内存</p></li></ul></li><li><p><strong><code>PE</code></strong>——Presentation Error格式错误</p></li><li><p><strong><code>OLE</code></strong>——Output Limit Exceed输出超出限制/输出超限</p></li><li><p><strong><code>UKE</code></strong>——Unknown Error未知错误</p></li></ul><span id="more"></span><h1 id="c-error">C++ Error</h1><h2 id="float-point-exception">Float Point Exception</h2><ul><li>除 <code>0</code></li></ul><h2 id="error-expected-initializer-before-int">error: expectedinitializer before 'int'</h2><p>通常是前面一行末尾没有加 <code>;</code></p><h2 id="reference-to-xxx-is-ambiguous">reference to 'XXX' isambiguous</h2><h3 id="原因">原因</h3><blockquote><p><strong>自定义的变量与库中重名</strong></p></blockquote><h3 id="解决">解决</h3><p>​ <strong>修改变量名</strong>，避免使用以下变量</p><ul><li><code>left</code> ==&gt; <code>l</code></li><li><code>right</code> ==&gt; <code>r</code></li><li><code>size</code> ==&gt; <code>sz</code></li><li><code>next</code> ==&gt; <code>ne</code></li><li><code>start</code>==&gt;<code>st</code>/<code>S</code></li></ul><blockquote><p><code>st</code> 有可能与状态数组 <code>st[]</code>重名，如果重名请使用 <code>S</code></p></blockquote><ul><li><code>end</code>==&gt;<code>ed</code>/<code>T</code>(terminal)</li><li><code>max</code>==&gt;<code>maxv</code></li><li><code>min</code>==&gt;<code>minv</code></li></ul><!--more--><h2 id="invalid-types-intint-for-array-subscript">invalid types'int[int]' for array subscript</h2><p>这通常是数组的问题，我目前总结出3种可能：</p><ol type="1"><li>数组变量名不一致，或者没定义，比如你定义了一个ans数组，但是你在用的时候误写成了a数组（oj应该爆CE）</li><li>数组空间不够，比如你要访问a[6]，可是你只定义了inta[6]数组，所以下标最多到5，定义改成7就行了。（oj应该爆RE）</li><li><strong>变量名和数组名重复定义</strong>，比如定义了一个inta;然后又定义了一个int a[6];数组，（oj应该爆CE吧）</li></ol><h2 id="segmentation-fault">Segmentation Fault</h2><p>主要有 2 个原因</p><ul><li><p><strong>数组越界</strong>：比如</p><ul><li>你要访问<code>a[6]</code>，可是你只定义了<code>int a[6]</code>数组，所以下标最多到5，定义改成 7 就行了</li><li>循环的条件 <code>j++</code> 写成 <code>i++</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; i++)</span><br></pre></td></tr></table></figure><ul><li>循环条件<code>i–-</code>写成了<code>i++</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure><ul><li><font color = 'red'><strong>变量定义一定要初始化，尤其是数组</strong></font>，否则变量初始值就是随机数，会出现各种奇葩的问题，建议将<font color = 'red'><strong>所有数组都定义在全局变量</strong></font></li></ul></li><li><p>输入有误，漏写%d</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n, &amp;m);</span><br></pre></td></tr></table></figure></li><li><p>无向树的邻接表中，边数没有设置为 <spanclass="math inline">\(2N\)</span></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无向树，Segmentation Fault</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], w[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无向树，正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br></pre></td></tr></table></figure><ul><li><p><strong>函数无限递归/递归次数太多了</strong>，爆栈</p></li><li><p><code>while</code> 循环多了一个 <code>;</code></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s) != <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><ul><li><code>main()</code>函数内定义的变量<strong>没有赋初始值</strong>，导致其为<strong>任意值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">// 未赋值，其值任意</span></span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/video/468/">AcWing 416. 麦森数 -AcWing</a></p><h2id="error-no-matching-function-for-call-to-maxint-stdbasic_stringsize_type">error:no matching function for call to 'max(int&amp;,std::basic_string<char>::size_type)'</h2><ul><li><p><code>max()/min()</code>函数必须传入两个<strong>同类型的参数</strong></p></li><li><p><code>.length()</code> 和 <code>.size()</code>的返回类型都是<code>size_t</code>，使用时要在前面加上<code>(int)</code>强制类型转换</p></li></ul><h2 id="collect2-error-ld-returned-1-exit-status">collect2: error: ldreturned 1 exit status</h2><p>完整的报错信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccTm771g.o: In function `__static_initialization_and_destruction_0(int, int)&#x27;:</span><br><span class="line">a.cpp:(.text+0xd1): relocation truncated to fit: R_X86_64_32 against `.bss&#x27;</span><br><span class="line">a.cpp:(.text+0xe0): relocation truncated to fit: R_X86_64_32 against `.bss&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>​ 数组定义/声明的太大了（超过 <span class="math inline">\(1.6\times10^7\)</span> 个 <code>int</code> 大小），造成内存溢出</p><p><strong>解决办法：</strong></p><ul><li>将数组大小降到 <span class="math inline">\(10^7\)</span> 以下</li><li>改进算法（eg：哈希离散化、快速幂）</li></ul><h2 id="数组越界">数组越界</h2><p>如果数组越界，什么错误都有可能发生</p><ul><li>Segmentation Fault</li><li>TLE——Time Limit Exceed 运行超时</li><li>RE——Runtime Error</li><li>WA——Wrong Answer 答案错误</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《骗分导论》</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%8A%E9%AA%97%E5%88%86%E5%AF%BC%E8%AE%BA%E3%80%8B/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%8A%E9%AA%97%E5%88%86%E5%AF%BC%E8%AE%BA%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="骗分导论第-7-版">《骗分导论》（第 7 版）</h1><p>[TOC]</p><h2 id="前言">前言</h2><ul><li><ahref="https://fidel.js.org/2020/10/07/the-new-guide-of-cheating-in-oi/">【转载】蒟蒻的宝书- 新版骗分导论 | Fidel's Lab</a></li></ul><p>​ 文中类似<code>[*]</code>、<code>[**]</code>等的符号代表我对文章所做的注释<del>（并不是打错字了，也不是屏蔽语）</del>，其对应解释在文章末尾。</p><h2 id="第1章-绪论">第1章 绪论</h2><p>在 Oier 中，有一句话广为流传：任何蒟蒻必须经过大量的刷题练习才能成为大牛乃至于神牛。 这就是著名的 lzn定理。然而，我们这些蒟蒻们，没有经过那么多历练，却要和大牛们同场竞技，我们该怎么以弱胜强呢？答案就是：<strong>骗分</strong>。</p><p>那么，骗分是什么呢？骗分就是用简单的程序（比标准算法简单很多，保证蒟蒻能轻松搞定的程序），尽可能多得骗取分数。让我们走进这本<strong>《新版骗分导论》</strong>，来学习骗分的技巧，挑战神牛吧！</p><span id="more"></span><h2 id="第2章-从无解出发">第2章 从无解出发</h2><h3 id="无解情况">2.1 无解情况</h3><p>在很多题目中都有这句话：“若无解，请输出 <code>-1</code>.”看到这句话时，骗分的蒟蒻们就欣喜若狂，因为——数据中必定会有无解的情况！那么，只要打出下面这个程序： <code>printf("-1")</code>; 就能得到10 分，甚至 20 分，30 分！</p><p>举个例子： <a href="https://www.luogu.com.cn/problem/P1078">P1078NOIP2012 普及组 文化之旅</a></p><p>这道题看起来很复杂，但其中有振奋人心的一句话<em>“输出-1”</em>，我考试时就高兴坏了<del>（当时我才初一，水平太烂）</del> ，随手打了个<code>printf("-1");</code>,得 10 分。</p><blockquote><p>还有一道题：[P8819 <ahref="https://www.luogu.com.cn/problem/P8819">CSP-S 2022]星战</a>：全部输出 <code>no</code> 即可得到 45 分<del>（CCF拿脚造的数据吧……）</del></p><p>但是相应的，2022 年的 CSP-S 分数线暴涨，比往年多了七八十分。</p><p><del>顺便玩一下梗</del>：https://www.luogu.com.cn/discuss/525529</p></blockquote><h3 id="样例白送的分数">2.2 样例——白送的分数</h3><p>每道题目的后面，都有一组 <em>“样例输入”</em> 和 <em>“样例输出”</em>。它们的价值极大，不仅能初步帮你检验程序的对错（特别坑的样例除外），而且，如果你不会做这道题（这种情况蒟蒻们已经司空见惯了），你就可以直接输出样例！例如美国的USACO，它的题目有一个规则，就是第一组数据必须是样例。那么，只要你输出所有的样例，你就能得到100 分（满分 1000 分）！这是相当可观的分数了。</p><p>现在，你已经掌握了最基础的骗分技巧。只要你会基本的输入输出语句，你就能实现这些骗分方法。那么，如果你有一定的基础，请看下一章——我将教你怎样用简单方法骗取部分分数。</p><h2 id="第3章-艰苦朴素永不忘">第3章 “艰苦朴素永不忘”</h2><p>本章的标题来源于《学习雷锋好榜样》的一句歌词，但我不是想教导你们学习雷锋精神，而是学习骗分！</p><p>看到“朴素”两个字了吗？它们代表了一类算法[*]，主要有模拟和<code>DFS</code>。下面我就来介绍它们在骗分中的应用。</p><h3 id="模拟">3.1 模拟</h3><p>所谓模拟，就是用计算机程序来模拟实际的事件。例如 NOIP2012的“寻宝”，就是写一个程序来模拟小明上藏宝塔的动作。</p><p>较繁的模拟就不叫骗分了，我这里也不讨论这个问题。</p><p>模拟主要可以应用在骗高级数据结构题上的分，例如线段树。下面举一个例子来说明一下。</p><p><a href="https://www.luogu.com.cn/problem/P2880">P2880 USACO07JANBalanced Lineup G</a></p><p>对于这个例子，大牛们可以写个线段树，而我们蒟蒻，就模拟吧。</p><p>附模拟程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> min = INT_MAX, max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= b; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; min)</span><br><span class="line">            min = h[i];</span><br><span class="line">        <span class="keyword">if</span> (h[i] &gt; max)</span><br><span class="line">            max = h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max - min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序简洁明了，并且能高效骗分。本程序得50分。</p><h3 id="万能钥匙dfs">3.2 万能钥匙——<code>DFS</code>[**]</h3><p><code>DFS</code>是图论中的重要算法，但我们看来，图论神马的都是浮云，关键就是如何骗分。下面引出本书的第22 条定理：<code>DFS</code>是万能的。</p><p>这对于你的骗分是至关重要的。比如说，一些动态规划题，可以<code>DFS</code>；数学题，可以 <code>DFS</code>；剪枝的题，更能<code>DFS</code>。下面以一道省选题为例，解释一下<code>DFS</code>骗分。</p><p>例题： <a href="https://www.luogu.com.cn/problem/P1048">P1048NOIP2005 普及组 采药</a></p><p>这题的方法很简单。我们瞄准 20 的数据来做，可以用<code>DFS</code>枚举方案，然后模拟计算出最优解。</p><p>附一个大致的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; ans)</span><br><span class="line">            ans = c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(d + <span class="number">1</span>, c + w[i]);</span><br><span class="line">    <span class="built_in">DFS</span>(d + <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4章-骗分的关键猜想">第4章 骗分的关键——猜想</h2><h3 id="听天由命">4.1 听天由命</h3><p>如果你觉得你的人品很好，可以试试这一招——输出随机数。</p><p>先看一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">// &lt;ctime&gt;和&lt;cstdlib&gt;必不可少</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">random</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> <span class="comment">// 随机数函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    end++;</span><br><span class="line">    <span class="type">int</span> res = start + (end - start) * <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">unsigned</span>(<span class="built_in">time</span>(<span class="number">0</span>))); <span class="comment">// 利用时间确定随机数种子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">random</span>(<span class="number">1</span>, <span class="number">100</span>)); <span class="comment">// 重复一千次输出 1~100 之间的任意数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关随机数的具体叙述，可以自行<ahref="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=C%2B%2B%20随机数&amp;fenlei=256&amp;rsv_pq=d3f8e017002ad667&amp;rsv_t=c580sKegC7Ff19NF9vEI9tAWiO8y5beJWKKCtRAReNomFOPDStrMr4SCpl4&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=6&amp;rsv_sug1=6&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;prefixsug=%26lt%3B%2B%2B%20%E9%9A%8F%E6%9C%BA%E6%95%B0&amp;rsp=4&amp;inputT=3869&amp;rsv_sug4=3954">百度</a>（<ahref="https://www.cnblogs.com/xiaokang01/p/9786751.html">可参考</a>）</p><p>这种方法适用于输出一个整数（或判断是否）的题目中，答案的范围越小越好。让老天决定你的得分吧。</p><p>据说，在 NOIP2013 中，有人最后一题不会，愤然打了个随机数，结果得了 70分啊!!</p><h3 id="猜测答案">4.2 猜测答案</h3><p>有些时候，问题的答案可能很有特点：对于大多数情况，答案是一样的。这时，骗分就该出手了。你需要做的，就是发掘出这个答案，然后直接输出。</p><p>有时，你需要运用第 3章中学到的知识，先写出朴素算法，然后造一些数据，可能就会发现规律。</p><p>例如，本班月赛中有一道题：</p><blockquote><p>### 炸毁计划</p><p>#### 【问题描述】</p><p>皇军侵占了通往招远的黄金要道。为了保护渤海通道的安全，使得黄金能够顺利地运送到敌后战略总指挥地延安，从而购买战需武器，所以我们要通过你的程序确定这条战略走廊是否安全。已知我们有N座小岛，只有使得每一个小岛都能与其他任意一个小岛联通才能保证走廊的安全。每个小岛之间只能通过若干双向联通的桥保持联系，已知有M座桥(Ai,Bi)表示第i座桥连接了Ai与Bi这两座城市。现在，敌人的炸药只能炸毁其中一座桥，请问在仅仅炸毁这一座桥的情况下，能否保证所有岛屿安全，都能联通起来。现在给出Q个询问Ci，其中Ci表示桥梁编号，桥梁的编号按照输入顺序编号。每个询问表示在仅仅炸毁第Ci座桥的情况下能否保证所有岛屿安全。如果可以，在输出文件当中，对应输入顺序输出yes，否则输出no（输出为半角英文单词，区分大小写，默认为小写，不含任何小写符号，每行输出一个空格，忽略文末空格）。</p><p>#### 【输入格式】</p><p>第一行 三个整数N，M，Q，分别表示岛屿的个数，桥梁的个数和询问的个数。第二行到第M+1行 每行两个整数。第i+1行有两个整数Ai Bi表示这个桥梁的属性。第M+2行 有Q个整数Ci表示查询。</p><p>#### 【输出格式】</p><p>Q行，表示查询结果。</p><p>#### 【样例】</p><p>destroy.in destroy.out</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1 1</span><br><span class="line">1 2</span><br><span class="line">1 no</span><br></pre></td></tr></table></figure></p><p>#### 【样例范围】</p><p>对于80%的数据，N≤100。 对于100%的数据，N≤1000，N,Q≤M≤2000 。</p></blockquote><p>你发现问题了吗？那么多座桥，炸一座就破坏岛屿的联系，可能性微乎其微（除非特别设计数据）。那么，我们的骗分策略就出来了：对于所有询问，输出<code>yes</code>.果然，此算法效果不错，得 80 分。</p><p>现在知道猜测答案的厉害了吧？</p><h3 id="寻找规律">4.3 寻找规律</h3><p>首先声明：<strong>本节讲的规律不是正当的算法规律，而是数据的特点。</strong></p><p>某些题目会给你很多样例，你就可以观察他们的特点了。有时，数据中的某一个（或几个）数，能通过简单的关系直接算出答案。</p><p>只要你找到了规律，在很多情况下你都能得到可观的分数。</p><p>这样的题目大多出现在 NOI或更高等级的比赛中，本人蒟蒻一个，就不举例了。传说某人去省选时专门琢磨数据的规律，结果有一题得了30 分。</p><h3 id="小数据杀手打表">4.4 小数据杀手——打表</h3><p>我认识一个人，他在某老师家上<code>C语言</code>家教，老师每讲一题，他都喊一句：“打表行吗？”</p><p>他真的是打表的忠实粉丝。表虽然不能乱打，但还是很有用的。</p><p>先看一个例子：</p><p><strong><a href="https://www.luogu.com.cn/problem/P1044">NOIP2003栈</a></strong></p><p>这题看似复杂，但数据范围太小，<spanclass="math inline">\(N≤18\)</span>。所以，骗分程序就好写了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">18</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">42</span>, <span class="number">132</span>, <span class="number">429</span>, <span class="number">1430</span>, <span class="number">4862</span>, <span class="number">16796</span>, <span class="number">58786</span>, <span class="number">208012</span>, <span class="number">742900</span>, <span class="number">2674440</span>, <span class="number">9694845</span>, <span class="number">35357670</span>, <span class="number">129644790</span>, <span class="number">477638700</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[n - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>测试结果不言而喻，<strong>AC</strong>了。</p><p>学完这一章，你已基本掌握了骗分技巧。下面的内容涉及一点算法知识，难度有所增加。蒟蒻中的蒟蒻可以止步于此了。</p><h2 id="第5章-做贪心的人">第5章 做贪心的人</h2><h3 id="贪心的算法">5.1 贪心的算法</h3><p>给你一堆纸币，让你挑一张，相信你一定会挑面值最大的。其实，这就是贪心算法。</p><p>贪心算法是个复杂的问题，但你不用管那么多。我们只关心骗分。给你一个问题，让你从一些东西中选出一些，你就可以使用贪心的方法，尽量挑好的。</p><p>举个例子：这是我们的市队选拔的一道题。</p><blockquote><p>### 有趣的问题</p><p>#### 【问题描述】</p><p>2013 年的 NOIP 结束后， Smart发现自己又被题目碾压了，心里非常地不爽，于是暗下决心疯狂地刷数学题目，做到天昏地暗、废寝忘食，准备在今年的中考中大展身手。有一天，他在做题时发现了一个有趣的问题： 给定n 个二元组(ai, bi)i)，记函数： <span class="math inline">\(y=100*\sum{\left( a_i\right)}/\sum{\left( b_i \right)}\)</span>; 将函数y 的值四舍五入取整。现将n 个二元组去掉其中的k 个计算一个新的y值（也四舍五入取整），均能满足：y &lt;= z ，求出最小的z值。Smart想让你帮他一起找出最小的z值。</p><p>#### 【输入格式】</p><p>输入包含多组测试数据。每组测试数据第一行两个整数：n和k；第二行为n个数：a1 a2 …… an；第三行为n 个数： b1 b2 …… bn。 输入数据当n、k 均为0时结束。</p><p>#### 【输出格式】</p><p>对于每组测试数据输出一行，即找出的最小的冘值。注意：为避免精度四舍五入出现误差，测试点保证每个函数值与最终结果的差值至少为0.001 。</p><p>#### 【样例】</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">math.in</span><br><span class="line">3 1</span><br><span class="line">5 0 1</span><br><span class="line">5 1 6</span><br><span class="line">4 2</span><br><span class="line">1 2 7 9</span><br><span class="line">5 6 7 9</span><br><span class="line">0 0</span><br><span class="line">math. out</span><br><span class="line">83</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p><p>#### 【数据范围】</p><p>对于40% 的数据： n≤20； 对于70% 的数据： n≤1000； 对于100% 的数据：n≤10000，ai,bi 都在 int 范围内。</p></blockquote><p>这题让人望而生畏，但我们有贪心的手段。每个二元组的 <spanclass="math inline">\(a\)</span> 值是乘到答案中的，所以 <spanclass="math inline">\(a\)</span> 越大越好，那么只要选择出最小的 <spanclass="math inline">\(k\)</span>个去掉即可。代码就不写了，因为这个涉及到下一章的内容：排序。</p><p>此代码得20分。</p><h3 id="贪心地得分">5.2 贪心地得分</h3><p>我们已经学了很多骗分方法，但他们中的大多效率并不高，一般能骗10∼2010∼20 分。这不能满足我们的贪心。</p><p>然而，我们可以合成骗分的程序。举个最简单的例子，有些含有无解情况的题目，</p><p>它们同样有样例。我们可以写这个程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (是样例)</span><br><span class="line">    <span class="built_in">printf</span>(样例);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;- 1&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样也许能变 1010 分为 2020 分，甚至更多。</p><p>当然，合并骗分方法时要注意，不要重复骗同一种情况，或漏考虑一些情况。</p><p>大量能骗分的问题都能用此法，大家可以试试用新方法骗2.1中的例子“文化之旅”。</p><h2 id="第6章-c-的福利">第6章 C++ 的福利</h2><p><em>（请 P 党们跳过本章，这不是你们的福利）</em></p><p>在 <code>C++</code>中，有一个好东西，名唤<strong><code>STL</code></strong> ，被万千 Oier们所崇拜，所喜爱。下面让我们走进 <code>STL</code>。</p><h3 id="快速排序">6.1 快速排序</h3><p>快速排序是一个经典算法，也是<code>C++</code>党的经典福利。他们有这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//这是必须的</span></span></span><br><span class="line"><span class="built_in">sort</span>(A, A + n);      <span class="comment">// 对一个下标从0开始存储，长度为n的数组升序排序</span></span><br></pre></td></tr></table></figure><p>就这么简单，完成了 P 党[***]一大堆代码干的事情。</p><h3 id="如意金箍棒">6.2 “如意金箍棒”</h3><p><code>C++</code>里有一种东西，叫<code>vector</code>容器。它好比如意金箍棒，可以随着元素的数量而改变大小。它其实就是数组，却比数组强得多。</p><p>下面看看它的几种操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; V;  <span class="comment">// 定义</span></span><br><span class="line">V.<span class="built_in">push_back</span>(x); <span class="comment">// 末尾增加一个元素x</span></span><br><span class="line">V.<span class="built_in">pop_back</span>();   <span class="comment">// 末尾删除一个元素</span></span><br><span class="line">V.<span class="built_in">size</span>();       <span class="comment">// 返回容器中的元素个数</span></span><br><span class="line"><span class="comment">// 它同样可以使用下标（如 V[n] ）访问。（从0开始）</span></span><br></pre></td></tr></table></figure><h2 id="第7章-宁为玉碎不为瓦全">第7章 “宁为玉碎，不为瓦全”</h2><p>至此，我已介绍完了我所知的骗分方法。如果上面的方法都不奏效，我也无能为力。但是，我还有最后一招——</p><p>有句古话说：<em>“宁为玉碎，不为瓦全”</em>。我们蒟蒻也应有这样的精神。骗不到分，就报复一下，卡评测以泄愤吧！卡评测主要有两种方法：</p><ol type="1"><li>利用死循环，故意超时；</li><li>进入终端，卡住编译器。</li></ol><p>先介绍下第一种。代码很简单，请看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>就是这短短一句话，就能卡住评测机长达 <spanclass="math inline">\(10s\)</span>，<spanclass="math inline">\(20s\)</span>，甚至更多！对于测试点多、时限长的题目，这是个不错的方法。</p><p>第二种方法也很简单，但危害性较大，建议不要在重要比赛中使用，否则可能让你追悔莫及。它就是：[****]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;con&gt;</span>          <span class="comment">//windows系统中使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;/dev/console&gt;</span> <span class="comment">//Linux系统中使用</span></span></span><br></pre></td></tr></table></figure><p>它非常强大，可以卡住评测系统，使其永远停止不了编译你的程序。唯一的解除方法是，工作人员强行关机，重启，重测。当然，我不保证他们不会气愤地把你的成绩变成00 分。请慎用此方法。</p><h2 id="第8章-实战演练">第8章 实战演练</h2><p>下面我们来做一些习题，练习骗分技巧。我们来一起分析一下NOIP2013普及组的试题吧。</p><ol type="1"><li><a href="https://www.luogu.com.cn/problem/P1980">P1980 NOIP2013普及组 计数问题</a></li><li><a href="https://www.luogu.com.cn/problem/P1981">P1981 NOIP2013普及组 表达式求值</a></li><li><a href="https://www.luogu.com.cn/problem/P1982">NOIP2013 普及组小朋友的数字</a></li><li><a href="https://www.luogu.com.cn/problem/P1983">NOIP2013 普及组车站分级</a></li></ol><p>第 11 题，太弱了，不用骗，得 100100 分。</p><p>第 22 题，数据很大，但是可以直接输入一个数，输出它 mod  10000mod10000的值。得 1010 分。</p><p>第 33 题，是一道非常基础的 <code>DP</code>，但对于不知<code>DP</code>为何物的蒟蒻来说，就使用暴力算法（即<code>DFS</code>）。得 2020 分。</p><p>第 44 题，我们可以寻找一下数据的规律，你会发现，在所有样例中， <spanclass="math inline">\(M\)</span> 值即为答案。所以直接输出 <spanclass="math inline">\(M\)</span> ，得 1010 分。</p><p>这样下来，一共得 140140 分，比一等分数线还高 2020分！你的信心一定会得到鼓舞的。这就是骗分的神奇。</p><h2 id="第9章-结语">第9章 结语</h2><p>骗分是蒟蒻的有力武器，可以在比赛中骗得大量分数。相信大家在这本书中收获了很多，希望本书能帮助你多得一些分。但是，最后我还是要说一句：</p><p>不骗分，是骗分的最高境界。不骗分，是骗分的最高境界。</p><hr /><blockquote><p>### 注释</p><p>[*] 【朴素算法】 英文术语为<em>brute-force</em>，也可直译为“暴力求解”。</p></blockquote><blockquote><p>[**] 【<code>DFS</code>】 即“深度优先搜索”算法。</p></blockquote><blockquote><p>[***] 【P 党】 原文如此，应该是指学习<code>Pascal</code>语言的学生。</p></blockquote><blockquote><p>[****] 【<code>#include&lt;con&gt;...</code>】这里应该是只用在代码中加入以上两个头文件即可。不过实际使用时很可能会编译错误。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【对拍代码示例】</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%AF%B9%E6%8B%8D%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E3%80%91/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%AF%B9%E6%8B%8D%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="对拍代码示例">对拍代码示例</h1><p>题目：<a href="https://www.acwing.com/problem/content/2/">AcWing 2.01背包问题</a></p><h2 id="dp写法">DP写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v; j -- )</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="暴力写法">暴力写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sumv = <span class="number">0</span>, sumw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sumv += v[j];</span><br><span class="line">                sumw += w[j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (sumv &lt;= m) res = <span class="built_in">max</span>(res, sumw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><h2 id="数据生成器代码">数据生成器代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>, m = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">50</span>;</span><br><span class="line">    fout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">rand</span>() % <span class="number">50</span> + <span class="number">10</span>, w = <span class="built_in">rand</span>() % <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">        fout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;iteration: %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">generate_data</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;Dp.exe &lt; input.txt &gt; dp_output.txt&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;bruteforce.exe &lt; input.txt &gt; bf_output.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">&quot;fc dp_output.txt bf_output.txt&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;错啦!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV vs Resume</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/CV%20vs%20Resume/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/CV%20vs%20Resume/</url>
      
        <content type="html"><![CDATA[<h1 id="学术">学术</h1><h2 id="cv">CV</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403110913323.png"alt="image-20240311091351193" /><figcaption aria-hidden="true">image-20240311091351193</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403110913499.png"alt="image-20240311091339390" /><figcaption aria-hidden="true">image-20240311091339390</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403110913567.png"alt="image-20240311091331323" /><figcaption aria-hidden="true">image-20240311091331323</figcaption></figure><p><ahref="https://www.bilibili.com/video/BV1CE411P7vj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【求职求学系列#1】你知道CV和resume的不同吗？还有personalstatememt和cover letter..._哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能头文件</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="万能头文件">万能头文件</h1><h2 id="介绍">介绍</h2><p>万能头文件<strong><code>#include &lt;bits/stdc++.h&gt;</code></strong>==<strong>包含了目前c++所包含的所有头文件！！！！</strong>==</p><span id="more"></span><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看我们开挂以后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol type="1"><li>使用万能头文件<font color='red'><strong>不会影响运行速度，只是会略微增加编译时间</strong></font>。考试的时候编译时间不会被计算在运行时间里，只是在debug的时候每次编译都会慢一点，如果不care这一点的话那使用万能头文件会方便一些~</li><li>使用场景：当我们==<strong>忘记</strong>==<strong>某函数的头文件</strong>或者<strong>头文件较多</strong>时，可以用<strong><code>#include&lt;bits/stdc++.h&gt;</code></strong>代替。</li><li>缺点：<ul><li><strong>编译时间太长</strong>。</li><li><strong><code>#include &lt;bits/stdc++.h&gt;</code></strong>不是c++的标准头文件，部分编译器不支持。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏定义</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="宏定义">宏定义</h1><h2 id="宏常量"><strong>宏常量</strong></h2><p>  我们最常使用到的#define的用法就是用#define来定义一个符号常量，而要修改时,只需修改#define这条语句就行了,不必每处代码都修改例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR <span class="string">&quot;圆周率约等于&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %f&quot;</span>,STR,PI); <span class="comment">//预处理时会被替换为 printf(&quot;%s %f&quot;,&quot;圆周率约等于&quot;,3.14);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>运行结果: <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429733.png"alt="在这里插入图片描述" /></p><h2 id="宏语句"><strong>宏语句</strong></h2><p>  我们还可以用宏定义一条或多条语句 例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Print printf(<span class="string">&quot;hello world!&quot;</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Print;  <span class="comment">//预处理时会被替换为 printf(&quot;hello world!&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>操作结果: <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429680.png"alt="在这里插入图片描述" /></p><h2 id="宏函数"><strong>宏函数</strong></h2><p>  我还可以用宏来定义函数,因为宏定义也可以带参数 例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Print(str) printf(<span class="string">&quot;%s&quot;</span>,str)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Print(<span class="string">&quot;这是一个只有一条语句的宏函数!&quot;</span>);</span><br><span class="line">    <span class="comment">//预处理时会被替换为 printf(&quot;%s&quot;,&quot;这是一个只有一条语句的宏函数!&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429685.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="其它"><strong>其它</strong></h2><p><strong>1.#undef 是用来撤销宏定义的，用法如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.141592654</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI</span></span><br><span class="line"><span class="comment">//下面开始 PI 就失效了</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>2.使用ifndef防止头文件被重复包含和编译</strong></p><p>  这是宏定义的一种，它可以根据是否已经定义了一个变量来进行分支选择，一般用于调试等等.实际上确切的说这应该是预处理功能中三种（宏定义，文件包含和条件编译）中的一种----条件编译。C语言在对程序进行编译时，会先根据预处理命令进行“预处理”。C语言编译系统包括预处理，编译和链接等部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> x <span class="comment">//先测试x是否被宏定义过</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x <span class="comment">//如果没有宏定义下面就宏定义x并编译下面的语句</span></span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//如果已经定义了则编译#endif后面的语句</span></span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>条件指示符#ifndef检查预编译常量在前面是否已经被宏定义。如果在前面没有被宏定义,则条件指示符的值为真，于是从#ifndef到#endif之间的所有语句都被包含进来进行编译处理。相反，如果#ifndef指示符的值为假，则它与#endif指示符之间的行将被忽略。条件指示符#ifndef的最主要目的是防止头文件的重复包含和编译。　　千万不要忽略了头件的中的#ifndef，这是一个很关键的东西。比如你有两个C文件，这两个C文件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。</p><p>所以还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p><标识>在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDIO_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> xxx <span class="comment">//如果没有定义xxx</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xxx <span class="comment">//定义xxx</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//结束如果</span></span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>这个用法主要是在头文件中，主要是为了防止类重复的include，所以在类的头文件之前加上前面两个，用类名替代xxx，在最后加上最后一句</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转义字符</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="转义字符">转义字符</h1><table><colgroup><col style="width: 17%" /><col style="width: 50%" /><col style="width: 32%" /></colgroup><thead><tr class="header"><th style="text-align: center;">转义字符</th><th style="text-align: center;">字 符 值</th><th style="text-align: center;">输 出 结 果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\'</code></td><td style="text-align: center;">一个单撇号（'）</td><td style="text-align: center;">输出单撇号字符'</td></tr><tr class="even"><td style="text-align: center;"><code>\"</code></td><td style="text-align: center;">一个双撇号（"）</td><td style="text-align: center;">输出双撇号字符"</td></tr><tr class="odd"><td style="text-align: center;"><code>\?</code></td><td style="text-align: center;">一个人问号（?）</td><td style="text-align: center;">输出问号字符?</td></tr><tr class="even"><td style="text-align: center;"><code>\\</code></td><td style="text-align: center;">一个反斜杠（）</td><td style="text-align: center;">输出反斜杠字符\</td></tr><tr class="odd"><td style="text-align: center;"><code>\a</code></td><td style="text-align: center;">警告（alert）</td><td style="text-align: center;">产生声音或视觉信号</td></tr><tr class="even"><td style="text-align: center;"><code>\b</code></td><td style="text-align: center;">退格（backspace）</td><td style="text-align: center;">将光标当前位置后退一个字符</td></tr><tr class="odd"><td style="text-align: center;"><code>\f</code></td><td style="text-align: center;">换页（from feed）</td><td style="text-align: center;">将光标当前位置移到下一页的开头</td></tr><tr class="even"><td style="text-align: center;"><code>\n</code></td><td style="text-align: center;">换行</td><td style="text-align: center;">将光标当前位置移到下一行的开头</td></tr><tr class="odd"><td style="text-align: center;"><code>\r</code></td><td style="text-align: center;">回车（carriagereturn）</td><td style="text-align: center;">将光标当前位置移到本行的开头</td></tr><tr class="even"><td style="text-align: center;"><code>\t</code></td><td style="text-align: center;">水平制表符</td><td style="text-align: center;">将光标当前位置移到下一个Tab位置</td></tr><tr class="odd"><td style="text-align: center;"><code>\v</code></td><td style="text-align: center;">垂直制表符</td><tdstyle="text-align: center;">将光标当前位置移到下一个垂直表对齐点</td></tr><tr class="even"><tdstyle="text-align: center;"><code>\o</code>、<code>\oo</code>、<code>\ooo</code></td><tdstyle="text-align: center;">与该八进制码对应的ASCII字符，其中o表示一个八进制数字</td><td style="text-align: center;">与该八进制码对应的字符</td></tr><tr class="odd"><td style="text-align: center;"><code>\xh[h...]</code></td><tdstyle="text-align: center;">与该十六进制码对应的ASCII字符，其中h代表一个十六进制数字</td><td style="text-align: center;">与该十六进制码对应的字符</td></tr></tbody></table><p><strong>详解</strong></p><blockquote><p><ahref="https://blog.csdn.net/qq_61552595/article/details/124109830?ops_request_misc=%7B%22request%5Fid%22%3A%22169709154416800192287021%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169709154416800192287021&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-124109830-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=转义字符&amp;spm=1018.2226.3001.4187">详解转义字符_小蜗牛~向前冲的博客-CSDN博客</a></p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  输出 %</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%%&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组初始化</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的初始化">数组的初始化</h1><h2 id="局部变量-vs-全局变量">局部变量 vs 全局变量</h2><h3 id="引例">引例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;全局变量初始值：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;局部变量初始值：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全局变量初始值：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">局部变量初始值：</span><br><span class="line"><span class="number">8</span> <span class="number">0</span> <span class="number">43</span> <span class="number">0</span> <span class="number">10363872</span></span><br></pre></td></tr></table></figure><h3 id="结论">结论</h3><ul><li><font color = 'red'><strong>全局</strong>变量的初始值为<strong><span class="math inline">\(0\)</span></strong></font></li><li><font color = 'red'><strong>局部</strong>变量的初始值为<strong>随机数</strong>，而且多次执行初始值不同</font></li></ul><span id="more"></span><h2 id="一维数组初始化">一维数组初始化</h2><ul><li>直接给每个元素赋值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>给一部分赋值，后面的全部为0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>由赋值参数个数决定数组的个数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>数组元素初始化为0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 后面默认为0</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：声明 vs 初始化 vs 赋值</p><ul><li>声明：<code>int a;</code></li><li>初始化：<code>int a = 2;</code>（在声明的时候顺带赋值叫做初始化）</li><li>赋值：<code>a = 2;</code></li></ul></blockquote><h2 id="多维数组初始化">多维数组初始化</h2><p>​ 以下以二维数组为例：</p><ul><li>如果维度比较少，采用一维数组的方式初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;<span class="comment">// 按照行依次赋值</span></span><br></pre></td></tr></table></figure><ul><li>如果维度比较多，采用二维数组的方式初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>定义一个二维数组，并将数组元素全部初始化为 <spanclass="math inline">\(0\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 后面默认为 0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【自定义函数】</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E3%80%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E3%80%91/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E3%80%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义函数">自定义函数</h1><h2 id="将某个数转化为-0p-1-之间">将某个数转化为 0~p-1 之间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="keyword">inline</span> <span class="title">mod</span><span class="params">(LL a, LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a % p) + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((LL)x % p + p) % p</span><br></pre></td></tr></table></figure><ul><li>这里的x也可以是表达式eg：<spanclass="math inline">\(x*a\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((LL)x * a % m+ m) % m</span><br></pre></td></tr></table></figure><blockquote><p><span class="math inline">\(x * a\)</span> 可能会爆掉 int，具体参考算法—数学知识</p></blockquote><h2 id="求多个数的最大小值">求多个数的最大/小值</h2><p>​ 以求四个数中的最<strong>小</strong>/<strong>大</strong>值为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 a, b, c, d 四个数中的最大值</span></span><br><span class="line"><span class="built_in">max</span>(&#123;a, b, c, d&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 a, b, c, d 四个数中的最大值</span></span><br><span class="line"><span class="built_in">min</span>(&#123;a, b, c, d&#125;)</span><br></pre></td></tr></table></figure><p>注意</p><ol type="1"><li><code>min()</code>，<code>max()</code>的多个参数均在<code>&#123;&#125;</code>中</li><li>使用 <code>min(&#123;&#125;)</code> 写法必需要加头文件<code>#include &lt;algorithm&gt;</code></li></ol><blockquote><p>如果不加这个头文件会报错，因为此时只能使用<spanclass="math inline">\(min()\)</span> 传入 <spanclass="math inline">\(2\)</span> 个参数</p></blockquote><span id="more"></span><h2 id="生成mnmle-n的随机数">生成<span class="math inline">\([m，n](m\len)\)</span>的随机数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span><span class="comment">//srand(time(0));</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">random</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() % (n - m + <span class="number">1</span>) + m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//放在主函数main()内部</span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="判断是否为闰年">判断是否为闰年</h2><p>闰年：被 4 整除且不能被 100 整除 或者 可以被 400 整除</p><ul><li><p>闰年：二月29天，一年366天</p></li><li><p>非闰年：二月28天，一年365天</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leap</span>(<span class="params">year</span>):</span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">400</span> == <span class="number">0</span> <span class="keyword">or</span> (year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="求year的天数">求year的天数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">days</span>(<span class="type">int</span> year)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">365</span> + <span class="built_in">leap</span>(year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求year年month月的天数">求year年month月的天数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">days</span>(<span class="type">int</span> year, <span class="type">int</span> month)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (month == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">28</span> + <span class="built_in">leap</span>(year);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">1</span> || month == <span class="number">3</span> || month == <span class="number">5</span> || month == <span class="number">7</span> || month == <span class="number">8</span> || month == <span class="number">10</span> || month == <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求关键字k的第p位">求关键字k的第p位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Radix</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> p)</span><span class="comment">// k 从下标 0 开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k / (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">10</span>, p) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ge = k % <span class="number">10</span>;<span class="comment">// 个位</span></span><br><span class="line">shi = k / <span class="number">10</span> % <span class="number">10</span>;<span class="comment">// 十位</span></span><br><span class="line">bai = k / <span class="number">100</span> % <span class="number">10</span>;<span class="comment">// 百位</span></span><br><span class="line">qian = k / <span class="number">1000</span> % <span class="number">10</span>;<span class="comment">// 千位</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>pow()</code> 的返回值是浮点数，对浮点数直接取模<code>%</code> 会<strong>报错</strong>，必须强制转化为 <code>int</code>之后取模</p></blockquote><h2 id="四舍五入精确到小数点后i位">四舍五入精确到小数点后i位</h2><p>C++默认是<strong>向下取整</strong>的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">rounding</span><span class="params">(<span class="type">double</span> x)</span> <span class="comment">// 四舍五入保留 i 位小数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>(x * <span class="built_in">pow</span>(<span class="number">10</span>, i)) / <span class="built_in">pow</span>(<span class="number">10</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为指定字符">判断是否为“指定字符”</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s=<span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">find</span>(ch)!=string::npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用sort自定义cmp函数">使用sort自定义cmp函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v,<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v,<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式3 */</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v,<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a, stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score)</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a, stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score != b.score ? a.score &gt; b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式3 */</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](stu a, stu b)</span><br><span class="line">     &#123; <span class="keyword">return</span> a.score != b.score ? a.score &gt; b.score : a.number &lt; b.nember; &#125;);</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height != b.height ? a.height &gt; b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](node a, node b)</span><br><span class="line">     &#123; <span class="keyword">return</span> a.height != b.height ? a.height &gt; b.height : a.name &lt; b.name; &#125;);</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对分数 x / y 从小到大排序</span></span><br><span class="line">sort(a, a + cnt, [](PII a, PII b)</span><br><span class="line">     &#123; <span class="keyword">return</span> a.x * b.y &lt; b.x * a.y; &#125;);</span><br></pre></td></tr></table></figure><ul><li>注：类型为void类型时，可以不带return语句，系统会自动加上一个return语句</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403132252291.png"alt="image-20240313225235092" /><figcaption aria-hidden="true">image-20240313225235092</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符数组&amp;&amp;字符串</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84&amp;&amp;%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84&amp;&amp;%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符数组字符串">字符数组&amp;&amp;字符串</h1><h2 id="字符数组">字符数组</h2><p>​我们知道定义一个数组时需要为其指定相应的变量类型。也就是说，定义了数组的类型之后这个数组中的所有变量就都是相同的类型。现在我们就来定义一个<strong>字符数组</strong>，如下：</p><p><code>char hello[5] = &#123;'H','e','l','l','o'&#125;;</code></p><p>​这样我们就定义了一个字符型的数组，对于数组型的变量这样定义是没有问题的，但有两个方面的不足：</p><ol type="1"><li><p>定义的过程比较麻烦，在数组变量初始化时需要逐个写出每一个字符，并在这每一个字符的两端加上一对单引号。</p></li><li><p>在显示字符数组时，我们通常希望能够让其一次性的显示出来，而不是通过循环数组的方式逐个显示这些字符。</p></li></ol><p>​例如上面定义的数组我们想要用printf将其显示出来我们则需要通过循环的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">5</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, hello[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="字符串">字符串</h2><p>​其实，在C语言中支持直接定义<strong>字符串</strong>的方式，定义字符数组，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, hello);</span><br></pre></td></tr></table></figure><p>​注意，我们在定义这个数组时，指定数组的大小为6，也就是说需要申请6个字节的存储空间，而在等号右侧的双引号中我们却只书写了5个字符。这并不是笔误，C语言规定当使用<strong><font color='red'>双引号定义字符串</font></strong>时以==<strong><code>'\0'</code></strong>==作为这个字符串的<strong><font color='blue'>结束标志符</font></strong>，也就是说这个字符串一共有6个字符，分别是<code>'H'</code>、<code>'e'</code>、<code>'l'</code>、<code>'l'</code>、<code>'o'</code>、<code>'\0'</code></p><blockquote><p>关于<code>'\0'</code>读者只需要知道这是一个特殊的字符即可，它表示字符串的结束，它的值为0。</p></blockquote><p>​这样我们就可以通过printf函数将这个字符串直接打印出来。需要注意的是，<strong>当使用<code>printf(“%s”,  )</code>来显示字符串时，我们要确保这个<font color='red'>字符串变量中最后一个结束字符为\0</font>，如果结束字符不是\0则printf在显示这个字符串时，就不知道显示到何处结束，</strong>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">Hello#@($<span class="number">0948</span>#.<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>​也就是说，我们虽然定义了一个字符串，但只定义了5个字符的长度，而使用双引号为其初始化时，这个字符串的<strong>实际大小应该是6</strong>，因为要<strong>追加一个<code>\0</code></strong>，但我们在定义数组大小时只指定其大小是5，所以这个数组中的中只有5个元素是<code>'H'</code>、<code>'e'</code>、<code>'l'</code>、<code>'l'</code>、<code>'o'</code>。而在'o'之后并没有<code>'\0'</code>，所以在<code>printf</code>显示这个字符串时，显示Hello之后，并不知道何时结束，所以就会继续显示，直到遇到一个<code>'\0'</code>为止，于是我们程序就出现了非预期的结果。这样的程序并不是我们提倡的，<strong>我们在定义字符串时一定要为其<font color='red'>多分配一个字符的长度</font>，以便存放<font color='blue'>字符串结束符<code>'\0'</code></font>。</strong>当然，使用双引号定义的字符串可以像使用普通数组一样使用其数组元素，例如ABC运行结果可以看到直接显示字符串和循环显示字符数组中的元素的效果是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(str); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>​在这里我们使用了另一个重要函数sizeof()，它的作用是可以计算出某一个变量或类型的大小，就是占用的内存字节数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d\n&quot;</span>, </span><br><span class="line">        <span class="built_in">sizeof</span>(ch), </span><br><span class="line">        <span class="built_in">sizeof</span>(sh), </span><br><span class="line">        <span class="built_in">sizeof</span>(i), </span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">long</span>), </span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>​请注意，long类型的变量在不同的操作系统下占用字节数可能不同，请参数参见《变量大小》。另外在使用sizeof来计算数组大小时，计算的是数组一共占用内存的字节数，而不是数组的元素元素的个数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br></pre></td></tr></table></figure><p>​ 上面例子的结果是16而不是4。</p><h2 id="输入对比">输入对比</h2><ol type="1"><li>字符数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">50</span>];<span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>字符串</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">50</span>];<span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121407458.png"alt="image-20221010181124750" /><figcaption aria-hidden="true">image-20221010181124750</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串string</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/STL/%E5%AD%97%E7%AC%A6%E4%B8%B2string/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/STL/%E5%AD%97%E7%AC%A6%E4%B8%B2string/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串string">字符串string</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;string&gt;</code></strong></p><blockquote><p><strong>建议写</strong>，在某些OJ平台（如HDOJ），如果不写这个头文件的话，使用string会报错（如下图所示）</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408220048747.png"alt="image-20240822004835357" /><figcaption aria-hidden="true">image-20240822004835357</figcaption></figure><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br></pre></td></tr></table></figure><blockquote><p>生成<strong>空字符串</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 法1 */</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="comment">/* 法2 */</span></span><br><span class="line">string s = str;</span><br></pre></td></tr></table></figure><blockquote><p>将字符串str的内容复制给s；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, i, len)</span></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cstr, i, len)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>将字符串str或cstr中从<strong>下标<spanclass="math inline">\(i\)</span>开始</strong>、<strong>长度为len</strong>的部分作为字符串初值</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, i)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>将字符串str中从<font color='red'><strong>下标i开始</strong></font>到<font color='blue'><strong>字符串结束</strong></font>的部分作为字符串初值</li></ul></blockquote><blockquote><ul><li>这里的str是<strong>string类型变量</strong>，eg：<code>string s(str,3);</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cstr, len)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>以<strong>C_string类型</strong>cstr的<strong>前len个字符</strong>作为字符串s的初值</li><li>这里的==C_string类型是<strong>字符串常量</strong>类型==，eg：<code>string s("abcde",3);</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(num ,c)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>生成<font color='red'><strong>num个 c字符</strong></font>的字符串，c为char类型</p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;                <span class="comment">// 生成空字符串</span></span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;   <span class="comment">// 生成&quot;1234456789&quot;的复制品</span></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 结果为&quot;123&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;0123456&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">// 结果为&quot;01234&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;        <span class="comment">// 结果为&quot;11111&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;       <span class="comment">// 结果为&quot;3456789&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str7</span><span class="params">(str2, <span class="number">1</span>, <span class="number">6</span>)</span></span>;    <span class="comment">// 结果为&quot;234567&quot;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2:&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3:&quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str4:&quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str5:&quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str7:&quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121323094.png"alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><h2 id="方法">方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.size();</span><br></pre></td></tr></table></figure><blockquote><p>字符串 s 的<strong>长度</strong>(unsigned_int)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.length();</span><br></pre></td></tr></table></figure><blockquote><p>字符串 s 的<strong>长度</strong>(int)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><blockquote><p>将字符串 s 清空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">max_size</span>();</span><br></pre></td></tr></table></figure><blockquote><p><code>s.max_size()</code>：返回string对象最多包含的字符数，超出编译器会抛出length_error异常</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.capacity();</span><br></pre></td></tr></table></figure><blockquote><p><code>s.capacity()</code>：返回当前string类在<strong>不重新分配内存</strong>的情况下，能存多少字符（即当前内存支持多少）</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;1234567&quot;</span>)</span></span>; <span class="comment">// string s=&quot;1234567&quot;;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;length=&quot;</span> &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_size=&quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>运行结果：</strong></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size=7</span><br><span class="line">length=7</span><br><span class="line">max_size=9223372036854775807</span><br><span class="line">capacity=15</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">compare</span>()</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>C++字符串支持<strong>比较</strong>操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如<code>str&lt;"hello"</code>)。string比较的原则是<strong>从左往右</strong>，按<strong>字典序</strong>，<strong>逐个字符比较</strong>，直到不同</p></li><li><p><code>s.compare()</code>支持多参数处理，支持用索引值和长度定位子串来进行比较，他返回一个整数来表示比较结果：</p><ul><li><strong>0：相等</strong></li><li><strong>1：大于</strong></li><li><strong>-1：小于</strong></li></ul></li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (A的ASCII码是65，a的ASCII码是97)</span></span><br><span class="line">    <span class="comment">// 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0</span></span><br><span class="line">    <span class="function">string <span class="title">A</span><span class="params">(<span class="string">&quot;aBcd&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">B</span><span class="params">(<span class="string">&quot;Abcd&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">C</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">D</span><span class="params">(<span class="string">&quot;123dfg&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;aBcd&quot; 和 &quot;Abcd&quot;比较------ a &gt; A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(B)：&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(B)&lt;&lt; endl;                          <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;cd&quot; 和 &quot;Abcd&quot;比较------- c &gt; A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B):&quot;</span> &lt;&lt;A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B)&lt;&lt; endl;                <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;cd&quot; 和 &quot;cd&quot;比较 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B, 2, 3):&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由结果看出来：0表示下标，3表示长度</span></span><br><span class="line">    <span class="comment">// &quot;123&quot; 和 &quot;123&quot;比较 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C.compare(0, 3, D, 0, 3)&quot;</span> &lt;&lt;C.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, D, <span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl;    <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>(pos)</span><br></pre></td></tr></table></figure><blockquote><p>返回从<strong>s[pos] 开始一直到结束</strong>的子串</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.substr(pos, num)</span><br></pre></td></tr></table></figure><blockquote><p>返回从 <strong>s[pos] 开始</strong>、<strong>长度为 num</strong>的子串</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;0123456789abcdefghij&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count 是 npos，返回 [pos, size())</span></span><br><span class="line">    string sub1 = a.<span class="built_in">substr</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; sub1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pos 和 pos + count 都在边界内，返回 [pos, pos + count)</span></span><br><span class="line">    string sub2 = a.<span class="built_in">substr</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; sub2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pos 在边界内，pos+count 不在，返回 [pos, size())</span></span><br><span class="line">    string sub4 = a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - <span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 这等效于</span></span><br><span class="line">    <span class="comment">// string sub4 = a.substr(17, 3);</span></span><br><span class="line">    <span class="comment">// 因为 a.size() == 20，pos == a.size() - 3 == 17 而 a.size() - pos == 3</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sub4 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pos 在边界外，抛出</span></span><br><span class="line">        string sub5 = a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() + <span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">        cout &lt;&lt; sub5 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> out_of_range &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pos 超出了字符串的大小\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.empty()</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">s == <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>返回 <span class="math inline">\(s\)</span> 是否为空</p></blockquote><h2 id="举例">举例</h2><p>:sweat_drops:c语言里没有<strong><code>string</code></strong>型的，<strong><code>string</code></strong>在c++里面。但有时候在c++里要用<strong><code>scanf()</code></strong>和<strong><code>printf()</code></strong>输入输出<strong><code>string</code></strong>型字符串，此时可以使用<strong>string</strong> 的成员函数<strong><code>s.c_str()</code></strong>，该函数返回字符串的首字符的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s[<span class="number">0</span>]); <span class="comment">// 不能用&amp;s</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><ul><li><a href="https://www.acwing.com/solution/content/250684/">AcWing2066. 解码 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/&amp;%E7%9A%842%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/&amp;%E7%9A%842%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="的两种使用方法">&amp;的两种使用方法</h1><h2 id="取地址符">取地址符</h2><p>​ 用来获取变量的地址，通常在 <code>=</code> 的右侧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// 这就是取地址符，指针p指向对象a，p里面存的a的地址</span></span><br></pre></td></tr></table></figure><h2 id="引用">引用</h2><p>​C++里面的引用时在变量名之前加一个<code>&amp;</code>符号，比如在函数传入的参数中<code>int &amp;a</code>,那么对这个引用变量<code>a</code>做的所以操作都是<strong>直接对传入的原变量进行操作</strong>，并没有像原来<code>int a</code>一样只是<strong>拷贝一个副本</strong>（传值），运行速度更快</p><span id="more"></span><h3 id="例子">例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">(<span class="type">int</span> &amp;a)</span> <span class="comment">// 传入的是n的引用，相当于直接对n进行了操作,只不过在func函数中换了个名字叫a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">int</span> a)</span> <span class="comment">// 传入的是0这个值，并不会改变main函数中n的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">33</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func_1</span>(n); <span class="comment">// n由0变成了99</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func_2</span>(n); <span class="comment">// 并不会改变n的值，n还是99</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法">用法</h3><h4 id="对函数参数引用">对函数参数引用</h4><p>​相当于在函数内部可以直接<strong>对传入的原变量</strong>进行操作，通常用于需要向函数内传递<strong>大数组</strong>，引用可以省去了对原变量的拷贝，运行速度更快，减少运行时间</p><h4 id="对变量引用减小代码量">对变量引用减小代码量</h4><p>​当某一变量名特别长，且下面要多次使用时，为了减小代码量，我们通常使用引用，相当于对变量起了一个别名。如下面所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// son[p][x &gt;&gt; i &amp; 1]太长了，用 s 引用</span></span><br><span class="line">        <span class="type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!s) s = ++ idx;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈stack</title>
      <link href="/2023/10/11/%5Bobject%20Object%5D/STL/%E6%A0%88stack/"/>
      <url>/2023/10/11/%5Bobject%20Object%5D/STL/%E6%A0%88stack/</url>
      
        <content type="html"><![CDATA[<h1 id="栈stack">栈stack</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;stack&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;ElementType&gt; s;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>ElementType</code>可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。</p></blockquote><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">push</span>()</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>压入栈顶</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>栈顶元素</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p>令<strong><font color='red'>栈顶元素</font>出栈</strong>，<font color='blue'><strong>删除</strong></font>栈顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 stack 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回 stack 中的<font color='red'><strong>元素个数</strong></font></p></blockquote><span id="more"></span><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 0</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, q.<span class="built_in">front</span>(),q.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sailboat:<code>s.pop()</code>无返回值，仅删除栈顶元素。要<strong><font color='blue'>获得</font></strong><font color='red'><strong>栈顶元素</strong></font>还需<code>s.top()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;  q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.size &quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.top &quot;</span>&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;   <span class="comment">//输出栈顶元素 </span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//删除栈顶元素</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.size &quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;  </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.top &quot;</span>&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q.size 5</span><br><span class="line">q.top 5</span><br><span class="line">q.size 4</span><br><span class="line">q.top 4</span><br></pre></td></tr></table></figure></li></ul><hr /><p>:tea:使用 <strong><code>s.top()</code></strong>和<strong><code>s.pop()</code></strong>函数前，必须用<strong><code>s.empty()</code></strong>判断队列==<strong>是否为空</strong>==，否则可能因为<strong>队空</strong>而出现错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用list或vector作为栈的容器，默认是使用deque的。</span></span><br><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; a;</span><br><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.<span class="built_in">top</span>()); <span class="comment">// 取栈项数据</span></span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">3</span>);              <span class="comment">// 将3这个元素入栈a</span></span><br><span class="line">b.<span class="built_in">push</span>(<span class="number">2</span>);              <span class="comment">// 将2这个元素入栈b</span></span><br><span class="line">a.<span class="built_in">pop</span>();                <span class="comment">// 将栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//  判断栈是否为空</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射map</title>
      <link href="/2023/10/10/%5Bobject%20Object%5D/STL/%E6%98%A0%E5%B0%84map/"/>
      <url>/2023/10/10/%5Bobject%20Object%5D/STL/%E6%98%A0%E5%B0%84map/</url>
      
        <content type="html"><![CDATA[<h1 id="映射map">映射map</h1><p>​map提供了“[]”运算符，使得map可以像数组一样使用，所以map也称为“关联数组”，map就是从键（key）到值（value）的映射。例如可以用一个<code>map&lt;string, int&gt; month_name</code>来表示“月份名字到月份编号”的映射，然后用<code>month_name[“July”] = 7</code>这样的方式来赋值</p><blockquote><p>map 会自动将所有的键值对，按照==<strong>键</strong>==从小到大排序</p></blockquote><h2 id="头文件">头文件</h2><p><code>#include &lt;map&gt;</code></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;ElementType, ElementType&gt; m;</span><br></pre></td></tr></table></figure><blockquote><p>这里的ElementType可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等</p><p>哈希表：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;ElementType, ElementType&gt; m;</span><br></pre></td></tr></table></figure></p></blockquote><span id="more"></span><h2 id="方法">方法</h2><p><ahref="https://blog.csdn.net/sevenjoin/article/details/81943864?ops_request_misc=%7B%22request%5Fid%22%3A%22169708750416800215061817%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169708750416800215061817&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81943864-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=map&amp;spm=1018.2226.3001.4187">C++map用法总结</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">begin</span>()         <span class="comment">// 返回指向map头部的迭代器</span></span><br><span class="line">m.<span class="built_in">clear</span>()         <span class="comment">// 删除所有元素</span></span><br><span class="line">m.<span class="built_in">count</span>(elem)     <span class="comment">// 返回指定元素出现的次数</span></span><br><span class="line">m.<span class="built_in">empty</span>()         <span class="comment">// 如果map为空则返回true</span></span><br><span class="line">m.<span class="built_in">end</span>()           <span class="comment">// 返回指向map末尾的迭代器</span></span><br><span class="line">m.<span class="built_in">equal_range</span>()   <span class="comment">// 返回特殊条目的迭代器对</span></span><br><span class="line">m.<span class="built_in">erase</span>()         <span class="comment">// 删除一个元素(输入的参数是pair或者迭代器)</span></span><br><span class="line">m.<span class="built_in">find</span>()          <span class="comment">// 查找一个元素</span></span><br><span class="line">m.<span class="built_in">get_allocator</span>() <span class="comment">// 返回map的配置器</span></span><br><span class="line">m.<span class="built_in">insert</span>()        <span class="comment">// 插入pair</span></span><br><span class="line">m.<span class="built_in">key_comp</span>()      <span class="comment">// 返回比较元素key的函数</span></span><br><span class="line">m.<span class="built_in">max_size</span>()      <span class="comment">// 返回可以容纳的最大元素个数</span></span><br><span class="line">m.<span class="built_in">rbegin</span>()        <span class="comment">// 返回一个指向map尾部的逆向迭代器</span></span><br><span class="line">m.<span class="built_in">rend</span>()          <span class="comment">// 返回一个指向map头部的逆向迭代器</span></span><br><span class="line">m.<span class="built_in">size</span>()          <span class="comment">// 返回map中元素的个数</span></span><br><span class="line">m.<span class="built_in">swap</span>()          <span class="comment">// 交换两个map</span></span><br><span class="line">m.<span class="built_in">lower_bound</span>()   <span class="comment">// 返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line">m.<span class="built_in">upper_bound</span>()   <span class="comment">// 返回键值&gt;给定元素的第一个位置</span></span><br><span class="line">m.<span class="built_in">value_comp</span>()    <span class="comment">// 返回比较元素value的函数</span></span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><p><strong>反片语</strong>输入一些单词，找出所有满足如下条件的单词:该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输入时应保留输入中的大小写，按字典序进行排列(所有大写字母在小写字母的前面)</p><ul><li><p>样例输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ladder came tape soon leader acme RIDE lone Dreis peat ScAlE orb eye Rides dealer NotE derail LaCeS drled noel dire Disk mace Rob dries #</span><br></pre></td></tr></table></figure></li><li><p>样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disk</span><br><span class="line">NotE</span><br><span class="line">derail</span><br><span class="line">drled</span><br><span class="line">eye</span><br><span class="line">ladder</span><br></pre></td></tr></table></figure></li><li><p><strong>代码：</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mapp;</span><br><span class="line">vector&lt;string&gt; words;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将单词s标准化</span></span><br><span class="line"><span class="function">string <span class="title">standard</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">length</span>(); i++)</span><br><span class="line">        t[i] = <span class="built_in">tolower</span>(t[i]);</span><br><span class="line">    <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        words.<span class="built_in">push_back</span>(s);</span><br><span class="line">        string r = <span class="built_in">standard</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (!mapp.<span class="built_in">count</span>(r))</span><br><span class="line">            mapp[r] = <span class="number">0</span>;</span><br><span class="line">        mapp[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapp[<span class="built_in">standard</span>(words[i])] == <span class="number">1</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位集bitset</title>
      <link href="/2023/10/09/%5Bobject%20Object%5D/STL/%E4%BD%8D%E9%9B%86bitset/"/>
      <url>/2023/10/09/%5Bobject%20Object%5D/STL/%E4%BD%8D%E9%9B%86bitset/</url>
      
        <content type="html"><![CDATA[<h1 id="位集bitset">位集bitset</h1><h2 id="基本介绍">基本介绍</h2><p><code>bitset</code> 是标准库中的一个存储 <code>0/1</code>的大小不可变容器。严格来讲，它并不属于 STL。</p><blockquote><p><code>bitset</code> 并不属于 STL，而是一种标准库中的“SpecialContainer”。事实上，它作为一种容器，也并不满足 STL容器的要求。说它是适配器，它也并不依赖于其它 STL容器作为底层实现。——摘自《The C++ Standard Library 2nd Edition》</p></blockquote><p>由于内存地址是按字节即 <code>byte</code> 寻址，而非比特<code>bit</code> ，一个 <code>bool</code> 类型的变量，虽然只能表示<code>0/1</code> , 但是也占了 1 byte 的内存。<code>bitset</code>就是通过固定的优化，使得一个字节的八个比特能分别储存 8 位的<code>0/1</code></p><blockquote><p>简单的来说，bitset就是<strong>压位优化</strong>的0/1数组</p></blockquote><p>在变量只存 <code>0/1</code> 的前提下， <code>bitset&lt;N&gt;</code><strong>占用空间</strong>是 <code>int [N]</code> 的 <spanclass="math inline">\(1/32\)</span>，是 <code>bool [N]</code> 的 <spanclass="math inline">\(1/8\)</span>；计算一些信息时，<code>bitset&lt;N&gt;</code><strong>所需时间</strong>也是 <code>int&lt;N&gt;</code> 的 <spanclass="math inline">\(1/32\)</span> ，是 <code>bool [N]</code> 的 <spanclass="math inline">\(1/8\)</span>，在某些情况下通过 <code>bitset</code>可以优化程序的运行效率，至于其优化的是复杂度还是常数，要看计算复杂度的角度。设原复杂度为<span class="math inline">\(O(n)\)</span>，一般 <code>bitset</code>的复杂度为 <span class="math inline">\(O(n/w)\)</span>，其中 <spanclass="math inline">\(w=32\)</span>（计算机的位数）</p><p>当然，<code>vector</code> 的一个特化 <code>vector&lt;bool&gt;</code>的储存方式同 <code>bitset</code>一样，区别在于其支持动态开空间，<code>bitset</code>则和我们一般的静态数组一样，是在编译时就开好了的；而且<code>bitset</code>有一些非常好用的库函数，不仅方便，而且有时可以避免使用 for循环而没有实质的速度优化。因此，一般不使用<code>vector&lt;bool&gt;</code></p><span id="more"></span><h2 id="使用">使用</h2><h3 id="头文件">头文件</h3><p><code>#include &lt;bitset&gt;</code></p><h3 id="指定大小">指定大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;<span class="number">1000</span>&gt; bs; <span class="comment">// a bitset with 1000 bits</span></span><br></pre></td></tr></table></figure><h3 id="构造函数">构造函数</h3><ul><li><code>bitset()</code>: 每一位都是 <code>0</code>。</li><li><code>bitset(unsigned long val)</code>: 设为 <code>val</code>的二进制形式。</li><li><code>bitset(const string&amp; str)</code>: 设为 串<code>str</code>。</li></ul><h3 id="运算符">运算符¶</h3><ul><li><code>operator []</code>: 访问其特定的一位。</li><li><code>operator ==、!=</code>: 比较两个 <code>bitset</code>内容是否完全一样。</li><li><code>operator &amp;、&amp;=、|、|=、^、^=、~</code>:进行<strong>按位</strong>与/或/异或/取反操作。<strong><code>bitset</code>只能与 <code>bitset</code>进行位运算</strong>，若要和整型进行位运算，要先将整型转换为<code>bitset</code></li><li><code>operator &lt;&lt;=、&gt;&gt;=</code>:进行二进制左移/右移。</li><li><code>operator &lt;&gt;</code>: 流运算符，这意味着你可以通过<code>cin/cout</code> 进行输入输出。</li></ul><h3 id="成员函数">成员函数¶</h3><ul><li><p><code>count()</code>: 返回 <code>1</code> 的数量</p></li><li><p><code>size()</code>: 返回 <code>bitset</code> 的大小</p></li><li><p><code>test(pos)</code>: 它和 <code>vector</code> 中的<code>at()</code> 的作用是一样的，和 <code>[]</code>运算符的区别就是越界检查</p></li><li><p><code>any()</code>: 若存在某一位是 <code>1</code> 则返回<code>true</code>，否则返回 <code>false</code></p></li><li><p><code>none()</code>: 若所有位都是 <code>0</code> 则返回<code>true</code>，否则返回 <code>false</code></p></li><li><p><code>all()</code>:<strong>C++11</strong>，若所有位都是<code>1</code> 则返回 <code>true</code>，否则返回<code>false</code></p></li><li><ol type="1"><li><code>set()</code>: 将整个 <code>bitset</code> 设置成<code>1</code></li><li><code>set(pos, val = true)</code>: 将某一位设置成<code>1</code>/<code>0</code></li></ol></li><li><ol type="1"><li><code>reset()</code>: 将整个 <code>bitset</code> 设置成<code>false</code>。</li><li><code>reset(pos)</code>: 将某一位设置成 <code>0</code>，相当于<code>set(pos, false)</code>。</li></ol></li><li><ol type="1"><li><code>flip()</code>: 翻转每一位（相当于异或一个全是 1 的<code>bitset</code>）</li><li><code>flip(pos)</code>: 翻转某一位</li></ol></li><li><p><code>to_string()</code>: 返回转换成的字符串表达</p></li><li><p><code>to_ulong()</code>: 返回转换成的 <code>unsigned long</code>表达（<code>long</code> 在 NT 及 32 位 POSIX 系统下与 <code>int</code>一样，在 64 位 POSIX 下与 <code>long long</code> 一样）</p></li><li><p><code>to_ullong()</code>: <strong>C++11</strong>，返回转换成的<code>unsigned long long</code> 表达</p></li><li><p><code>_Find_first()</code>: 返回 <code>bitset</code> 第一个<code>1</code> 的下标，若没有 <code>1</code> 则返回 <code>bitset</code>的大小</p></li><li><p><code>_Find_next(pos)</code>: 返回 <code>pos</code>后面（下标严格大于 <code>pos</code> 的位置）第一个 <code>1</code>的下标，若 <code>pos</code> 后面没有 <code>1</code> 则返回<code>bitset</code> 的大小</p></li></ul><h2 id="实例">实例</h2><h3 id="基本使用">基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">bitset&lt;8&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;11001010&quot;</span>)</span></span>; <span class="comment">// 从字符串初始化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Initial bitset: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问特定位置的位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bit at position 3: &quot;</span> &lt;&lt; b[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改位</span></span><br><span class="line">    b[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Modified bitset: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转位</span></span><br><span class="line">    b.<span class="built_in">flip</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Flipped bitset: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Initial bitset: 11001010</span><br><span class="line">Bit at position 3: 0</span><br><span class="line">Modified bitset: 11001011</span><br><span class="line">Flipped bitset: 00110110</span><br></pre></td></tr></table></figure><h3 id="位操作">位操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">bitset&lt;8&gt; <span class="title">b1</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">bitset&lt;8&gt; <span class="title">b2</span><span class="params">(<span class="string">&quot;11110000&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位与操作</span></span><br><span class="line">    bitset&lt;8&gt; b_and = b1 &amp; b2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bitwise AND: &quot;</span> &lt;&lt; b_and &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位或操作</span></span><br><span class="line">    bitset&lt;8&gt; b_or = b1 | b2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bitwise OR: &quot;</span> &lt;&lt; b_or &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位异或操作</span></span><br><span class="line">    bitset&lt;8&gt; b_xor = b1 ^ b2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bitwise XOR: &quot;</span> &lt;&lt; b_xor &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位非操作</span></span><br><span class="line">    bitset&lt;8&gt; b_not = ~b1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bitwise NOT: &quot;</span> &lt;&lt; b_not &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bitwise AND: 10100000</span><br><span class="line">Bitwise OR: 11111010</span><br><span class="line">Bitwise XOR: 01111010</span><br><span class="line">Bitwise NOT: 01010101</span><br></pre></td></tr></table></figure><h3 id="循环遍历位集合">循环遍历位集合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">bitset&lt;8&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历bitset中的位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; b[i];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10101010</span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8819625/">AcWing164. 可达性统计 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双端队列deque</title>
      <link href="/2023/10/09/%5Bobject%20Object%5D/STL/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/"/>
      <url>/2023/10/09/%5Bobject%20Object%5D/STL/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/</url>
      
        <content type="html"><![CDATA[<h1 id="双端队列deque">双端队列deque</h1><h2 id="头文件"><strong>头文件</strong></h2><p><code>#include &lt;deque&gt;</code></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;ElementType&gt; a;</span><br></pre></td></tr></table></figure><ul><li>queue 只能在对头删除元素，在队尾添加元素</li><li>deque 在队头队尾均能删除/插入元素</li></ul><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在队首加入数据0</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">11</span>); <span class="comment">// 在队尾加入数据11</span></span><br><span class="line">a.<span class="built_in">pop_front</span>();   <span class="comment">// 在队首删除数据</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();    <span class="comment">// 在队尾删除数据</span></span><br><span class="line">a.<span class="built_in">front</span>()<span class="comment">// 返回队头元素</span></span><br><span class="line">a.<span class="built_in">back</span>()<span class="comment">// 返回队尾元素</span></span><br><span class="line">    </span><br><span class="line">a.<span class="built_in">resize</span>(num);   <span class="comment">// 重新指定队列的长度</span></span><br><span class="line">a.<span class="built_in">size</span>()         <span class="comment">// 返回容器中实际数据个数</span></span><br><span class="line">a.<span class="built_in">max_size</span>()     <span class="comment">// 返回容器中最大数据的数量</span></span><br><span class="line">a.<span class="built_in">clear</span>()<span class="comment">// 清空队列</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//创建一个有10个元素双端队列a,初始值都为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给deque赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出deque中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头尾加入新数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在头部加入数据0：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在尾部加入数据11：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头尾删除数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在头部删除数据: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在尾部删除数据: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回容器中实际数据个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新指定队列的长度</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回容器中最大数据的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.max_size() = &quot;</span> &lt;&lt; a.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.front() = &quot;</span> &lt;&lt; a.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.back() = &quot;</span> &lt;&lt; a.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空队列</span></span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入&amp;&amp;输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">在头部加入数据0：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">在尾部加入数据11：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 </span><br><span class="line">在头部删除数据: </span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 </span><br><span class="line">在尾部删除数据: </span><br><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">a.size() = 10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 0 </span><br><span class="line">a.empty() = 0</span><br><span class="line">a.max_size() = 4611686018427387903</span><br><span class="line">a.front() = 1</span><br><span class="line">a.back() = 0</span><br><span class="line">a.empty() = 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组vector</title>
      <link href="/2023/10/08/%5Bobject%20Object%5D/STL/%E6%95%B0%E7%BB%84vector/"/>
      <url>/2023/10/08/%5Bobject%20Object%5D/STL/%E6%95%B0%E7%BB%84vector/</url>
      
        <content type="html"><![CDATA[<h1 id="数组vector">数组vector</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;vector&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ElementType&gt; v;</span><br></pre></td></tr></table></figure><blockquote><p>这里的ElementType可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br></pre></td></tr></table></figure><blockquote><p>定义一个向量v，<strong><font color='red'>大小为0</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><blockquote><p>先定义⼀个向量v，然后<strong><font color='red'>将长度resize为8</font></strong>，默认这8个元素都是0</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>定义具有10个int元素的向量v，<strong><font color='red'>默认这10个元素值都为0</font></strong></p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>定义具有10个int元素的向量v，且<strong><font color='red'>这10个元素值都为</font></strong>1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a = b;</span><br></pre></td></tr></table></figure><blockquote><p>先定义⼀个向量a，然后<strong><font color='red'>将向量b赋值给向量a</font></strong>（a的值完全等于b的值）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>将向量b中从0-2（<strong><font color='blue'>共3个</font></strong>）的元素赋值给a，a的类型为int型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b, b + <span class="number">7</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>从数组中获得初值</p></blockquote><h2 id="方法">方法</h2><p><ahref="https://blog.csdn.net/weixin_41743247/article/details/90635931?ops_request_misc=%7B%22request%5Fid%22%3A%22167064353616800184186226%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167064353616800184186226&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90635931-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&amp;utm_term=vector&amp;spm=1018.2226.3001.4187">C++_vector操作</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>vector数组大小</font></strong>，类型<strong>unsignedint</strong></p></blockquote><p>:taco: 如果v.size()==1，则v.size()-3为正数，必须int(a.size()) -3才行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(n)</span><br></pre></td></tr></table></figure><blockquote><p>将向量 v的<strong><font color='red'>元素个数调整为n个</font></strong>，<strong><font color='blue'>多则删，少则补（其值为0）</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(n,x)</span><br></pre></td></tr></table></figure><blockquote><p>将向量 v的<strong><font color='red'>元素个数调整为n个</font></strong>，<strong><font color='blue'>多则删，少则补（其值为x）</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>清空</font></strong>向量<strong>v</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">front</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回v的<font color='red'><strong>第一个元素</strong></font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回v的<font color='red'><strong>最后一个元素</strong></font>，不检查这个数据是否存在</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 vector 是否为空：==<strong><font color='red'>返回 true则空，返回 false 则非空</font></strong>== 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>将 <strong>x</strong> 添加到<strong><font color='red'>向量 v最后</font></strong>（<code>v.size</code>会加1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>删除</font></strong>向量 v的<strong><font color='red'>最后一个元素</font></strong>（<code>v.size</code>会减1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,elem)</span><br></pre></td></tr></table></figure><blockquote><p>在pos位置插入一个elem拷贝，传回新数据位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,n,elem)</span><br></pre></td></tr></table></figure><blockquote><p>在pos位置插入n个elem数据,无返回值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>在pos位置插入在[beg,end)区间的数据。无返回值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(pos);</span><br></pre></td></tr></table></figure><blockquote><p>删除pos位置的数据，传回下一个数据的位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>删除[beg,end)区间的数据，传回下一个数据的位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>将(beg; end)区间中的数据赋值给v</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(n,elem)</span><br></pre></td></tr></table></figure><blockquote><p>将n个elem的拷贝赋值给v</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.at(idx)</span><br></pre></td></tr></table></figure><blockquote><p>传回索引idx所指的数据，如果idx越界，抛出out_of_range。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.capacity()</span><br></pre></td></tr></table></figure><blockquote><p>返回容器中数据个数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.max_size()</span><br></pre></td></tr></table></figure><blockquote><p>返回容器中最大数据的数量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1.<span class="built_in">swap</span>(v2)</span><br></pre></td></tr></table></figure><blockquote><p>将vector:v1中的元素和vector:v2中的元素<strong><font color='red'>整体交换</font></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">a</span><span class="params">(b.rbegin(), r.end())</span>;</span><br><span class="line"><span class="comment">// 上面的写法等价于</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; a = b;</span><br><span class="line">reverse(a.begin, a.end());</span><br></pre></td></tr></table></figure><p>​将vector:b中的元素<strong><font color='red'>从后往前</font></strong>依次赋值给vector:a</p><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除v[2]元素（即数字3）</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After erasing v[2]: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除v[2]、v[3]、v[4]元素（即数字4、5、6）</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">begin</span>() + <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After erasing range from v[2] to v[4]: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用assign函数重新赋值</span></span><br><span class="line">    v.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">100</span>); <span class="comment">// 创建一个大小为5的vector，所有元素值为100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After using assign to set 5 elements to 100: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用at函数访问元素</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idxElement = v.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; idxElement &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> out_of_range &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Out of range error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中数据的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of the vector: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中最大数据的数量（通常与size()相同）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max size of the vector: &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义另一个vector并与当前vector交换</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">swap</span>(v2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">After erasing v[2]: 1 2 4 5 6 7 8 9 10 </span><br><span class="line">After erasing range from v[2] to v[4]: 1 2 7 8 9 10</span><br><span class="line">After using assign to set 5 elements to 100: 100 100 100 100 100</span><br><span class="line">Element at index 2: 100</span><br><span class="line">Size of the vector: 5</span><br><span class="line">Max size of the vector: 4611686018427387903</span><br><span class="line">Before swap:</span><br><span class="line">v1: 100 100 100 100 100</span><br><span class="line">v2: 11 12 13 14 15</span><br><span class="line">After swap:</span><br><span class="line">v1: 11 12 13 14 15</span><br><span class="line">v2: 100 100 100 100 100</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义的时候不指定vector的大小</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">// 这个时候size是0 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        a.<span class="built_in">push_back</span>(i); <span class="comment">//在vector a的末尾添加一个元素i </span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 此时会发现a的size变成了10 </span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">15</span>)</span></span>; <span class="comment">//定义的时候指定vector的大小，默认b里面元素都是0</span></span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) </span><br><span class="line">        b[i]= <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) </span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>)</span></span>; <span class="comment">//定义的时候指定vector的大小并把所有的元素赋一个指定的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i++) </span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); it++) <span class="comment">//使用迭代器的方式访问vector </span></span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><h2 id="相等判断与直接赋值">相等判断与直接赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//vector相等判断与赋值    </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec2;</span><br><span class="line"><span class="keyword">if</span> (vec1 == vec2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec1与vec2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">vec2 = vec1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值后&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (vec1 == vec2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec1与vec2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">赋值后</span><br><span class="line">vec1与vec2相等</span><br></pre></td></tr></table></figure></li><li><p>vector的赋值会把<strong>一个vector的所有元素</strong>赋值到<strong>另一个vector中</strong>，并<font color='red'><strong>替代所有元素</strong></font>；</p></li><li><p>而vector的相等也是需要<strong>逐个元素<font color='red'>依次比较</font></strong>并<strong><font color='blue'>全部相等</font></strong>才算相等。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  ..........</span><br><span class="line">  v.<span class="built_in">pop_back</span>();</span><br><span class="line">  ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>v.pop_back()</code>之前要<code>v.empty()</code></p></li><li><p>`<code>v.pop_back();</code>无返回值，<strong><font color='blue'>仅删除</font></strong>向量v的最后一个元素；要<strong><font color='gree'>获得</font></strong><font color='red'><strong>向量v 的最后一个元素</strong></font>需要<code>v.back()</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合set</title>
      <link href="/2023/10/07/%5Bobject%20Object%5D/STL/%E9%9B%86%E5%90%88set/"/>
      <url>/2023/10/07/%5Bobject%20Object%5D/STL/%E9%9B%86%E5%90%88set/</url>
      
        <content type="html"><![CDATA[<h1 id="集合set">集合set</h1><p><code>set</code> 是集合：满足以下2个特点</p><ul><li><code>set</code> ⾥面的各元素是各不相同的</li><li><code>set</code> 会按照元素进行从小到⼤排序</li></ul><blockquote><blockquote><p><code>multiset</code>里面的各元素是<font color='red'><strong>可以有相同的</strong></font></p></blockquote></blockquote><h2 id="头文件">头文件</h2><p><code>#include &lt;set&gt;</code></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;ElementType&gt; s;</span><br><span class="line">multiset&lt;ElementType&gt; s;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">begin</span>()         <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">clear</span>()         <span class="comment">// 清除所有元素</span></span><br><span class="line">s.<span class="built_in">count</span>()         <span class="comment">// 返回某个值元素的个数</span></span><br><span class="line">s.<span class="built_in">empty</span>()         <span class="comment">// 如果集合为空，返回true(真）</span></span><br><span class="line">s.<span class="built_in">end</span>()           <span class="comment">// 返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line">s.<span class="built_in">equal_range</span>()   <span class="comment">// 返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line">s.<span class="built_in">erase</span>()         </span><br><span class="line"><span class="comment">// (1) 输入是一个数x，删除所有x   O(k + logn)</span></span><br><span class="line"><span class="comment">// (2) 输入一个迭代器，删除这个迭代器</span></span><br><span class="line">s.<span class="built_in">find</span>()          <span class="comment">// 返回一个指向被查找到元素的迭代器</span></span><br><span class="line">s.<span class="built_in">get_allocator</span>() <span class="comment">// 返回集合的分配器</span></span><br><span class="line">s.<span class="built_in">insert</span>()        <span class="comment">// 在集合中插入元素</span></span><br><span class="line">s.<span class="built_in">key_comp</span>()      <span class="comment">// 返回一个用于元素间值比较的函数</span></span><br><span class="line">s.<span class="built_in">max_size</span>()      <span class="comment">// 返回集合能容纳的元素的最大限值</span></span><br><span class="line">s.<span class="built_in">rbegin</span>()        <span class="comment">// 返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">s.<span class="built_in">rend</span>()          <span class="comment">// 返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">s.<span class="built_in">size</span>()          <span class="comment">// 集合中元素的数目</span></span><br><span class="line">s.<span class="built_in">swap</span>()          <span class="comment">// 交换两个集合变量</span></span><br><span class="line">s.<span class="built_in">lower_bound</span>(x)   <span class="comment">// 返回【&gt;=】x 的第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>(x)   <span class="comment">// 返回【&gt;】x 的第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">value_comp</span>()    <span class="comment">// 返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s; <span class="comment">// 创建一个空的整数集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of set: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查集合是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is set empty? &quot;</span> &lt;&lt; (s.<span class="built_in">empty</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向最后一个元素之后的迭代器</span></span><br><span class="line">    it = s.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 注意：这里不能通过*it来访问元素，因为it现在指向的是最后一个元素之后的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;One past the last element: &quot;</span> &lt;&lt; *<span class="built_in">prev</span>(it) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    it = s.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found element 10&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element 10 not found&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查集合是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is set empty after clear? &quot;</span> &lt;&lt; (s.<span class="built_in">empty</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用insert插入多个元素</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入重复元素，set会忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count of element 10: &quot;</span> &lt;&lt; s.<span class="built_in">count</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 总是返回1，因为set中不会有重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::reverse_iterator rit = s.<span class="built_in">rbegin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Last element (reverse): &quot;</span> &lt;&lt; *rit &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">    rit = s.<span class="built_in">rend</span>();</span><br><span class="line">    <span class="comment">// 注意：这里不能通过*rit来访问元素，因为rit现在指向的是第一个元素之前的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before the first element (reverse): &quot;</span> &lt;&lt; *<span class="built_in">prev</span>(rit) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个集合变量（这里只有一个集合，所以无法演示交换）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合的上界和下界</span></span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator&gt; bounds = s.<span class="built_in">equal_range</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lower bound of 5: &quot;</span> &lt;&lt; *bounds.first &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Upper bound of 5: &quot;</span> &lt;&lt; *bounds.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合的分配器</span></span><br><span class="line">    allocator&lt;<span class="type">int</span>&gt; alloc = s.<span class="built_in">get_allocator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取比较键的函数对象</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::key_compare keyComp = s.<span class="built_in">key_comp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取比较值的函数对象</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::value_compare valueComp = s.<span class="built_in">value_comp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合能容纳的最大元素数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max size of set: &quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Size of set: 4</span><br><span class="line">Is set empty? false</span><br><span class="line">First element: 5</span><br><span class="line">One past the last element: 20</span><br><span class="line">Found element 10</span><br><span class="line">Is set empty after clear? true</span><br><span class="line">Count of element 10: 1</span><br><span class="line">Last element (reverse): 5</span><br><span class="line">Before the first element (reverse): 5</span><br><span class="line">Lower bound of 5: 5</span><br><span class="line">Upper bound of 5: 1</span><br><span class="line">Max size of set: 461168601842738790</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对组pair</title>
      <link href="/2023/10/06/%5Bobject%20Object%5D/STL/%E5%93%88%E5%B8%8C%E8%A1%A8unordered/"/>
      <url>/2023/10/06/%5Bobject%20Object%5D/STL/%E5%93%88%E5%B8%8C%E8%A1%A8unordered/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表">哈希表</h1><table><thead><tr class="header"><th>哈希</th><th style="text-align: center;">原来</th></tr></thead><tbody><tr class="odd"><td>unordered_set</td><td style="text-align: center;">set</td></tr><tr class="even"><td>unordered_map</td><td style="text-align: center;">map</td></tr><tr class="odd"><td>unordered_multiset</td><td style="text-align: center;">multiset</td></tr><tr class="even"><td>unordered_multimap</td><td style="text-align: center;">multimap</td></tr></tbody></table><ul><li>哈希表不支持 lower_bound()/upper_bound()， 迭代器的++，--</li><li>其余操作与原来的一摸一样</li></ul><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对组pair</title>
      <link href="/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E7%BB%84pair/"/>
      <url>/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E7%BB%84pair/</url>
      
        <content type="html"><![CDATA[<h1 id="对组pair">对组pair</h1><ul><li><span class="math inline">\(pair\)</span> 就是一个拥有 <spanclass="math inline">\(2\)</span> 个成员变量的结构体</li><li>当需要使用具有 <span class="math inline">\(2\)</span>个成员变量的结构体时，为了方便，我们通常不使用自定义的结构体，而是直接使用<span class="math inline">\(C++\)</span> 内置的 <spanclass="math inline">\(pair\)</span></li></ul><h2 id="应用">应用</h2><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。pair的实现是一个结构体，主要的两个成员变量是first second因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><p>其标准库类型--pair类型定义在<code>#include &lt;utility&gt;</code>头文件中，定义如下：</p><ul><li><p>类模板：template&lt;class T1,class T2&gt; struct pair</p></li><li><p>参数：T1是第一个值的数据类型，T2是第二个值的数据类型。</p></li><li><p>功能：<strong>pair将一对值(T1类型和T2类型)组合成一个值</strong></p><ul><li>这一对值可以具有不同的数据类型（T1和T2）</li><li>两个值可以分别用<font color='red'><strong>pair的两个公有成员变量first和second访问</strong></font></li></ul></li><li><p>定义(构造函数)：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;         <span class="comment">// 创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p1</span><span class="params">(v1, v2)</span></span>; <span class="comment">// 创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);       <span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line">p1 &lt; p2;                 <span class="comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span></span><br><span class="line">p1 == p;                 <span class="comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span></span><br><span class="line">p1.first;                <span class="comment">// 返回对象p1中名为first的公有数据成员</span></span><br><span class="line">p1.second;               <span class="comment">// 返回对象p1中名为second的公有数据成员</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="定义">定义</h2><ul><li><p>pair包含两个数值，与容器一样，pair也是一种模板类型。但是又与之前介绍的容器不同；</p></li><li><p>在创建pair对象时，<font color='red'><strong>必须提供两个类型名，两个对应的类型名的类型不必相同</strong></font></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br></pre></td></tr></table></figure><ul><li>当然也可以在定义时进行成员初始化：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">author</span><span class="params">(<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joy&quot;</span>)</span></span>;    <span class="comment">// 创建一个author对象，两个元素类型分别为string类型，并默认初始值为James和Joy。</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">name_age</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">name_age2</span><span class="params">(name_age)</span></span>;    <span class="comment">// 拷贝构造初始化</span></span><br></pre></td></tr></table></figure><ul><li>pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string,string&gt; Author;</span><br><span class="line"><span class="function">Author <span class="title">proust</span><span class="params">(<span class="string">&quot;March&quot;</span>,<span class="string">&quot;Proust&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Author <span class="title">Joy</span><span class="params">(<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joy&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>变量间赋值：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">1.2</span>)</span></span>;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p2 = p1;     <span class="comment">// copy construction to initialize object</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p3；</span><br><span class="line">p3 = p1;    <span class="comment">// operator =</span></span><br></pre></td></tr></table></figure><h2 id="操作">操作</h2><ul><li>访问两个元素操作可以通过<code>first</code>和<code>second</code>访问：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;</span><br><span class="line"></span><br><span class="line">p1.first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">p1.second = <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：1 2.5</span></span><br><span class="line"></span><br><span class="line">string firstBook;</span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">&quot;James&quot;</span> &amp;&amp; author.second == <span class="string">&quot;Joy&quot;</span>)</span><br><span class="line">    firstBook = <span class="string">&quot;Stephen Hero&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以利用<code>make_pair</code>创建新的 pair 对象：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;</span><br><span class="line">p1 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1.2</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 1 1.2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">string m = <span class="string">&quot;James&quot;</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, string&gt; newone;</span><br><span class="line"></span><br><span class="line">newone = <span class="built_in">make_pair</span>(a, m);</span><br><span class="line">cout &lt;&lt; newone.first &lt;&lt; newone.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 8 James</span></span><br></pre></td></tr></table></figure><ul><li><p>通过 <code>tie</code> 获取 pair 元素值：在某些清况函数会以 pair对象作为返回值时，可以直接通过<code>std::tie</code>进行接收。比如：</p><blockquote><blockquote><p>注意使用tie要引入<code>#include &lt;tuple&gt;</code></p></blockquote></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">getPreson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="comment">/* C++ 11支持下面操作 */</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> ages;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tie</span>(name, ages) = <span class="built_in">getPreson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, ages: &quot;</span> &lt;&lt; ages &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line">PII author;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">&quot;James&quot;</span> &amp;&amp; author.second == <span class="string">&quot;Joy&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (author == <span class="built_in">make_pair</span>(<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Joy&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> (author == &#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Joy&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列queue</title>
      <link href="/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E5%88%97queue/"/>
      <url>/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E5%88%97queue/</url>
      
        <content type="html"><![CDATA[<h1 id="队列queue">队列queue</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;ElementType&gt; q;</span><br></pre></td></tr></table></figure><blockquote><p>这里的ElementType可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。</p></blockquote><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>队列大小</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>()</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>插入队尾</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">front</span>()</span><br><span class="line">q.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分别返回<strong><font color='red'>队首元素</font></strong>和<font color='red'><strong>队尾元素</strong></font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p>令队首元素<strong>出队</strong>，<font color='blue'><strong>删除</strong></font>队首元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 queue 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回 queue 中<font color='red'><strong>元素个数</strong></font></p></blockquote><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 0</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, q.<span class="built_in">front</span>(),q.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>q.pop()</code>无返回值，仅删除队首元素。要<strong><font color='gree'>获得</font></strong><font color='red'><strong>队首元素</strong></font><strong>还需<code>q.front()</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()==<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EMPTY! \n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NOT EMPTY! \n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EMPTY! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NOT EMPTY! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EMPTY!</span><br><span class="line">NOT EMPTY!</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li><li><p>注意： 使用 <code>q.front()</code>和<code>q.pop()</code>函数前，必须用<code>q.empty()</code>判断队列==<strong>是否为空</strong>==，否则可能因为<strong>队空</strong>而出现<strong>SegmentationFault</strong>错误</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结</title>
      <link href="/2023/10/05/%5Bobject%20Object%5D/STL/%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>/2023/10/05/%5Bobject%20Object%5D/STL/%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="总结">总结</h1><h2 id="清空stl">清空STL</h2><p>有的 <span class="math inline">\(STL\)</span>（eg：<code>queue</code>、 <code>stack</code>）没有 <code>clear()</code>方法，但是清空 <span class="math inline">\(STL\)</span>有一个统一的方法，就是将原有的对象重新赋值为一个新的空对象，这样原有的栈内容就会被清空：</p><ol type="1"><li><p><strong>vector</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="comment">// 清空 vector</span></span><br><span class="line">vec = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>queue</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">// 清空 queue</span></span><br><span class="line">q = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure></p></li><li><p><strong>stack</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="comment">// 清空 stack</span></span><br><span class="line">stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>map</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">// 清空 map</span></span><br><span class="line">m = <span class="built_in">map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>set</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="comment">// 清空 set</span></span><br><span class="line">s = <span class="built_in">set</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure></p></li></ol><span id="more"></span><h2 id="查找stl">查找STL</h2><p>STL中更有很多函数十分常用，其中查找是使用最高频的函数之一，以下针对C++11的查找进行总结。</p><h3 id="stdfind">std::find()</h3><h4 id="常用形式">常用形式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++20前</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">find</span><span class="params">( InputIt first, InputIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++20前</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate &gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">find_if</span><span class="params">( InputIt first, InputIt last, </span></span></span><br><span class="line"><span class="params"><span class="function">                 UnaryPredicate p )</span></span>;</span><br><span class="line">                 </span><br><span class="line"><span class="comment">//C++11起，C++20前</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate &gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">find_if_not</span><span class="params">( InputIt first, InputIt last, </span></span></span><br><span class="line"><span class="params"><span class="function">                     UnaryPredicate q )</span></span>;</span><br></pre></td></tr></table></figure><p>针对顺序容器，STL并没有提供相应的find方法，所以需要使用<code>std::find()</code>，其时间复杂度可以认为是为<code>O(n)</code> 。其实现可以认为是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">find</span><span class="params">(InputIt first, InputIt last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first == value) &#123; <span class="comment">//因为使用了==操作符比较，所以自定义类型需要重载==</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用示例">使用示例</h4><p>顺序容器vector,deque,list,forward_list和array本身都没有find方法，可以使用std::find来进行查找。</p><h5 id="内置类型">内置类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator v1It = std::<span class="built_in">find</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator d1It = std::<span class="built_in">find</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator l1It = std::<span class="built_in">find</span>(l1.<span class="built_in">begin</span>(), l1.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//forward_list</span></span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; l2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt;::iterator l2It = std::<span class="built_in">find</span>(l2.<span class="built_in">begin</span>(), l2.<span class="built_in">end</span>(), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//array</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt; a1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;::iterator a1It = std::<span class="built_in">find</span>(a1.<span class="built_in">begin</span>(), a1.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h5 id="自定义类型">自定义类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用std::find()需要要重载==操作符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> Node&amp; right) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == right.a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b == right.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a == right.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector</span></span><br><span class="line">vector&lt;Node&gt; v2;</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt;::iterator v2It = std::<span class="built_in">find</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">Node</span>(<span class="number">0</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="setfind">set::find()</h3><h4 id="常用形式-1">常用形式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>其时间复杂度可认为是 <code>O(log(n))</code>,即拥有对数复杂度。<br />查找的逻辑实际上如下：</p><ol type="1"><li>首先找到set中不大于（&lt;=）给定key的第一个元素 <code>_where</code>；</li><li><code>_where</code>与给定的key等价（这里的等价含义详见严格弱序）则返回<code>_where</code>,否则返回 <code>end()</code>;</li></ol><p>实际上STL的关联容器set，map，multiset和multimap中的元素都应该满足严格弱序（stickweak ordering）,详见 <ahref="https://blog.csdn.net/hf19931101/article/details/82710366">C++严格弱序</a>。</p><h4 id="使用示例-1">使用示例</h4><h5 id="内置类型-1">内置类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator s1It = s1.<span class="built_in">find</span>(<span class="number">5</span>); <span class="comment">//找到5</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">double</span>&gt; s2&#123; <span class="number">1.1</span>, <span class="number">2.54</span>, <span class="number">3.6</span>, <span class="number">4.421</span>, <span class="number">5.87</span>, <span class="number">6.213</span>, <span class="number">7.321</span>, <span class="number">8.0</span>, <span class="number">9.5</span> &#125;;</span><br><span class="line">set&lt;<span class="type">double</span>&gt;::iterator s2It = s2.<span class="built_in">find</span>(<span class="number">2.5</span>); <span class="comment">//找不到2.5</span></span><br></pre></td></tr></table></figure><h5 id="自定义类型-1">自定义类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用set::find()需要要重载&lt;操作符,使之满足严格弱序</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Node&amp; right) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == right.a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; right.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; right.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Node&gt; s3;</span><br><span class="line">s3.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">s3.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">s3.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">s3.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">s3.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">s3.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">set&lt;Node&gt;::iterator s3It = s3.<span class="built_in">find</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>)); </span><br></pre></td></tr></table></figure><h3 id="mapfind">map::find()</h3><h4 id="常用形式-2">常用形式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>因为map和set的底层实际上都是红黑树，所以底层的实现一致，其时间复杂度也可认为是<code>O(log(n))</code>,即拥有对数复杂度。<br />查找的逻辑也与set一致。</p><h4 id="使用示例-2">使用示例</h4><h5 id="内置类型-2">内置类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1&#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">2</span>,<span class="number">0</span>&#125;, &#123;<span class="number">3</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator m1It = m1.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m2&#123; &#123; <span class="string">&#x27;a&#x27;</span>,<span class="number">1</span> &#125;,&#123; <span class="string">&#x27;b&#x27;</span>,<span class="number">2</span> &#125;,&#123; <span class="string">&#x27;c&#x27;</span>,<span class="number">3</span> &#125;,&#123; <span class="string">&#x27;d&#x27;</span>,<span class="number">4</span> &#125; &#125;;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator m2It = m2.<span class="built_in">find</span>(<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="自定义类型-2">自定义类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用map::find()需要要重载&lt;操作符,使之满足严格弱序</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Node&amp; right) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == right.a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; right.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; right.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;Node, <span class="type">int</span>&gt; m3;</span><br><span class="line">m3.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span>));</span><br><span class="line">m3.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="number">1</span>));</span><br><span class="line">m3.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">3</span>), <span class="number">1</span>));</span><br><span class="line">m3.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="number">1</span>));</span><br><span class="line">m3.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="number">1</span>));</span><br><span class="line">m3.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">3</span>), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">map&lt;Node, <span class="type">int</span>&gt;::iterator m3It = m3.<span class="built_in">find</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="multisetfind">multiset::find()</h3><h4 id="常用形式-3">常用形式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找给定键的元素，若容器中有数个拥有 key 的元素，则可能返回任意一者。</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回容器中所有拥有给定关键的元素范围。</span></span><br><span class="line"><span class="comment">范围以二个迭代器定义，一个指向首个不小于（&gt;=）key 的元素，另一个指向首个大于（&gt;）key 的元素。</span></span><br><span class="line"><span class="comment">首个迭代器可以换用 lower_bound() 获得，而第二迭代器可换用 upper_bound() 获得。*/</span></span><br><span class="line"><span class="function">std::pair&lt;iterator,iterator&gt; <span class="title">equal_range</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">std::pair&lt;const_iterator,const_iterator&gt; <span class="title">equal_range</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指向首个不小于（&gt;=）给定键的元素的迭代器 </span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指向首个大于（&gt;）给定键的元素的迭代器 </span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>其时间复杂度可认为是 <code>O(log(n))</code>,即拥有对数复杂度。</p><h4 id="使用示例-3">使用示例</h4><h5 id="内置类型-3">内置类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;int&gt; ms1&#123; 1,1,1,2,3,4,5,5,5,6,7,8,9 &#125;;</span><br><span class="line">using It = multiset&lt;int&gt;::iterator;</span><br><span class="line">using PairIt = pair&lt;It, It&gt;;</span><br><span class="line">It ms1It = ms1.find(1);</span><br><span class="line">It ms1It1 = ms1.lower_bound(1);</span><br><span class="line">It ms1It2 = ms1.upper_bound(1);</span><br><span class="line">PairIt pairIt = ms1.equal_range(1);</span><br><span class="line">for (It it = pairIt.first; it != pairIt.second; it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="自定义类型-3">自定义类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用multiset::find()需要要重载&lt;操作符,使之满足严格弱序</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Node&amp; right) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == right.a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; right.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; right.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiset&lt;Node&gt; ms2;</span><br><span class="line">ms2.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">ms2.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">ms2.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">ms2.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">ms2.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">ms2.<span class="built_in">insert</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">using</span> It = multiset&lt;Node&gt;::iterator;</span><br><span class="line"><span class="keyword">using</span> PairIt = pair&lt;It, It&gt;;</span><br><span class="line">It ms2It = ms2.<span class="built_in">find</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">It ms2It1 = ms2.<span class="built_in">lower_bound</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">It ms2It2 = ms2.<span class="built_in">upper_bound</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">PairIt pairIt = ms2.<span class="built_in">equal_range</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (It it = pairIt.first; it != pairIt.second; it++)</span><br><span class="line">&#123;</span><br><span class="line">Node node = *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="multimapfind">multimap::find()</h3><h4 id="常用形式-4">常用形式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找拥有等于 key 的键的元素。若容器中有数个拥有 key 的元素，则可能返回任意一者。</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回容器中所有拥有给定关键的元素范围。</span></span><br><span class="line"><span class="comment">范围以二个迭代器定义，一个指向首个不小于（&gt;=） key 的元素，另一个指向首个大于（&gt;）key 的元素。</span></span><br><span class="line"><span class="comment">首个迭代器可以换用 lower_bound() 获得，而第二迭代器可换用 upper_bound() 获得。*/</span></span><br><span class="line"><span class="function">std::pair&lt;iterator,iterator&gt; <span class="title">equal_range</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">std::pair&lt;const_iterator,const_iterator&gt; <span class="title">equal_range</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指向首个不小于（&gt;=）给定key的元素的迭代器 </span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指向首个大于（&gt;）给定key的元素的迭代器 </span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>其时间复杂度可认为是 <code>O(log(n))</code>,即拥有对数复杂度。</p><h4 id="使用示例-4">使用示例</h4><h5 id="内置类型-4">内置类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mm1&#123; &#123; <span class="number">0</span>,<span class="number">0</span> &#125;,&#123; <span class="number">1</span>,<span class="number">0</span> &#125;,&#123; <span class="number">1</span>,<span class="number">0</span> &#125;,&#123; <span class="number">1</span>,<span class="number">0</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">using</span> It = multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator;</span><br><span class="line"><span class="keyword">using</span> PairIt = pair&lt;It, It&gt;;</span><br><span class="line">It mm1It = mm1.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">It mm1It1 = mm1.<span class="built_in">lower_bound</span>(<span class="number">1</span>);</span><br><span class="line">It mm1It2 = mm1.<span class="built_in">upper_bound</span>(<span class="number">1</span>);</span><br><span class="line">PairIt pairIt = mm1.<span class="built_in">equal_range</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (It it = pairIt.first; it != pairIt.second; it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义类型-4">自定义类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用multimap::find()需要要重载&lt;操作符,使之满足严格弱序</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Node&amp; right) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == right.a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b &lt; right.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; right.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multimap&lt;Node, <span class="type">int</span>&gt; mm2;</span><br><span class="line">mm2.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="number">0</span>));</span><br><span class="line">mm2.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="number">0</span>));</span><br><span class="line">mm2.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">2</span>), <span class="number">0</span>));</span><br><span class="line">mm2.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>));</span><br><span class="line">mm2.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>));</span><br><span class="line">mm2.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>));</span><br><span class="line"><span class="keyword">using</span> It = multimap&lt;Node, <span class="type">int</span>&gt;::iterator;</span><br><span class="line"><span class="keyword">using</span> PairIt = pair&lt;It, It&gt;;</span><br><span class="line">It mm1It = mm2.<span class="built_in">find</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">It mm1It1 = mm2.<span class="built_in">lower_bound</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">It mm1It2 = mm2.<span class="built_in">upper_bound</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">PairIt pairIt = mm2.<span class="built_in">equal_range</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (It it = pairIt.first; it != pairIt.second; it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2023/10/05/%5Bobject%20Object%5D/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2023/10/05/%5Bobject%20Object%5D/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1><p>遍历<strong><font color='blue'>容器</font></strong><code>vector</code>、<code>set</code>、<code>map</code>要使用<strong><font color='red'>迭代器/反向迭代器</font></strong>访问</p><ul><li><p><strong><code>c.begin()</code></strong>是一个指针，指向容器的<strong><font color='purple'>第一个元素</font></strong></p></li><li><p><strong><code>c.end()</code></strong>是一个指针，指向容器==<strong><font color='red'>最后一个元素的后一个位置</font></strong>==</p></li><li><p><strong><code>c.rbegin()</code></strong>是一个指针，指向容器的<font color='purple'><strong>最后一个元素</strong></font></p></li><li><p><strong><code>c.rend()</code></strong>是一个指针，指向容器的==<font color='red'><strong>第一个元素的前一个位置</strong></font>==</p></li></ul><p>所以<strong><font color='blue'>迭代器指针it</font></strong>的for循环判断条件是 <strong><code>it != c.end()</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); it++)  <span class="comment">// 使用迭代器的方式访问vector </span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">rbegin</span>(); it != c.<span class="built_in">rend</span>(); it--)  <span class="comment">// 使用反向迭代器的方式访问vector </span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221222424.jpeg"alt="e5b86169c82b93bbe409229eb505976" /><figcaptionaria-hidden="true">e5b86169c82b93bbe409229eb505976</figcaption></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【thu贵系机试】</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E8%B4%B5%E7%B3%BB%E6%9C%BA%E8%AF%95%E3%80%91/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E8%B4%B5%E7%B3%BB%E6%9C%BA%E8%AF%95%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="售货机">1、售货机</h1><p><strong>时间限制：</strong> 1.0 秒</p><p><strong>空间限制：</strong> 512 MiB</p><h2 id="题目描述">题目描述</h2><p>清华大学的自动售货机一共有 𝑛种饮料出售，每种饮料有自己的售价，并在售货机上各有一个出售口。购买第 𝑖种饮料时，可以在第 𝑖 个出售口支付 𝑎𝑖的价格，售货机便会在下方的出货处放出对应的饮料。</p><p>又到了清凉的夏日，自动售货机为每种饮料各进货了<strong>1瓶</strong>存储在其中，供同学购买。但是，自动售货机却出现了一些故障，它有可能会出货不属于这个出售口的饮料。</p><p>对于第 𝑖 个出售口，<strong>支付 𝑎𝑖 的价格购买后</strong>，如果饮料 𝑖与饮料 𝑏𝑖 都有存货，有 𝑝𝑖 的概率出货饮料 𝑖 ，有 1−𝑝𝑖 的概率出货饮料 𝑏𝑖。如果其中一个有存货，另一个已经没有存货，则将出货有存货的那一种饮料。如果两种饮料都没有存货，售货机将不会出货任何饮料并发出警报。**即便最后你没有获得任何饮料，也需要支付𝑎𝑖 的价格 ** 。</p><p>长颈鹿下楼来到这台售货机前，希望能买到最近火爆全网的饮料 𝑥，此时售货机中 𝑛 种饮料都存货有 1瓶。由于他知道售货机有问题，因此决定采取这样的策略来购买：</p><ul><li>在 𝑛 个出售口中等概率选择一个出售口 𝑠 开始购买，支付这个出售口的价格𝑎𝑠 并得到出货。</li><li>当得到想要的饮料 𝑥 时，停止购买流程，满意欢喜的离去。</li><li>当得到不想要的饮料 𝑦 时，继续在第 𝑦 个支付口购买，支付 𝑎𝑦的价格并等待出货。</li><li>当售货机发出警报时，停止购买流程，灰心丧气的离去。</li></ul><p>现在他希望你告诉他，他这一次购买过程期望支付的价钱数量是多少？</p><h2 id="输入格式">输入格式</h2><p>从标准输入读入数据。</p><p>第一行两个正整数 𝑛,𝑥。</p><p>接下来 𝑛 行每行三个数，其中第 𝑖 行表示 𝑎𝑖,𝑏𝑖,𝑝𝑖。</p><h2 id="输出格式">输出格式</h2><p>输出到标准输出。</p><p>一行一个实数表示答案，表示长颈鹿按他的策略买水期望支付的价钱。</p><p>记答案为 𝑎，而你的输出为 𝑏，那么当且仅当 |𝑎−𝑏|&lt;10−6时我们认为你的输出是正确的。</p><h2 id="样例输入">样例输入</h2><p><code>2 2 8 2 0.90 7 1 0.40</code></p><h2 id="样例输出">样例输出</h2><p><code>13.500000000</code></p><h2 id="样例解释">样例解释</h2><p>售货机里饮料 1 与饮料 2 各有一瓶，且当两瓶都还有存货时，在第 1个出售口有 0.1 的概率买到饮料 2 ，在第 2 个出售口有 0.6 的概率买到饮料 1。</p><ul><li>长颈鹿有0.5的概率初始选择第1个出售口开始购买，并支付8元。</li><li>有 0.1 的概率直接出货饮料 2 ，一共支付 8 元，这种情况的概率是 0.05。</li><li>有 0.9 的概率出货饮料 1 ，则长颈鹿会再支付 8 元重新从第 1个出售口购买饮料。由于饮料 1 已售空，第二次购买时必定直接出货饮料 2，一共支付 16 元，这种情况的概率是 0.45 。</li><li>长颈鹿有0.5的概率初始选择第2个出售口开始购买，并支付7元。</li><li>有 0.4 的概率直接出货饮料 2 ，一共支付 7 元，这种情况的概率是 0.2。</li><li>有 0.6 的概率出货饮料 1 ，则长颈鹿会再支付 8 元重新从第 1个出售口购买饮料。由于饮料 1 已售空，第二次购买时必定直接出货饮料 2，一共支付 15 元，这种情况的概率是 0.3 。</li></ul><p>于是期望支付的价钱为 8×0.05+16×0.45+7×0.2+15×0.3=13.5</p><h2 id="子任务">子任务</h2><p>保证 𝑛≤2000 ， 1≤𝑏𝑖≤𝑛 , 𝑏𝑖≠𝑖 , 0≤𝑎𝑖≤100 ，0≤𝑝𝑖≤1 ，且 𝑝𝑖不超过两位小数。</p><p>子任务 1（50分）：𝑛≤10</p><p>子任务 2（30分）：𝑝𝑖=0</p><p>子任务 3（20分）：无特殊限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">double</span> res = <span class="number">0.0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="type">int</span> ver;</span><br><span class="line">    <span class="type">double</span> probility;</span><br><span class="line">    <span class="type">bool</span> has = <span class="literal">true</span>;</span><br><span class="line">&#125;goods[N];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">double</span> cost, <span class="type">double</span> probility)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = goods[u].ver;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(goods[u].has &amp;&amp; goods[k].has)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出u</span></span><br><span class="line">        <span class="keyword">if</span>(u == x)</span><br><span class="line">            res += (cost + goods[u].price) * probility * goods[u].probility;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            goods[u].has = <span class="literal">false</span>;</span><br><span class="line">            res += dfs(u, cost + goods[u].price, probility * goods[u].probility);</span><br><span class="line">            goods[u].has = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出k</span></span><br><span class="line">        <span class="keyword">if</span>(k == x)</span><br><span class="line">            res += (cost + goods[u].price) * probility * (<span class="number">1</span> - goods[u].probility);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            goods[k].has = <span class="literal">false</span>;</span><br><span class="line">            res += dfs(k, cost + goods[u].price, probility * (<span class="number">1</span> - goods[u].probility));</span><br><span class="line">            goods[k].has = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(goods[u].has)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只能出u</span></span><br><span class="line">        <span class="keyword">if</span>(u == x)</span><br><span class="line">            res += (cost + goods[u].price) * probility;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            goods[u].has = <span class="literal">false</span>;</span><br><span class="line">            res += dfs(u, cost + goods[u].price, probility);</span><br><span class="line">            goods[u].has = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(goods[k].has)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只能出k</span></span><br><span class="line">        <span class="keyword">if</span>(k == x)</span><br><span class="line">            res += (cost + goods[u].price) * probility;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            goods[k].has = <span class="literal">false</span>;</span><br><span class="line">            res += dfs(k, cost + goods[u].price, probility);</span><br><span class="line">            goods[k].has = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res += cost + goods[u].price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf&quot;</span>, &amp;goods[i].price, &amp;goods[i].ver, &amp;goods[i].probility);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> t = dfs(i, <span class="number">0.0</span>, <span class="number">1.0</span> / n);</span><br><span class="line">        res += t;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="水滴">2、水滴</h1><p><strong>时间限制：</strong> 2.0 秒</p><p><strong>空间限制：</strong> 512 MiB</p><p><strong>相关文件：</strong> 题目目录</p><h2 id="题目描述-1">题目描述</h2><p>这是一个经典的游戏。</p><p>在一个 𝑛×𝑚 的棋盘上，每一个格子中都有一些水滴。</p><p>玩家的操作是，在一个格子中加一滴水。</p><p>当一个格子中的水滴数超过了4，这一大滴水就会因格子承载不住而向外扩散。扩散的规则是这样的：</p><p>这个格子中的水滴会消失，然后分别向上、左、下、右 4个方向发射一个水滴。如果水滴碰到一个有水的格子，就会进入这个格子。否则水滴会继续移动直到到达棋盘边界后消失。扩散后，水滴进入新的格子可能导致该格子的水滴数也超过4，则会立即引发这个格子的扩散。我们规定，每个格子按逆时针顺序从上方向开始，递归处理完每一个方向的扩散以及其引发的连锁反应，再处理下一个方向的扩散。</p><p>给定棋盘的初始状态和玩家的操作，求最后水滴的分布情况。</p><p>由于把水滴在一个空格看起来用处不大，所以保证所有的玩家操作都不会选择空格。</p><p>提示：可以记录每个水滴上下左右方向第一个水滴的位置，扩散时根据规则模拟，并在每次操作后维护。</p><h2 id="输入格式-1">输入格式</h2><p>从标准输入读入数据。</p><p>第一行四个整数 𝑛,𝑚,𝑐,𝑇。</p><p>接下来 𝑐 行，每行三个正整数 𝑥𝑖,𝑦𝑖,𝑎𝑖，表示初始棋盘上第 𝑥𝑖 行 𝑦𝑖 列有𝑎𝑖 个水滴。</p><p>接下来 𝑇 行，每行两个正整数 𝑢𝑖,𝑣𝑖，表示在第 𝑢𝑖 行 𝑣𝑖列放入一个水滴。</p><h2 id="输出格式-1">输出格式</h2><p>输出到标准输出。</p><p>输出 𝑇 加若干行。</p><p>前 𝑇 行每行一个整数，第 𝑖 行表示在第 𝑖次操作后扩散的水滴数。若没有扩散输出 0。</p><p>最后若干行（可能是 0行）表示棋盘上水滴的分布情况。由上至下，由左至右输出，每行三个正整数表示行号、列号、水滴数。</p><h2 id="样例输入-1">样例输入</h2><p><code>4 4 12 1 1 2 1 1 3 2 2 1 1 2 4 1 3 1 1 3 4 1 4 2 1 4 3 1 2 2 4 2 3 4 3 2 4 3 3 3 2 2</code></p><h2 id="样例输出-1">样例输出</h2><p><code>4 1 2 3 1 3 4 2 1 3 2 4 2 3 1 3 3 4 2 4 2 2 4 3 2</code></p><h2 id="样例解释-1">样例解释</h2><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408102237897.png"alt="img" /> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408102237892.png"alt="img" /></p><p>整个过程从上到下从左到右表示。</p><p>字母表示该格子即将发射水滴的方向。U：上；D：下；L：左；R：右。</p><p>黄色格子表示即将发射水滴的格子。</p><h2 id="子任务-1">子任务</h2><p>保证 1≤𝑛,𝑚≤351493，0≤𝑐≤750000，0≤𝑇≤500000。</p><p>保证 1≤𝑥𝑖,𝑢𝑖≤𝑛,1≤𝑦𝑖,𝑣𝑖≤𝑚,1≤𝑎𝑖≤4。</p><p>保证没有重复的 (𝑥𝑖,𝑦𝑖)。</p><p>子任务 1（17分）：𝑛,𝑚≤100</p><p>子任务 2（24分）：𝑛,𝑚≤2000</p><p>子任务 3（24分）：𝑐≤105</p><p>子任务 4（35分）：无特殊性质</p><h1 id="phi的游戏">3、Phi的游戏</h1><p><strong>时间限制：</strong> 1.5 秒</p><p><strong>空间限制：</strong> 512 MiB</p><h2 id="题目描述-2">题目描述</h2><p>Picar 和 Roman是两个非常喜欢玩各种游戏的赌徒。这一天，他们又发现了一种新的数字游戏，名叫𝜑 的游戏（Phigames）。</p><p>𝜑 的游戏是双人游戏，每局游戏由任意的一个正整数 𝑁开始，由两人轮流对当前的数字进行操作。轮到其中任意一方进行操作时，玩家可以有以下三种选择：</p><ol type="1"><li>大喊“𝜑:1！”并将当前的数字 𝑛 变为 𝜑(𝑛)；</li><li>大喊“𝜑:2！”并将当前的数字 𝑛 变为 𝜑(2𝑛)；</li><li>大喊“𝜑:𝐾！”并将当前的数字 𝑛 变为 𝜑(𝑛−𝐾)，其中 𝐾是一个双方在开始游戏之前约定好的正整数。</li></ol><p>其中，𝜑(𝑛) 表示的是在 1 到 𝑛 这 𝑛 个正整数中，有多少个正整数与 𝑛互质，如 𝜑(1)=1，𝜑(4)=2，𝜑(10)=4。根据这一定义可知，𝜑(𝑛) 的定义域是ℕ∗，所以如果选择第 3 种操作“𝜑:𝐾！”，需要保证当前的数字 𝑛&gt;𝐾。</p><p>两名玩家轮流操作，如果谁在进行操作之后得到了已经出现过的数字，谁就输掉了本局游戏。例如，如果玩家A 对当前的数字 1 选择了操作 1 “𝜑:1！”，由于 𝜑(1)=1 是出现过的数字，玩家A 输掉了本局游戏，对手获胜。</p><p>𝜑 的游戏考验了玩家的心算能力和逻辑推理能力。可惜，由于 Picar 和 Roman足够聪明，只要指定一个 𝐾 和最开始的数字𝑁，他们就可以算出是先手还是后手有必胜策略。如果对于某个确定的 𝐾，以 𝑁开始游戏时先手有必胜策略，则称这个 𝑁为先手必胜态；否则后手有必胜策略，称 𝑁为后手必胜态。为了使得这个游戏（对他们来说）更有趣，他们决定对游戏进行扩展：</p><ul><li>玩家先指定 𝐾，并选择两个正整数 𝐿,𝑅，由系统在 [𝐿,𝑅]中的先手必胜态中随机挑选一个 𝑟 作为右端点；</li><li>由后手选择一个正整数左端点 𝑙 ，需要保证 𝑙≤𝑟；</li><li>开始一局游戏时，系统从 [𝑙,𝑟] 中等概率挑选一个正整数 𝑁，作为游戏开始时由先手操作的数字。</li></ul><p>尽管 Picar 和 Roman足够聪明，计算修改后的游戏对他们来说也需要花费不少的时间。于是，他们找到了你，想让你帮忙计算一下修改后的游戏的平衡性。即：给定参数𝐿,𝑅,𝐾，求后手对于任意的 𝑟 能<strong>选出最优的 𝑙使得后手胜率最大</strong>时，先手的平均胜率。</p><h2 id="输入格式-2">输入格式</h2><p>从标准输入读入数据。</p><p>输入仅一行，包含三个正整数 𝐿,𝑅,𝐾，含义如题目描述所示。保证 𝐿≤𝑅，且在[𝐿,𝑅] 中至少存在一个先手必胜态。</p><h2 id="输出格式-2">输出格式</h2><p>输出到标准输出。</p><p>输出一个实数，表示在给定的参数 𝐿,𝑅,𝐾下，修改后的游戏的先手平均胜率。</p><p>记答案为 𝑎，而你的输出为 𝑏，那么当且仅当 |𝑎−𝑏|&lt;10−6时我们认为你的输出是正确的。</p><h2 id="样例1输入">样例1输入</h2><p><code>1 10 3</code></p><h2 id="样例1输出">样例1输出</h2><p><code>0.533333333333333333</code></p><h2 id="样例1解释">样例1解释</h2><p>此时 2,4,5,7,9,10 为先手必胜态，1,3,6,8 为后手必胜态。</p><ul><li>𝑟=2 对应的最优左端点 𝑙 为 1，此时先手胜率为 1/2；</li><li>𝑟=4 对应的最优左端点 𝑙 为 3，此时先手胜率为 1/2；</li><li>𝑟=5 对应的最优左端点 𝑙 为 1，此时先手胜率为 3/5；</li><li>𝑟=7 对应的最优左端点 𝑙 为 6，此时先手胜率为 1/2；</li><li>𝑟=9 对应的最优左端点 𝑙 为 8，此时先手胜率为 1/2；</li><li>𝑟=10 对应的最优左端点 𝑙 为 6，此时先手胜率为 3/5。</li></ul><p>故先手的平均胜率为 (1/2+1/2+3/5+1/2+1/2+3/5)/6=8/15≈0.5333。</p><h2 id="样例2输入">样例2输入</h2><p><code>2021 5000 0</code></p><h2 id="样例2输出">样例2输出</h2><p><code>0.391970630667343944</code></p><h2 id="样例3输入">样例3输入</h2><p><code>214 7483648 57721</code></p><h2 id="样例3输出">样例3输出</h2><p><code>0.490802831707061571</code></p><h2 id="子任务-2">子任务</h2><p>对于 100 的数据，保证 1≤𝐿≤𝑅≤107,0≤𝐾≤107。</p><p>具体的测试点分布见下表：</p><table><thead><tr class="header"><th>测试点</th><th>𝐿,𝑅≤</th><th>𝐾</th><th>特殊性质</th></tr></thead><tbody><tr class="odd"><td>1</td><td>6</td><td>&lt;𝑅</td><td>无</td></tr><tr class="even"><td>2</td><td>10</td><td></td><td></td></tr><tr class="odd"><td>3</td><td>16</td><td></td><td></td></tr><tr class="even"><td>4</td><td>18</td><td></td><td></td></tr><tr class="odd"><td>5</td><td>1000</td><td></td><td></td></tr><tr class="even"><td>6</td><td>2000</td><td></td><td></td></tr><tr class="odd"><td>7</td><td>3000</td><td></td><td></td></tr><tr class="even"><td>8</td><td>5000</td><td></td><td></td></tr><tr class="odd"><td>9</td><td>105</td><td>𝑅−𝐿≤99</td><td></td></tr><tr class="even"><td>10</td><td>106</td><td>𝑅−𝐿≤9</td><td></td></tr><tr class="odd"><td>11</td><td>5×106</td><td>=0</td><td></td></tr><tr class="even"><td>12</td><td>&lt;𝑅</td><td></td><td></td></tr><tr class="odd"><td>13</td><td>105</td><td>无</td><td></td></tr><tr class="even"><td>14</td><td></td><td></td><td></td></tr><tr class="odd"><td>15</td><td></td><td></td><td></td></tr><tr class="even"><td>16</td><td>106</td><td>=0</td><td></td></tr><tr class="odd"><td>17</td><td>&lt;𝑅</td><td></td><td></td></tr><tr class="even"><td>18</td><td>107</td><td>𝐿=𝑅</td><td></td></tr><tr class="odd"><td>19</td><td>无</td><td></td><td></td></tr><tr class="even"><td>20</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【thu机试2024】</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E6%9C%BA%E8%AF%952024%E3%80%91/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E6%9C%BA%E8%AF%952024%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="年thu预推免机试">2024年thu预推免机试</h1><h2 id="整体情况">整体情况</h2><p>4 小时，3 道传统题，每题 100 分，共 300 分。</p><p>我报了直博的专项改革工程博士志愿，考这套题花了约 1.5 小时AK，感觉这套题比 9 月 9日的第一场校内推免机试略简单。考前带了打印的一大摞 500 多页 OI-Wiki怀疑又用不上，最后看到第三题非常感动（雾）</p><h2 id="具体题目">具体题目</h2><p>尽量脑补还原了考场代码，但因为没数据测了，不保证正确。</p><h3 id="t1-阿瓦隆">t1 —阿瓦隆</h3><p>签到题，略。</p><h3 id="t2-网络">t2 — 网络</h3><p><strong>题目描述</strong></p><p>给定 <span class="math inline">\(n\)</span> 个 A 类节点（编号 <spanclass="math inline">\(1\sim n\)</span>）和 <spanclass="math inline">\(m\)</span> 个 B 类节点（编号 <spanclass="math inline">\(1 \sim m\)</span>）。对于 <spanclass="math inline">\(n\)</span> 个 A 类节点中的第 <spanclass="math inline">\(i\)</span> 个节点，它可以向编号在 <spanclass="math inline">\([l_i, r_i]\)</span> 中的 B类节点连边，每连一条边代价为 <spanclass="math inline">\(c_i\)</span>。对于整幅图，你需要选择一些边连接，使得在整幅图连通块数量最少的情况下，连边的代价之和最小。</p><p><strong>输入：</strong>第一行 <span class="math inline">\(m,n\)</span>（注意顺序）；接下来 <span class="math inline">\(n\)</span>行，第 <span class="math inline">\(i\)</span> 行为 <spanclass="math inline">\(l_i, r_i, c_i\)</span>。</p><p><strong>输出：</strong>最小的总代价。</p><p><strong>数据规模：</strong><span class="math inline">\(n, m\)</span>为 <span class="math inline">\(10^5\)</span> 级别，<spanclass="math inline">\(c_i\)</span> 非负。</p><p><strong>题解</strong></p><p>模拟一下求最小生成树的 Kruskal 算法，发现我们干的事情就是：按照 <spanclass="math inline">\(c_i\)</span> 从小到大枚举每一个 A类节点，然后把对应的 <span class="math inline">\([l_i, r_i]\)</span>编号范围内的 B 类节点连成一个大连通块。在这之前，如果 <spanclass="math inline">\([l_i, r_i]\)</span> 编号范围内的 B 类节点一共有<span class="math inline">\(k\)</span> 个连通块，那么总代价就需要增加<span class="math inline">\(k \timesc_i\)</span>（每一个连通块都需要向第 <spanclass="math inline">\(i\)</span> 个 A 类节点连一条边）。注意到任何时刻 B类节点的连通块都必然是连续的线段，所以使用并查集维护 B类节点的连通关系并记录每一个连通块当前的右端点即可。</p><p>并查集我只写了路径压缩，所以时间复杂度是 <spanclass="math inline">\(O(n + m \log m)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">  vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; p;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> l, r, c;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    --l;</span><br><span class="line">    --r;</span><br><span class="line">    p.<span class="built_in">emplace_back</span>(c, l, r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(m + n)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(m + n)</span></span>;</span><br><span class="line">  function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; find = [&amp;] (<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> father[x] == x ? x : father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    father[i] = i;</span><br><span class="line">    right[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; m + n; ++i) &#123;</span><br><span class="line">    father[i] = i;</span><br><span class="line">    right[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> ptr = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(p[i]);</span><br><span class="line">    right[m + i] = <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(p[i]);</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt;= <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(p[i])) &#123;</span><br><span class="line">      answer += <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(p[i]);</span><br><span class="line">      <span class="type">int</span> f = <span class="built_in">find</span>(ptr);</span><br><span class="line">      father[f] = m + i;</span><br><span class="line">      right[m + i] = <span class="built_in">max</span>(right[m + i], right[f]);</span><br><span class="line">      ptr = right[f] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; answer &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="t3-图定向">t3 — 图定向</h3><p><strong>题目描述</strong></p><p>给定一幅 <span class="math inline">\(n\)</span> 个点 <spanclass="math inline">\(m\)</span> 条边的无向简单图，节点编号为 <spanclass="math inline">\(1 \sim n\)</span>，第 <spanclass="math inline">\(i\)</span> 个节点有权值 <spanclass="math inline">\(c_i\)</span>。往图中再添加任意一条边（可以添加已有的边），然后选择一条从<span class="math inline">\(1\)</span> 号节点出发，回到 <spanclass="math inline">\(1\)</span>号节点的路线，满足图中的每一条边在路线中只能单向通行，即对于一条边 <spanclass="math inline">\((u, v)\)</span>，如果路线中以 <spanclass="math inline">\(u \to v\)</span>的方向经过了这条边，那么就不能再以 <span class="math inline">\(v \tou\)</span>的方向经过这条边。你需要最大化路线经过的所有节点的权值和，注意多次经过同一节点只取得一次权值。</p><p><strong>输入：</strong>第一行 <span class="math inline">\(n,m\)</span>；第二行 <span class="math inline">\(n\)</span> 个数 <spanclass="math inline">\(\{c_i\}\)</span>；接下来 <spanclass="math inline">\(m\)</span> 行，第 <spanclass="math inline">\(i\)</span> 行为 <span class="math inline">\(u_i,v_i\)</span>，表示一条边 <span class="math inline">\((u_i,v_i)\)</span>。</p><p><strong>输出：</strong>最大权值和。</p><p><strong>数据规模：</strong><span class="math inline">\(n, m\)</span>为 <span class="math inline">\(10^5\)</span> 级别，<spanclass="math inline">\(c_i\)</span> 非负。</p><p><strong>题解</strong></p><p>对于一个环，我们可以在保证每条边只单向行走的情况下取完其中所有点的权值。于是把原图的每个边双连通分量缩成一个点后，求一条经过<span class="math inline">\(1\)</span> 号节点的权值最长链即可。</p><p>时间复杂度为 <span class="math inline">\(O(n + m)\)</span>。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    cin &gt;&gt; c[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    --u;</span><br><span class="line">    --v;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">belong</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n)</span></span>;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; my_stack;</span><br><span class="line">  <span class="type">int</span> dfn_cnt = <span class="number">0</span>;</span><br><span class="line">  function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; tarjan = [&amp;] (<span class="type">int</span> x, <span class="type">int</span> from) &#123;</span><br><span class="line">    dfn[x] = low[x] = dfn_cnt++;</span><br><span class="line">    my_stack.<span class="built_in">push_back</span>(x);</span><br><span class="line">    visit[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y: adj[x]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!~dfn[y]) &#123;</span><br><span class="line">          <span class="built_in">tarjan</span>(y, x);</span><br><span class="line">          low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visit[y]) &#123;</span><br><span class="line">          low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">      <span class="keyword">while</span> (my_stack.<span class="built_in">back</span>() != x) &#123;</span><br><span class="line">        <span class="type">int</span> y = my_stack.<span class="built_in">back</span>();</span><br><span class="line">        visit[y] = <span class="literal">false</span>;</span><br><span class="line">        c[x] += c[y];</span><br><span class="line">        belong[y] = x;</span><br><span class="line">        my_stack.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      belong[x] = x;</span><br><span class="line">      my_stack.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">new_adj</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y: adj[x]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (belong[x] != belong[y]) &#123;</span><br><span class="line">        new_adj[belong[x]].<span class="built_in">push_back</span>(belong[y]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">  function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;] (<span class="type">int</span> x, <span class="type">int</span> from) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> best = <span class="number">0</span>, second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y: new_adj[x]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (y != from) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        <span class="keyword">if</span> (dp[y] &gt;= best) &#123;</span><br><span class="line">          second = best;</span><br><span class="line">          best = dp[y];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[y] &gt;= second) &#123;</span><br><span class="line">          second = dp[y];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">      dp[x] = c[x] + best + second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[x] = c[x] + best;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【thu软院机试】</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E8%BD%AF%E9%99%A2%E6%9C%BA%E8%AF%95%E3%80%91/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90thu%E8%BD%AF%E9%99%A2%E6%9C%BA%E8%AF%95%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="thu软院机试">thu软院机试</h1><p><ahref="https://blog.csdn.net/da_kao_la/category_9279280.html?biz_id=102&amp;utm_term=清华大学软件学院&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-category_9279280.html&amp;spm=1018.2118.3001.4187">清华大学软件学院保研机试经验_da_kao_la的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_35307005/category_8674849.html">算法_PatrickStar1的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_35307005/article/details/107936378">【清华大学软院】15-19年推免试题历年整理_清华大学软件学院预推免机试真题-CSDN博客</a></p><h2 id="注意事项">注意事项</h2><p>清华软院保研机试的赛制与清华计算机系类似，由于相关信息较少，故根据亲身经历总结要点如下：</p><ol type="1"><li><p>机试时长为3小时，一般有3道题，每道题有多个数据点，按数据点给分。每题分值在20~40分之间，总分100分</p></li><li><p>不是OJ形式，而是采用本地保存代码，考后测评程序黑盒测试的方法判分，所以考试的时候是不知道自己代码的对错的，如果有时间的话可以自己生成数据、写对拍程序对自己的程序进行测试</p></li><li><p>题目对于运行空间似乎没有明确要求，运行时间的要求是1s以内</p></li><li><p>语言限定为C/C++，环境是VS2017，可以使用MSDN（在VS中按F1调出），但不能上网或带纸质材料</p></li><li><p>2018年保研机试（外校直博/校内硕博）真题见链接：</p></li></ol><h2 id="section">2015​</h2><ul class="task-list"><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251905/">AcWing2015清华软院T1. 病毒感染 - AcWing</a>：模拟</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251923/">AcWing2015清华软院T2. 找到算式Ⅰ - AcWing</a>： DFS+栈</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251924/">AcWing2015清华软院T3. 航线交叉 - AcWing</a>：最长上升子序列DP</label></li></ul><h2 id="section-1">2016</h2><ul class="task-list"><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251925/">AcWing2016清华软院T1. 高精度立方 - AcWing</a>：高精度乘法</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251931/">AcWing2016清华软院T2. 最短路径 - AcWing</a>：单源最短路模板</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/252426/">AcWing T3.找到算式Ⅱ - AcWing</a>： DFS+栈</label></li></ul><h2 id="section-2">2017</h2><ul class="task-list"><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251688/">AcWing2017清华软院T1. 火星A+B - AcWing</a>：高精度加法</label></p></li><li><p><label><input type="checkbox" /><ahref="https://blog.csdn.net/da_kao_la/article/details/82381617">2017年清华软院保研机试第2题：被遗漏的数字_被遗漏的数字,字符串数字,算法题-CSDN博客</a>、</label></p></li><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/activity/content/code/content/8411489/">AcWing1015. 摘花生 - AcWing</a>：线性DP</label></p></li></ul><h2 id="section-3">2018</h2><ul class="task-list"><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251832/">AcWing2018清华软院T1. 回文数 - AcWing</a>：模拟</label></p></li><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251930/">AcWing2018清华软院T2. 上凸函数 - AcWing</a>：斜率优化+二分</label></p></li><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/activity/content/code/content/8815328/">AcWing1378. 谦虚数字 - AcWing</a>：多路归并+堆优化+数论</label></p></li><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/252605/">HDU SDUT 2493.Constructing Roads - AcWing</a>：分层图+最短路</label></p></li></ul><hr /><ul class="task-list"><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/252514/">AcWing T1.时间转换 - AcWing</a>：模拟+日期转换</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/252457/">AcWing 416.麦森数 - AcWing</a>：高精度+快速幂+数学</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/activity/content/code/content/8813370/">LeetCode312. 戳气球 - AcWing</a>：区间DP</label></li></ul><h2 id="section-4">2019</h2><ul class="task-list"><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251681/">AcWing2019清华软院T1. 超长整数排列相乘 - AcWing</a>：高精度乘法</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251928/">AcWing2019清华软院T2. 超长整数排列 - AcWing</a>：排列</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251926/">AcWing2019清华软院T3. 同构数 - AcWing</a>：数论</label></li></ul><hr /><ul class="task-list"><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/activity/content/code/content/8065120/">AcWing2019清华软院T1. 分解质因数 - AcWing</a>：数学知识</label></p></li><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251933/">AcWing2019清华软院T2. 二叉树算权 -AcWing</a>：DFS+前序中序建树</label></p></li><li><p><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/251935/">AcWing2019清华软院T3. 字符串折叠 - AcWing</a>：区间DP</label></p></li></ul><h2 id="section-5">2020</h2><ul class="task-list"><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/12342657/">AcWing2020清华软院T1. 狡兔三窟 - AcWing</a>：模拟</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/252578/">牛客 WY28. 跳石板- AcWing</a>：线性DP + 试除法求所有约数</label></li><li><label><input type="checkbox" /><ahref="https://cn.bing.com/search?q=多边形游戏oj&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;lq=0&amp;pq=多边形游戏oj&amp;sc=7-7&amp;sk=&amp;cvid=CF6D33A67A8B4ABC9C0BE887C87A365F&amp;ghsh=0&amp;ghacc=0&amp;ghpl=">多边形游戏oj- 搜索 (bing.com)</a></label></li><li><label><input type="checkbox" /><ahref="https://www.acwing.com/problem/content/description/2929/">2926.小Z的房间 - AcWing题库</a></label></li></ul><h2 id="section-6">2021</h2><p><ahref="https://zhuanlan.zhihu.com/p/418347688">2021计算机保研经验分享：清华软件、南大、哈工大、哈工深- 知乎 (zhihu.com)</a></p><ul class="task-list"><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/252844/">AcWing T1. 棋子 -AcWing</a>：二分图的最大匹配问题</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/solution/content/252681/">AcWing T2.方格取物 - AcWing</a>：线性DP+滚动数组/状态省略优化</label></li><li><label><input type="checkbox" checked="" /><ahref="https://www.acwing.com/activity/content/code/content/8006099/">AcWing846. 树的重心 - AcWing</a>：DFS+回溯</label></li></ul><h2 id="蓝桥杯">2024蓝桥杯</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强弱com】</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90%E5%BC%BA%E5%BC%B1com%E3%80%91/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E3%80%90%E5%BC%BA%E5%BC%B1com%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="强弱com">强弱com</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150851284.jpeg"alt="38249f41fdcdd6b840eb92e95c719ba" /><figcaptionaria-hidden="true">38249f41fdcdd6b840eb92e95c719ba</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261622008.jpg"alt="3756f0f7c4457c4c50fe2db2c9e6e6a" /><figcaptionaria-hidden="true">3756f0f7c4457c4c50fe2db2c9e6e6a</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261622887.jpg"alt="cb7777272adc0455cb53596e7af73a9" /><figcaptionaria-hidden="true">cb7777272adc0455cb53596e7af73a9</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261622653.jpg"alt="eba94262d123ff7046dbc6479bfd4f7" /><figcaptionaria-hidden="true">eba94262d123ff7046dbc6479bfd4f7</figcaption></figure><h1 id="院校com概念">院校COM概念</h1><p><strong>强COM院校:</strong></p><table><thead><tr class="header"><th style="text-align: left;">院校</th><th style="text-align: left;">com强弱</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">清华软件</td><td style="text-align: left;">强com*</td></tr><tr class="even"><td style="text-align: left;">北大软微</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">中科院自动化所</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">上交计算机硕士</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">复旦计算机</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">南大计算机</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">南大人工智能</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">人大高瓴</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">人大信息</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">北航计算机</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">哈工大计算机</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">天大智算</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">南开软院</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">厦大计算机</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">川大计算机</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">中科大计算机</td><td style="text-align: left;">强com*</td></tr><tr class="odd"><td style="text-align: left;">东南计算机</td><td style="text-align: left;">强com*</td></tr></tbody></table><p>清华*: 如果涉及上机考核，必须通过上机考试</p><p>中科大计算机*：导师可以推荐入营，但是仍需要通过学校面试拿到优营。</p><p>东南计算机*：必须先陶瓷拿到导师推荐信，才能入营参加学院考核。</p><p><strong>弱COM院校:</strong></p><table><thead><tr class="header"><th style="text-align: left;">院校</th><th style="text-align: left;">com强弱</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">清华叉院</td><td style="text-align: left;">弱com*</td></tr><tr class="even"><td style="text-align: left;">北大叉院</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">北大计算机</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">北大智能</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">中科院计算所</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">中科院软件所</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">上交计算机直博</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">浙大计算机直博</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">南开计算机</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">上科大计算机</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">北邮计算机</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">西电AI</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">电子科大计算机</td><td style="text-align: left;">弱com*</td></tr></tbody></table><p>清华*: 如果涉及上机考核，必须通过上机考试</p><p>电子科大*：22年因导师招生超标，学院组织面试刷掉部分学生</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老师交流话术</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E8%80%81%E5%B8%88%E4%BA%A4%E6%B5%81%E8%AF%9D%E6%9C%AF/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E8%80%81%E5%B8%88%E4%BA%A4%E6%B5%81%E8%AF%9D%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>还是蛮建议各位研究生在读研前，再申请一个微信号，留作读研期间以及以后工作用的。</p><p>再申请一个，你就不用去担心发朋友圈要屏蔽谁，不用怕把不该发东西发出去。</p><p><strong>1. 加了微信后。</strong></p><p>这个时候导师也确认了，介绍一下自己就行：姓名+学校+家乡+手机号码。老师好，我是小诸，本科就读于xxxx，老家是xx省xx市xx县的，我的手机号码是123456789。非常高兴成为您的学术！</p><p><strong>2. 做好老师的备注。</strong></p><p>郑重告知各位，不要给老师备注什么奇怪奇怪的名字，万一被看到，尴尬的是自己。</p><p><strong>3. 不要吐槽，不要吐槽！</strong></p><p>很多人都是吐槽老师，然后就发到<ahref="https://www.zhihu.com/search?q=课题组&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%223171015542%22%7D">课题组</a>或者老师那里了，社死三年啊！</p><p><strong>4. 明确目的</strong></p><p>和老师沟通，一般是和科研任务有关，所以明确自己的沟通目的，确保信息传达清晰。避免模糊的开场白，直接表达你要讨论的主题。没事还是少和导师聊，他们也不喜欢的。</p><p><strong>5. 简洁明了</strong></p><p>微信是<ahref="https://www.zhihu.com/search?q=即时通讯&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%223171015542%22%7D">即时通讯</a>工具，因此消息最好简洁明了。用清晰的语言表达自己的问题、需求或意见，避免过长的篇幅。</p><p><strong>6. 避免过度频繁</strong></p><p>别有问题就去找导师，导师脾气再好也会被折磨得想哭。有问题，自己先查查。给导师点时间，避免在短时间内连续发送多条消息。也让自己喘口气。如果涉及到较复杂的问题，可以提前说明，和导师商量，安排一个正式的讨论时间。</p><p><strong>7.避免在非工作时间（如晚上或周末）打扰导师，除非有紧急情况。</strong></p><p>其实发了也没事，导师会装作没看到，等他空了回就是了。紧急情况，一定要打电话！</p><p><strong>8. 回应尽可能及时</strong></p><p>除了做实验的时候，不方便回。一般情况，建议看到就回，保持流畅的沟通。但如果你需要时间来做进一步的准备或思考，也可以委婉地表达。</p><p><strong>9. 少聊私事</strong></p><p>在与导师沟通时，避免涉及过多个人隐私或敏感信息。尽量保持专业和学术性质的讨论。特别是女生，如果导师和你聊一些奇奇怪怪的，截图保存，立马检举他！</p><p><strong>10. 常用话术</strong></p><p>「好的，老师。」「收到，老师！」「嗯嗯，好。」「嗯嗯，行」以及各种大拇指、撒花表情</p><p><strong>11. 记得总结</strong></p><p>在沟通结束后，对讨论的要点进行简要回顾，以确保双方都对沟通内容有清晰的理解。</p><p><strong>12. 灵活切换</strong></p><p>如果发现微信并不适合某些复杂或重要的讨论，可以适时切换到其他更合适的沟通方式，如面谈。</p><p>其实跟导师聊微信没什么聊的，除了科研学术相关，其他的聊不到一块去。</p><p>你一个二十几的人，和一个三四十，甚至五六十岁的人，压根没有什么共同话题的。</p><p>你：玩玩玩，嗨皮嗨皮嗨皮，搞个毛学术！</p><p>导师：钱钱钱，项目项目项目，本子本子本子！老婆孩子家人……</p><p>少聊一点，没关系的。聊什么都不如来一句：老师，这个实验我做出来了，数据不错，可以写文章了！老师，文章中了！老师，我毕业走了！</p><hr /><p>在微信上和导师聊，最多就是一些任务分配，约一个时间沟通这类比较细碎的事情。</p><p>要指导，还是得面对面的。</p><p>很多研究生就不喜欢沟通，但是没办法。你不找，他也要找你。你不找，他刚好就有理由甩锅。</p><p>“你自己不主动，论文出问题，毕业不了，和我有什么关系？”</p><p>别怕，聊几回就习惯了。</p><p><strong>1.使用恰当的呼：</strong>有事找老师的第一点，就是客气礼貌，就是很正常的客套话，比如“老师好...”、“老师，打扰一下您.....”。这个是通用的，你麻烦谁都要先客气一下。别低估一些奇葩导师的自尊心！</p><p><strong>2. 简明扼要：</strong>把自己的目的说清楚。比如说：“我想讨论一下关于……的事情，不知道您啥时候方便？”不要问：老师，在吗？。直接说事情就好，老师看到就会回复。问“在吗”，非常膈应人。</p><p><strong>3. 提前预约：</strong>尽量提前预约拜访时间，让导师能有足够的准备。可以说：“您哪个时间比较方便？我想约个时间和您讨论一下。”也可以给几个时间选项，问问导师哪个时间段方便。</p><p><strong>4. 适当提前提醒：</strong>在约好当天的上午或者前一天晚上，可以再次发条消息确认。“老师，我们约好了沟通时间，是XX号楼XX室，时间是XX点。”</p><p><strong>5. 尊重导师的时间：</strong>如果导师当时很忙，可能没法立即拜访。你可以这样说：“如果现在不方便，那我们可以再定个时间。”</p><p><strong>6. 准备好问题：</strong>在拜访前，准备好你想要讨论的问题或话题，发一个PPT或者Word给他，确保能有意义的交流。</p><p><strong>7. 开场礼节：</strong>在见面时，先表示感谢，比如：“感谢您抽时间和我见面”。</p><p><strong>8. 尊重导师意见：</strong>在交流中，尊重导师的意见和建议，不要争论或反驳。反驳了，导师会不爽，他会让你也不爽。</p><p><strong>9. 主动提问：</strong>问一些开放性的问题，让导师能够深入分享他的观点和经验。</p><p><strong>10. 表达感谢：</strong>在拜访结束时，表达感谢并表示你会认真考虑导师的建议。</p><p><strong>11. 跟进邮件：</strong>拜访后，可以发一封邮件，再次感谢导师，并简要总结一下你们的讨论和得出的结论。</p><p><strong>12. 保持联系：</strong>如果有需要，以后也可以不定期地通过微信向导师请教问题或分享进展。</p><p>读研和大学不同。大学你能舒舒服服，翘翘课，美滋滋。读研你得老老实实在实验室，三年完成导师规定的工作量，否则别想毕业。两者可比性不高，因为不在一个数量级。</p><p>该做的事情，还是要做的。别拖着，越拖着越倒霉！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑话</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%BB%91%E8%AF%9D/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%BB%91%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101310480.jpg"alt="71aadb82ca8db1e3230dd4494834751" /><figcaptionaria-hidden="true">71aadb82ca8db1e3230dd4494834751</figcaption></figure><span id="more"></span><ul><li>rk：rank，绩点排名。</li><li>bar：入营门槛。</li><li>oq：即overqualified，举例：清北选手报中九末九，可能因oq直接被筛掉。</li><li>弱(强)com：com即committee，弱com即学院官方权利弱，对应导师权力大。强com反之。</li><li>套磁：由 keep in touch引申而来，指提前与老师联系，通常以实习或捞入营为目的，部分导师会提前组织考核。</li><li>bg：即 background，指个人背景条件。</li><li>pub：即 publication，指论文发表情况。</li></ul><h2 id="保研黑话大全"><ahref="https://mp.weixin.qq.com/s/I-wBSnUTf7Oa-bjESjn3Gg">保研黑话大全</a></h2><ul><li><p><strong>title：</strong>通常指学校的层次，包括985、211、双一流等，反映学校的整体实力和声誉，有时候也会作为入营录取的隐形门槛。</p></li><li><p><strong>双非：</strong>非985、211的院校，在保研竞争中处于劣势地位。</p></li><li><p><strong>rank/rk：</strong>专业排名，指学院盖章的官方成绩排名，又分为纯绩点排名和综测排名，影响着学生保研的选择和竞争。</p></li><li><p><strong>bg：background</strong>，指你的院校专业、专业排名、英语成绩和科研竞赛等综合背景，是从留学申请的“黑话”中借用过来的一个词。</p></li><li><p><strong>bar：</strong>即入营门槛，不同层次的院校bar有所不同，在本科学校，成绩排名，英语四六级成绩，竞赛，科研论文等方面都会有要求。</p></li><li><p><strong>oq：</strong>overqualified，学生报名比自己本科院校或能力水平低的院校，一般这样做是为了保底，但有时候也会因为oq而被院校主动放弃。</p></li><li><p><strong>套磁：</strong>提前联系导师介绍自身背景情况，表明读研意愿，增加获得导师名额的机会。一般理工科同学需要套磁的比较多，经管类比较少。</p></li><li><p><strong>强com：</strong>招生办话语权大于导师，录取方式、名额增减等主要由招生办决定，而不是导师。</p></li><li><p><strong>弱com：</strong>导师话语权大于招生办，能够自主决定学生的去留、名额的增减。</p></li><li><p><strong>ap：</strong>assistantprofessor，助理教授，也可以带研究生。</p></li><li><p><strong>霸面：</strong>入营失败但通过联系导师同样获得面试机会，常见于计算机专业保研中。</p></li><li><p><strong>mock：</strong>指模拟面试，一般会在夏令营前找学长学姐帮自己模拟面试，以提前熟悉夏令营流程，训练口语表达能力。</p></li><li><p><strong>优营/offer：</strong>优秀营员，优营效力视具体学校而定。有些优营＝拟录取，直接9.28填系统就可以。有些优营仍然需要进入预推免，参加预推免考核。</p></li><li><p><strong>候补/wl/waitinglist：</strong>候补队列，许多学校防止优营鸽太狠，优营不去以后一般从wl开始往后顺延录取。</p></li><li><p><strong>鸽子：</strong>和A导师/学校约定好，后来放导师鸽子，去B导师/学校。</p></li><li><p><strong>被海：</strong>分两种情况</p><ul><li><strong>学生被海：</strong>院校超放大量offer/入营后录取人数多很多。</li><li><strong>学校被海：</strong>学生有很多offer，但依然没有拒绝院校的offer。</li></ul></li><li><p><strong>夏0营：</strong>夏令营一个offer都没有获得。</p></li><li><p><strong>捡漏：</strong>9.28之后，有些院校开系统后招不够人进行补录，保研er可能捡到高性价比的offer，甚至被梦校捞起来。</p></li><li><p><strong>学硕：</strong>3年，学士型研究生，偏向学术研究，可以直接读博/硕博连读。</p></li><li><p><strong>专硕：</strong>2-3年，专业型研究生，偏向实际应用，学费普遍比学硕贵（有的不含宿舍），需实习。</p></li><li><p><strong>直博：</strong>5/6年毕业，直博不经过硕士阶段，毕业时只拿博士学位。如果放弃，一些项目可以选择转硕，然后以硕士毕业；一些项目则只能拿本科学位。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5A景区</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/5A%E6%99%AF%E5%8C%BA/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/5A%E6%99%AF%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939877.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030949257.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939648.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939378.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939756.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940425.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940146.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940323.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940140.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030950797.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【排序】</title>
      <link href="/2023/09/29/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91/"/>
      <url>/2023/09/29/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="内部排序">内部排序</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900163.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><span id="more"></span><h2 id="前提">前提</h2><p><code>void XSort ( ElementType A[], int N )</code></p><ul><li>为简单起见，讨论<strong><font color='red'>从小大的整数</font></strong>排序</li><li>只讨论基于比较的排序（&gt; = &lt; 有定义）</li><li>==<strong>没有一种排序是任何情况下都表现最好的</strong>==</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290857254.png"alt="image-20230929085748167" /><figcaption aria-hidden="true">image-20230929085748167</figcaption></figure><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><h4 id="算法">算法</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900164.png"alt="image-20221021191151215" /><figcaption aria-hidden="true">image-20221021191151215</figcaption></figure><ol type="1"><li>将序列中的<strong>第 <span class="math inline">\(1\)</span>个记录</strong>看成是一个<strong>有序子序列</strong></li><li>从第 <span class="math inline">\(2\)</span>个记录起按关键字大小<strong>逐个进行插入</strong>，直至整个序列变成按关键字有序序列为止</li><li>整个排序过程需要进行比较、后移记录、插入适当位置。共需 <spanclass="math inline">\(n-1\)</span> 趟</li></ol><blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407061642238.gif"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>注：</p><ol type="1"><li>直接插入排序是从<strong><font color='red'>第二个元素</font></strong>开始的</li><li>直接插入排序<strong><code>L</code></strong>趟后，前<strong><code>L+1</code></strong>个元素是<strong><font color='blue'>有序的</font></strong>。</li><li>总共需要==<strong><font color='blue'>n-1</font></strong>==趟排序</li></ol></blockquote><h4 id="伪码">伪码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ElementType t = A[i];<span class="type">int</span> j=i<span class="number">-1</span>;<span class="comment">//t为待插入元素</span></span><br><span class="line"><span class="comment">//寻找待插入元素的位置，同时移动元素</span></span><br><span class="line"><span class="keyword">while</span>( A[j] &gt; t &amp;&amp; j &gt;= <span class="number">0</span> )<span class="comment">//必须是t&lt;a[j]，不能是a[i]&lt;a[j] </span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">A[j+<span class="number">1</span>] = t;<span class="comment">//j+1即为待插入的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li><strong><code>while( a[j] &gt; t &amp;&amp; j &gt;= 0 )</code></strong>决定了该算法是<strong><font color='red'>稳定的排序算法</font></strong></li><li>移动位置时<strong><font color='blue'>从后往前</font></strong>移动</li></ol></blockquote><h4 id="分析">分析</h4><h5 id="时间复杂度">时间复杂度</h5><ul><li>最好情况：比较 <span class="math inline">\(O(n)\)</span>、移动 <spanclass="math inline">\(O(1)\)</span></li></ul><blockquote><p>原序列呈正序排列时</p></blockquote><ul><li>最坏情况：比较 <span class="math inline">\(O(n^2)\)</span>、移动<span class="math inline">\(O(n^2)\)</span></li></ul><blockquote><p>原序列呈反序排列时</p></blockquote><ul><li>平均：<span class="math inline">\(O(n^2)\)</span></li></ul><h5 id="空间复杂度">空间复杂度</h5><p><span class="math inline">\(O(1)\)</span></p><h3 id="折半插入排序">折半插入排序</h3><h4 id="算法-1">算法</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900168.png"alt="image-20221021194551088" /><figcaption aria-hidden="true">image-20221021194551088</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900169.png"alt="image-20221208164824621" /><figcaption aria-hidden="true">image-20221208164824621</figcaption></figure><h4 id="伪码-1">伪码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(ElementType A[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == t)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; t)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModInsertSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = A[i];</span><br><span class="line">        <span class="comment">// 折半插入排序采用--折半查找</span></span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">BinarySearch</span>(A, <span class="number">0</span>, i - <span class="number">1</span>, t);</span><br><span class="line">        <span class="comment">// 从后往前移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= k; j--)</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        A[k] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：折半插入排序采用--折半查找，查找效率提高，但<strong><font color='blue'>元素移动次数不变</font></strong>（<strong><font color='blue'>元素比较次数减少</font></strong>），仅仅将<strong><font color='red'>分散移动</font></strong>改为<strong><font color='red'>集体移动</font></strong></p></blockquote><h2 id="希尔排序">希尔排序</h2><p>是对直接插入排序的优化和扩展，把数据按下标的一定增量分组，对每组使用直接插入排序算法排序；当增量减至1 时，</p><p><strong>希尔排序</strong>又叫“<strong>缩小增量排序</strong>”，其思想是</p><ol type="1"><li>对待排记录序列先作“宏观”调整，再作“微观”调整</li><li>所谓“宏观”调整，指的是<strong>“跳跃式”</strong>的<strong>插入排序</strong></li></ol><h3 id="算法-2">算法</h3><ol type="1"><li>将数据按下标的<strong>一定增量</strong>分成若干<strong>分组</strong>，分别对每个子序列进行<strong>直接插入排序</strong></li></ol><p><span class="math display">\[\{R[1],R[1+d],R[1+2d],...,R[1+kd]\}\\\{R[2],R[2+d],R[2+2d],...,R[2+kd]\}\\.......................................\\\{R[d],R[d+d],R[d+2d],...,R[d+kd]\}\]</span></p><ol start="2" type="1"><li>其中，<span class="math inline">\(d\)</span>称为增量，它的值在排序过程中<strong>逐渐减小</strong>，</li><li>直至最后一趟排序<strong>减为 <spanclass="math inline">\(1\)</span></strong>，每个元素都是一个分组，进行整体排序后结束</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407061643621.gif"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="伪码-2">伪码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=gap; i&lt;n; i++) <span class="comment">//插入排序,从第二个元素开始,对所有组进行</span></span><br><span class="line">        &#123;</span><br><span class="line">            ElementType t=A[i];<span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; t &lt; A[j]; j -= gap) <span class="comment">//从后往前移动</span></span><br><span class="line">                A[j+gap]=A[j];</span><br><span class="line">            A[j+gap]=t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序">冒泡排序</h2><h3 id="算法-3">算法</h3><ol type="1"><li>依次比较所有<strong>相邻</strong>元素，大的元素放在后面</li><li>冒泡排序一趟后，<font color='red'><strong>最大元素沉底</strong></font>且<strong>位于最终位置</strong></li><li>对<spanclass="math inline">\(n\)</span>个数进行排序<font color='blue'><strong>需<spanclass="math inline">\(n-1\)</span>次排序</strong></font></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407061644991.gif"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="伪码-3">伪码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) <span class="comment">//n-1次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j=<span class="number">0</span>; j&lt;n-i; j++)</span><br><span class="line"><span class="keyword">if</span>( A[j] &gt; A[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=A[j];A[j]=A[j+<span class="number">1</span>];A[j+<span class="number">1</span>]=t;<span class="comment">// swap(A[j],A[j+1]);</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若某一趟排序中没有元素交换,则说明所有元素已经有序，不需要再排序</span></span><br><span class="line"><span class="keyword">if</span> (flag)<span class="keyword">return</span>;<span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><h3 id="算法-4">算法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121640359.png"alt="image-20240812164055169" /><figcaption aria-hidden="true">image-20240812164055169</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121639410.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="伪码-4">伪码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要轻易改动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// q[l...j] 均 &lt;=x , q[j...r] 均 &gt;=x</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序">选择排序</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121641925.png" alt="image-20240812164138801" style="zoom: 25%;" /></p><h3 id="算法-5">算法</h3><ol type="1"><li>第一次从 <span class="math inline">\(n\)</span>个关键字中选择一个最小值，确定第一个</li><li>第二次再从剩余元素中选择一个最小值，确定第二个</li><li>共需 <span class="math inline">\(n-1\)</span> 次选择</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407061643802.gif"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="伪码-5">伪码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = i; <span class="comment">// min是用来记录a[i]后面最小元素的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min])</span><br><span class="line">                min = j;</span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">            <span class="built_in">swap</span>(A[i], A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序">堆排序</h2><h3 id="算法-6">算法</h3><ol type="1"><li>构造初始堆：将给定的无序序列构造成<strong><font color='red'>小根堆</font></strong></li><li>输出堆顶元素，然后调整剩余元素成为一个新的最小堆</li><li>重复步骤2，反复调整、输出、调整，直到堆为空</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121643639.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="上滤">上滤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s]=A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下滤">下滤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])<span class="comment">//i&lt;n说明A[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= A[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s]=A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><blockquote><p>从<strong><font color='red'>最后一个非终端结点</font></strong>开始建堆：</p><ul><li>n个结点 ,最后一个非终端结点的下标是 $n/2 $</li><li>归并排序采用<strong><font color='blue'>下滤筛选</font></strong>算法</li></ul></blockquote><h3 id="伪码-6">伪码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调整为初始堆</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=n; i&gt;<span class="number">1</span>; i--)  <span class="comment">//i表示当前最大堆的末尾元素，也是当前堆的大小</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//堆顶元素A[1]与末尾元素A[i]交换，使最大元素沉底        </span></span><br><span class="line">        ElementType t=A[i];A[i]=A[<span class="number">1</span>];A[<span class="number">1</span>]=t;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,i<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二路归并排序">二路归并排序</h2><h3 id="算法-7">算法</h3><ol type="1"><li>[ L , R ] =&gt; [ L , mid ] , [ mid + 1 , R ]</li><li>递归排序 [ L , mid ] 和 [ mid + 1 , R]</li><li>归并，将左右 2 个有序序列合并成 1 个有序序列</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121635754.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="伪码-7">伪码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElementType A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType B[n]; <span class="comment">// 构造辅助数组B,n为A数组大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">        B[i] = A[i]; <span class="comment">// 复制A中元素到B中</span></span><br><span class="line">    <span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = low;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j])</span><br><span class="line">            A[k++] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有剩余元素，则一一复制到数组A中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElementType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(A, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(A, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MergeSort</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="基数排序">基数排序</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121740952.png"alt="image-20221209090418302" /><figcaption aria-hidden="true">image-20221209090418302</figcaption></figure><h3 id="算法-8">算法</h3><p>设待排序列A为 <span class="math inline">\(r\)</span>进制的整数，关键字最大位数为 <spanclass="math inline">\(d\)</span>，则需要 <spanclass="math inline">\(r\)</span> 个队列 <code>Q[r]</code>，进行 <spanclass="math inline">\(n\)</span> 趟排序</p><ol type="1"><li><strong>分配</strong>：从<strong>最低位</strong>开始进行分配，扫描关键字的<span class="math inline">\(pass\)</span> 位，把等于 <spanclass="math inline">\(i\)</span> 的插入到 <code>Q[i]</code><spanclass="math inline">\((i=0，1，2.. r-1)\)</span></li><li><strong>收集</strong>：将<code>Q[0]</code>，…..，<code>Q[9]</code>中的数据依次收集到<code>A[]</code>中;</li><li><code>pass ++</code>，重复执行步骤1、2，直到<code>pass == d</code></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121758989.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="伪码-8">伪码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Radix</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(ElementType A[],<span class="type">int</span> figure,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;Q[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> pass=<span class="number">1</span>; pass&lt;=figure; pass++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-1">分析</h3><h4 id="时间复杂度-1">时间复杂度</h4><p>设有 <span class="math inline">\(n\)</span>个待排序记录，关键字位数为 <spanclass="math inline">\(d\)</span>，每位有 <spanclass="math inline">\(r\)</span> 种取值，则排序的趟数是 <spanclass="math inline">\(d\)</span>。在每一趟中：</p><ul><li>链表初始化的时间复杂度：<spanclass="math inline">\(O(r)\)</span></li><li>分配的时间复杂度：<span class="math inline">\(O(n)\)</span></li><li>分配后收集的时间复杂度：<spanclass="math inline">\(O(r)\)</span></li></ul><p>则链式基数排序的时间复杂度为： <spanclass="math inline">\(O(d(n+r))\)</span>，考虑到 <spanclass="math inline">\(d\)</span> 是一 个常数，时间复杂性为 <spanclass="math inline">\(O(n)\)</span></p><h4 id="空间复杂度-1">空间复杂度</h4><p>在排序过程中使用的辅助空间是：空间复杂度为 <spanclass="math inline">\(O(n)\)</span></p><h2 id="总结">总结</h2><table style="width:100%;"><colgroup><col style="width: 10%" /><col style="width: 12%" /><col style="width: 26%" /><col style="width: 12%" /><col style="width: 18%" /><col style="width: 12%" /><col style="width: 7%" /></colgroup><thead><tr class="header"><th>算法种类</th><th><br />最好情况</th><th>时间复杂度<br />平均情况</th><th><br />最坏情况</th><th>空间复杂度</th><th>趟数</th><th>是否稳定</th></tr></thead><tbody><tr class="odd"><td>直接插入排序</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(n-1\)</span></td><td>是</td></tr><tr class="even"><td>冒泡排序</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(0\sim n-1\)</span></td><td>是</td></tr><tr class="odd"><td>简单选择排序</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(n-1\)</span></td><td>否</td></tr><tr class="even"><td>希尔排序</td><td></td><td>平均<span class="math inline">\(O(n^{1.3})\)</span>到<spanclass="math inline">\(O(n^{1.5})\)</span></td><td></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(\log_2n\)</span></td><td>否</td></tr><tr class="odd"><td>快速排序</td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\sim O(\log_2n)\)</span></td><td><span class="math inline">\(\log n\sim n\)</span></td><td>否</td></tr><tr class="even"><td>堆排序</td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(n-1\)</span></td><td>否</td></tr><tr class="odd"><td>2路归并排序</td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(n\log_2n)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(\log_2n\)</span></td><td>是</td></tr><tr class="even"><td>基数排序</td><td><span class="math inline">\(O(d(n+r))\)</span></td><td><span class="math inline">\(O(d(n+r))\)</span></td><td><span class="math inline">\(O(d(n+r))\)</span></td><td><span class="math inline">\(O(r)\)</span></td><td><span class="math inline">\(d\)</span></td><td>是</td></tr></tbody></table><p>稳定排序算法：<strong><font color='red'>插入排序，冒泡排序，归并排序，基数排序</font></strong>，其余都是不稳定的排序算法</p><h1 id="例题">例题</h1><h2 id="例一">例一</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900182.png"alt="image-20221111123448323" /><figcaption aria-hidden="true">image-20221111123448323</figcaption></figure><h3 id="问题抽象">问题抽象</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900183.png"alt="image-20221111123540642" /><figcaption aria-hidden="true">image-20221111123540642</figcaption></figure><h3 id="算法-9">算法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900184.png"alt="image-20221111123621514" /><figcaption aria-hidden="true">image-20221111123621514</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(ElementType A[i],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=n, h=<span class="number">1</span>;<span class="comment">//h代表颜色</span></span><br><span class="line">    <span class="keyword">while</span>(h&lt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( i&lt;j &amp;&amp; A[i].key==h )</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>( i&lt;j &amp;&amp; A[j].key!=h )</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;ElementType t=A[i];A[i]=A[j];A[j]=t;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j=n;h++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>此题采用了———<strong><font color='red'>快速排序</font></strong>的部分思想</p></blockquote><h2 id="例二">例二</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900185.png"alt="image-20221211154954610" /><figcaption aria-hidden="true">image-20221211154954610</figcaption></figure><h3 id="补充">补充</h3><h4 id="下滤筛选">下滤筛选</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])<span class="comment">//i &lt; n 说明A[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= A[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆调整">堆调整</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h4 id="上滤筛选">上滤筛选</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆调整-1">堆调整</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>上滤</font>：用于<font color='blue'>向堆中插入一个元素</font></strong></p></blockquote><h3 id="答案">答案</h3><ul><li>==<strong><font color='red'>上滤算法</font></strong> +<strong><font color='red'>调整算法</font></strong>==</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h1 id="重点参考">重点参考</h1></li></ul><p><ahref="https://blog.csdn.net/weixin_53011574/article/details/125964731?spm=1001.2014.3001.5506">(72条消息)数据结构学习笔记（第八章排序-内部排序）_低调$(生活)的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【对列】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%AF%B9%E5%88%97%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%AF%B9%E5%88%97%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一循环队列">一：循环队列</h1><p>循环队列的引入是为了克服==<strong><font color='red'>“假上溢”现象</font></strong>==。</p><h3 id="存储结构">1、存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* base;</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>front和rear</font></strong>是头尾指针（相对于数组），front指向<strong>第一个元素</strong>，rear指向<strong>最后一个元素的==<font color='blue'>下一个位置</font>==</strong></p></blockquote><span id="more"></span><h3 id="初始化">2、初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(Queue&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q.base = <span class="keyword">new</span> ElementType[MASQSIZE];<span class="comment">//开辟空间</span></span><br><span class="line"><span class="keyword">if</span> (!q.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">q.front = q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队">3、入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; q, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((q.rear + <span class="number">1</span>) % MAXQSIZE == q.front)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队满</span></span><br><span class="line">q.base[q.rear] = e;</span><br><span class="line">q.rear = (q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队">3、出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; q, ElementType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q.front == q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">e = q.base[q.front];</span><br><span class="line">q.front = (q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列长度">4、队列长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q.rear - q.front + MAXQSIZE ) % MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队满">5、队满</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueFull</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q.rear + <span class="number">1</span> ) % MAXQSIZE == q.front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二链队列">二、链队列</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119858.png"alt="image-20230928211711116" /><figcaption aria-hidden="true">image-20230928211711116</figcaption></figure><blockquote><p><strong><font color='red'>链队</font></strong>带<strong><font color='blue'>头结点</font></strong></p></blockquote><h3 id="存储结构-1">1、存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">Node* front;<span class="comment">//队头指针</span></span><br><span class="line">Node* rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h3 id="链队的初始化">2、链队的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front = Q.rear = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队的入队">3、链队的入队</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119834.png"alt="image-20230928211729867" /><figcaption aria-hidden="true">image-20230928211729867</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">p-&gt;data = x;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//头插法    </span></span><br><span class="line">Q.rear-&gt;next = p;</span><br><span class="line">Q.rear = p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链队的出队">4、链队的出队</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119867.png"alt="image-20230928211745037" /><figcaption aria-hidden="true">image-20230928211745037</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队列为空</span></span><br><span class="line">p = Q.front-&gt;next;<span class="comment">//p指向队头元素</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//e保存队头元素的值</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)<span class="comment">//如果最后一个元素被删，则队尾指针为空</span></span><br><span class="line">Q.rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放原队头元素的空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><pre><code>  如果队列Q中==**&lt;font color=&#39;red&#39;&gt;最后一个元素被删除&lt;/font&gt;**==了，则队列中没有元素了，  </code></pre><ul><li><strong><code>Q.rear</code></strong>不指向任何元素，要修改并赋值<strong><code>NULL</code></strong></li><li><strong><code>Q.front</code></strong>由于是<strong><font color='red'>头结点</font></strong>，所以其值始终不会改变</li></ul></blockquote><h1 id="例题">例题</h1><h2 id="例一">例一</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119854.png"alt="image-20221216122834047" /><figcaption aria-hidden="true">image-20221216122834047</figcaption></figure><blockquote><p><strong><font color='red'>不设置头结点</font></strong>，就必须考虑</p><ol type="1"><li>初始时==<strong><font color='blue'>链表是否为空</font></strong>==</li><li>是否在<strong><font color='orange'>第一个结点前插入新结点</font></strong></li><li>是否<strong><font color='red'>删除</font></strong>结点后<strong><font color='blue'>链表为空</font></strong></li></ol></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119888.jpeg"alt="13315216532604079" /><figcaption aria-hidden="true">13315216532604079</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(node* rear,ElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p=<span class="keyword">new</span> node;</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">    <span class="keyword">if</span>(rear==<span class="literal">NULL</span>)<span class="comment">//队列为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=p;</span><br><span class="line">        rear=p;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=rear-&gt;next;</span><br><span class="line">        rear-&gt;next=p;</span><br><span class="line">        rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">DeQueue</span><span class="params">(ElementType &amp;x,node* rear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear==<span class="literal">NULL</span>)<span class="keyword">return</span> ERROR;       </span><br><span class="line">    node* p=rear-&gt;next;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(p==rear)<span class="comment">//删除后队列为空</span></span><br><span class="line">        rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rear-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符优先级</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/C++/%E3%80%90%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/C++/%E3%80%90%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%91/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310031506806.png"alt="202310031501616" /><figcaption aria-hidden="true">202310031501616</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310031505067.png"alt="202310031501616" /><figcaption aria-hidden="true">202310031501616</figcaption></figure><p><strong>说明</strong>：</p><ol type="1"><li><strong>同一优先级</strong>的运算符，运算次序由<strong>结合方向</strong>决定</li><li><strong>单目运算符 &gt; 算术运算符 &gt; 关系运算符 &gt; 位运算符&gt; 逻辑运算符 &gt; 赋值运算符 &gt; 逗号运算符</strong>【单算关位逻赋逗】<ul><li>单目运算符：<code>-</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>!</code>‧‧‧‧‧‧</li><li>算术运算符（从高到低）<ul><li><p><code>*</code>、<code>\</code>、<code>%</code></p></li><li><p><code>+</code>、<code>-</code></p></li><li><p><code>&gt;&gt;</code>、<code>&lt;&lt;</code></p></li></ul></li><li>关系运算符：<code>==</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li><li>双目位运算符：<code>&amp;</code>、<code>|</code>、<code>^</code></li></ul><blockquote><p>不包含单目位运算符 <code>~</code></p></blockquote><ul><li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code></li><li>赋值运算符：<code>=</code></li><li>逗号运算符：<code>,</code></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【串】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E4%B8%B2%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E4%B8%B2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="串">串</h1><h2 id="例题">例题</h2><h3 id="例一">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291850568.jpeg"alt="307d2ae478633f0ab69b5f4ea7662e1" /><figcaptionaria-hidden="true">307d2ae478633f0ab69b5f4ea7662e1</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsReverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断输入的字符串中‘&amp;’前后两部分是否为逆串，是则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;s;<span class="type">char</span> c,t;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        s.<span class="built_in">push</span>(c);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t!=c)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>判断是否为逆序通常需要使用<strong><code>stack</code></strong></li><li>注意<strong>第9，第13行</strong>。</li></ol></blockquote><h3 id="例二">例二</h3><p><strong>1095 解码PAT准考证</strong></p><p><strong>题目</strong></p><p>PAT 准考证号由 4 部分组成：</p><ul><li>第 1 位是级别，即 <code>T</code> 代表顶级；<code>A</code>代表甲级；<code>B</code> 代表乙级；</li><li>第 2~4 位是考场编号，范围从 101 到 999；</li><li>第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；</li><li>最后 11~13 位是考生编号，范围从 000 到 999。</li></ul><p>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。</p><p><strong>输入格式：</strong></p><p>输入首先在一行中给出两个正整数 <em>N</em>（≤104）和<em>M</em>（≤100），分别为考生人数和统计要求的个数。</p><p>接下来 <em>N</em> 行，每行给出一个考生的准考证号和其分数（在区间[0,100] 内的整数），其间以空格分隔。</p><p>考生信息之后，再给出 <em>M</em>行，每行给出一个统计要求，格式为：<code>类型 指令</code>，其中</p><ul><li><code>类型</code> 为 1表示要求按分数非升序输出某个指定级别的考生的成绩，对应的<code>指令</code> 则给出代表指定级别的字母；</li><li><code>类型</code> 为 2表示要求将某指定考场的考生人数和总分统计输出，对应的 <code>指令</code>则给出指定考场的编号；</li><li><code>类型</code> 为 3表示要求将某指定日期的考生人数分考场统计输出，对应的 <code>指令</code>则给出指定日期，格式与准考证上日期相同。</li></ul><p><strong>输出格式：</strong></p><p>对每项统计要求，首先在一行中输出 <code>Case #: 要求</code>，其中<code>#</code> 是该项要求的编号，从 1 开始；<code>要求</code>即复制输入给出的要求。随后输出相应的统计结果：</p><ul><li><code>类型</code> 为 1 的指令，输出格式与输入的考生信息格式相同，即<code>准考证号 成绩</code>。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；</li><li><code>类型</code> 为 2 的指令，按 <code>人数 总分</code>的格式输出；</li><li><code>类型</code> 为 3 的指令，输出按人数非递增顺序，格式为<code>考场编号 总人数</code>。若人数并列则按考场编号递增顺序输出。</li></ul><p>如果查询结果为空，则输出 <code>NA</code>。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8 4</span><br><span class="line">B123180908127 99</span><br><span class="line">B102180908003 86</span><br><span class="line">A112180318002 98</span><br><span class="line">T107150310127 62</span><br><span class="line">A107180908108 100</span><br><span class="line">T123180908010 78</span><br><span class="line">B112160918035 88</span><br><span class="line">A107180908021 98</span><br><span class="line">1 A</span><br><span class="line">2 107</span><br><span class="line">3 180908</span><br><span class="line">2 999</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1 A</span><br><span class="line">A107180908108 100</span><br><span class="line">A107180908021 98</span><br><span class="line">A112180318002 98</span><br><span class="line">Case 2: 2 107</span><br><span class="line">3 260</span><br><span class="line">Case 3: 3 180908</span><br><span class="line">107 2</span><br><span class="line">123 2</span><br><span class="line">102 1</span><br><span class="line">Case 4: 2 999</span><br><span class="line">NA</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string t;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value != b.value ? a.value &gt; b.value : a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; v[i].t &gt;&gt; v[i].value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; num &gt;&gt; s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>, i, num, s.<span class="built_in">c_str</span>());      <span class="comment">//Attention!    s.c_str()</span></span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t[<span class="number">0</span>] == s[<span class="number">0</span>])      ans.<span class="built_in">push_back</span>(v[j]); <span class="comment">//S[0]即为字符‘A’....</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, ans[j].t.<span class="built_in">c_str</span>(), ans[j].value);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>)     <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>) == s) </span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    sum += v[j].value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt)   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, sum);</span><br><span class="line">            <span class="keyword">else</span>       <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">6</span>) == s)   m[v[j].t.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>)]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : m)   </span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;it.first, it.second&#125;);   <span class="comment">//Attention!!   &#123;it.first,it.second&#125;直接插入结构体</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, ans[j].t.<span class="built_in">c_str</span>(), ans[j].value);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>)     <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>27行：<code>string</code>类型的变量s用printf输出必须是<code>printf(“%s”,s.c_str());</code>即<strong>s.c_str()</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HuffmanTree】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90HuffmanTree%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90HuffmanTree%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树">哈夫曼树</h1><h2 id="定义">定义</h2><blockquote><p>通过==最小堆（最小堆存放树的根结点）==来实现，每次拿出两个权值==最小的二叉树==进行合并，合并后的新树插入最小堆</p></blockquote><h2 id="注意">注意</h2><ol type="1"><li>哈夫曼<strong>树</strong> 属于 ==树==，也是链式存储</li><li><strong>构建<code>HuffmanTree</code>之前必须先构建<code>MinHeap</code></strong></li></ol><span id="more"></span><h2 id="特点">特点</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012075.png"alt="image-20230916123759336" /><figcaption aria-hidden="true">image-20230916123759336</figcaption></figure><blockquote><ol type="1"><li>==<strong><font color='red'>权值的个数即为叶子节点的个数</font></strong>==</li><li><span class="math inline">\(HuffmanTree\)</span>编码的<strong><font color='gree'>码字</font></strong>均在<strong><font color='purple'>叶结点</font></strong>上</li></ol></blockquote><p>哈夫曼树是一种带权路径长度最短的树，在一个度为 <spanclass="math inline">\(m\)</span> 的哈夫曼树中，其叶结点个数为 <spanclass="math inline">\(n_0\)</span>，则非叶结点的个数为<u><strong><font color='red'>（n-1)/ （m-1）</font></strong></u>。</p><ul><li>度为 <span class="math inline">\(m\)</span> 的哈夫曼树中，只存在<span class="math inline">\(n_0\)</span> 和 <spanclass="math inline">\(n_m\)</span>，所以</li></ul><p><span class="math display">\[n_0+n_{}=mn_m+1\\\Longrightarrow n_{}=\small{\frac{n_0-1}{m-1}}\]</span></p><ul><li>若 <span class="math inline">\(n-1\)</span>不能被整除，即所给数据不能直接构造最优 <spanclass="math inline">\(m\)</span>叉树，这时需要加一些不影响建树的数据，可以添 <spanclass="math inline">\(0\)</span>，添加的个数为 <spanclass="math inline">\(\left( m-1 \right) -\left( n-1 \right) \%\left(m-1 \right)\)</span></li><li>所以最终 <span class="math inline">\(x\)</span> 应该为 <spanclass="math inline">\(\lceil n-1/m-1 \rceil\)</span></li></ul><blockquote><p>联想：信息论进行 <span class="math inline">\(m\)</span> 元 <spanclass="math inline">\(Huffman\)</span> 编码进行压缩，每 <spanclass="math inline">\(m\)</span> 个压缩一次后减少了 <spanclass="math inline">\(m-1\)</span> 个，最后一次压缩可能需要补零 <spanclass="math inline">\(q+t=k(m-1)+m\)</span></p></blockquote><h2 id="操作">操作</h2><h3 id="对象">对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* left,right;</span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree data[Maxsize];<span class="comment">//Attention!!</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MinHeap;</span><br><span class="line"></span><br><span class="line">HuffmanTree T=<span class="built_in">CreateHuffman</span>();</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树的创建初始化">哈夫曼树的创建(初始化)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Huffman T=(Huffman)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;weight=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树的建立">哈夫曼树的建立</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">BuildHuffman</span><span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;H-&gt;size;i++)<span class="comment">/*做H-&gt;Size-1次合并*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));<span class="comment">/*建立新结点*/</span></span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(H);<span class="comment">/*从最小堆中删除一个结点，作为新T的左子结点*/</span></span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(H);<span class="comment">/*再从最小堆中删除一个结点，作为新T的右子结点*/</span></span><br><span class="line">        T-&gt;weight=T-&gt;left-&gt;weight+T-&gt;right-&gt;weight;<span class="comment">/*计算新权值*/</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T);<span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="built_in">Delete</span>(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要调用的minheap函数">需要调用的MinHeap函数</h4><h5 id="最小堆creatheap">最小堆CreatHeap</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinHeap H=(MinHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HeapNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]=(Huffman)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;left=H-&gt;data[<span class="number">0</span>]-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;weight=<span class="number">-1</span>;<span class="comment">//哨兵H-&gt;data[0]的值最小</span></span><br><span class="line">H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr /><h5 id="最小堆buildheap函数">最小堆BuildHeap函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuidHeap</span> <span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    HuffmanTree t=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">    t-&gt;left=t-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t-&gt;weight;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h5 id="最小堆delete函数">最小堆Delete函数</h5><blockquote><ol type="1"><li>需要把<code>ElementType</code>改变成<code>HuffmanTree</code></li><li>将<code>H-&gt;data[child]</code>改为<code>H-&gt;data[child]-&gt;weight</code></li><li>将<code>t</code>改为<code>t-&gt;weight</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span><span class="comment">//Attention!!!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//可有可无</span></span><br><span class="line"><span class="comment">//    if(H-&gt;size==0)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line">    </span><br><span class="line">    HuffmanTree min=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点最小值，最后return</span></span><br><span class="line">   <span class="comment">/* 用最小堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    HuffmanTree t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最小的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;size&amp;&amp;H-&gt;data[child]-&gt;weight &gt; H-&gt;data[child+<span class="number">1</span>]-&gt;weight)<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;weight &lt;= H-&gt;data[child]-&gt;weight)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>将H-&gt;Elements[]按==权值==<code>H-&gt;Elements[]-&gt;weight</code>调整为最小堆</li><li>第11行~~parent*=2~~错误，必须是<code>parent=child</code>,作用是parent索引变成儿子索引，向下交换</li><li>第9行<del><code>data[H-&gt;size]</code></del>错误，必须是<code>data[H-&gt;size--]</code></li></ol></blockquote><hr /><h6 id="最小堆insert函数">最小堆Insert函数</h6><blockquote><ol type="1"><li>需要把<code>ElementType</code>改变成<code>HuffmanTree</code></li><li>将<code>H-&gt;data[i/2]</code>改为<code>H-&gt;data[i/2]-&gt;weight</code></li><li>将<code>t</code>改为<code>t-&gt;weight</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size&gt;=Maxsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t-&gt;weight &lt; H-&gt;data[i/<span class="number">2</span>]-&gt;weight;i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="wpl的计算">WPL的计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意：哈夫曼树没有度为1的节点 </span></span><br><span class="line"><span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)<span class="comment">//左右子树都为空</span></span><br><span class="line"><span class="keyword">return</span> depth*T-&gt;weight;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//递归去左右子树求权重，而且深度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">WPL</span>(T-&gt;left,depth+<span class="number">1</span>)+<span class="built_in">WPL</span>(T-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>初次调用WPL时：<code>int sum=WPL(T,0);</code>使depth的初始值为==0==；（因为==根节点的深度为0==）。这里的深度<code>depth</code>实际是码字长度</li><li>递归出口为根节点<code>T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL</code></li><li>递归关系为<code>WPL(T-&gt;left,depth+1)+WPL(T-&gt;right,depth+1);</code></li><li>哈夫曼树没有度为1的节点</li></ol></blockquote><hr /><h1 id="例题-05-树9-huffman-codes">例题 <strong>05-树9 HuffmanCodes</strong></h1><p>In 1953, David A. Huffman published his paper "A Method for theConstruction of Minimum-Redundancy Codes", and hence printed his name inthe history of computer science. As a professor who gives the final examproblem on Huffman codes, I am encountering a big problem: the Huffmancodes are NOT unique. For example, given a string "aaaxuaxz", we canobserve that the frequencies of the characters 'a', 'x', 'u' and 'z' are4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0,'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001,'z'=000}, both compress the string into 14 bits. Another set of code canbe given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01,'u'=011, 'z'=001} is NOT correct since "aaaxuaxz" and "aazuaxax" canboth be decoded from the code 00001011001001. The students aresubmitting all kinds of codes, and I need a computer program to help medetermine which ones are correct and which ones are not.</p><h3 id="input-specification">Input Specification:</h3><p>Each input file contains one test case. For each case, the first linegives an integer <em>N</em> (2≤<em>N</em>≤63), then followed by a linethat contains all the <em>N</em> distinct characters and theirfrequencies in the following format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[1] f[1] c[2] f[2] ... c[N] f[N]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is a character chosen from {'0' - '9', 'a' -'z', 'A' - 'Z', '_'}, and <code>f[i]</code> is the frequency of<code>c[i]</code> and is an integer no more than 1000. The next linegives a positive integer <em>M</em> (≤1000), then followed by <em>M</em>student submissions. Each student submission consists of <em>N</em>lines, each in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i] code[i]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is the <code>i</code>-th character and<code>code[i]</code> is an non-empty string of no more than 63 '0's and'1's.</p><h3 id="output-specification">Output Specification:</h3><p>For each test case, print in each line either "Yes" if the student'ssubmission is correct, or "No" if not.</p><p>Note: The optimal solution is not necessarily generated by Huffmanalgorithm. Any prefix code with code length being optimal is consideredcorrect.</p><h3 id="sample-input">Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">A 1 B 1 C 1 D 3 E 3 F 6 G 6</span><br><span class="line">4</span><br><span class="line">A 00000</span><br><span class="line">B 00001</span><br><span class="line">C 0001</span><br><span class="line">D 001</span><br><span class="line">E 01</span><br><span class="line">F 10</span><br><span class="line">G 11</span><br><span class="line">A 01010</span><br><span class="line">B 01011</span><br><span class="line">C 0100</span><br><span class="line">D 011</span><br><span class="line">E 10</span><br><span class="line">F 11</span><br><span class="line">G 00</span><br><span class="line">A 000</span><br><span class="line">B 001</span><br><span class="line">C 010</span><br><span class="line">D 011</span><br><span class="line">E 100</span><br><span class="line">F 101</span><br><span class="line">G 110</span><br><span class="line">A 00000</span><br><span class="line">B 00001</span><br><span class="line">C 0001</span><br><span class="line">D 001</span><br><span class="line">E 00</span><br><span class="line">F 10</span><br><span class="line">G 11</span><br></pre></td></tr></table></figure><h3 id="sample-output">Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>400 ms</p><p>内存限制</p><p>64 MB</p><p><ahref="%5B数据结构_中国大学MOOC(慕课)%20(icourse163.org)%5D(https://www.icourse163.org/learn/ZJU-93001?tid=1468077441#/learn/content?type=detail&amp;id=1249683129&amp;cid=1277237407)">解题思路</a></p><h2 id="分析">分析</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012036.png"alt="image-20220923151214229" /><figcaption aria-hidden="true">image-20220923151214229</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012970.png"alt="image-20220923151404979" /><figcaption aria-hidden="true">image-20220923151404979</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012024.png"alt="image-20220923151427266" /><figcaption aria-hidden="true">image-20220923151427266</figcaption></figure><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 64</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建MinHeap和HeapNode结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* left, *right;</span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree data[Maxsize];<span class="comment">//Attention!!</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MinHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line"><span class="type">int</span> n,m,min_length;<span class="type">char</span> c; </span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span>;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//建立最小堆 </span></span><br><span class="line">MinHeap H=<span class="built_in">CreatHeap</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    HuffmanTree t=<span class="built_in">CreateHuffman</span>(); </span><br><span class="line">        cin&gt;&gt;c&gt;&gt;t-&gt;weight;</span><br><span class="line">        cnt[c]=t-&gt;weight;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  建立哈夫曼树 </span></span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="type">int</span> n=H-&gt;size; </span><br><span class="line"><span class="comment">//  for(int i=1;i&lt;H-&gt;size;i++) 错误，H-&gt;size的值会在循环中改变 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">/*做n-1次合并*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(H);</span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(H);</span><br><span class="line">        T-&gt;weight=T-&gt;left-&gt;weight+T-&gt;right-&gt;weight;<span class="comment">/*计算新权值*/</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T);<span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="built_in">Delete</span>(H);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  计算最短长度 </span></span><br><span class="line">min_length=<span class="built_in">WPL</span>(T,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//判断 </span></span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">judge</span>())<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinHeap H=(MinHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HeapNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;left=H-&gt;data[<span class="number">0</span>]-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;weight=<span class="number">-1</span>;<span class="comment">//哨兵H-&gt;data[0]的值最小</span></span><br><span class="line">H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HuffmanTree T=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;weight=<span class="number">0</span>;<span class="comment">//Attention！！</span></span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    可有可无 </span></span><br><span class="line"><span class="comment">//    if(H-&gt;size&gt;=Maxsize)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t-&gt;weight &lt; H-&gt;data[i/<span class="number">2</span>]-&gt;weight;i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    HuffmanTree min=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点（weight最小），最后return</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 用最小堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    HuffmanTree t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最小的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;size&amp;&amp;H-&gt;data[child]-&gt;weight &gt; H-&gt;data[child+<span class="number">1</span>]-&gt;weight)<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;weight&lt;=H-&gt;data[child]-&gt;weight)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意：哈夫曼树没有度为1的节点 </span></span><br><span class="line"><span class="keyword">if</span>((T-&gt;left==<span class="literal">NULL</span>)&amp;&amp;(T-&gt;right==<span class="literal">NULL</span>))<span class="comment">//左右子树都为空</span></span><br><span class="line"><span class="keyword">return</span> depth*T-&gt;weight;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//递归去左右子树求权重，而且深度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">WPL</span>(T-&gt;left,depth+<span class="number">1</span>)+<span class="built_in">WPL</span>(T-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">string codes; </span><br><span class="line">HuffmanTree T=<span class="built_in">CreateHuffman</span>();      <span class="comment">//模拟建树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c&gt;&gt;codes;</span><br><span class="line"><span class="keyword">if</span>(codes.<span class="built_in">length</span>()&gt;=n)<span class="comment">//也可以没有这个判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree p = T;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;codes.<span class="built_in">length</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(codes[j]==<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">p-&gt;left = <span class="built_in">CreateHuffman</span>();</span><br><span class="line">p = p-&gt;left;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(codes[j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">p-&gt;right = <span class="built_in">CreateHuffman</span>();</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;weight) <span class="comment">//说明已经被访问过了 </span></span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//不能直接打印，要把后面的读完 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;left || p-&gt;right )<span class="comment">//说明该结点不是叶子节点 </span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p-&gt;weight = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">len += codes.<span class="built_in">length</span>()*cnt[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(len!=min_length)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1">注意</h3><blockquote><p>judge函数模拟建树过程中</p><ol type="1"><li>左右移动过程中不能遇到<strong>已经访问的节点</strong></li><li>最后赋值的节点必须是<strong>叶节点</strong></li><li>节点weight起到标记flag的作用</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%9B%BE%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%9B%BE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="图的术语">图的术语</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017409.png"alt="image-20221105083921772" /><figcaption aria-hidden="true">image-20221105083921772</figcaption></figure><span id="more"></span><h1 id="图的存储结构">图的存储结构</h1><h2 id="邻接矩阵adjacency-matrix">邻接矩阵（Adjacency Matrix)</h2><h3 id="存储结构">存储结构</h3><blockquote><p>1、图是由<strong>顶点</strong>和<strong>边/弧</strong>两部分组成，合在一起比较困难，可以分为两个结构来存储</p><p>2、<strong>顶点</strong>因为不区分大小，主次，所以可以用一个<font color='red'><strong>一维数组</strong>来存储顶点</font>，记录各个顶点的信息</p><p><strong>边/弧</strong>是顶点和顶点的关系，用<strong>邻接矩阵</strong>来存储，表示各个顶点之间的邻接关系。是图的<strong><font color='red'>顺序存储结构</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;  <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><blockquote><p>注：<strong>VertexType</strong>和<strong>ArcType</strong>等价于<strong>ElementType</strong></p><ol type="1"><li><p><strong><code>ElementType</code></strong>既可以是<code>int</code>，<code>char</code>，<code>double</code>，<code>float</code>等，即</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> ElementType;    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ElementType ;      </span><br></pre></td></tr></table></figure></p><blockquote><p>注意typedef最后面的<font color='red'><strong>分号</strong></font></p></blockquote><p><strong><code>ElementType</code></strong>也可以是自定义的<strong>struct类型</strong>，eg：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;ElementType;</span><br></pre></td></tr></table></figure></p></li><li><p><code>MVNum</code>与<code>MaxInt</code>需要通过宏定义</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br></pre></td></tr></table></figure></p></li></ol></blockquote><hr /><hr /><h3 id="采用邻接矩阵创建无向网">采用邻接矩阵创建无向网</h3><blockquote><p>【算法步骤】 1、输入总顶点数和边数 2、依次输入点的信息存入到顶点表中3、初始化邻接矩阵，使每个权值初始化为极大值 4、构造邻接矩阵</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用邻接矩阵表示法创建无向网*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateUDN</span><span class="params">(Graph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入总顶点数和总边数</span></span><br><span class="line">cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输入顶点表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">cin &gt;&gt; G.vexs[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入邻接矩阵</span></span><br><span class="line"><span class="comment">    1. 初始化邻接矩阵，边的权值均置为极大值    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*法一：</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; G.vexnum;++i)</span></span><br><span class="line"><span class="comment">for (int j = 0;j &lt; G.vexnum;++j)</span></span><br><span class="line"><span class="comment">G.arcs[i][j] = INT_MAX;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line">    <span class="built_in">fill</span>(G.arcs[<span class="number">0</span>],G.arc[<span class="number">0</span>] + G.vexnum * G.vexnum, INT_MAX);<span class="comment">//头文件：#include &lt;algorithm&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2. 输入边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.arcnum;++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输入一条边依附的顶点和权值        </span></span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line"><span class="comment">//确定两个顶点v1和v2在G中的位置        </span></span><br><span class="line">i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line"><span class="comment">//无向网 边&lt;v1,v2&gt;和&lt;v2,v1&gt;的权值均置为w        </span></span><br><span class="line">G.arcs[i][j] = G.arcs[j][i] = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在图中查找顶点的位置LocateVex()函数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(Graph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若在图中找到这个元素，则返回它的下标i,否则返回-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line"><span class="keyword">if</span> (u == G.vexs[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意">注意</h3><p>问：图的邻接矩阵，不相连的边用0还是无穷？</p><blockquote><p>——–那要看你的边权到底是拿来干嘛用的了</p><ul><li><p>若做路径搜索/最小生成树/最短距离，边权是路程长度，那不连通的理所应当用inf。</p></li><li><p>但若仅判断有无边，无关长度/路径/代价，无连接的时候自然可以用0</p></li></ul></blockquote><h4 id="无向有向图的邻接矩阵">（无向/有向）图的邻接矩阵</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017348.png"alt="image-20221101200143602" /><figcaption aria-hidden="true">image-20221101200143602</figcaption></figure><blockquote><p><strong><font color='blue'>无边用0表示</font></strong></p></blockquote><p>例如：<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017365.png"alt="image-20221101200513851" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017328.png"alt="image-20221101200537514" /><figcaption aria-hidden="true">image-20221101200537514</figcaption></figure><h4 id="有向无向网">（有向/无向）网</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017324.png"alt="image-20221101200729973" /><figcaption aria-hidden="true">image-20221101200729973</figcaption></figure><blockquote><p><strong><font color='blue'>无边用∞表示</font></strong></p></blockquote><p>例如</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017330.png"alt="image-20221101200823831" /><figcaption aria-hidden="true">image-20221101200823831</figcaption></figure><p>有向带权图（网）的邻接矩阵</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017882.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><table><thead><tr class="header"><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr class="odd"><td>A</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>B</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>C</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr class="even"><td>D</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>E</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>F</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id="邻接表adjacency-list">邻接表(Adjacency List）</h2><ol type="1"><li>邻接表是图的<strong><font color='red'>链式存储结构</font></strong></li><li>只存储图中<strong>存在的边</strong>的信息，对不相邻的顶点则不保留信息</li><li>对图中<strong>每个顶点v</strong>i建立一个<strong>带头结点的单链表</strong>，称为顶点表</li><li>把<strong>与vi相邻接的顶点</strong>放在这个链表中，一个单链表对应邻接矩阵中的一行，称为<strong>边链表</strong>。</li></ol><h3 id="存储结构-1">存储结构</h3><blockquote><p><strong>分三部分： 1、图的结构定义 2、顶点的头结点结构3、弧（边）的结点结构</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（即在AdjList[]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*说明*/</span></span><br><span class="line">Graph G;<span class="comment">//定义了邻接表表示的图G</span></span><br><span class="line">G.vexnum = <span class="number">5</span>;G.arcnum = <span class="number">6</span>;<span class="comment">//图G包含了5个顶点和6条边</span></span><br><span class="line">G.vexs[<span class="number">1</span>].data = <span class="string">&#x27;v2&#x27;</span>;<span class="comment">//图G中第2个顶点是v2</span></span><br><span class="line">p = G.vexs[<span class="number">1</span>].firstarc;<span class="comment">//指针p指向顶点v2的第一个边结点</span></span><br><span class="line">p-&gt;adjvex = <span class="number">4</span>;<span class="comment">//p指针所指边结点是到下标为4的结点的边</span></span><br></pre></td></tr></table></figure><h3 id="采用邻接表创建无向图">2，采用邻接表创建无向图</h3><blockquote><p>【算法步骤】</p><p>1，输入总顶点数和总边数</p><p>2，建立顶点表</p><ul><li>依次输入点的信息存入顶点表中</li><li>使每个表头结点的指针域初始化为<code>NULL</code></li></ul><p>3、创建邻接表</p><ul><li>依次输入每条边依附的两个顶点</li><li>确定这两个顶点的序号<code>i</code>和<code>j</code></li><li>将此边结点分别插入<code>vi</code>和<code>vj</code>对应的两个边链表的头部</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用邻接表表示法创建无向图*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(Graph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入顶点数和弧数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; G.vexs[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">G.vexs[i].firstarc = <span class="literal">NULL</span>;<span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.arcnum;k++)<span class="comment">//输入各边，构造邻接表，头插法</span></span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">i = <span class="built_in">LocateVex</span>(G, v1);j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">        p1=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));<span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">p1-&gt;adjvex = j;<span class="comment">//邻结点序号为j</span></span><br><span class="line">p1-&gt;nextarc = G.vexs[i].firstarc;<span class="comment">//firstarc为空，所以nextarc也指向空，即最后的一个结点</span></span><br><span class="line">G.vexs[i].firstarc = p1;   <span class="comment">//将新结点*p1插入到顶点vi的边表头部</span></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">p2 = <span class="keyword">new</span> ArcNode;<span class="comment">//生成一个新的边结点*p2</span></span><br><span class="line">p2-&gt;adjvex = i;</span><br><span class="line">p2-&gt;nextarc = G.vexs[j].firstarc;<span class="comment">//插入弧结点到单链表</span></span><br><span class="line">G.vexs[j].firstarc = p2;<span class="comment">//将新结点*p2插入到顶点vi的边表头部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1">注意</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017876.png"alt="image-20221101201335057" /><figcaption aria-hidden="true">image-20221101201335057</figcaption></figure><blockquote><ol type="1"><li>顶点表顺序存储，以便可以随机访问任一顶点的边链表</li><li>邻接表表示不唯一</li></ol></blockquote><h1 id="图的遍历">图的遍历</h1><h2 id="dfs">DFS</h2><h3 id="连通图">连通图</h3><h4 id="邻接矩阵"><strong>邻接矩阵</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵的存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//当前图的顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DFS遍历连通图*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从第v个顶点依次遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//访问标志符数组置为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; G.vexnum;w++)<span class="comment">//依次检查邻接矩阵v所在行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][w] != <span class="number">0</span> &amp;&amp; !visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//w是v的邻接点，如果w未被访问，则调用DFS_AM</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表"><strong><font color='red'>邻接表</font></strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span>* nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"></span><br><span class="line">==========================================================================================================================================</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*采用邻接表表示图的DFS*/</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">DFS</span>(ALGraph G, <span class="type">int</span> v)</span><br><span class="line">&#123;<span class="comment">//图G为邻接表类型，从第v个结点出发DFS图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//置访问标志符为true</span></span><br><span class="line"><span class="keyword">for</span>(ArcNode* p = G.vexs[v].firstarc; p ;p = p-&gt;nextarc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> w = p-&gt;adjvex;<span class="comment">//w是p邻接点的下标</span></span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//如果w未访问，则递归调用DFS_AL</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非连通图">非连通图</h3><h4 id="邻接矩阵-1">邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*非连通图G的深度优先搜索遍历*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从第v个顶点依次遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//访问标志符数组置为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; G.vexnum; w++)<span class="comment">//依次检查邻接矩阵v所在行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][w] &amp;&amp; !visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//w是v的邻接点，如果w未被访问，则调用DFS_AM</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//访问标志数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line"><span class="built_in">DFS</span>(G, i);<span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表-1">邻接表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v)</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(ArcNode* p=G.vexs[v].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[j])</span><br><span class="line">            <span class="built_in">DFS</span>(G,j);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//访问标志数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line"><span class="built_in">DFS</span>(G, i);<span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bfs">BFS</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017851.png"alt="image-20221003205935386" /><figcaption aria-hidden="true">image-20221003205935386</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017845.png"alt="image-20221003205948486" /><figcaption aria-hidden="true">image-20221003205948486</figcaption></figure><h3id="采用邻接矩阵表示的图的bfs"><strong>采用<font color='red'>邻接矩阵</font>表示的图的BFS:</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按广度优先非递归遍历连通图G*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">q.<span class="built_in">push</span>(v);<span class="comment">//v进队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();<span class="comment">//队头元素出队并置为u</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line"><span class="keyword">if</span> (arcs[u][w] &amp;&amp; !visited[w])<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;<span class="comment">//置访问标志数组分量为true</span></span><br><span class="line">q.<span class="built_in">push</span>(w);<span class="comment">//w进队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>入栈的同时访问</font></strong>，出栈时不必访问</p></blockquote><h3id="采用邻接表表示的图的bfs"><strong>采用<font color='red'>邻接表</font>表示的图的BFS:</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按广度优先非递归遍历连通图G*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">q.<span class="built_in">push</span>(v);<span class="comment">//v进队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();<span class="comment">//队头元素出队并置为u</span></span><br><span class="line"><span class="keyword">for</span> (ArcNode* p=G.vexs[u].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w=p-&gt;adjvex;<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;<span class="comment">//置访问标志数组分量为true</span></span><br><span class="line">q.<span class="built_in">push</span>(w);<span class="comment">//w进队</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用">作用</h2><p>DFS/BFS的作用</p><ul><li>求图的<strong><font color='red'>连通分量</font></strong></li><li>判断图是否连通</li></ul><h2 id="例题">例题</h2><h3 id="图1-列出连通集"><strong>06-图1 列出连通集</strong></h3><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式">输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式">输出格式:</h3><p>按照"{ <em>v</em>1 <em>v</em>2 ... *v**k*}"的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arc[<span class="number">105</span>][<span class="number">105</span>];<span class="type">int</span> visit[<span class="number">10</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arc[i][j]==<span class="number">1</span>&amp;&amp;visit[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">            visit[j]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">visit[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arc[i][j]==<span class="number">1</span>&amp;&amp;visit[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line"> visit[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> t1,t2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">arc[t1][t2]=arc[t2][t1]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//memset(visit,0,sizeof(visit));</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">visit[i]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树">最小生成树</h1><ul><li><p>生成树：包含==<strong><font color='red'>连通图</font></strong>==中<strong><font color='blue'>所有顶点</font></strong>的<strong><font color='gree'>极小</font><font color='orange'>连通子图</font></strong></p></li><li><p>最小生成树（Minimum SpanningTree，简称MST）：带权<strong><font color='red'>连通图</font></strong>（网）的所有生成树中，<strong>各边权值之和最小</strong>的<strong>生成树</strong>称为<strong>最小生成树</strong></p></li></ul><blockquote><ol type="1"><li><p>只有<strong><font color='red'>连通图（无向）</font></strong>才存在最小生成树/生成树</p></li><li><p><strong><font color='red'>有向图不存在生成树</font></strong>的概念</p></li><li><p>连通图的生成树具有这样的特征，即生成树中<code>边的数量 = 顶点数 - 1</code>。</p></li></ol></blockquote><h2 id="prim算法加点法">prim算法(加点法)</h2><h3 id="算法概要">算法概要</h3><pre><code>**设G = （ V , E )是连通网，T是 G 上最小生成树中边的集合。U为G上最小生成树顶点的集合**</code></pre><p>（1）初始时，<strong>U={u<sub>0</sub>}（u<sub>0</sub>∈V）,T={}</strong></p><p>（2）找到满足<strong><code>min&#123; weight(ui,vi) |ui∈U，vi∈V-U&#125;</code></strong>的边<strong><code>(ui,vi)</code></strong>，并将该边加入T，同时<strong><code>vi</code></strong>并入U；</p><p>（3）重复步骤（2），直到<strong><code>U=V</code></strong>时算法结束</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017920.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="数据结构">数据结构</h3><p><strong>（1）图采用邻接矩阵来存储（2）一维数组closedeg,记录从U到V-U具有最小代价的边。</strong></p><blockquote><p><strong><code>closeedge[i]</code></strong>表示顶点==<strong><font color='blue'>v<sub>i</sub></font></strong>==到集合U的<strong><font color='gree'>最短边</font></strong>，其中</p><ul><li><strong><code>closeedge[i].adjvex</code></strong>表示依附于这条最小代价边的<strong><font color='blue'>另一个顶点</font></strong></li><li><strong><code>closeedge[i].lowcost</code></strong>表示最小边的权值<ul><li><strong><code>closeedge[i].lowcost = 0</code></strong> :表示顶点v<sub>i</sub> 已经在顶点集U中</li><li><strong><code>closeedge[i].lowcost != 0</code></strong> :表示顶点v<sub>i</sub> 还在顶点集V-U中</li></ul></li></ul><blockquote><p><strong><code>closeedge[i];</code></strong>有三种功能</p><ol type="1"><li>标记顶点 v<sub>i</sub>是否已经再顶点集U中</li><li>记录顶点v<sub>i</sub>到集合U-V的最小边（包含另一个顶点adjvex和边的权值）</li></ol></blockquote></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018349.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;  <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VerTexType adjvex;<span class="comment">//最小边的顶点</span></span><br><span class="line">ArcType lowcost;<span class="comment">//最小边的权值</span></span><br><span class="line">&#125;closedge[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//adjvex:依附于这条最小代价边的另一个顶点</span></span><br><span class="line"><span class="comment">//lowcost = 0 :表示顶点已经在顶点集U中</span></span><br><span class="line"><span class="comment">//lowcost != 0 :表示顶点i还在V-U中</span></span><br></pre></td></tr></table></figure><h3 id="算法实现">算法实现</h3><h4 id="邻接矩阵-2">邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(Graph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//无向网G以邻接矩阵存储，从顶点u出发构造G的最小生成树T,输出T的各条边</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">LocateVex</span>(G, u);<span class="comment">//起点位置，k为顶点u的下标</span></span><br><span class="line"><span class="comment">//对V-U的每个顶点vi,初始化closedge[i]    </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            closedge[i].adjvex = u;</span><br><span class="line">closedge[i].lowcost = G.arcs[k][i];</span><br><span class="line">          <span class="comment">//closedge[i]=&#123;G.vexs[k],G.arcs[k][i]&#125;  //closedge[i]=&#123; u, G.arcs[k][i]&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            closedge[i].lowcost = <span class="number">0</span>;<span class="comment">//初始，U = &#123; u &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; G.vexnum;++i)<span class="comment">//选择其余n-1个顶点，生成n-1条边（n = G.vexnum ）</span></span><br><span class="line">&#123;</span><br><span class="line">k = <span class="built_in">Min</span>(closedge);<span class="comment">//求出T的下一个结点：closedge[k]存有当前最小边(非零最小)</span></span><br><span class="line"><span class="built_in">printf</span>( G.vexs[k], closedge[k].adjvex );</span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//新顶点并入U后修改其他顶点最小边        </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line"><span class="keyword">if</span> (G.arcs[k][j] &lt; closedge[j].lowcost)</span><br><span class="line">&#123;</span><br><span class="line">closedge[j].adjvex = G.vexs[k];</span><br><span class="line">closedge[j].lowcost = G.arcs[k][j];</span><br><span class="line">             <span class="comment">//closedge[j]=&#123;G.vexs[k],G.arcs[k][j]&#125;  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表-2">邻接表</h4><h2 id="kruskal算法加边法">Kruskal算法（加边法）</h2><h3 id="算法思想">算法思想</h3><pre><code>            **设G = （ V , E )是连通网，T是 G 上最小生成树中边的集合。**</code></pre><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018480.png"alt="image-20221101171353307" /><figcaption aria-hidden="true">image-20221101171353307</figcaption></figure><h3 id="算法实现-1">算法实现</h3><h2 id="注意-2">注意</h2><blockquote><p>Dijkstra算法不能处理带有<strong><font color='red'>负权值</font></strong>的边</p></blockquote><ul><li>反例<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018368.webp"alt="img" /></li></ul><p>按照Prim算法，d（4）为2，路径为1，3，4</p><p>但显然路径是1，2，3，4时，d（4）才是最小，为1</p><ul><li>原因：Dijkstra算法是按照<strong><font color='red'>路径长度递增</font></strong>的次序，逐步产生各个顶点到源点最短路径的<strong><font color='red'>贪心</font></strong>算法，而当存在带负权值的边时，当把一个节点选入集合S时，即意味着已经找到了从源点到这个点的最短路径，但若存在负权边，就与这个前提矛盾，可能会出现得出的距离加上负权后比已经得到S中的最短路径还短。（无法回溯）</li></ul><blockquote><p>Floyd算法允许有<strong><font color='red'>带负权值的边</font></strong>，但不允许图中有<strong><font color='red'>包含带负权值回路</font></strong></p></blockquote><ul><li><p>这句话的意思并不是说“<strong>只要回路中存在负权值Floyd就不可以解决</strong>”。而是<strong>“组成这个回路的所有的边的权值之和如果为负，就无法解决，否则还是可以解决的”</strong></p></li><li><p>举例说明<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018397.png"alt="img" /></p></li></ul><p>这个图中右侧的三个边组成了一个回路，其中一边为负，但是三边权值之和为：<strong>2+3+(-1)=4&gt;0</strong>，此时Folyd算法是可以解决的</p><hr /><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018382.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>而第二张图同样右侧的三个边组成了一个回路，其中一边为负，但是三边权值之和为：<strong>1+1+(-3)=-2&lt;0</strong>，此时Folyd算法无法解决，因为每多走一遍回路总的路径就会-2 如果求路径长度最小值只需要一直走下去，进入了死循环。</p><hr /><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018390.png"alt="image-20221109220903123" /><figcaption aria-hidden="true">image-20221109220903123</figcaption></figure><h2 id="例题-1">例题</h2><p><strong>利用Prim算法、Kruskal算法构造最小生成树</strong> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018791.png"alt="在这里插入图片描述" /></p><p><strong>利用Prim算法、Kruskal算法构造最小生成树</strong> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018797.png"alt="在这里插入图片描述" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018021.jpeg"alt="13311768599213125" /><figcaption aria-hidden="true">13311768599213125</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018029.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h1 id="拓扑排序">拓扑排序</h1><h2 id="定义">定义</h2><ol type="1"><li><p><strong><font color='red'>顶点活动网(AOV网</font></strong>，ActivityOn <strong><font color='red'>Vertex</font></strong>NetWork)：将==<strong><font color='oran'>顶点表示活动，边表示活动之间的关系</font></strong>==的有向网称为<strong>顶点活动网</strong>；</p></li><li><p>拓扑序列：若有向图G/AOV网的顶点序列v1,v2,…,vn满足下列条件：若在AOV网/有向图G中<strong>存在从vi到vj的路径</strong>，则在该<strong>（线性）序列</strong>中的<strong><font color='orange'>vi必定在vj之前</font></strong>，便称这个序列为一个拓扑序列。</p></li><li><p>求一个有向图拓扑序列的过程称为拓扑排序。</p></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018070.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="算法概要-1">算法概要</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018246.png"alt="image-20221102100608149" /><figcaption aria-hidden="true">image-20221102100608149</figcaption></figure><p>拓扑排序<strong>可以判断一个有向图<font color='red'>是否存在环路</font></strong></p><ol type="1"><li>若网中<strong>所有顶点</strong>都在其的拓扑排序序列中，则该AOV网中必不存在环。</li><li>如果有向图存在环，则不能进行拓扑排序；反之，如果对一个有向图不能进行拓扑排序，则必定存在环。<ul><li>==<strong><font color='red'>有向图存在环路&lt; = =&gt;不能进行拓扑排序&lt; = = &gt;不存在关键路径</font></strong>==</li><li>==<strong><font color='red'>有向图不存在环路（即有向无环图）&lt; = =&gt;能进行拓扑排序&lt; = = &gt;存在关键路径</font></strong>==</li></ul></li></ol><h3 id="算法实现-2">算法实现</h3><h4 id="邻接矩阵-3">邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(Graph G,<span class="type">int</span> &amp;indegree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[i][j])</span><br><span class="line">            indegree[j]++;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G, <span class="type">int</span> topo[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图G采用邻接矩阵存储</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G,indegree);<span class="comment">//求出各顶点的入度存入数组indegree中</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;<span class="comment">//栈初始化为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line"><span class="keyword">if</span> (!indegree[i]) s.<span class="built_in">push</span>(i);<span class="comment">//入度为0者进栈</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始化为0</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())<span class="comment">//栈S非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();<span class="comment">//取栈顶顶点vi出栈</span></span><br><span class="line">topo[cnt++] = i;<span class="comment">//将vi保存在拓扑序列数组topo中    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p遍历vi的所有邻接点        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[i][j] &amp;&amp; --indegree[j]==<span class="number">0</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (cnt &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//该有向图有回路</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="邻接表-3">邻接表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（在AdjList[MVNum]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(Graph G,<span class="type">int</span> &amp;indegree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(ArcNode *p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopoSort</span><span class="params">(Graph G, <span class="type">int</span> topo[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G,indegree);<span class="comment">//求出各顶点的入度存入数组indegree中</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;<span class="comment">//栈初始化为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line"><span class="keyword">if</span> (!indegree[i]) s.<span class="built_in">push</span>(i);<span class="comment">//入度为0者进栈</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始化为0</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())<span class="comment">//栈S非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();<span class="comment">//取栈顶顶点vi出栈</span></span><br><span class="line">topo[cnt++] = i;<span class="comment">//将vi保存在拓扑序列数组topo中    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p遍历vi的所有邻接点        </span></span><br><span class="line">        <span class="keyword">for</span>(ArcNode *p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            k=p-&gt;adjvex;<span class="comment">//vk为vi的邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(--indegree[k]==<span class="number">0</span>)<span class="comment">//先把indegree[k]减1，若入度减为0，则入栈</span></span><br><span class="line">                s.<span class="built_in">push</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (cnt &lt; G.vexnum)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//该有向图有回路</span></span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="关键路径">关键路径</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018217.png"alt="image-20221109094330861" /><figcaption aria-hidden="true">image-20221109094330861</figcaption></figure><h3 id="邻接表-4">邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（在AdjList[MVNum]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"><span class="comment">//G为邻接表存储的有向网，输出G的各项关键活动    </span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CriticalPath</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">TopoSort</span>(G, topo)) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给每个事件的最早发生时间置初值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">ve[i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*按照拓扑次序求每个事件的最早发生时间*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//从前往后</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = topo[i];<span class="comment">//取得拓扑序列中的顶点序号j</span></span><br><span class="line"><span class="keyword">for</span>(ArcNode *p = G.vexs[j].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">&#123;    <span class="comment">//依次更新j的所有邻接顶点的最早发生时间</span></span><br><span class="line"><span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//k为邻接顶点的序号</span></span><br><span class="line"><span class="keyword">if</span> (ve[k] &lt; ve[j] + p-&gt;info)   <span class="comment">//更新顶点k的最早发生时间ve[k]</span></span><br><span class="line">ve[k] = ve[j] + p-&gt;info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给每个事件的最迟发生时间置初值为ve[n-1]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) </span><br><span class="line">vl[i] = ve[G.vexnum - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*按逆拓扑次序求每个事件的最迟发生时间*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = G.vexnum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//从后往前</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = topo[i];<span class="comment">//取得拓扑序列中的顶点序号k</span></span><br><span class="line"><span class="keyword">for</span>(p = G.vexs[j].firstarc; p ; p=p-&gt;nextarc)<span class="comment">//活动&lt;vj,vk&gt;</span></span><br><span class="line">&#123; <span class="comment">//依次更新j的所有邻接顶点的最迟发生时间</span></span><br><span class="line"><span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//k为邻接顶点的序号</span></span><br><span class="line"><span class="keyword">if</span> (vl[j] &gt; vl[k] - p-&gt;info)   <span class="comment">//更新顶点j的最迟发生时间vl[j]</span></span><br><span class="line">vl[j] = vl[k] - p-&gt;info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*判断每一活动是否为关键活动*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">&#123; <span class="comment">//每次循环针对vi为活动开始点的所有活动</span></span><br><span class="line"><span class="keyword">for</span> (p = G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = p-&gt;adjvex;<span class="comment">//j为i的邻接顶点的序号</span></span><br><span class="line"><span class="type">int</span> e = ve[i];<span class="comment">//计算活动&lt;vi,vj&gt;的最早开始时间</span></span><br><span class="line"><span class="type">int</span> l = vl[j] - p-&gt;info;<span class="comment">//计算活动&lt;vi,vj&gt;的最迟开始时间</span></span><br><span class="line"><span class="keyword">if</span> (e == l)<span class="comment">//若为关键活动，输出&lt;vi,vj&gt;</span></span><br><span class="line">cout &lt;&lt; G.vexs[i].data &lt;&lt; G.vexs[j].data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li><p>关键活动和拓扑排序是针对<strong><font color='blue'>有向无环图</font></strong>而言的</p></li><li><p>求<strong>关键路径</strong>之前<strong>首先要进行<font color='red'>拓朴排序</font></strong>，目的是</p><ul><li>判断该有向网是否存在环路；若存在环路，不存在关键路径，否则存在关键路径</li><li>给出相应的拓扑序列（工程能完成的某一个事件顺序，从最开始源点事件到汇点事件，包含所有事件的一条路径）</li></ul></li></ol></blockquote><h1 id="最短路径">最短路径</h1><h2 id="单源最短路径">单源最短路径</h2><h3 id="dijkstra算法">Dijkstra算法</h3><h4 id="算法概述">算法概述</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017920.png"alt="1、初始化：" /><figcaption aria-hidden="true"><strong>1、初始化：</strong></figcaption></figure><blockquote><p>用Dijkstra算法求有向网G的<strong>v<sub>0</sub>顶点</strong>到<strong><font color='red'>其余各个顶点</font></strong>的最短路径</p></blockquote><h4 id="存储结构-2">存储结构</h4><p>1, 主要存储结构：<strong>邻接矩阵</strong>G(或者邻接表)</p><p>2 , 辅助存储结构：</p><p>（1）数组<strong><code>final[n]</code></strong>:记录相应顶点是否==<strong>已被确定</strong>最短距离==（是否在<strong>集合S</strong>中）</p><ul><li>初值：1：已确定；0:未确定</li></ul><p>（2）数组<strong><code>D[n]</code></strong>:记录<strong><font color='red'>源点V<sub>0</sub></font></strong>到相应顶点V<sub>i</sub> 路径的长度</p><ul><li>初值：如果V<sub>0</sub>到V<sub>i</sub><strong>有弧</strong>，则<code>D[i]</code>为弧上权值，否则为无穷</li></ul><p>（3）数组<strong><code>P[n]</code></strong>:记录相应顶点的<strong><font color='red'>前驱顶点</font></strong></p><ul><li>初值：如果v0到vi有弧，则<strong><code>P[i]</code></strong>为<strong><font color='gree'>v<sub>0</sub></font></strong>，否则为==<font color='blue'><strong>–1</strong></font>==</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ArcType ;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph G;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">final</span>[MVNum];</span><br><span class="line"><span class="type">int</span> P[MVNum];</span><br><span class="line"><span class="type">double</span> D[MVNum];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="算法实现-3">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*迪杰斯特拉算法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//初始化辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123; </span><br><span class="line">D[w] = G.arcs[v][w]; <span class="comment">//将v到各个终点的最短路径长度初始化       </span></span><br><span class="line"><span class="keyword">final</span>[w] = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (D[w] &lt; MaxInt)</span><br><span class="line">P[w] = v; <span class="comment">//v与w之间有弧，将w的前驱置为v</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P[w] = <span class="number">-1</span>; <span class="comment">//如果v与w之间无弧，则将w的前驱置为-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">1</span>; <span class="comment">//将v加入final</span></span><br><span class="line">P[v]= <span class="number">-1</span>; <span class="comment">//源点v的前驱结点设为-1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*循环n-1次，将图中所有顶点加入集合S中*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//找到当前离v距离最近的顶点j（即在D[]中寻找最小值）</span></span><br><span class="line"><span class="type">int</span> min = MaxInt;<span class="comment">//min辅组找最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">final</span>[j] == <span class="number">0</span> &amp;&amp; D[j] &lt; min)<span class="comment">//w顶点在V-S中</span></span><br><span class="line">&#123;</span><br><span class="line">min = D[j];                </span><br><span class="line">v = j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">1</span>; <span class="comment">//将v加入S集</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//更新从v出发到集合V-S上所有顶点的P[]和D[]        </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; w++) </span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; D[v] + G.arcs[v][w] &lt; D[w])</span><br><span class="line">&#123;</span><br><span class="line">D[w] = D[v] + G.arcs[v][w];<span class="comment">//更新D[w]</span></span><br><span class="line">P[w] = v;<span class="comment">//更改w的前驱为v</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">=====================================================================</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出v到各个顶点的最小距离和路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(i != v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n%f:%d&quot;</span>,D[i],i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> pre=P[i]; pre!= <span class="number">-1</span>; pre=P[pre])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;-%d&quot;</span>,pre);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多源最短路径">多源最短路径</h2><h3 id="floyd算法">Floyd算法</h3><blockquote><p>求有向网G中<strong><font color='red'>任意两个顶点V<sub>i</sub>，V<sub>j</sub>之间</font></strong>/ <strong><font color='red'>所有顶点之间</font></strong>的最短路径</p></blockquote><h4 id="算法思想-1">算法思想</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018452.png"alt="image-20221012132457324" /><figcaption aria-hidden="true">image-20221012132457324</figcaption></figure><h4 id="算法实例分析">算法实例分析</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018694.png"alt="image-20221012132532780" /><figcaption aria-hidden="true">image-20221012132532780</figcaption></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018686.png" alt="image-20221012132638042" style="zoom:60%;" /></p><blockquote><ol type="1"><li>表中<strong><font color='red'>最多只有三个字母</font></strong>，<strong>最左最右是固定的，中间的那个字母是动态调整的</strong></li><li>只有<strong><font color='orange'>两个字母表示直达</font></strong>，对角线一定是两个相同的字母00</li></ol></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018576.png"alt="image-20221012132812283" /><figcaption aria-hidden="true">image-20221012132812283</figcaption></figure><h4 id="算法要点迭代">算法要点—迭代</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018828.png"alt="image-20221012132930217" /><figcaption aria-hidden="true">image-20221012132930217</figcaption></figure><h4 id="存储结构-3">存储结构</h4><p>1, 主要存储结构：邻接矩阵G</p><p>2 , 辅助存储结构：</p><p>（1）数组<strong><code>D[i][j]</code></strong>:记录==<strong>当前</strong>==<strong><font color='red'>从【顶点i】到 【顶点j】 的最短路径长度</font></strong></p><ul><li>初值：<strong><code>D[i][j]=G.arc[i][j];</code></strong></li></ul><p>（2）数组<strong><code>P[i][j]</code></strong>:记录==<strong>顶点j</strong>==的（到顶点i这条路径）<strong><font color='red'>前驱顶点</font></strong></p><ul><li>初值：如果vi到vj有弧，则<strong><code>P[i][j]=i</code></strong>，否则为<font color='gree'>-1</font></li></ul><h4 id="算法实现-4">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_Floyed</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//初始化各结点之间的已知路径及距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line">D[i][j] = G.arcs[i][j];</span><br><span class="line"><span class="keyword">if</span> (D[i][j] &lt; MaxInt)</span><br><span class="line">P[i][j] = i;<span class="comment">//i和j之间有弧，将j的前驱置为i</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P[i][j] = <span class="number">-1</span>;<span class="comment">//i和j之间无弧，则将j的前驱置为-1</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Dk依次迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.vexnum;k++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line"><span class="keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j])</span><br><span class="line">&#123; <span class="comment">// 从i经过k到j的一条路径更短</span></span><br><span class="line">D[i][j] = D[i][k] + D[k][j];<span class="comment">//更新D[i][j]</span></span><br><span class="line">P[i][j] = k;<span class="comment">//更改j的前驱为k，记录路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：==<strong>不可以</strong>==先循环<code>i</code>和<code>j</code>，把<code>k</code>放到最内层循环</p><ul><li>可以把k想象成一个阶段，即k为中转点时，枚举 i，j，通过k的变动不停地松弛i、j之间的最短路。因为i、j可以重复遍历，但k不能。如果k在内层循环，程序无法进行多次的松弛操作，也就是程序出错的原因。</li></ul></blockquote><h1 id="例题-2"><a id="liti">例题</a></h1><h2 id="简单路径">简单路径</h2><p>​自选存储结构，编写一算法判断无向图中任意给定的两个顶点间是否存在一条长度等于k的简单路径（即不含回路的路径）</p><h3 id="存储结构-4">存储结构</h3><p>采用邻接表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（即在AdjList[]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018073.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>有利用<strong><font color='red'>DFS</font></strong>的思想</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"><span class="comment">//出发点为i，终点为j，长度为k </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exist_path_len</span><span class="params">(Graph G,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( k&lt;<span class="number">0</span> )<span class="comment">//路径为负显然不成立</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j &amp;&amp; k==<span class="number">0</span>)<span class="comment">//递归终止条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    visited[i]=<span class="number">1</span>;</span><br><span class="line"> <span class="comment">/*寻找i的邻接点是否存在到j的长度为k-1的路径*/</span>     </span><br><span class="line">    <span class="keyword">for</span>( ArcNode* p=G.vertices[i].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[t])</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist_path_len</span>(G, t, j, k - p-&gt;info))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    visited[i]=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">/*如果沿某个方向不存在长度为length的路径,</span></span><br><span class="line"><span class="comment">  沿这个方向 经过的顶点 仍可能存在于沿其他方向的目标路径中,</span></span><br><span class="line"><span class="comment">  因此要恢复成未访问*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="两节点间是否存在路径">两节点间是否存在路径</h2><p>​ 试写一算法，判断以邻接表方式存储的有向图中是否存在由顶点 <spanclass="math inline">\(V_i\)</span> 到顶点 <spanclass="math inline">\(V_j\)</span> 的路径 <spanclass="math inline">\((i≠j)\)</span>。注意：算法中涉及的图的基本操作必须在存储结构上实现。</p><h3 id="存储结构-5">存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;</span><br><span class="line">    InfoType info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode * firstarc;</span><br><span class="line">&#125;VNode,*AdjList[MVNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    AdjList vexs;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><h3 id="算法">算法</h3><h4 id="法一">法一</h4><p>​ 在有向图中，判断顶点 <span class="math inline">\(V_i\)</span> 和顶点<span class="math inline">\(V_j\)</span>间是否有路径，可采用遍历的方法，从顶点 <spanclass="math inline">\(V_i\)</span> 出发，不论是 <spanclass="math inline">\(dfs\)</span> 还是 <spanclass="math inline">\(bfs\)</span> ，在未退出 <spanclass="math inline">\(dfs\)</span> 或 <spanclass="math inline">\(bfs\)</span> 前，若访问到 <spanclass="math inline">\(V_j\)</span>，则说明有通路，否则无通路。设一全程变量 <spanclass="math inline">\(flag\)</span>。初始化为 0，若有通路，则 <spanclass="math inline">\(flag=1\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> visited[], <span class="type">int</span> &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visited[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ArcNode *p = G.vertices[i].firstarc;</span><br><span class="line"><span class="keyword">while</span>(!flag &amp;&amp; p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="type">int</span> k = p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(!visited[k])</span><br><span class="line"><span class="built_in">DFS</span>(G, k, j, visited, flag);</span><br><span class="line">p = p-&gt;nextarc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Path</span><span class="params">(ALGraph G, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> visited[MVNum];<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">1</span>; m &lt;= G.vexnum; m++)</span><br><span class="line">visited[m] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">DFS</span>(G, i, j, visited, flag);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二">法二</h4><p>从<strong><font color='red'>V<sub>i</sub></font></strong>开始进行DFS/BFS。</p><ul><li><p>若在此过程中访问到V<sub>j</sub>，则说明存在，返回1；</p></li><li><p>若遍历结束，则说明未找到，返回0；</p></li></ul><blockquote><p>改编DFS，将<strong><code>visit（i）</code></strong>改为判断<strong><code>if(i==j)  return 1;</code></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exist_path</span><span class="params">(Graph G,<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visited[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==j)<span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ArcNode*p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[k])</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist_path</span>(G,k,j))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​利用了DFS/BFS可用于求<strong><font color='red'>连通分量</font></strong>（任意两个顶点间均存在路径，均可达）的作用</p><h2 id="欧拉回路">欧拉回路</h2><p>在一个图中，存在这样一条路径，它经过每条边恰好一次，并在最后一个顶点时会到第一个顶点，这样的路径叫做<strong>欧拉回路</strong>。给无向图，编写程序输出是否存在欧拉回路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="克隆图"><a id="kelong"><ahref="https://leetcode.cn/problems/clone-graph/">克隆图</a></a></h2><p>​ 给你无向 <strong><ahref="https://baike.baidu.com/item/连通图/6460995?fr=aladdin">连通</a></strong>图中一个节点的引用，请你返回该图的 <ahref="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值<code>val</code>（<code>int</code>）和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>​ 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为1（<code>val = 1</code>），第二个节点值为2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。<strong>邻接列表</strong>是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。给定节点将始终是图中的第一个节点（值为1）。你必须将 <strong>给定节点的拷贝</strong>作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031014453.png" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031014420.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031014413.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol type="1"><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code>都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<ahref="https://baike.baidu.com/item/简单图/1680528?fr=aladdin">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em>的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是<strong>连通图</strong>，你可以从给定节点访问到所有节点。</li></ol><p><strong>分析：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031019694.png" alt="image-20240303101924546" style="zoom:33%;" /></p><ul><li>首先<strong>拷贝顶点</strong>，使用<code>dfs</code>遍历图，并用<strong>hash表</strong> 记录原顶点与新顶点的映射关系，避免重复拷贝</li><li>然后拷贝边，我们只需要遍历一遍原始顶点，把它们的相邻顶点通过哈希表转换成拷贝顶点，并添加到当前拷贝顶点的邻居列表就可以了</li></ul><p><ahref="https://www.bilibili.com/video/BV1H34y1E7Ao/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】133. 克隆图 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; h;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        h[node] = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : node-&gt;neighbors)</span><br><span class="line">            <span class="keyword">if</span> (!h[next])</span><br><span class="line">                <span class="built_in">dfs</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* 拷贝顶点 */</span></span><br><span class="line">        <span class="built_in">dfs</span>(node);</span><br><span class="line">        <span class="comment">/* 拷贝边 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [from, to] : h)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> next : from-&gt;neighbors)</span><br><span class="line">                to-&gt;neighbors.<span class="built_in">push_back</span>(h[next]);</span><br><span class="line">        <span class="keyword">return</span> h[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同类型<ahref="D:\downloads\hexo\blog\source_posts\数据结构【线性表】.md#shenkaobei">链表的深拷贝</a></p></blockquote><h2 id="岛屿数量"><ahref="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></h2><p>给你一个由 <code>'1'</code>（陆地）和<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 网格中上下左右四个方向[0,1],[1,0],[0,-1],[-1,0],</span></span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir_y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 或者vector&lt;pair&lt;int,int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0,1&#125;&#125;;</span></span><br><span class="line">    <span class="comment">// 或者vector&lt;vector&lt;int&gt;&gt; dd = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;grid, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;             <span class="comment">// 标记当前网格为已访问,相当于visited的作用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">// 依次检查grid[x][y]的4个临界网格是否访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; grid[tx][ty] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(grid, tx, ty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; x++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; m; y++)</span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="腐烂的橘子"><ahref="https://leetcode.cn/problems/rotting-oranges/">腐烂的橘子</a></h2><p>​ 在给定的 <code>m x n</code> 网格 <code>grid</code>中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong>的新鲜橘子都会腐烂。返回<em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回<code>-1</code></em> 。</p><p><strong>示例 1：</strong></p><p><strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032222594.png"alt="img" /></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>​ 为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 cnt表示当前网格中的新鲜橘子数，先遍历统计新鲜数量和腐烂节点，BFS的时候如果有新鲜橘子被腐烂，则 cnt-=1 ，最后搜索结束时如果 cnt 大于 0，说明有新鲜橘子没被腐烂，返回 -1，否则返回所有新鲜橘子被腐烂的时间的最大值即可.</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m, fresh_cnt = <span class="number">0</span>, round = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir_y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    fresh_cnt++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">func</span>(grid);</span><br><span class="line">        <span class="keyword">while</span> (fresh_cnt &gt; <span class="number">0</span> &amp;&amp; !q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            round++;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tx = t.first + dir_x[i], ty = t.second + dir_y[i];</span><br><span class="line">                    <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp;</span><br><span class="line">                        grid[tx][ty] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        grid[tx][ty] = <span class="number">2</span>;</span><br><span class="line">                        fresh_cnt--;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;tx, ty&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fresh_cnt == <span class="number">0</span> ? round : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词搜索"><ahref="https://leetcode.cn/problems/word-search/">单词搜索</a></h2><p>​ 给定一个 <code>m x n</code> 二维字符网格 <code>board</code>和一个字符串单词 <code>word</code> 。如果 <code>word</code>存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code>。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032232283.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032232317.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032232329.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>​用DFS来做，我们可以<strong>举枚矩阵的每个位置作为单词的起点</strong>，只要能够找到对应单词，就直接返回True。具体在每次搜索中可以依次尝试相邻未访问格子的字母，只要能和单词的对应位置匹配，就继续线下搜索。<ahref="https://www.bilibili.com/video/BV16T4y1i76C/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】79. 单词搜索 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码</strong></p><p>​ 原版：空间复杂度<strong>O(nm)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dir_y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> id, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != word[id])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (id == word.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; !visited[tx][ty])</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, id + <span class="number">1</span>, tx, ty))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        visited.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改版：空间复杂度<strong>O(1)</strong></p><p>​这里有一点可以优化的地方。正常情况下，我们需要一个和矩阵一样大的数组visited来记录格子的访问状态。在这道题中指出，<strong>每个格子的字符仅由大小写英文字母组成。那么我们就可以用原始数组来记录格子的访问状态。</strong>比如每次都把选择后的格子标记为特殊符号（比如<code>!</code>）。那么在当前的搜索过程中，就不会再访问到这个格子了，这样就把空间复杂度从<strong>O(MN)</strong>优化到了<strong>O(1)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dir_y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> id, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != word[id])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (id == word.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span> t = board[x][y]; <span class="comment">// 记录原值，用于还原</span></span><br><span class="line">        board[x][y] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; board[tx][ty] != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, id + <span class="number">1</span>, tx, ty))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = t; <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【堆】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%A0%86%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%A0%86%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="堆">堆</h1><h2 id="定义">定义</h2><p>==采用<strong><font color='blue'>数组存储</font></strong>的<strong><font color='red'>完全二叉树</font></strong>==</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011962.png"alt="image-20230916123313335" /><figcaption aria-hidden="true">image-20230916123313335</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011898.png"alt="image-20221019101952011" /><figcaption aria-hidden="true">image-20221019101952011</figcaption></figure><ul><li>从<font color='red'><code>h[1]</code>开始存储数据</font>，<code>h[0]</code>用来存放==<strong>哨兵</strong>==</li><li><code>i</code> 的左儿子 <code>2 * i</code>，右儿子<code>2 * i + 1</code></li></ul><span id="more"></span><h2 id="分类">分类</h2><blockquote><p><code>最小堆</code>（MinHeap）：任一结点的<code>data</code>小于其所有子树结点的data</p></blockquote><blockquote><p><code>最大堆</code>（MinHeap）：任一结点的<code>data</code>大于其所有子树结点的data</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011027.png"alt="image-20230916123453824" /><figcaption aria-hidden="true">image-20230916123453824</figcaption></figure><h2 id="模板">模板</h2><ul><li><p>使用数组来模拟堆，堆中的数据从 <code>h[1]</code> 开始存储</p><blockquote><p>因为如果从0开始存储，根节点0按照公式计算得到的左右节点都是0，显然不成了，需要特判，麻烦</p></blockquote></li><li><p>所有关于堆的操作均建立在堆的 <code>down()</code> 和<code>up()</code> 函数基础上</p></li></ul><h3 id="模板1">模板1</h3><p>如果只希望实现与C++ STL堆中相同的功能1、2、3，则堆的下滤和上滤操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>down() 注意：</p><ol type="1"><li>down 操作需要保证左右儿子是堆</li><li>t 是根节点 <code>h[u]</code>, 左儿子 <code>h[2 * u]</code>, 右儿子<code>h[2 * u + 1]</code>中最小值的下标</li><li><code>2 * u &lt;= cnt</code>说明存在左儿子，<code>2 * u + 1 &lt;= cnt</code> 说明存在右儿子</li></ol><p>up() 注意：</p><ol type="1"><li><code>u / 2 != 0</code> 说明存在父节点</li></ol></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[++cnt]=x;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>] = h[cnt--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h3 id="模板2">模板2</h3><p>如果希望实现在 C++ STL堆中功能的基础上，添加在任意位置修改/删除的功能，需要存储映射：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081015324.png" alt="image-20240308101556244" style="zoom:15%;" /></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081036812.jpg" alt="b9b669b4a3a28e34e104b0c5bda7d7c" style="zoom:13%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的下标p:pointer</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的h:heap</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="comment">// m是当前堆中插入操作的次数</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换两个点，及其映射关系 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>p:pointer</li><li>h:heap</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt++, m++;</span><br><span class="line">h[cnt] = x, hp[cnt] = m, ph[m] = cnt;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt--);</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除第 k 个插入的数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line"><span class="built_in">heap_swap</span>(k, cnt--);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改第 k 个插入的数,将其变为 x</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure><blockquote><p>修改后的值与原来值相比，有3种情况</p><ul><li>相等：不需要调整堆</li><li>小于：up(k)</li><li>大于：down(k)</li></ul><p>把上面 3 种情况综合考虑，不管是相等/大于/小于，为了简单起见:</p><ul><li>如果修改h[1]：down(1)</li><li>在最后插入数据：up(++size)</li><li>如果修改其他： up(k); down(k)</li></ul><p>【实际运行时要么都不执行，要么只 up(k) ，要么只 down(k) 】</p></blockquote><ol start="6" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="操作以maxheap为例">操作（以MaxHeap为例）</h2><h3 id="对象集">对象集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">ElementType data[Maxsize];</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MaxHeap;</span><br></pre></td></tr></table></figure><h3 id="下滤筛选">下滤筛选</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(MaxHeap H,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = H-&gt;data[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; H-&gt;size &amp;&amp; H-&gt;data[i] &lt; H-&gt;data[i+<span class="number">1</span>])<span class="comment">//i &lt; H-&gt;size说明H-&gt;data[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= H-&gt;data[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;H-&gt;data[s]=H-&gt;data[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h3 id="上滤筛选">上滤筛选</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(MaxHeap H,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = H-&gt;data[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;data[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;H-&gt;data[s]=H-&gt;data[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>上滤</font>：用于<font color='blue'>向堆中插入一个元素</font></strong></p></blockquote><h3 id="最大堆的初始化创建">最大堆的初始化创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">CreatHeap</span><span class="params">(<span class="type">int</span> Max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆的插入">最大堆的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size&gt;=Maxsize)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t&gt;H-&gt;data[i/<span class="number">2</span>];i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>H-&gt;data[0]</code>是哨兵，它不会小于堆中的最大元素，其作用：控制循环结束。</p></blockquote><h3 id="最大堆的删除">最大堆的删除</h3><h4 id="步骤">步骤</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011907.png"alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><blockquote><p>删除并且返回根节点（最大值）</p></blockquote><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(MaxHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ElementType max=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点最大值，最后return</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    ElementType t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最大的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>((child!=H-&gt;size)&amp;&amp;H-&gt;data[child] &lt; H-&gt;data[child+<span class="number">1</span>])<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=H-&gt;data[child])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第10行~~parent*=2~~错误，必须是<code>parent=child</code>,作用是parent索引变成儿子索引，向下交换</li><li>第8行<del><code>data[H-&gt;size]</code></del>错误，必须是<code>data[H-&gt;size--]</code></li></ul></blockquote><h3 id="最大堆的建立">最大堆的建立</h3><h4 id="法一">法一：</h4><h5 id="步骤-1">步骤：</h5><h6id="调用insert函数将n个元素一个个相继插入到一个初始为空的堆heap中去">（1）调用Insert函数，将N个元素一个个相继插入到一个初始为空的堆Heap中去。</h6><h6 id="其时间复杂度为on-logn">（2）其时间复杂度为O(N logN)。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">BuildHeap</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    ElementType t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二">法二：</h4><h5 id="步骤-2">步骤：</h5><h6id="将n个元素按输入顺序存入先满足完全二叉树的结构特性">（1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性</h6><h6id="调整各结点位置以满足最大堆的有序特性">（2）调整各结点位置，以满足最大堆的有序特性。</h6><h5 id="代码-1">代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">BuildHeap</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ElementType t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;H-&gt;data[i];</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【查找】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290957892.png"alt="image-20230929095705501" /><figcaption aria-hidden="true">image-20230929095705501</figcaption></figure><span id="more"></span><h1 id="静态查找表">静态查找表</h1><p><font color='red'><strong>Static SearchTable</strong></font>：不涉及<strong><font color='blue'>插入和删除</font></strong>操作</p><h2 id="顺序查找">顺序查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素类型的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">keyType key;<span class="comment">//关键字域</span></span><br><span class="line">InfoType otherInfo;<span class="comment">//其他域</span></span><br><span class="line">&#125;ElementType;</span><br><span class="line"><span class="comment">//静态查找表的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElememtType* R;<span class="comment">//数据元素存储空间基地址，建表时按实际长度分配，0号单元留空</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//表长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line">SSTable ST;<span class="comment">//定义顺序表ST</span></span><br><span class="line"><span class="comment">//设元素从ST.R[1]开始向后顺序存放，ST.R[0]不用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, keyType key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ST.length;i &gt;= <span class="number">1</span>;--i)</span><br><span class="line"><span class="keyword">if</span> (ST.R[i].key == key)</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//从后往前找</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>ElememtType* R;</code></strong></p><p>数据元素存储空间<strong>基地址</strong>，建表时按<strong>实际长度（length）</strong>malloc分配，<strong><font color='red'>0号单元留空</font></strong></p></blockquote><h3 id="改进">改进</h3><p>==改进==：把待查<strong>关键字key</strong>存入<strong><font color='red'>表头(0号单元)</font></strong>，充当<strong><font color='blue'>"哨兵“</font></strong>，从后向前逐个比较时，可<strong>免去</strong>查找过程中每一步都要检测是否查找完毕.<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949384.png"alt="在这里插入图片描述" />加快速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, keyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//若成功返回其位置信息，否找返回0</span></span><br><span class="line">ST.R[<span class="number">0</span>].key = key;<span class="comment">//哨兵</span></span><br><span class="line"><span class="keyword">for</span> (i = ST.length;ST.R[i].key != key;--i)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="comment">//不用for (int i = ST.length;i &gt;= 1;--i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引查找">索引查找</h2><h3 id="存储要求">存储要求</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949385.png"alt="image-20221025123336315" /><figcaption aria-hidden="true">image-20221025123336315</figcaption></figure><h2 id="折半查找">折半查找</h2><blockquote><p><strong>折半查找</strong>又称<strong>二分查找</strong>，前提条件是<strong><font color='red'>顺序存储且数组元素有序</font></strong></p></blockquote><h3 id="算法描述">算法描述</h3><p>设表长为<code>n</code>，<code>low</code>，<code>high</code>，<code>mid</code>分别指向待查元素所在区间的上界、下界和中点，key为要查找的值。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949386.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="伪码">伪码</h3><h4 id="非递归">非递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素类型的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">keyType key;<span class="comment">//关键字域</span></span><br><span class="line">InfoType otherInfo;<span class="comment">//其他域</span></span><br><span class="line">&#125;ElementType;</span><br><span class="line"><span class="comment">//顺序表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* R;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若找到，则函数值为该元素在表中的位置，否则为0</span></span><br><span class="line">low = <span class="number">1</span>;high = ST.length;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (key == ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key)</span><br><span class="line">high = mid - <span class="number">1</span>;<span class="comment">//前一子表查找</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;<span class="comment">//后一子表查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表中不存在待查元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>18行注意是==low<strong><code>&lt;=</code></strong>high==</p></blockquote><h4 id="递归">递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType* R;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin_re</span><span class="params">(SSTable ST, KeyType key,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若找到，则函数值为该元素在表中的位置，否则为0</span></span><br><span class="line"><span class="keyword">if</span> (low &gt; high)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表中不存在待查元素</span></span><br><span class="line"><span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (key == ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Search_Bin_re</span>(ST, key, low, mid - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Search_Bin_re</span>(ST, key, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半查找判定树的画法">折半查找判定树的画法</h3><h4 id="思路分析">思路分析</h4><p>​ 在计算mid值时，使用的时mid=（low+high）/2。这里由于mid为int类型，自动默认为向下取整，因此对于一个长度为n序列进行划分之后的序列为<strong><code>（0，1，2，……，mid-1）mid（mid+1，mid+2，……n-1）</code></strong>，此时出现两种情况：</p><ul><li><p>左子序列长==右子序列长 （n=2k+1 k=0，1，2，……）</p></li><li><p>左子序列长==右子序列长-1 （n=2k k=1，2，3，……）</p></li></ul><p>因此可以得知，<strong><font color='purple'>折半查找</font></strong>的二叉判定树对于所有结点，<strong><font color='red'>右子树结点个数&gt;= 左子树结点个数。</font></strong>即：</p><ul><li>若某序列总长n为奇数，左右子树结点个数相等；</li><li>若某序列总长n为偶数，左字数结点个数=右子树结点个数-1.</li></ul><blockquote><p>换句话说，对判定树中所有结点都有： （右子树结点数 - 左子树结点数 ==1）||（右子树结点数 — 左子树结点数 == 0）</p></blockquote><h4 id="步骤">步骤</h4><p><strong>由此给定某个序列，构建折半查找判定树方法如下三步：</strong></p><ol type="1"><li>按照结点总数先画出<strong><font color='blue'>最大的满二叉树</font></strong>结构，并计算剩余几个结点</li><li>将剩余结点按照上述的规律依次填入最底层即为二叉判定树的树形</li><li>将给定序列依次按照<strong><font color='red'>中序遍历</font></strong>顺序填入各个结点</li></ol><blockquote><p><strong><font color='blue'>折半查找判定树</font></strong>也是<strong><font color='red'>二叉查找树</font></strong>，故<strong>中序遍历即为递增序列</strong></p></blockquote><h4 id="实例">实例</h4><p>画出（2，5，7，10，14，15，18，23，35，41，52）的折半查找判定树。</p><blockquote><p>折半查找的前提就是<strong>序列有序</strong></p></blockquote><ol type="1"><li>序列总长度为 <span class="math inline">\(n=11&gt;2^3-1\)</span>即二叉判定树为 <span class="math inline">\(4\)</span>层，前三层为满二叉树结构，剩余 <span class="math inline">\(4\)</span>个结点，先画出前三层结构</li></ol><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949387.png" alt="img" style="zoom:50%;" /></p><ol start="2" type="1"><li>依次将剩余 <span class="math inline">\(4\)</span>个结点插入树中</li></ol><p>1）第一个结点 <span class="math inline">\(a\)</span>的左右子树结点个数相等，所以新的结点应加入 <spanclass="math inline">\(a\)</span> 的右子树；再看 <spanclass="math inline">\(a\)</span> 的右子树，<spanclass="math inline">\(c\)</span>的左右子树结点个数相等，所以新结点应加入 <spanclass="math inline">\(c\)</span> 的右子树；再看 <spanclass="math inline">\(c\)</span> 的右子树，<spanclass="math inline">\(g\)</span>的左右子树结点个数相等，所以新结点应加入 <spanclass="math inline">\(g\)</span> 的右子树，如图：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949388.png" alt="img" style="zoom:50%;" /></p><p>2）第二个结点： <span class="math inline">\(a\)</span>的左子树结点数-右子树结点数<spanclass="math inline">\(=-1\)</span>，所以新结点应加入 <spanclass="math inline">\(a\)</span> 的左子树（若加入右子树，对于 <spanclass="math inline">\(a\)</span> 来说左右子树结点之差<spanclass="math inline">\(=-2\)</span>，不符合规律）；再看 <spanclass="math inline">\(a\)</span> 的左子树，<spanclass="math inline">\(b\)</span>的左右子树结点个数相等，所以新结点应加入 <spanclass="math inline">\(b\)</span> 的右子树；再看 <spanclass="math inline">\(b\)</span> 的右子树，<spanclass="math inline">\(e\)</span>的左右子树结点个数相等，所以新结点应加入 <spanclass="math inline">\(e\)</span> 的右子树。如图</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949389.png" alt="img" style="zoom:50%;" /></p><p>3）同理分析，第三个结点应加在如图位置。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949390.png" alt="img" style="zoom:50%;" /></p><p>4）第四个结点加在如图位置。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949391.png" alt="img" style="zoom: 67%;" /></p><p>得到最终的树形如上图。（字母编号不唯一，但后面中序遍历结果会不同）</p><ol start="3" type="1"><li>该二叉树的<strong><font color='red'>中序遍历</font></strong>顺序为dkbeiafjcgh，分别对应2，5，7，10，14，15，18，23，35，41，52。因此将序列一一对应填入树中，即</li></ol><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949392.png" alt="img" style="zoom:67%;" /></p><p>该树即为此序列的二叉判定树。</p><p><strong>【总结】</strong></p><ul><li><p>做题过程中熟练使用此方法比通过算法模拟来推断二叉判定树的速度要快许多倍</p></li><li><p>在平时做题过程中，涉及到需要具体画出二叉判定树的题目，往往结点个数（序列长度）不超过<span class="math inline">\(2^4-1=15\)</span> 个，即一般为高度不超过<span class="math inline">\(4\)</span> 的树，因此可以在练习时将结点个数<span class="math inline">\(8-14\)</span>的所有树形画几遍，就可以很熟练的掌握这个方法</p></li></ul><h3 id="例题">例题</h3><h4 id="例1">例1</h4><p>一个递增有序表为R[0..11]，采用折半查找方法进行查找，在一次不成功查找中，以下（A）是不可能的记录比较序列</p><p>A.R[5]、R[8]、R[10]</p><p>B.R[5]、R[8]、R[6]、R[7]</p><p>C.R[5]、R[2]、R[3]</p><p>D.R[5]、R[8]、R[6]</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949393.jpg"alt="56cb394ddbe752ccadbe544a3b9f40c" /><figcaptionaria-hidden="true">56cb394ddbe752ccadbe544a3b9f40c</figcaption></figure><blockquote><p>一次失败的查找必须查找到<strong><font color='red'>叶结点/只有一个儿子节点</font></strong>处</p></blockquote><h4 id="例2">例2</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949394.png"alt="image-20221111202130826" /><figcaption aria-hidden="true">image-20221111202130826</figcaption></figure><p>答案：<strong><font color='red'>B</font></strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281630053.jpg"alt="bf652cb54134325fb5833d6442f6a5f" /><figcaptionaria-hidden="true">bf652cb54134325fb5833d6442f6a5f</figcaption></figure><h4 id="例3">例3</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281632371.jpg"alt="221e8af7521bc5821578e9a20a6809d" /><figcaptionaria-hidden="true">221e8af7521bc5821578e9a20a6809d</figcaption></figure><h4 id="例4">例4</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202408121817270.jpeg"alt="13312013948078200" /><figcaption aria-hidden="true">13312013948078200</figcaption></figure><h1 id="动态查找表">动态查找表</h1><h2 id="二叉排序树">二叉排序树</h2><blockquote><p>详细见—<ahref="D:\downloads\hexo\blog\source_posts\数据结构【树】.md">二叉排序树</a></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949395.png"alt="image-20221104133158218" /><figcaption aria-hidden="true">image-20221104133158218</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949396.jpg"alt="8b2b8cf18df013cb2e84b09b02b897b" /><figcaptionaria-hidden="true">8b2b8cf18df013cb2e84b09b02b897b</figcaption></figure><p><ahref="D:\downloads\hexo\blog\source_posts\数据结构\AVL树画法.md">AVL树画法</a></p><h2 id="平衡二叉树">平衡二叉树</h2><h3 id="基本理论">基本理论</h3><h4 id="avl树的前身">AVL树的前身</h4><p>平衡二叉树（AVL树）的前身是<strong>二叉排序树（二叉查找树）</strong></p><blockquote><p>二叉排序树的一个重要性质：左子树上的所有结点都小于根结点，右子树上的所有结点都大于根节点。<strong>简而言之，左小右大。</strong></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639515.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><!--more--><p>如上图所示，<span class="math inline">\(10\)</span>左边的数都比它小，右边的数都比它大。对于 <spanclass="math inline">\(9\)</span> 和 <spanclass="math inline">\(15\)</span>来说也是一样。<strong>所以如果要插入一个数字 <spanclass="math inline">\(14\)</span>，那么该如何做呢？</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639417.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如上图所示，14比10大，所以在10的右边。比15小，所以在15的左边。比12大，所以在12的右边</p><h4 id="何来平衡">何来“平衡”？</h4><p><strong>平衡因子</strong>：即左子树与右子树的高度（深度）差。请为上图，标上平衡因子</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639523.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如上图所示，<strong>平衡二叉树要求平衡因子的绝对值不大于1</strong>，所以该图就是一个标准的平衡二叉树</p><h4 id="不平衡与旋转">不平衡与旋转</h4><p><strong>不平衡</strong>即出现了<strong>绝对值大于1的平衡因子</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639504.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图4（LL旋转）</p><p>插入3之后，9的平衡因子变为2。<strong>二叉树失去平衡，需要通过旋转来重新平衡</strong></p><h4 id="旋转类型的判定">旋转类型的判定</h4><p><font color='red'><strong>离插入点最近的</strong></font>，平衡因子的绝对值大于1的点称为<strong>失衡点</strong>。</p><p>==<font color='blue'><strong>从失衡点开始，沿树“寻找”插入点。且只记录“寻找”的前两步的路径方向。由此判定旋转类型。</strong></font>==</p><p>以图4为例，插入点为3，失衡点为9。从9开始，“寻找”3。<strong>发现3在9的左子树的左子树上</strong>，将路径简记为“左左”，所以需要<strong>LL旋转</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639539.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图5（LR旋转）</p><p>如图5所示，从失衡点5开始，“寻找”插入点4。将路径简记为“左右”，所以需要<strong>LR旋转</strong>。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639592.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图6（RR旋转）</p><p>如图6所示，“寻找”路径简记为“右右”，所以需要<strong>RR旋转</strong>。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639300.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图7（RL旋转）</p><p>如图7。“寻找”路径简记为“右左”。所以需要<strong>RL旋转</strong>。</p><hr /><h3 id="旋转方法">旋转方法</h3><p>旋转方法与旋转类型无关，<strong>一种方法</strong>就可应对四种旋转类型</p><p><strong><font color='red'>从失衡点开始，经过两步“寻找”，则必然遇到两个结点，加上失衡点，总共三个结点。</font>假设为A、B、C，并规定A&lt;B&lt;C。将这三个结点单独拿出来。把其中的“中位数”B作为根结点，A作为B的左子树，C作为B的右子树，构建一个新的平衡二叉树。并将该新树的根B放到原来的失衡点上。其中，A和C的子树不动。【当B原来的左子树根≠A时，把它接到A的右边。当B原来的右子树根≠C时，把它接到C的左边。】</strong>（框内步骤不一定会用到，需要具体问题具体分析。）</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639364.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>旋转方法图解</p><p>问：那A原来的右子树和C原来的左子树怎么办？</p><p>答：它们不存在，或者A原来的右子树根=B or C，C原来的左子树根=A orB。</p><p>问：B的右子树恰好是C</p><p>答：这个时候就<strong>不用将</strong>B的右子树“顺理成章”的放在新树C的左边了</p><h3 id="实例-1">实例</h3><p><strong>1. 将图4重新平衡</strong></p><p>失衡点为9。<strong>“寻找”路径上的三个点为9、4、3。取“中位数”4为树根，</strong>生成新的平衡二叉树。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639466.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>把树根4替换到失衡点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639497.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>二叉树重新获得平衡。</p><p><strong>2.画出以序列{25,27,30,12,11,18,14,20,15,22}构造的一棵平衡二叉树</strong></p><p>首先，<strong>按照左小右大的原则，画二叉树。依次插入25,27,30。</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639614.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入30后，二叉树失衡。显然，需要进行<strong>RR旋转。</strong>取“中位数”27作树根，25作左子树，30作右子树，生成新的平衡二叉树。并替换到失衡点25上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639779.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>继续插入12，11。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639303.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入11后，二叉树又失衡了。显然，需要进行<strong>LL旋转。</strong>取“中位数”12作树根，11作左子树，25作右子树，生成新的平衡二叉树。并替换到失衡点25上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639425.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>继续插入18。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639577.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入18后，二叉树双失衡了。插入点为18，失衡点为27。“寻找”路径记为“左右”，因此需要<strong>LR旋转</strong>。<strong>在27,12,25中</strong>，取“中位数”25作树根，12作左子树，27作右子树，生成新的平衡二叉树。<strong>且25的左子树根18“顺理成章”地放在12的右侧。</strong>（不懂请看旋转方法图解）并替换到失衡点27上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639065.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>继续插入14，20，15。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639914.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入15后，二叉树叒失衡了。插入点为15，失衡点为12。“寻找”路径记为“右左”，因此需要<strong>RL旋转</strong>。<strong>在12,18,14中</strong>，取“中位数”14作树根，12作左子树，18作右子树，生成新的平衡二叉树。<strong>且14的右子树根15“顺利成章”地放在18的左侧。</strong>（不懂请看旋转方法图解）并替换到失衡点12上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639077.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>最后插入22。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639183.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入22后，二叉树叕失衡了。插入点为22，失衡点为25。“寻找”路径记为“左右”，因此需要<strong>LR旋转</strong>。<strong>在25,14,18中</strong>，取“中位数”18作树根，14作左子树，25作右子树，生成新的平衡二叉树。<strong>且18的左子树根15“顺理成章”地放在14的右侧，18的右子树根20“顺利成章”地放在25的左侧。</strong>（不懂请看旋转方法图解）并替换到失衡点25上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639226.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>最终的平衡二叉树，如图</p><h3 id="例题-1">例题</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639352.png"alt="image-20221111200549327" /><figcaption aria-hidden="true">image-20221111200549327</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281639022.jpeg"alt="59b2f7b53f3380a64c814219d3e04bb" /><figcaptionaria-hidden="true">59b2f7b53f3380a64c814219d3e04bb</figcaption></figure><h1 id="哈希查找的asl">哈希查找的ASL</h1><h2 id="查找成功的asl">查找成功的ASL</h2><h3 id="定义">定义</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002906.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="说明">说明</h3><ol type="1"><li>题目条件通常是在<strong><font color='red'>等概率下</font>查找</strong>，所以<strong><code>ASL=（C0+C1+...+Cn）/n.</code></strong></li><li>查找成功是针对==<strong><font color='red'>关键字</font></strong>==查找的，最后除以<strong><font color='blue'>关键字的总个数</font></strong></li><li>装填因子=哈希表中关键字数量/哈希表的长度</li></ol><h2 id="查找失败的asl">查找失败的ASL</h2><h3 id="失败原因">失败原因</h3><p>如果我们要查找<strong>表中的元素</strong>，那么一定可以找到，所以讨论查找失败就没有意义。我们讨论查找失败，一定是针对<strong><font color='orange'>表中没有的元素</font></strong>在哈希表中查找，才有查找失败的意义。</p><h3 id="说明-1">说明</h3><ol type="1"><li>查找失败是针对<strong><font color='red'>表中没有的元素，是对位置的查找</font></strong></li><li>失败查找次数就是该位置<strong><font color='blue'>该位置向后探测到第一个没有关键字的地址位置之间的距离</font></strong></li><li>求平均数的除数是==<strong><font color='red'>模的大小</font></strong>==，与哈希表的长度无关</li></ol><h2 id="例题-2">例题</h2><h3 id="例一">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002983.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h4 id="线性探测法开放定址法">线性探测法/开放定址法</h4><h5 id="查找成功">查找成功</h5><p>构建出来的哈希表有8个元素，针对这8个元素的比较次数，得出： <spanclass="math display">\[ASL_{success}=(1+1+1+2+1+2+1+2)/8 = 11/8\]</span></p><h5 id="查找失败">查找失败</h5><p>​查找失败时的平均查找长度，却是针对位置的查找。因为如果我们要查找表中的元素，那么一定可以找到，所以讨论查找失败就没有意义；我们讨论查找失败，一定是针对表中没有的元素在这张表中查找，才有查找失败的意义。所以，针对上图的哈希表，我们将待查找关键字X代入哈希函数，我们设定X与这张表中的关键字都不相同：</p><ol type="1"><li><p>当<span class="math inline">\(H(X)=3X mod11=0\)</span>时，因为散列地址为<spanclass="math inline">\(0\)</span>的位置没有关键字，所以查找1次就失败了</p></li><li><p>当<span class="math inline">\(H(X)=3X mod11=1\)</span>时，因为散列地址为1的位置有关键字4，X与4不等，所以按照线性探测法向后探测1，散列地址为2的位置没有关键字，所以查找失败，一共查找了2次</p></li><li><p>当<span class="math inline">\(H(X)=3X mod11=2\)</span>时，同0</p></li><li><p>当<span class="math inline">\(H(X)=3X mod11=3\)</span>时，因为散列地址为3的位置有关键字12，X与12不等，所以向后线性探测，散列地址为4的位置有关键字49，还不等，继续探测，因为X与表中的关键字都不等，所以直到散列地址为10没有关键字，才查找失败，这次一共查找了8次</p></li><li><p>…以此类推</p></li></ol><p>而求平均数的除数，是<strong><font color='red'>模的大小</font></strong></p><p>​因为失败查找次数是针对位置查找，因为模为11，所以查找的位置(哈希函数的值)为0-10(共11个),针对这11个位置进行查找，而与表的长度无关。</p><h4 id="链地址法">链地址法</h4><p>理清了思路，我们来看看链地址法表示的哈希表：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002875.png" alt="img" style="zoom:80%;" /></p><h5 id="查找成功-1">查找成功</h5><p>成功时的平均查找长度很好求，针对表中的每个关键字：有5个关键字找一次：4,12,49,13,32；3个关键字找两次：38,24,21</p><h5 id="查找失败-1">查找失败</h5><p>失败时的平均查找长度针对位置来查找：</p><ol type="1"><li>等于0时，只有空指针域，查找1次；</li><li>等于1时，带一个结点，所以查找2次找到空指针； …</li><li>等于4时，带两个节点，所以查找3次找到空指针； …</li></ol><h4 id="总结">总结</h4><ul><li><p><strong>失败查找次数就是当前位置所带的结点个数+1</strong></p></li><li><p>链地址法<strong>不存在</strong>二次聚集现象</p></li></ul><blockquote><p><strong>二次聚集</strong>：处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象</p></blockquote><h3 id="例二">例二</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002818.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="例三">例三</h3><p>将关键字序列（7、8、30、11、18、9、14）散列存储到散列表中。散列表的存储空间是一个下标从0开始的一维数组。散列函数为：<span class="math display">\[H(key) = (key\times3)\ mod\T\]</span>，处理冲突采用线性探测再散列法，要求装填（载）因子为0.7 (1)请画出所构造的散列表； (2)分别计算等概率情况下查找成功和查找不成功的平均查找长度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002054.jpeg"alt="752a42495403f7b79fb9becef3eb5c8" /><figcaptionaria-hidden="true">752a42495403f7b79fb9becef3eb5c8</figcaption></figure><h3 id="例四">例四</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002811.jpeg"alt="54636c164030154e379275639ca60fe" /><figcaptionaria-hidden="true">54636c164030154e379275639ca60fe</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002407.png"alt="image-20221025140718996" /><figcaption aria-hidden="true">image-20221025140718996</figcaption></figure><blockquote><p>d<sub>i</sub>为增量，<strong><code>i((7k)MOD10+1)</code></strong>省略了乘号，中间是k（关键字）</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002571.jpeg"alt="13312114798622059" /><figcaption aria-hidden="true">13312114798622059</figcaption></figure><p>不成功<strong><code>30/11</code></strong></p><h2 id="删除操作">删除操作</h2><p>开放定址法删除元素不能直接删除元素</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281722199.png"alt="image-20240528172259057" /><figcaption aria-hidden="true">image-20240528172259057</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281722043.png"alt="image-20240528172212773" /><figcaption aria-hidden="true">image-20240528172212773</figcaption></figure><p><strong>【例题】</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405281759702.jpg"alt="0d04c1f410cb864a08ba47b1d3af6fa" /><figcaptionaria-hidden="true">0d04c1f410cb864a08ba47b1d3af6fa</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【栈】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%88%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%88%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一顺序栈">一：顺序栈</h1><h2 id="表示">表示</h2><ul><li><p>因为栈底位置是固定不变的，所以可以将栈底位置设置在数组的任何一个端点</p></li><li><p>栈顶位置是随着进栈和退栈操作而变化的，故需要一个变量top来指示当前栈顶的位置，通常称top为<strong><font color='red'>栈顶指针</font></strong></p></li></ul><blockquote><p><strong><font color='red'>栈顶指针top</font></strong>指向<strong><font color='blue'>栈顶元素的下一个位置</font></strong></p></blockquote><span id="more"></span><h2 id="顺序栈的定义">顺序栈的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* base;<span class="comment">//栈底指针</span></span><br><span class="line">ElementType* top;<span class="comment">//栈顶指针</span></span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//可使用的最大容量</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">Stack S;<span class="comment">//定义顺序栈</span></span><br><span class="line">S.stacksize = s;<span class="comment">//栈的大小</span></span><br><span class="line">S.base == S.top;<span class="comment">//空栈</span></span><br><span class="line">S.top - S.base == stacksize;<span class="comment">//满栈</span></span><br></pre></td></tr></table></figure><h2 id="顺序栈初始化">顺序栈初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.base = <span class="keyword">new</span> SElemType[MAXSIZE];<span class="comment">//分配空间</span></span><br><span class="line"><span class="keyword">if</span> (!S.base) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//分配失败，返回错误</span></span><br><span class="line">S.top = S.base;<span class="comment">//栈顶指针初始化为栈底指针</span></span><br><span class="line">S.stacksize = MAXSIZE;<span class="comment">//初始化栈的最大容量</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><font color='red'>exit是c++程序的退出函数</font></strong>，声明为<code>void exit(int value)</code>，其功能是退出当前的程序，并将参数value返回主调进程</li><li><strong><font color='red'>OVERFLOW为math.h的一个宏定义</font></strong>，其值为3。含义为运算过程中出现了上溢，运算结果超出了运算变量所能存储的范围。</li><li>所以，<code>exit(OVERFLOW)</code>的含义就是，退出程序，并返回OVERFLOW的值给主调进程。其标准的使用范围为，当程序运算出现上溢时，退出程序并报错给主调进程。</li></ul></blockquote><h2 id="顺序栈入栈">顺序栈入栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855471.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Stack&amp; S, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top - S.base == S.stacksize)<span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*S.top++ = e;<span class="comment">//新元素e压入栈顶，同时将栈顶指针+1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈出栈">顺序栈出栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855473.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><p>算法思想 1、判断是否栈空，若空则出错 2、栈顶指针-13、获取栈顶元素e（<strong><font color='red'>引用&amp;返回</font></strong>）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack&amp; S, ElementType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//栈空报错</span></span><br><span class="line">e = *--S.top;<span class="comment">//获取栈顶元素e，同时将栈顶指针-1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取顺序栈栈顶元素">取顺序栈栈顶元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">GetTop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top != S.base)<span class="comment">//栈非空</span></span><br><span class="line"><span class="keyword">return</span> *(S.top - <span class="number">1</span>);<span class="comment">//返回栈顶元素的值</span></span><br><span class="line">                        <span class="comment">//栈顶指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出栈内容">输出栈内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut_SqS</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == S.base)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空栈！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (ElementType* p = S.top - <span class="number">1</span> ; p &gt;= S.base ; p--)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二链栈">二：链栈</h1><blockquote><p>1、链式存储方式表示的栈称链栈 2、运算受限的单链表3、<strong><font color='red'>链表的头结点就是栈顶</font></strong>4、<strong><font color='blue'>插入与删除仅在栈顶执行</font></strong></p></blockquote><h2 id="链栈的存储结构">链栈的存储结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*Stack;</span><br><span class="line"></span><br><span class="line">Stack S;</span><br></pre></td></tr></table></figure><h2 id="链栈的初始化">链栈的初始化</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855474.png"alt="image-20221110233126960" /><figcaption aria-hidden="true">image-20221110233126960</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!S)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的入栈">链栈的入栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855475.png"alt="image-20221110235147314" /><figcaption aria-hidden="true">image-20221110235147314</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(Stack&amp; S, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> Node;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="comment">//头插法    </span></span><br><span class="line">p-&gt;next = S-&gt;next;</span><br><span class="line">S-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的出栈">链栈的出栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855476.png"alt="image-20221110235341367" /><figcaption aria-hidden="true">image-20221110235341367</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack&amp; S, ElementType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> ERROR;<span class="comment">//栈空</span></span><br><span class="line">    p = S-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">    </span><br><span class="line">S-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取链栈栈顶元素">取链栈栈顶元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">GetTop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = S-&gt;next;</span><br><span class="line"><span class="keyword">if</span> ( p != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出链栈的内容">输出链栈的内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* p = S-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空栈！&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题">例题</h1><h2 id="例一">例一</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290854572.png"alt="image-20230929085414412" /><figcaption aria-hidden="true">image-20230929085414412</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsReverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断输入的字符串中‘&amp;’前后两部分是否为逆串，是则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;s;<span class="type">char</span> c,t;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        s.<span class="built_in">push</span>(c);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t!=c)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>判断是否为逆序通常需要使用<strong><code>stack</code></strong></li><li>注意<strong>第9，第13行</strong>。</li></ol></blockquote><h2 id="例二数制转换">例二：数制转换</h2><p>基于栈设计一个算法，将一个十进制整数d转化为相应的r进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=d%r;</span><br><span class="line">        s.<span class="built_in">push</span>(t);</span><br><span class="line">        d/=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例三回文数的判断">例三：回文数的判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;    stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        t=n%<span class="number">10</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(t);</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">       t=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例四">例四</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855477.png"alt="image-20221110223733088" /><figcaption aria-hidden="true">image-20221110223733088</figcaption></figure><h3 id="分析">分析</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855478.png"alt="image-20221111125540175" /><figcaption aria-hidden="true">image-20221111125540175</figcaption></figure><h3 id="存储结构">存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType v[m];</span><br><span class="line">    <span class="type">int</span> top[<span class="number">2</span>];<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure><h3 id="建栈">建栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(Stack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.top[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    S.top[<span class="number">1</span>]=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈">入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Stack &amp;S,ElementType x,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top[<span class="number">1</span>]-S.top[<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:S.v[++S.top[<span class="number">0</span>]]=x;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: S.v[--S.top[<span class="number">1</span>]]=x;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈">出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack &amp;S, ElementType &amp;x, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(S.top[<span class="number">0</span>]==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x=S.v[S.top[<span class="number">0</span>]--];</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(S.top[<span class="number">1</span>]==m)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            x=S.v[S.top[<span class="number">1</span>]++];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例五表达式求值">例五：表达式求值</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855479.png"alt="image-20221111000921743" /><figcaption aria-hidden="true">image-20221111000921743</figcaption></figure><h3 id="分析-1">分析</h3><hr /><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855480.png"alt="image-20221111125043545" /><figcaption aria-hidden="true">image-20221111125043545</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855481.png"alt="image-20221111125349605" /><figcaption aria-hidden="true">image-20221111125349605</figcaption></figure><h3 id="例五括号匹配">例五：括号匹配</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855482.png"alt="image-20221111110712016" /><figcaption aria-hidden="true">image-20221111110712016</figcaption></figure><h4 id="分析-2">分析</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855483.png"alt="image-20221111110734311" /><figcaption aria-hidden="true">image-20221111110734311</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855484.png"alt="image-20221111110748683" /><figcaption aria-hidden="true">image-20221111110748683</figcaption></figure><h4 id="算法">算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;stack&lt;<span class="type">char</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;(&#x27;</span> || ch==<span class="string">&#x27;[&#x27;</span> || ch==<span class="string">&#x27;&#123;&#x27;</span> ):</span><br><span class="line">                s.<span class="built_in">push</span>(ch);<span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;)&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(t!=<span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;[&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(t!=<span class="string">&#x27;]&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;&#123;&#x27;</span> ):</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">if</span>(t!=<span class="string">&#x27;&#125;&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例六迷宫求解">例六：迷宫求解</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855485.png"alt="image-20221211163004047" /><figcaption aria-hidden="true">image-20221211163004047</figcaption></figure><p><ahref="D:\Document\已结课资料\数据结构\老师课件\第3章%20栈和队列22.pdf">栈和队列</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树】</title>
      <link href="/2023/09/24/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%91%E3%80%91/"/>
      <url>/2023/09/24/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%91%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树">二叉树</h1><h2 id="存储结构">存储结构</h2><h3 id="顺序存储结构">顺序存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">typedef</span> ElementType BinTree[MAX];</span><br><span class="line">BinTree T;</span><br></pre></td></tr></table></figure><ul><li>顺序存储的二叉树是<strong>完全二叉树</strong>，完全二叉树的性质如下：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072113883.jpg"alt="7476a7cbe9d1fbd33df03cf13ab37b4" /><figcaptionaria-hidden="true">7476a7cbe9d1fbd33df03cf13ab37b4</figcaption></figure><ol type="1"><li><strong><font color='red'>从1号单元开始存储树节点</font></strong>（0号单元存节点的个数）</li><li><span class="math inline">\(i\)</span> 左子树是 <spanclass="math inline">\(2i\)</span>，右子树是 <spanclass="math inline">\(2i+1\)</span>，根节点是 <spanclass="math inline">\(\lfloor i/2 \rfloor\)</span>，左兄弟是 <spanclass="math inline">\(i-1\)</span>，右兄弟 <spanclass="math inline">\(i+1\)</span></li><li>如果完全二叉树一共有 <span class="math inline">\(n\)</span>个节点，则非叶子节点为 <spanclass="math inline">\(T[0…n/2]\)</span>，叶节点为 <spanclass="math inline">\(T[n/2+1,…,n]\)</span></li></ol><span id="more"></span><h3 id="链式存储结构">链式存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol type="1"><li><p><strong><code>ElementType</code></strong>既可以是<code>int</code>，<code>char</code>，<code>double</code>，<code>float</code>等，即</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> ElementType;    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ElementType ;      </span><br></pre></td></tr></table></figure></p><blockquote><p>注意typedef最后面的<font color='red'><strong>分号</strong></font></p></blockquote></li><li><p><strong><code>ElementType</code></strong>也可以是自定义的<strong>struct类型</strong>，eg：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;ElementType;</span><br></pre></td></tr></table></figure></blockquote><h2 id="常见函数">常见函数</h2><h3 id="先序遍历">先序遍历</h3><p><strong>前序遍历(先根遍历)</strong></p><ol type="1"><li>若二叉树为空，则返回；</li><li>若不空：<ol type="1"><li>访问根结点；</li><li>前序遍历左子树；</li><li>前序遍历右子树。</li></ol></li></ol><h4 id="递归算法">递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  if(T==NULL)return;</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">        <span class="built_in">preorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(T-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法">非递归算法</h4><ul><li>通过<strong><font color='red'>堆栈</font></strong>来实现</li><li>从当前节点开始遍历：<ol type="1"><li>若当前节点存在，就存入栈中，并访问左子树</li><li>直到当前节点不存在，就<strong><font color='blue'>出栈，并通过栈顶节点访问右子树</font></strong></li><li>不断重复1、2，直到当前节点不存在且栈空</li></ol></li></ul><blockquote><p>若<strong><font color='red'>入栈</font></strong>时访问节点，则为<strong><font color='blue'>前序</font></strong>遍历；若<strong><font color='red'>出栈</font></strong>时访问节点，则为<strong><font color='blue'>中序</font></strong>遍历</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951583.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinTree p = T;</span><br><span class="line">    stack&lt;BinTree&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;val); <span class="comment">// 先序，第一次遇到就输出</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>visit(p-&gt;val)</code></strong> 语句与<strong><code>s.push(p)</code></strong>语句成对出现，这表明==<strong><font color='red'>先序遍历的序列就是入栈的顺序</font></strong>==</p></blockquote><h3 id="中序遍历">中序遍历</h3><p><strong>中序遍历(中根遍历)</strong></p><ol type="1"><li>若二叉树为空，则退出；</li><li>若不空：<ol type="1"><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树</li></ol></li></ol><h4 id="递归算法-1">递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法-1">非递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinTree p = T;</span><br><span class="line">    stack&lt;BinTree&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;val); <span class="comment">// 中序，第二次遇到才输出</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>visit(p-&gt;val)</code></strong> 语句与<strong><code>s.pop()</code></strong>语句成对出现，这表明==<strong><font color='red'>中序遍历的序列就是出栈的顺序</font></strong>==</p></blockquote><h3 id="后序遍历">后序遍历</h3><p><strong>后序遍历(后根遍历)</strong></p><ol type="1"><li>若二又树为空，则退出；</li><li>若不空：<ol type="1"><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点</li></ol></li></ol><h4 id="递归算法-2">递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">postorder</span>(T-&gt;right);</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法-2">非递归算法</h4><ul><li><p><strong>双栈法</strong>：用两个栈来实现后序遍历的非递归算法。</p></li><li><p>注意到<strong><font color='purple'>后序遍历</font></strong>可以看作是<font color='purple'><strong>下面遍历的逆过程</strong></font>：即<strong>先遍历<font color='red'>根结点</font>，然后遍历其<font color='red'>右子树</font>，然后遍历其<font color='red'>左子树</font></strong>。这个<strong><font color='blue'>过程逆过来就是后序遍历</font></strong>。算法步骤如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinTree p = T;</span><br><span class="line">    stack&lt;BinTree&gt; s1, s2;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !s1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(p);</span><br><span class="line">            s2.<span class="built_in">push</span>(p); <span class="comment">// visit(p)换成s2.push();</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s1.<span class="built_in">top</span>();</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆序输出即为后序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!s2.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        p = s2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">visit</span>(p-&gt;val);</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历">层序遍历</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951110.png"alt="image-20221001230537604" /><figcaption aria-hidden="true">image-20221001230537604</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="comment">/* 若是空树则直接返回 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode *&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        BinTree t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(t-&gt;val); <span class="comment">/* 访问取出队列的结点 */</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left)</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果返回形式是下面的类型:<strong>:star2:LeetCode102</strong></p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20240220223112586.png" alt="image-20240220223112586" style="zoom:33%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                row.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(row);</span><br><span class="line">            row.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="先序遍历建立二叉树">先序遍历建立二叉树</h3><p><strong>扩充先序序列：先序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的先序遍历序列是：ABCDEFG</strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /></p><p><strong>扩充先序序列为：ABC##DE#G##F###</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">T-&gt;val = x;<span class="comment">//生成根结点</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历建立二叉树">中序遍历建立二叉树</h3><p><strong>扩充中序序列：中序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的中序遍历序列是：CBEGDFA</strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /></p><p><strong>扩充先序序列为：#C#B#E#G#D#F#A#</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line">        T-&gt;val = x;<span class="comment">//生成根结点</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历建立二叉树">后序遍历建立二叉树</h3><p><strong>扩充后序序列：后序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的后序遍历序列是：CGEFDBA</strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /></p><p><strong>扩充先序序列为：##C###GE##FDB#A</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">        T-&gt;val = x;<span class="comment">//生成根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的高度深度">求二叉树的高度（深度）</h3><blockquote><p>算法基本思想：</p><p>1、若二叉树为==<strong>空树</strong>==，则高度（深度）为02、否则，二叉树的高度（深度）为左右子树的高度（深度）的最大值+1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeHeight</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h1 = <span class="built_in">TreeHeight</span>(T-&gt;left);</span><br><span class="line">    <span class="type">int</span> h2 = <span class="built_in">TreeHeight</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (h1 &gt; h2)</span><br><span class="line">        <span class="keyword">return</span> h1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> h2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的直径">求二叉树的直径</h3><p>【LeetCode:543】</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402211129363.png"alt="image-20240221112902928" /><figcaption aria-hidden="true">image-20240221112902928</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left), r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        res = <span class="built_in">max</span>(res, l + r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="统计结点个数">统计结点个数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951318.png"alt="image-20221002083141111" /><figcaption aria-hidden="true">image-20221002083141111</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nodesum</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodesum</span>(T-&gt;left)+<span class="built_in">nodes</span>(T-&gt;right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计叶结点个数">统计叶结点个数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951178.png"alt="image-20221002085013531" /><figcaption aria-hidden="true">image-20221002085013531</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leafnodes</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;left == <span class="literal">NULL</span> &amp;&amp; T-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leafnodes</span>(T-&gt;left) + <span class="built_in">leafnodes</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计度数为2的结点个数">统计度数为2的结点个数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nodes_two</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;left &amp;&amp; T-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodes_two</span>(T-&gt;left) + <span class="built_in">nodes_two</span>(T-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodes_two</span>(T-&gt;left) + <span class="built_in">nodes_two</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为对称二叉树">判断是否为对称二叉树</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402202108310.png"alt="image-20240220210836661" /><figcaption aria-hidden="true">image-20240220210836661</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(TreeNode *a, TreeNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">nullptr</span> &amp;&amp; b != <span class="literal">nullptr</span> &amp;&amp; a-&gt;val == b-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(a-&gt;left, b-&gt;right) &amp;&amp; <span class="built_in">func</span>(a-&gt;right, b-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断两个二叉树是否相同">判断两个二叉树是否相同</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBinTree</span><span class="params">(BinTree T1, BinTree T2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((T1 == <span class="literal">NULL</span> &amp;&amp; T2 != <span class="literal">NULL</span>) || (T1 != <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T1-&gt;val != T2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isBinTree</span>(T1-&gt;left) &amp;&amp; <span class="built_in">isBinTree</span>(T1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出叶结点">输出叶结点</h3><p>本题要求按照<strong>先序遍历</strong>的顺序输出二叉树的叶结点。</p><blockquote><p>思路：==<strong>先序遍历</strong>==输出根节点时<strong><font color='red'>加上判断</font></strong>其是否为叶结点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderPrintLeaves</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">        <span class="built_in">PreorderPrintLeaves</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">PreorderPrintLeaves</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除二叉树">删除二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyTree</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">Destroy</span>(T-&gt;left);</span><br><span class="line">    <span class="built_in">Destrot</span>(T-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：必须<strong><code>Destroy(T-&gt;left);     Destrot(T-&gt;right);</code><font color='red'>之后</font>才能<code>free(T);</code></strong></p></blockquote><h3 id="复制二叉树">复制二叉树</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951514.png"alt="image-20221002113115794" /><figcaption aria-hidden="true">image-20221002113115794</figcaption></figure><h4 id="法一">法一：</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951555.png"alt="image-20221002113137163" /><figcaption aria-hidden="true">image-20221002113137163</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinTree &amp;b, BinTree &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        t == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = b-&gt;val;</span><br><span class="line">    <span class="built_in">CopyTree</span>(b-&gt;left, t-&gt;left);</span><br><span class="line">    <span class="built_in">CopyTree</span>(b-&gt;right, b-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二">法二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">CopyTree</span><span class="params">(BinTree b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = b-&gt;val;</span><br><span class="line">    t-&gt;left = <span class="built_in">CopyTree</span>(b-&gt;left);</span><br><span class="line">    t-&gt;right = <span class="built_in">CopyTree</span>(b-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换二叉树的左右子树">交换二叉树的左右子树</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951582.png"alt="image-20221002120102502" /><figcaption aria-hidden="true">image-20221002120102502</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402202059497.png"alt="image-20240220205942861" /><figcaption aria-hidden="true">image-20240220205942861</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">invertTree</span><span class="params">(BinTree b, BinTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = b-&gt;val;</span><br><span class="line">    <span class="built_in">invertTree</span>(b-&gt;left, t-&gt;right);</span><br><span class="line">    <span class="built_in">invertTree</span>(b-&gt;right, t-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以破坏原来的二叉树,则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值为x的结点所在的层数">返回值为x的结点所在的层数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951796.jpeg"alt="38251992cd4cab160ebe3b423b0e74a" /><figcaptionaria-hidden="true">38251992cd4cab160ebe3b423b0e74a</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodeLevel</span> <span class="params">(BinTree T,ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树的层号为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;val==X)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//规定根节点的层号为1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t1=<span class="built_in">NodeLevel</span>(T-&gt;left,X);</span><br><span class="line">        <span class="type">int</span> t2=<span class="built_in">NodeLevel</span>(T-&gt;right,X);</span><br><span class="line">        <span class="keyword">if</span>(t1 &gt; <span class="number">0</span>)<span class="keyword">return</span> t1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t2 &gt; <span class="number">0</span>)<span class="keyword">return</span> t2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若树中不存在值为X的结点，返回0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>若函数返回0，说明树中不存在值为X的结点</strong></p></blockquote><h3 id="前序中序建树">前序中序建树</h3><h4 id="法一-1">法一：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> preorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【前序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BinTree <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = (BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    t-&gt;val = preorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != preorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    t-&gt;left = <span class="built_in">BuildTree</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">    t-&gt;right = <span class="built_in">BuildTree</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T = <span class="built_in">BuildTree</span>(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="法二-1">法二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【前序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, BinTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    T-&gt;val = preorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != preorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>, T-&gt;left);</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right, T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, T);</span><br></pre></td></tr></table></figure><h3 id="后序中序建树">后序中序建树</h3><h4 id="法一-2">法一：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【后序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BinTree <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = postorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != postorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    t-&gt;left = <span class="built_in">BuildTree</span>(root - right + i - <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">    t-&gt;right = <span class="built_in">BuildTree</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T = <span class="built_in">BuildTree</span>(n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="法二-2">法二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【后序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, BinTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    T-&gt;val = postorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != postorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>, T-&gt;left);</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right, T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T;</span><br><span class="line"><span class="built_in">BuildTree</span>(n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, T);</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li><p>注意第10行</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left&gt;right)</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><p>而<strong>不能直接</strong>==<del><code>return;</code></del>==</p></li><li><p>```c++ void BuildTree(int root, int left, int right, BinTree&amp;T) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    注意**T**是引用类型，加了一个==**&amp;**==</span><br><span class="line"></span><br><span class="line">3. 递归模型</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    left&gt;rightT==NULL;</span><br><span class="line">    BuildTree(root+1, left, i-1, T-&gt;left);</span><br><span class="line">    BuildTree(root+i-left+1, i+1, right, T-&gt;right);</span><br></pre></td></tr></table></figure></p></li></ol></blockquote><h3 id="前序中序转后序">前序中序转后序</h3><p>已知前序与中序,请输出后序。 前序：1, 2, 3, 4, 5, 6（根左右） 中序：3,2, 4, 1, 6, 5（左根右）</p><blockquote><p>分析：因为前序的第一个总是根结点，令i在中序中找到该根结点，则i把中序分为两部分，左边是左子树，右边是右子树。因为是输出后序（左右根）所以先打印出当前左子树，然后右子树，再打印根结点。</p></blockquote><p><strong>:smile:算法</strong></p><ol type="1"><li>root为当前子树的根结点在<strong>前序</strong><code>preorder</code>中的下标。<strong>left和right</strong>为当前子树的最左边和最右边的结点在<strong>中序</strong><code>inorder</code>中的下标。</li><li>用<code>i</code>找到当前子树的<strong>根结点</strong>root在<strong>中序</strong>中的下标，然后左边和右边就分别为当前根结点root的左子树和右子树。递归实现～</li><li>左子树在<strong>前序</strong>中的根结点为当前根结点的后一个结点<code>root + 1</code>；左子树在<strong>中序</strong>中的起始点left为<code>left</code>，末尾点right为<code>i – 1</code>.</li><li>右子树的根结点在<strong>前序</strong>中为<code>root + (i -left + 1)</code>，即为当前根结点+(左子树的个数+1)。右子树在中序中的起始点left为<code>i+1</code>，末尾right点为<code>right</code>。</li></ol><p>输出的后序应为：3 4 2 6 5 1（左右根）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用数组，且数组必须是是全局变量</span></span><br><span class="line"><span class="type">int</span> preorder[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 前序</span></span><br><span class="line"><span class="type">int</span> inorder[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;  <span class="comment">// 中序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- root: 当前根节点在【前序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = left; <span class="comment">// i从当前树的起点开始寻找 ，直到end</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != preorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    <span class="built_in">postorder</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>);             <span class="comment">// 左子树</span></span><br><span class="line">    <span class="built_in">postorder</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, preorder[root]);                <span class="comment">// 或printf(&quot;%d &quot;, in[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">postorder</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 初始根节点在preorder和最左最右结点在inorder中下标已知</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序中序转前序">后序中序转前序</h3><p>已知后序与中序,请输出前序（先序）： 后序：3, 4, 2, 6, 5, 1（左右根）中序：3, 2, 4, 1, 6, 5（左根右）</p><blockquote><p>分析：因为后序的最后一个总是根结点，令<code>i</code>在中序中找到该根结点，然后<code>i</code>把中序分为两部分，左边是左子树，右边是右子树。因为是输出先序（根左右），所以先打印出当前根结点，然后打印左子树，再打印右子树。</p></blockquote><p><strong>:smile:算法</strong></p><ol type="1"><li><p>root为当前子树的根结点在<strong>后序</strong><code>postorder</code>中的下标。<strong>left和right</strong>为当前子树的最左边和最右边的结点在<strong>中序</strong><code>inorder</code>中的下标。</p></li><li><p>用<code>i</code>找到当前子树的<strong>根结点</strong>root在<strong>中序</strong>中的下标，然后左边和右边就分别为当前根结点root的左子树和右子树。递归实现～</p></li><li><p>左子树的根结点在<strong>后序</strong>中为<code>root – (end – i + 1)</code>，即为当前根结点-(右子树的个数+1)；左子树在中序中的起始点left为<code>left</code>，末尾点right为<code>i – 1</code>.</p></li><li><p>右子树的根结点在后序中为当前根结点的前一个结点root – 1；右子树在中序中的起始点left为<code>i+1</code>，末尾right点为<code>right</code>。</p></li></ol><p>输出的前序应该为：1, 2, 3, 4, 5, 6（根左右）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> postorder[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;; <span class="comment">// 后序</span></span><br><span class="line"><span class="type">int</span> inorder[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;   <span class="comment">// 中序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- root: 当前根节点在【后序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left; <span class="comment">// i从当前树的起点开始寻找 ，直到end</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != postorder[root])</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, postorder[root]);              <span class="comment">// 或printf(&quot;%d &quot;, inorder[i]);</span></span><br><span class="line">    <span class="built_in">preorder</span>(root - <span class="number">1</span> - right + i, left, i - <span class="number">1</span>); <span class="comment">// 左子树</span></span><br><span class="line">    <span class="built_in">preorder</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, right);            <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">preorder</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 初始根节点在postorder和最左最右结点在inorder中下标已知</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的右视图"><ahref="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a></h3><p>​ 给定一个二叉树的 <strong>根节点</strong><code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402251724343.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p>按照<strong>层序遍历</strong>的⽅式，把每一层的<strong>最后⼀个结点</strong>的值存⼊vector中，最后返回vector～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            TreeNode *t;</span><br><span class="line">            <span class="keyword">while</span> (size--)</span><br><span class="line">            &#123;</span><br><span class="line">                t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和-i"><ahref="https://leetcode.cn/problems/path-sum/">路径总和 I</a></h3><p>​ 给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数<code>targetSum</code> 。判断该树中是否存在<strong>根节点到叶子节点</strong>的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code>。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code>。<strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val == targetSum;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) ||</span><br><span class="line">               <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和-ii"><ahref="https://leetcode.cn/problems/path-sum-ii/">路径总和 II</a></h3><p>​ 给你二叉树的根节点 <code>root</code> 和一个整数目标和<code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong>路径总和等于给定目标和的路径。<strong>叶子节点</strong>是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>​pathsum函数中只需dfs一下然后返回result数组即可，dfs函数中从root开始寻找到底端sum==root-&gt;val的结点，如果满足就将root-&gt;val压入path数组中，path数组压入result数组中，然后将当前结点弹出，return。不满足是最后一个结点的则不断深度优先左结点、右结点，同时处理好path数组的压入和弹出~~</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">            root-&gt;val == sum) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();<span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="section"></h3><h2 id="例题">例题</h2><blockquote><blockquote><p>先序序列a,b,c,d的不同二又树个数是() A.13 B.14 C.15 D.16</p></blockquote></blockquote><ul><li><p>因为先序序列和中序序列可以唯一地确定一棵二叉树，并且题目已经给出了先序序列，所以我们只需要知道由该先序序列可以确定多少个中序序列，即可确定确定多少棵二叉树！</p></li><li><p>那么，问题来了，由一个先序序列如何确定有多少个中序序列呢？这就有两个“公式”需要大家去牢记了！</p></li></ul><blockquote><p>1、先序序列和中序序列的关系为：==<strong><font color='blue'>以先序序列入栈，则出栈序列必为中序序列</font></strong>==2、一个入栈顺序可以确定的出栈顺序有 <spanclass="math inline">\(f(n)\)</span> 种（卡特兰数），<spanclass="math inline">\(n\)</span>为结点个数 <span class="math display">\[f\left( n \right) =C_{2n}^{n}-C_{2n}^{n-1}=\frac{1}{n+1}C_{2n}^{n}\]</span></p></blockquote><ul><li>所以答案就清楚了，如果以 <span class="math inline">\(abcd\)</span>的顺序入栈，将有 <span class="math inline">\(14\)</span>种出栈顺序，也就是可以确定 <span class="math inline">\(14\)</span>个中序序列，即可以确定 14 个不同的二叉树。</li></ul><blockquote><blockquote><p>假定只有四个结点A、B、C、D的二叉树，其前序遍历序列为ABCD，则下面哪个序列是不可能的中序遍历序列?</p><p>A：ABCD B：ACDB C：DCBA D：DABC</p></blockquote></blockquote><blockquote><p>答案：D 二叉树的前序遍历和中序遍历分别对应入栈和出栈顺序</p></blockquote><h1 id="二叉搜索树bst">二叉搜索树(BST)</h1><h2 id="介绍">介绍</h2><p>==<strong><font color='blue'>二叉搜索树</font></strong> ==<strong><font color='blue'>二叉查找树</font></strong> （Binary SearchTree） == <strong><font color='blue'>二叉排序树</font></strong> （BinarySort Tree）==</p><ul><li>若它的左子树不空，则<strong>左子树</strong>上<strong>所有</strong>结点的值均<font color='red'><strong>小于</strong></font>根结点的值;</li><li>若它的右子树不空，则<strong>右子树</strong>上<strong>所有</strong>结点的值均<font color='red'><strong>大于</strong></font>根结点的值;</li><li>它的左、右子树也都分别是<strong>二又搜索树</strong></li></ul><blockquote><blockquote><ol type="1"><li><strong>二叉排序树</strong>的<strong><font color='red'>中序遍历</font></strong>是<strong><font color='gree'>递增</font></strong>序列</li><li>在构造二叉排序树时，若关键字序列有序，则二叉排序树的高度最大</li></ol></blockquote></blockquote><h2 id="存储结构-1">存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>struct TreeNode* left, *right;</code></strong>中<strong><code>*</code></strong>是跟着变量名的</p></blockquote><h2 id="操作集">操作集</h2><h3 id="查找">查找</h3><ul><li>函数<code>Find</code>在二叉搜索树<code>T</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li></ul><h4 id="法一递归">法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Find</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Find</span>(T-&gt;right,X);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Find</span>(T-&gt;left,X);</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二循环">法二：循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Find</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">            T=T-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">            T=T-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最小值">找最小值</h3><ul><li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li></ul><h4 id="法一递归-1">法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">FindMin</span>(T-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二循环-1">法二:循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">while</span>(T-&gt;left)</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最大值">找最大值</h3><ul><li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li></ul><h4 id="法一递归-2">法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">FindMin</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二循环-2">法二：循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">while</span>(T-&gt;right)</span><br><span class="line">            T=T-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入">插入</h3><ul><li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li></ul><h4 id="法一-3">法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;val=X;</span><br><span class="line">        T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X&lt;T-&gt;Data)    </span><br><span class="line">            T-&gt;left=<span class="built_in">Insert</span>(T-&gt;left,X);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;val)</span><br><span class="line">            T-&gt;right=<span class="built_in">Insert</span>(T-&gt;right,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二-3">法二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">( BinTree &amp;T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;val=X;T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">            <span class="built_in">Insert</span>( T-&gt;right, ElementType X );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">            <span class="built_in">Insert</span>( T-&gt;left, ElementType X );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>二叉树排序树中<strong><font color='red'>不存在</font></strong>相同的结点，故</p><p><strong><code>if( X==T-&gt;val )    return;         //无需插入</code></strong></p></li><li><p>注意函数参数T是<font color='blue'><strong>引用&amp;类型</strong></font></p></li></ul></blockquote><h3 id="删除">删除</h3><ul><li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li></ul><h4 id="算法描述">算法描述</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951998.png" alt="image-20221019104744543" style="zoom:80%;" /></p><p><strong>（1）p为叶结点</strong></p><p>删除方法：释放结点p，修改p父节点指针f的相应指针</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951995.png" alt="image-20221019105019917" style="zoom:80%;" /></p><p><strong>（2）p只有左子树</strong></p><p>删除方法：释放结点p，p的左子树顶替p结点的位置</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952089.png"alt="image-20221019105212235" /><figcaption aria-hidden="true">image-20221019105212235</figcaption></figure><p><strong>（3）p只有右子树</strong></p><p>删除方法：释放结点p，p的右子树顶替p结点的位置</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952098.png"alt="image-20221019105327790" /><figcaption aria-hidden="true">image-20221019105327790</figcaption></figure><p><strong>(4）p既有左子树，也有右子树</strong></p><p>删除方法：寻找p<strong><font color='red'>左子树中最大的结点</font></strong>或 p<strong><font color='red'>右子树中最小的结点</font></strong>来替代结点p</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952259.png" alt="image-20221019191743343" style="zoom:67%;" /></p><h4 id="法一-4">法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(T-&gt;left,X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(T-&gt;right,X);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left &amp;&amp; T-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            BinTree t=<span class="built_in">FindMin</span>(T-&gt;right);</span><br><span class="line">            T-&gt;val=t-&gt;val;</span><br><span class="line">            T-&gt;right=<span class="built_in">Delete</span>(T-&gt;right,T-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            BinTree t=T;</span><br><span class="line">            <span class="keyword">if</span>(!T-&gt;left)</span><br><span class="line">                T=T-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!T-&gt;right)</span><br><span class="line">                T=T-&gt;left;  </span><br><span class="line">            <span class="built_in">free</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二-4">法二</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952414.jpeg"alt="微信图片_20221019200024" /><figcaption aria-hidden="true">微信图片_20221019200024</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">( BinTree &amp;T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;left,X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;right,X);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( T-&gt;left == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;BinTree t=T;T = T-&gt;left;<span class="built_in">free</span>(t);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;right == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;BinTree t=T;T = T-&gt;right;<span class="built_in">free</span>(t);&#125;          </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;<span class="comment">//在左子树中寻找最大的（最右边的）</span></span><br><span class="line">            BinTree p=T;BinTree t=T-&gt;left;</span><br><span class="line">            <span class="comment">//初始化：p为t的父节点,t为左子树的根节点</span></span><br><span class="line">            <span class="keyword">while</span>( t-&gt;right )</span><br><span class="line">            &#123;p = t;t=t-&gt;right;&#125;<span class="comment">//p为被删除结点t的前驱</span></span><br><span class="line">            T-&gt;val=t-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(p!=T )p-&gt;right=t-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;left=t-&gt;left；</span><br><span class="line">            <span class="built_in">free</span>(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见函数-1">常见函数</h2><h3 id="判断二叉树">判断二叉树</h3><p>​ 给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p>:sunny:<strong>分析</strong>：既然是⼆叉搜索树，那么按照左根右遍历后的结果一定是增序～所以只需要中序遍历一遍，判断遍历结果的数组是不是后⾯面数⼀定⼤于前面数就可以了～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">            v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (v[i] &gt;= v[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树中第k小的元素"><ahref="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a></h3><p>​ 给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数<code>k</code> ，请你设计一个算法查找其中第 <code>k</code>个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250211734.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250211749.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">inOrder</span>(root-&gt;left, k);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k)</span><br><span class="line">            &#123;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">inOrder</span>(root-&gt;right, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode *root, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树avl">平衡二叉树（AVL）</h1><h2 id="介绍-1">介绍</h2><h3 id="定义">定义</h3><p>​ 平衡二叉树 全称叫做 <code>平衡二叉搜索（排序）树</code>，简称AVL树。英文：Balanced Binary Tree （BBT），注：二叉查找树(BST)</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221451357.jpg" alt="960faf26fc684ecc6dad1e5ba01e3ba" style="zoom: 33%;" /></p><h3 id="avl-什么意思">AVL 什么意思 ？</h3><p>​ AVL 是大学教授 G.M. Adelson-Velsky 和 E.M. Landis名称的缩写，他们提出的平衡二叉树的概念，为了纪念他们，将平衡二叉树称为AVL树。</p><h3 id="为什么使用avl树">为什么使用AVL树</h3><p>​ 二叉搜索树能提高查找的效率 O(log n)，但是当你插入<code>&#123;1,2,3,4,5,6&#125;</code> 这种数据的时候，二叉树的效率变为 O(n)</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952506.png" alt="image-20210110143451761" style="zoom: 33%;" /></p><p>:sunny:判断「平衡二叉树」的 2 个条件：</p><ol type="1"><li><p><strong>是「二叉排序树」</strong></p></li><li><p><strong>任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于1）</strong></p></li></ol><h3 id="平衡因子">平衡因子</h3><p>平衡因子（Balance Factor，简写为bf）=<font color='red'><strong>左子树的==高度== - 右子树的==高度==</strong> </font>。</p><blockquote><blockquote><p><strong>在 AVL树中，所有节点的平衡因子都必须满足：-1&lt;=bf&lt;=1;</strong></p></blockquote></blockquote><h2 id="有序数组构建avl">有序数组构建AVL</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按<strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong>二叉搜索树。</p><p><strong>高度平衡</strong>二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1」的二叉树。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221527581.png"alt="image-20240222152702374" /><figcaption aria-hidden="true">image-20240222152702374</figcaption></figure><p>​ 思路：设⽴立left和right，mid = (left + right) /2，每次将数组的中点mid的值为根结点的值，中点左边为根结点的左⼦子树，右边为根结点的右⼦子树～递归求解～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据有序数组构建平衡二叉树AVL */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">func</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="构造方法">构造方法</h2><p>详细请看 <ahref="https://zhuanlan.zhihu.com/p/165939383">【数据结构】AVL树（平衡二叉树）画法速成教学 - 知乎 (zhihu.com)</a></p><h3 id="ll型右旋">LL型—右旋</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BinTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree t=p-&gt;left;</span><br><span class="line">    p-&gt;left=t-&gt;right;</span><br><span class="line">    t-&gt;right=p;</span><br><span class="line">    p=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rr型左旋">RR型—左旋</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952586.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree t=p-&gt;right;</span><br><span class="line">    p-&gt;right=t-&gt;left;</span><br><span class="line">    t-&gt;left=p;</span><br><span class="line">    p=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lr型左右旋">LR型—左右旋</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952663.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952646.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LR_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">L_Rotate</span>(p-&gt;left);</span><br><span class="line">    <span class="built_in">R_Rotate</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rl型右左旋">RL型—右左旋</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952836.png" alt="在这里插入图片描述" style="zoom:95%;" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952963.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RL_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">R_Rotate</span>(p-&gt;right);</span><br><span class="line">    <span class="built_in">L_Rotate</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><p><strong>1123 Is It a Complete AVL Tree</strong></p><p>An AVL tree is a self-balancing binary search tree. In an AVL tree,the heights of the two child subtrees of any node differ by at most one;if at any time they differ by more than one, rebalancing is done torestore this property. Figures 1-4 illustrate the rotation rules.</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952090.jpeg"alt="F1.jpg" /></th><th><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952183.jpeg"alt="F2.jpg" /></th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952280.jpeg"alt="F3.jpg" /></td><td><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952482.jpeg"alt="F4.jpg" /></td></tr></tbody></table><p>Now given a sequence of insertions, you are supposed to output thelevel-order traversal sequence of the resulting AVL tree, and to tell ifit is a complete binary tree.</p><ul><li><strong>Input Specification:</strong></li></ul><p>Each input file contains one test case. For each case, the first linecontains a positive integer N (≤ 20). Then N distinct integer keys aregiven in the next line. All the numbers in a line are separated by aspace.</p><ul><li><strong>Output Specification:</strong></li></ul><p>For each test case, insert the keys one by one into an initiallyempty AVL tree. Then first print in a line the level-order traversalsequence of the resulting AVL tree. All the numbers in a line must beseparated by a space, and there must be no extra space at the end of theline. Then in the next line, print <code>YES</code> if the tree iscomplete, or <code>NO</code> if not.</p><ul><li><strong>Sample Input 1:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 63 65</span><br></pre></td></tr></table></figure><ul><li><strong>Sample Output 1:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">70 63 88 61 65</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><ul><li><strong>Sample Input 2:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">88 70 61 96 120 90 65 68</span><br></pre></td></tr></table></figure><ul><li><strong>Sample Output 2:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88 65 96 61 70 90 120 68</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    TreeNode *temp = tree-&gt;right;</span><br><span class="line">    tree-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = tree;</span><br><span class="line">    tree = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    TreeNode *temp = tree-&gt;left;</span><br><span class="line">    tree-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = tree;</span><br><span class="line">    tree = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftRightRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">leftRotate</span>(tree-&gt;left);</span><br><span class="line">    <span class="built_in">rightRotate</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rightLeftRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rightRotate</span>(tree-&gt;right);</span><br><span class="line">    <span class="built_in">leftRotate</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode *tree, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        tree-&gt;val = val;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;val &gt; val) &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">insert</span>(tree-&gt;left, val);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left), r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (l - r &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; tree-&gt;left-&gt;val)</span><br><span class="line">                <span class="built_in">rightRotate</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">leftRightRotate</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">insert</span>(tree-&gt;right, val);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left), r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; tree-&gt;right-&gt;val)</span><br><span class="line">                <span class="built_in">leftRotate</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">rightLeftRotate</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> isComplete = <span class="number">1</span>, after = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode *tree)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    queue&lt;TreeNode *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(tree);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *temp = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    TreeNode *tree = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        tree = <span class="built_in">insert</span>(tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">levelOrder</span>(tree);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s&quot;</span>, isComplete ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的深度高度层数">树的深度/高度/层数</h1><h2 id="介绍-2">介绍</h2><p><strong>深度定义是从上往下的，高度定义是从下往上的。</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952536.jpeg"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="总结">总结</h2><p>==<strong>高度=深度=层数</strong>==</p><blockquote><p>其中<strong>根结点</strong>的<strong>高度/层数/深度</strong>均为1</p></blockquote><h2 id="举例">举例</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952587.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><table><thead><tr class="header"><th>图</th><th></th></tr></thead><tbody><tr class="odd"><td>层数</td><td>第1层开始</td></tr><tr class="even"><td>最大层数</td><td>5</td></tr><tr class="odd"><td>深度</td><td>5</td></tr><tr class="even"><td>高度</td><td>5</td></tr></tbody></table><h1 id="树和森林">树和森林</h1><h2 id="树二叉树森林的关系">树、二叉树、森林的关系</h2><blockquote><p><strong><font color='blue'>树&lt; == &gt;二叉树&lt; ==&gt;森林</font></strong>（三者<strong><font color='red'>一一对应</font></strong>）</p><ul><li>树可以唯一地确定 二叉树 和 森林</li><li>二叉树（不含左子树）可以唯一地确定 树 和 森林</li><li>森林可以唯一地确定树和二叉树</li></ul></blockquote><h2 id="树">树</h2><p>树(Tree)是 <span class="math inline">\(n(n≥0)\)</span>个结点的有限集合。在任意一棵非空树中，有以下两个性质：</p><ol type="1"><li>有且<strong>仅有一个特定的结点</strong>，称为根(Root)。</li><li>当n＞1时，其余的结点可分为m个互不相交的集合T1，T2，…，Tm，其中每一个集合都是一棵树，并且称为根的<strong>子树</strong>(Subtree)。</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952600.png"alt="树型结构实例" /><figcaption aria-hidden="true">树型结构实例</figcaption></figure><h2 id="森林">森林</h2><p>森林(Forest)是m(m≥0)棵互不相交的==<strong>树的集合</strong>==。对树中每个结点而言，其子树的集合即为森林</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952720.png"alt="image-20230924094551480" /><figcaption aria-hidden="true">image-20230924094551480</figcaption></figure><h2 id="树转化为二叉树">树转化为二叉树</h2><h3 id="方法">方法</h3><p>树中每个结点最多只有一个==<strong><font color='red'>最左边的孩子（长子）</font></strong>==和一个==<strong><font color='blue'>右邻的兄弟</font></strong>==。按照这种关系很自然地就能将树转换成相应的二叉树：</p><ol type="1"><li>在所有兄弟结点之间<strong>加一连线</strong></li><li>对每个结点，除了保留与其<strong>长子</strong>的连线外，去掉该结点与<strong>其它孩子节点</strong>的连线</li></ol><blockquote><p>注</p><ul><li>二叉树的<strong><font color='cyan'>左结点为儿子节点</font></strong>，<strong><font color='purple'>右结点为兄弟节点</font></strong></li><li>任何一棵==<strong><font color='red'>树</font></strong>==对应的<strong><font color='red'>二叉树</font></strong>，其==<strong><font color='blue'>右子树必定为空</font></strong>==</li></ul></blockquote><h3 id="树的遍历">树的遍历</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952797.png"alt="image-20221108225001648" /><figcaption aria-hidden="true">image-20221108225001648</figcaption></figure><blockquote><p>◆由于树中一个结点可以有两棵以上的子树，因此一般<strong><font color='red'>不讨论树的中序遍历</font></strong></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952916.png"alt="image-20221108225308793" /><figcaption aria-hidden="true">image-20221108225308793</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952127.png"alt="image-20221108225333415" /><figcaption aria-hidden="true">image-20221108225333415</figcaption></figure><blockquote><blockquote><ol type="1"><li>树的==<strong><font color='red'>先序遍历</font></strong>==与转化为二叉树的==<strong><font color='red'>先序遍历</font></strong>==相同</li><li>树的==<strong><font color='red'>后序遍历</font></strong>==与转化为二叉树的==<strong><font color='red'>中序遍历</font></strong>==相同</li><li>由于树中一个结点可以有两棵以上的子树，因此一般<strong><font color='red'>不讨论树的中序遍历</font></strong></li></ol></blockquote></blockquote><h3 id="例一">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952060.jpeg"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="例二">例二</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952136.png"alt="image-20221030194329120" /><figcaption aria-hidden="true">image-20221030194329120</figcaption></figure><h2 id="森林转化二叉树">森林转化二叉树</h2><h3 id="方法-1">方法</h3><ol type="1"><li>将森林中的每一棵<strong>树</strong>转化为<strong>二叉树</strong></li><li>将各二叉树的根节点视为兄弟结点连在一起</li><li>再将其转化为二叉树</li></ol><blockquote><p>注：</p><ol type="1"><li>任何一个==<strong>树或森林</strong>==可以唯一地对应到一棵<strong>二叉树</strong></li><li>任何一个==<strong>二叉树</strong>==可以唯一地对应到一棵<strong>树或森林</strong></li></ol></blockquote><h3 id="例一-1">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952176.png"alt="image-20221030194059329" /><figcaption aria-hidden="true">image-20221030194059329</figcaption></figure><h4 id="第一步">第一步</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952254.png"alt="image-20230924094405918" /><figcaption aria-hidden="true">image-20230924094405918</figcaption></figure><h4 id="第二步">第二步</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952755.png"alt="image-20230924094423337" /><figcaption aria-hidden="true">image-20230924094423337</figcaption></figure><blockquote><p>将==<strong>右边的一棵树</strong>==依次作为==<strong>左边那棵树</strong>==的<strong>右子树</strong>，最后得到的那<strong>1棵树</strong>即为森林对应的二叉树</p></blockquote><h4 id="第三步">第三步</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952695.png" alt="image-20230924094513604" style="zoom:33%;" /></p><h3 id="例二-1">例二</h3><p>​ 设森林 F中有三棵树，第一、第二、第三棵树的结点个数分别为M1、M2和M3。与森林 F对应的二叉树根结点的左子树上的节点个数为（），根结点的右子树上的结点个数是（)</p><p>A .M1 B .M1+M2 C . M3 D .M2+M3</p><p>E .M1-1 F: M2-1 G .M2 H .M3-1</p><blockquote><p>答案：==<strong>E D</strong>==</p></blockquote><blockquote><p>二叉树根节点<strong>右子树</strong>由森林<font color='red'><strong>除第一棵以外的</strong></font>==其他所有树==组成</p></blockquote><h3 id="例三">例三</h3><p>​ 设森林F对应的二叉树为 B ，它有 m 个结点，B的根为 p，p的右子树结点个数为 n，森林 F 中第一棵树的结点个数是（A） A.m-n B.m-n-1C:n+1 D.条件不足，无法确定</p><h1 id="二叉树的线索化">二叉树的线索化</h1><h2 id="方法-2">方法</h2><h3 id="头结点的设定">头结点的设定</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952955.png"alt="image-20220928190044829" /><figcaption aria-hidden="true">image-20220928190044829</figcaption></figure><h3 id="结点的设定">结点的设定</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952816.png"alt="image-20220928190232383" /><figcaption aria-hidden="true">image-20220928190232383</figcaption></figure><h2 id="例题-2">例题</h2><p>​已知二叉树的先序、中序和后序序列如下（其中有一些看不清的字母用*表示）：</p><p>前序序列：<code>*BC***G*</code> 中序序列：<code>CB*EAGH*</code>后序序列:<code>*EDB**FA</code></p><p>(1)请先补充<code>*</code>处的字母 (2)再构造一棵符合条件的二叉树(3)最后画出带头结点的中序线索链表。</p><h3 id="答案">答案</h3><p>前序：ABCDEFGH</p><p>后序：CBDEAGHF</p><p>后序：CEDBHGFA</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952200.png"alt="image-20220928191441993" /><figcaption aria-hidden="true">image-20220928191441993</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952307.png"alt="image-20220928191522050" /><figcaption aria-hidden="true">image-20220928191522050</figcaption></figure><blockquote><p>注：</p><ol type="1"><li>每个结点用<strong>5个域</strong>来表示</li><li>注意根节点<code>ltag=0;lright=1;</code></li><li><code>tag=1;</code>的指针指向前驱后继，用==<strong>带箭头的虚线</strong>==表示；</li><li><code>tag=0;</code>的指针指向左右孩子，用==<strong>不带箭头的实线</strong>==表示；</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀、中缀、后缀表达式</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%8D%E7%BC%80%EF%BC%8C%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%8D%E7%BC%80%EF%BC%8C%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概念">概念</h2><p>前缀表达式（波兰式），中缀表达式，后缀表达式（逆波兰式）</p><ul><li>区别在于<strong>运算符</strong>相对与<strong>操作数</strong>的位置不同：<ul><li>前缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之前</strong>；</li><li>中缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之间</strong>；</li><li>后缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之后</strong>；</li></ul></li><li>举例： (3 + 4) × 5 - 6 就是中缀表达式 - × + 3 4 5 6 前缀表达式 3 4 +5 × 6 - 后缀表达式</li></ul><span id="more"></span><h2 id="中缀表达式转后缀表达式">1、中缀表达式转后缀表达式：</h2><p>假定有中缀表达式A：1 + (( 2 + 3)* 4 ) –5，请将它转化为后缀表达式。</p><h3 id="方法一直接转换法">方法一：直接转换法</h3><p>（1）首先确定表达式表达式A的运算顺序，然后加括号：（（1 + (( 2 + 3)*4 )） – 5 ）</p><p>（2）从最里面的一层括号开始运算，转换成后缀表达式的方法为：（忽略括号）数字在前，符号在后。</p><p>​ 1）( 2 + 3) =&gt; 23+</p><p>​ 2) (( 2 + 3)* 4 ) =&gt; 23+4*</p><p>​ 3) （1 + (( 2 + 3)* 4 )）=&gt; 123+4*+[按照运算次序，从左到右排列]</p><p>​ 4）（（1 + (( 2 + 3)* 4 )） – 5 ）=&gt; 123+4*+ 5-</p><p>​ 后缀表达式为：12 3 + 4 * + 5 –</p><h3 id="方法二利用表达式树">方法二：利用表达式树</h3><p>​首先将中缀表达式转换为表达式树，然后<strong>后序遍历</strong>表达式树，所得结果就是后缀表达式。详细过程见<ahref="C:\Users\cuiluyi\Desktop\编程随想\DAG和二叉树描述表达式.md">DAG和二叉树描述表达式</a>如上述表达式的表达式树为：</p><blockquote><p><ahref="路径....................................">自定义名称</a>跳转文件，详细见<ahref="%5B(69条消息)%20Typora使用技巧%20%7C%20各种跳转%20【必备】_想要腹肌的熊的博客-CSDN博客_typora链接跳转到其他文件%5D(https://blog.csdn.net/qq_41907769/article/details/121722716)">Typora使用技巧| 各种跳转</a></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290925432.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="法三">法三</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290941178.png"alt="image-20230929094150044" /><figcaption aria-hidden="true">image-20230929094150044</figcaption></figure><blockquote><p>任意时刻<strong>栈顶的优先级</strong>都要<strong>大于</strong>其<strong><font color='red'>下面一个</font></strong>的优先级</p></blockquote><h4 id="例一">例一</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290942146.png"alt="image-20230929094204000" /><figcaption aria-hidden="true">image-20230929094204000</figcaption></figure><h4 id="例二">例二</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290942448.png"alt="image-20221103161920147" /><figcaption aria-hidden="true">image-20221103161920147</figcaption></figure><blockquote><p><strong><font color='red'>B</font></strong></p></blockquote><h2 id="中缀表达式转为前缀表达式">2、中缀表达式转为前缀表达式</h2><p>假定有中缀表达式1 + (( 2 + 3)* 4 ) – 5，请将它转化为前缀表达式。</p><p>### 方法一：直接转换法</p><p>（1）首先确定表达式表达式A的运算顺序，然后加括号：（（1 + (( 2 + 3)*4 )） – 5 ）</p><p>（2）从最里面的一层括号开始运算，转换成前缀表达式的方法为：（忽略括号）符号在前，数字在后。</p><p>​ 1）( 2 + 3) =&gt; +23</p><p>​ \2) (( 2 + 3)* 4 ) =&gt; *+234</p><p>​ \3) （1 + (( 2 + 3)* 4 )）=&gt; +1*+234</p><p>​ 4）（（1 + (( 2 + 3)* 4 )） – 5 ）=&gt; -+1*+2345</p><p>​ 前缀表达式为：-+1*+2345</p><h3 id="方法二利用表达式树-1">方法二：利用表达式树</h3><p>首先将中缀表达式转换为表达式树，然后先序遍历表达式树，所得结果就是前缀表达式。</p><p>将中缀表达式转化为表达式树的方法：表达式树的树叶是操作数，而其他节点为操作符，根结点为优先级最低且靠右的操作符（如上述表达式优先级最低是-和+，但-最靠右，所以根为-），圆括号不包括。</p><p>经过前序遍历所得前缀表达式为：- + 1 * + 2 3 4 5</p><h2 id="后缀表达式-转-中缀表达式">3、后缀表达式 转 中缀表达式</h2><p>假定有后缀表达式1 2 3 + 4 * +5 – ，请将它转化为前缀表达式。</p><p>### 方法一：利用表达式树：</p><p>​从左到右扫面后缀表达式，一次一个符号读入表达式。如果符号是操作数，那么就建立一个单节点树并将它推入栈中。如果符号是操作符，那么就从栈中弹出两个树T1和T2（T1先弹出）并形成一颗新的树，该树的根就是操作符，它的左、右儿子分别是T2和T1。然后将指向这棵新树的指针压入栈中。</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943091.png"alt="img" /> 扫描123后</p><p>前三个符号是操作数，因此创建三颗单节点树并将指向它们的指针压入栈中。</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943201.png"alt="img" /> 扫描+后</p><p>“+”被读入，因此指向最后两颗树的指针被弹出，形成一颗新树，并将指向新树的指针压入栈中。以下的流程图以相同原理执行。</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943954.png"alt="img" /> 扫描4和*后</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943074.png"alt="img" /> 扫描+和5后</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943478.png"alt="img" /> 扫描-后</p><p>最后再中序遍历所得的表达式树即得到我们所需的中缀表达式：1+（（2+3）*4）-5</p><h2 id="例题">例题</h2><h3 id="表达式转换">表达式转换</h3><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。</p><h3 id="输入格式">输入格式:</h3><p>输入在一行中给出不含空格的中缀表达式，可包含<code>+</code>、<code>-</code>、<code>*</code>、<code>\</code>以及左右括号<code>()</code>，表达式不超过20个字符。</p><h3 id="输出格式">输出格式:</h3><p>在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。</p><h3 id="输入样例">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2+3*(7-4)+8/4</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 7 4 - * + 8 4 / +</span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string c;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;p;</span><br><span class="line">p[<span class="string">&quot;+&quot;</span>]=<span class="number">1</span>;p[<span class="string">&quot;-&quot;</span>]=<span class="number">1</span>;p[<span class="string">&quot;*&quot;</span>]=<span class="number">2</span>;p[<span class="string">&quot;/&quot;</span>]=<span class="number">2</span>;p[<span class="string">&quot;(&quot;</span>]=<span class="number">3</span>;p[<span class="string">&quot;)&quot;</span>]=<span class="number">3</span>;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    vector&lt;string&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(c[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c[i]&lt;=<span class="string">&#x27;9&#x27;</span>||i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;(c[j]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c[j]&lt;=<span class="string">&#x27;9&#x27;</span>||c[j]==<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">j++;</span><br><span class="line">            l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i,j-i));    </span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;c[i+<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;c[j]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">j++;</span><br><span class="line">    l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i+<span class="number">2</span>,j-i<span class="number">-2</span>));</span><br><span class="line">    i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;c[i+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;c[j]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">j++;</span><br><span class="line">    l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i+<span class="number">1</span>,j-i<span class="number">-1</span>));</span><br><span class="line">    i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">stack&lt;string&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l[i]==<span class="string">&quot;+&quot;</span>||l[i]==<span class="string">&quot;-&quot;</span>||l[i]==<span class="string">&quot;*&quot;</span>||l[i]==<span class="string">&quot;/&quot;</span>||l[i]==<span class="string">&quot;(&quot;</span>||l[i]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||(p[l[i]]&gt;p[s.<span class="built_in">top</span>()]&amp;&amp;l[i]!=<span class="string">&quot;)&quot;</span>)||s.<span class="built_in">top</span>()==<span class="string">&quot;(&quot;</span>)</span><br><span class="line">s.<span class="built_in">push</span>(l[i]);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l[i]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">top</span>()!=<span class="string">&quot;(&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;p[l[i]]&lt;=p[s.<span class="built_in">top</span>()]&amp;&amp;s.<span class="built_in">top</span>()!=<span class="string">&quot;(&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">push</span>(l[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;cout&lt;&lt;(flag==<span class="number">0</span>?<span class="string">&quot;&quot;</span>:<span class="string">&quot; &quot;</span>)&lt;&lt;l[i];flag=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="时间空间复杂度">时间空间复杂度</h1><h2 id="例一">例一</h2><p>设 <em>n</em>是描述问题规模的非负整数，下列程序段的时间复杂度是：<strong><font color='red'>C</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( n &gt;= (x+<span class="number">1</span>)*(x+<span class="number">1</span>) )</span><br><span class="line">    x = x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>A. <em>O</em>(<em>n</em>2)</p><p>B. <em>O</em>(<em>n</em>)</p><p>C. <em>O</em>(n<sup>1/2</sup>)</p><p>D. <em>O</em>(logn) <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914207.png"alt="image-20221019111453276" /></p><span id="more"></span><h2 id="例二">例二</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914217.png" alt="image-20221019111930977" style="zoom:80%;" /></p><h2 id="例三">例三</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914238.png"alt="image-20221019111828861" /><figcaption aria-hidden="true">image-20221019111828861</figcaption></figure><h2 id="例四">例四</h2><p>设n nn是描述问题规模的非负整数，下面程序片段的时间复杂度是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">2</span>；</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">x=<span class="number">2</span>*x;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914208.png" alt="image-20221104182829170" style="zoom: 50%;" /></p><h2 id="例五">例五</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914201.png" alt="image-20221104182958557" style="zoom:150%;" /></p><h2 id="例六">例六</h2><p>下列函数的时间复杂度是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span> <span class="params">( <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sum&lt; n) sum += ++ i;</span><br><span class="line"><span class="keyword">return</span> i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914190.png"alt="image-20221104183451111" /><figcaption aria-hidden="true">image-20221104183451111</figcaption></figure><p><strong><code>B</code></strong></p><h1 id="存储密度">存储密度</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914686.png" alt="image-20221016175203394" style="zoom:150%;" /></p><h2 id="解析">解析</h2><h3 id="数据逻辑结构">数据逻辑结构</h3><p>1.<strong>集合结构</strong>:数据元素之间没有任何关系.</p><p>2.<strong>线性结构</strong>:数据元素之间定义了线性关系.1对1</p><p>3.<strong>树形结构</strong>:数据元素之间定义了层次关系 1对多.</p><p>4.<strong>图状结构</strong>:数据元素之间定义了网状关系 多对多.</p><h3 id="数据存储物理结构">数据存储/物理结构</h3><ol type="1"><li><p><strong>顺序存储结构</strong>:借助数据元素之间的相对位置来表示元素之间的逻辑结构.（vector动态数组、deque双端队列、stack栈容器、queue队列容器）</p></li><li><p><strong>链式存储结构</strong>:借助数据元素之间的元素的指针表示数组元素的逻辑结构.</p></li><li><p><strong>散列存储结构</strong>:顺序存储+算列.</p></li><li><p><strong>索引存储结构</strong>:顺序存储+索引.</p></li></ol><blockquote><p><strong>数据逻辑结构在计算机存储器中的表示称为数据的<ahref="https://so.csdn.net/so/search?q=存储结构&amp;spm=1001.2101.3001.7020">存储结构</a></strong>（或存储表示），也称为<strong>物理结构</strong>。</p></blockquote><h3 id="存储密度-1">存储密度</h3><h4 id="定义">定义：</h4><pre><code>存储密度 = &lt;u&gt;结点&lt;/u&gt;**数据**本身所占存储量 / &lt;u&gt;结点&lt;/u&gt;**结构**所占的存储量</code></pre><ul><li>结构数据本身所占存储量 = 数据域所占存储量</li><li>结点结构所占的存储总量 = （数据域+结点域）所占存储量</li><li>注：指针存储量与机器位数有关，如32位机指针大小为32bit，4Byte</li></ul><h4 id="注意">注意：</h4><ol type="1"><li><p>==<strong>顺序表</strong>==的存储密度等于1</p></li><li><p>假设单链表的结点的<strong>数据域</strong>占的存储量为N，结点的<strong>指针域</strong>所占的存储量为M，则存储密度= N / (N+M)，所以<strong>单链表的密度是小于1</strong>的。</p></li></ol><h4 id="举例">举例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">chainList</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chainList</span> *next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>该链表的</p><ul><li><p>结构数据本身所占存储量 = sizeof(int) = 2</p></li><li><p>结点结构所占的存储总量 = 8(64位机)+2</p></li><li><p>存储密度 = 20%</p></li></ul><h1 id="最小生成树">最小生成树</h1><p>对某个带权连通图构造最小生成树，以下说法中正确的是（ ）。</p><p>Ⅰ.该图的所有最小生成树的总代价一定是唯一的</p><p>Ⅱ.其<strong><font color='red'>所有</font></strong>权值<strong><font color='red'>最小的</font></strong>边一定会出现在所有的最小生成树中</p><p>Ⅲ.用普里姆（Prim）算法从不同顶点开始构造的所有最小生成树<strong><font color='red'>一定相同</font></strong></p><p>Ⅳ.使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树<font color='red'><strong>总不相同</strong></font></p><ol type="A"><li>仅Ⅰ、Ⅲ</li></ol><p>==<strong>B. 仅Ⅰ</strong>==</p><ol start="3" type="A"><li><p>仅Ⅱ</p></li><li><p>仅Ⅱ、Ⅳ</p></li></ol><blockquote><p>A：由一个<strong>带权连通图</strong>构造的最小生成树可能有多棵，但其代价一定是唯一的；</p><p>B：<strong><font color='red'>权值最小的边可能不止一条</font></strong>，这些不唯一的最小权值边<strong><font color='blue'>不一定都会</font></strong>出现在所有的最小生成树中，但至少会有一条权值最小的边出现在MBT中（根据Kruskal算法至少会有一条，多条可能导致<strong>内部联通</strong>）</p><p>C：当存在<strong><font color='blue'>多条权值相同的边</font></strong>时，用普里姆（Prim）算法从不同顶点开始得到的最小生成树不一定相同（不唯一）；</p><p>D：使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树不一定总不相同</p><ul><li>若图中<strong><font color='red'>最小生成树唯一时</font>，==无论用哪种算法==，得到的最小生成树都是相同的</strong>。</li><li>若图中<strong><font color='red'>最小生成树不唯一时</font>，prim和Kruskal算法得到的最小生成树并不总是相同</strong>。</li></ul></blockquote><h1 id="数据基本概念">数据基本概念</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914908.png"alt="image-20221104184520267" /><figcaption aria-hidden="true">image-20221104184520267</figcaption></figure><blockquote><p>数据元素是数据的==<strong><font color='red'>基本（最小）单位</font></strong>==</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914913.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914895.png"alt="image-20221109214634474" /><figcaption aria-hidden="true">image-20221109214634474</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914037.png"alt="image-20221109214836979" /><figcaption aria-hidden="true">image-20221109214836979</figcaption></figure><blockquote><p>DFS/BFS：邻接矩阵O（n<sup>2</sup>） 邻接表O（n+e）</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914968.png"alt="image-20221110140604533" /><figcaption aria-hidden="true">image-20221110140604533</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树结点的计算问题</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="树结点的计算问题">树结点的计算问题</h1><h2 id="完全二叉树">完全二叉树</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405241028130.png"alt="image-20240524102812052" /><figcaption aria-hidden="true">image-20240524102812052</figcaption></figure><h3 id="分析">分析</h3><p>设叶子节点个数为 <span class="math inline">\(n_0\)</span>，度为 <spanclass="math inline">\(1\)</span> 的节点个数为 <spanclass="math inline">\(n_1\)</span>，度为 <spanclass="math inline">\(2\)</span> 的节点个数为 <spanclass="math inline">\(n_2\)</span>，则：</p><p><span class="math display">\[\left. \begin{array}{r}    n_0+n_1+n_2=n\\    n_0=n_2+1\\\end{array} \right\} \Longrightarrow n_0=\frac{n+1-n_1}{2}\]</span></p><h3 id="总结">总结</h3><p>由<strong><font color='red'>完全二叉树的性质可知：<spanclass="math inline">\(n_1\)</span>=0 或 1</font></strong></p><ol type="1"><li><p>当 <span class="math inline">\(n_1=0\)</span> 或 <strong><spanclass="math inline">\(n\)</span>为奇数</strong> 时，<spanclass="math inline">\(n_0= (n+1)/2\)</span></p></li><li><p>当 <span class="math inline">\(n_1=1\)</span> 或 <strong><spanclass="math inline">\(n\)</span>为偶数</strong> 时，<spanclass="math inline">\(n_0= n/2\)</span></p></li></ol><p>综合1，2可得：</p><p>​ 一个具有 <span class="math inline">\(n\)</span>个节点的<strong>完全二叉树</strong>，其<strong>叶子节点的个数</strong><span class="math inline">\(n_0=\lceil \frac{n}{2} \rceil\)</span></p><hr /><h3 id="例题">例题</h3><h4 id="例1">例1</h4><p>设一棵完全二叉树共有699个节点，则在该二叉树中的叶节点数为？</p><p><span class="math inline">\(n_0=\lceil \frac{n}{2}\rceil=350\)</span></p><hr /><h4 id="例2">例2</h4><p>一棵完全二叉树<u>第六层有</u> 8个叶结点（根为第一层），则结点个数<u>最多有</u>（）个。</p><p><strong>【分析】</strong></p><ol type="1"><li><strong>二叉树第 <span class="math inline">\(k\)</span> 层最多有<span class="math inline">\(2^{k-1}\)</span> 个节点</strong></li></ol><p>​ 第一层最多有1个节点</p><p>​ 第二层最多有2个节点</p><p>​ 第三层最多有4个节点</p><p>​ 第四层最多有8个节点</p><p>​ 第五层最多有16个节点</p><p>​ 第六层最多有32个节点</p><ol start="2" type="1"><li><p><strong>完全二叉树的<font color='red'>叶节点只可能出现在后 2层</font></strong>，<strong>除最后一层可能不满，其余层均满</strong></p><p>第六层有 8（<spanclass="math inline">\(&lt;2^{6-1}=32\)</span>）个叶结点，说明<strong>第六层</strong>是完全二叉树的<strong>最后两层</strong>之一</p></li></ol><ul><li><p>==<strong>如果完全二叉树有 6 层</strong>==，则前 5层是满二叉树，总节点数 <spanclass="math inline">\(n=(2^5-1)+8=39\)</span></p></li><li><p>如果完全二叉树有 7 层，则</p><ul><li><p>前 6 层是满二叉树，前 6 层总节点数目为 <spanclass="math inline">\(2^6-1=63\)</span></p></li><li><p>第 6 层有 8 个叶子节点，则有 <spanclass="math inline">\(32-8=24\)</span> 个非叶子节点</p></li><li><p>第七层最多有 <span class="math inline">\(24 \times2=48\)</span>个叶子节点，最少有 47 个叶子节点</p></li></ul><p>故总节点数目为 <spanclass="math inline">\(63+48=111\)</span>​</p></li></ul><h4 id="例3">例3</h4><p>如果一个完全二叉树最底下一层为第六层（根为第一层）且该层共有 8个叶结点，那么该完全二叉树共有多少个结点? <span class="math display">\[\left( 2^5-1 \right) +8=39\]</span></p><h2 id="平衡二叉树avl">平衡二叉树AVL</h2><p>设 <span class="math inline">\(N_h\)</span> 表示 <spanclass="math inline">\(h\)</span> 层 <strong><spanclass="math inline">\(AVL\)</span>树</strong>的<strong>最少</strong>节点数，则存在以下规律： <spanclass="math display">\[\begin{cases}    N_h=N_{h-1}+N_{h-2}+1\\    \\    N_1=1,N_2=2\\\end{cases}\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202407021945798.png"alt="image-20221025134419965" /></p><p>【单选】若一AVL树的结点数是21，则该树的高度至多是多少?（注:只有一个根节点的树高度为0 ）</p><blockquote><p>答案：5 <strong><code>1 2 4 7 12 20 33</code></strong></p><p>21个结点达到了5层所需的最小结点数，但没有达到6层所需的最小结点数</p></blockquote><h2 id="树的结点问题">树的结点问题</h2><h3 id="例1-1">例1</h3><p>​ 已知在一棵度为 4 的树T中，若有 20 个度为 4 的结点，10 个度为 3的结点，1 个度为 2 的结点，10 个度为 1 的结点，则树 T的叶子结点的个数为？</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919578.jpg" alt="daf0765aa213be23c7bff6d820e6c92" style="zoom: 15%;" /></p><blockquote><p>注：==<strong>若树的节点数为 n，则边数为 <spanclass="math inline">\(n-1\)</span></strong>==</p></blockquote><h3 id="例2-1">例2</h3><p>一棵度为 3 的树中，有 3 度的结点 100 个，有 2 度的结点 200个，有叶子结点多少个？</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290921109.png" alt="image-20221002222557971" style="zoom: 13%;" /></p><h3 id="例3-1">例3</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919580.jpg"alt="6eb138545a60b02c6aace0b7aa36ab2" /><figcaptionaria-hidden="true">6eb138545a60b02c6aace0b7aa36ab2</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919581.jpg"alt="a07999b6a7af0f1122d73a179281c15" /><figcaptionaria-hidden="true">a07999b6a7af0f1122d73a179281c15</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405241023924.png"alt="image-20240524102333796" /><figcaption aria-hidden="true">image-20240524102333796</figcaption></figure><h2 id="树的种数">树的种数</h2><h3 id="例1-2">例1</h3><p>按照二叉树的定义，具有 <span class="math inline">\(3\)</span>个结点的二又树有多少种？</p><span id="more"></span><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291053249.png" alt="image-20230929105310153" style="zoom: 25%;" /></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DAG、BT描述表达式</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DAG%E3%80%81BT%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DAG%E3%80%81BT%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式二叉树">表达式二叉树</h1><h2 id="介绍">介绍</h2><p>用二叉树来表示一个简单算术表达式，树的每一个结点包括一个<strong>运算符</strong>/<strong>运算数</strong></p><h2 id="步骤">步骤</h2><p>把<strong><font color='red'>操作数作为叶结点</font></strong>，<strong><font color='blue'>操作符作为非叶节点</font></strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847728.png"alt="image-20221101205736696" /><figcaption aria-hidden="true">image-20221101205736696</figcaption></figure><p>表达式二叉树</p><ul><li><strong><font color='orange'>叶结点的个数</font></strong>即为<strong><font color='red'>操作数的个数</font><font color='cyan'>（可以重复）</font></strong></li><li><strong><font color='orange'>非叶结点的个数</font></strong>即为<strong><font color='red'>操作符的个数</font><font color='cyan'>（可以重复）</font></strong></li><li><strong><font color='green'>结点个数 = 操作数的个数 +操作符的个数</font></strong></li></ul><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847729.png"alt="image-20221101210106099" /><figcaption aria-hidden="true">image-20221101210106099</figcaption></figure><blockquote><ol type="1"><li>表达式二叉树的<strong><font color='red'>前序遍历</font></strong>序列和<strong><font color='red'>后序遍历</font></strong>序列即为相应的<strong><font color='blue'>前缀表达式</font></strong>和<strong><font color='blue'>后缀表达式</font></strong></li><li>表达式二叉树的<strong><font color='red'>中序遍历</font></strong>序列与中缀表达式有可能不符合【因为中序表达式可能需要括号，但是表达式二叉树将括号去掉了，前序/后续表达式不存在括号】</li></ol></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847730.jpg"alt="821ba35825723c1d45f5ee6ca406d33" /><figcaptionaria-hidden="true">821ba35825723c1d45f5ee6ca406d33</figcaption></figure><ul><li><h2 id="解答-b">解答 <font color='red'>B</font></h2></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847732.jpg"alt="13312021776171515" /><figcaption aria-hidden="true">13312021776171515</figcaption></figure><h1id="有向无环图描述表达式"><font color='purple'>有向</font>无环图描述表达式</h1><h2 id="步骤-1">步骤</h2><ol type="1"><li>把各个<strong>操作数<font color='red'>不重复地</font></strong>排成一排</li><li>标出各个运算符的<strong><font color='blue'>生效顺序</font></strong>（先算左边括号或者先算右边括号均可以）</li><li>==<strong>按运算先后顺序加入运算符</strong>==，不同的运算级别层次不同，过程中如果已经存在某部分，则直接用</li><li>最后生成的图就是有向无环图</li></ol><blockquote><ol type="1"><li><strong>用有向无环图表示表达式的目的就是<font color='red'>去掉相同的部分</font>，压缩存储，节省空间</strong></li><li>DAG中==<strong>顶点的个数</strong>即为<strong><font color='gree'>运算符号个数（无重复）</font></strong>和<strong><font color='cyan'>运算数个数（无重复）</font></strong>之和==</li></ol></blockquote><h2 id="例题">例题</h2><h3 id="例1">例1</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847733.png"alt="image-20221101203825317" /><figcaption aria-hidden="true">image-20221101203825317</figcaption></figure><blockquote><p>注意：<strong><code>( x + y )( ( x + y ) / x )</code><font color='red'>省略了一个<code>*</code></font></strong></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160848334.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="例2">例2</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847734.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法与MST</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><spanclass="math display">\[Dijkstra\]</span>最短路径算法构造的生成树是否一定为最小生成树？问题描述：一连通无向图,边为非负权值，问用<spanclass="math display">\[Dijkstra\]</span>最短路径算法能否给出一棵生成树，这树是否一定为最小生成树？说明理由。</p><span id="more"></span><blockquote><p>​ 解答:<spanclass="math display">\[Dijkstra\]</span>最短路径算法能够给出一棵生成树,但该树不一定为最小生成树。虽然<spanclass="math display">\[Dijkstra\]</span>算法和<spanclass="math display">\[Prim\]</span>算法的思路与步骤较为相似，但两者的更新算法不一致，而其余部分完全一致。</p></blockquote><ol type="1"><li><span class="math display">\[Dijkstra\]</span>算法对应的<spanclass="math display">\[Min\]</span>更新算法为:</li></ol><p><span class="math display">\[if(Min[j] &gt; Min[k] + G[k][j])\\Min[j] = Min[k] + G[k][j];\]</span></p><ol start="2" type="1"><li>而<span class="math display">\[Prim\]</span>算法对应的<spanclass="math display">\[Min\]</span>更新算法为:</li></ol><p><span class="math display">\[if(Min[j] &gt; G[k][j])\\Min[j] = G[k][j]\]</span></p><ol start="3" type="1"><li>为此，可考虑以下的反例：对于以下的带权连通无向图</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849744.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ul><li>用<spanclass="math display">\[Prim\]</span>算法构造的一棵最小生成树为:</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849802.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ul><li>而用<spanclass="math display">\[Dijkstra\]</span>算法构造的一棵生成树为:</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849648.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>​ 其中，<spanclass="math display">\[Dijkstra\]</span>算法的执行过程中，从<spanclass="math display">\[v1\]</span>到<spanclass="math display">\[v3\]</span>的最短路径选择的是<spanclass="math display">\[v1-&gt;v3\]</span>，而不是<spanclass="math display">\[v1-&gt;v4-&gt;v3\]</span>，原因是<spanclass="math display">\[Min[3]=Min[4]+G[4][3]\]</span>，即<spanclass="math display">\[v1\]</span>到<spanclass="math display">\[v3\]</span>的初始最短距离与<spanclass="math display">\[v1\]</span>到<spanclass="math display">\[v4\]</span>的最短路径加上<spanclass="math display">\[v4\]</span>到<spanclass="math display">\[v3\]</span>的距离相等，因此在更新过程中保留<spanclass="math display">\[v1-&gt;v3\]</span>的最短路径为<spanclass="math display">\[v1-&gt;v3\]</span>而非<spanclass="math display">\[v1-&gt;v4-&gt;v3\]</span>，所以最后，构造的生成树的边权值之和为<spanclass="math display">\[1+4+6=11\]</span>，远大于用<spanclass="math display">\[Prim\]</span>算法构造的最小生成树边权值之和<spanclass="math display">\[1+2+4=7\]</span>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
