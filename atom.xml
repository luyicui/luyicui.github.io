<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天道酬勤，厚德载物</title>
  
  
  <link href="https://cuiluyi.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cuiluyi.gitee.io/"/>
  <updated>2024-05-04T00:57:18.788Z</updated>
  <id>https://cuiluyi.gitee.io/</id>
  
  <author>
    <name>银杏枫树</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C++标准库函数】</title>
    <link href="https://cuiluyi.gitee.io/2024/04/27/[object%20Object]/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/04/27/[object%20Object]/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/</id>
    <published>2024-04-27T05:59:27.000Z</published>
    <updated>2024-05-04T00:57:18.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c标准库函数">C++标准库函数</h1><h2 id="lower_bound-upper_bound">lower_bound &amp;&amp; upper_bound</h2><h3 id="头文件">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用">作用</h3><ul><li><p>在一个<strong>排好序的数组</strong>中进行<strong>二分查找</strong></p></li><li><p><strong>基于二分查找！数组或容器必须有序！</strong></p></li></ul><h3 id="用法">用法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142542.png"alt="image-20240331214206385" /><figcaption aria-hidden="true">image-20240331214206385</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142606.png"alt="image-20240331214221383" /><figcaption aria-hidden="true">image-20240331214221383</figcaption></figure><span id="more"></span><h3 id="举例">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数组，假设已经从小到大排序</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 最后一个小于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 最后一个小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 没有小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 最后一个小于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p2 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 最后一个小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 没有小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第一个大于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p3 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p3 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 第一个大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 没有大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第一个大于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p4 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p4 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p4 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 没有大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">7</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">7</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">2.</span> 没有小于等于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">10</span> 的元素</span><br><span class="line"><span class="number">4.</span> 没有大于等于 <span class="number">10</span> 的元素</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">1</span> 的元素</span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">1</span> 的元素是: <span class="number">3</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">9</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">9</span> 的元素</span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="nth_element">nth_element</h2><h3 id="头文件-1">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="原型">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序规则采用默认的升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//排序规则为自定义的 comp 排序规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>first</code> 、 <code>last</code>为<strong>迭代器/指针</strong>，用于指定该函数的作用范围<code>[first, last)</code></li><li><code>nth</code>：也为<strong>迭代器/指针</strong>，其功能是令函数查找“<strong>第nth 小</strong>”的元素，并将其移动到 <code>nth</code> 指向的位置</li><li><code>comp</code>：用于<strong>自定义排序规则</strong></li></ul><blockquote><p><code>comp</code> 是可选参数，默认是求第 <spanclass="math inline">\(k\)</span> 小</p></blockquote><p><strong>返回值：</strong></p><ul><li>无</li></ul><h3 id="作用-1">作用</h3><ul><li>将数组中<strong>第 <span class="math inline">\(k\)</span>小</strong>的数 放在 <code>nth</code> 指向的位置</li><li>函数执行后， <code>nth</code>指向的元素将处于正确位置，其他位置元素顺序相较于初始顺序会被<strong>打乱</strong>，但前面的都比它小，后面的都比它大</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li></ul><h3 id="举例-1">举例</h3><h4 id="求第k小">求第k小</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> </span><br></pre></td></tr></table></figure><h4 id="求第k大">求第k大</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n, [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><h2 id="max_elementmin_element">max_element、min_element</h2><h3 id="头文件-2">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-2">作用</h3><p><strong>1. 求数组的最大值或最小值</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a, a + <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a, a + <span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//获取最大值</span></span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//获取最小值</span></span><br></pre></td></tr></table></figure><!--more--><p><strong>2. 求数组最大值最小值对应的下标</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a, a + <span class="number">8</span>) - a; </span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a, a + <span class="number">8</span>) - a;</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); <span class="comment">//获取最大值对应的下标</span></span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();<span class="comment">//获取最小值对应的下标</span></span><br></pre></td></tr></table></figure><h2 id="fill">fill</h2><h3 id="头文件-3">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-3">作用</h3><p><ahref="https://blog.csdn.net/liu16659/article/details/87152348?ops_request_misc=%7B%22request%5Fid%22%3A%22167715751316800188555444%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167715751316800188555444&amp;biz_id=0&amp;spm=1018.2226.3001.4187">(96条消息)C++ 中 fill() 的使用_LawsonAbs的博客-CSDN博客_c++ fill</a></p><h2 id="memset">memset</h2><h3 id="头文件-4">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型-1">原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, Byte c, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>s：为指针或是数组</li><li>c：是赋给 s 的值</li><li>count：是 s 的长度</li></ul><p>返回值</p><ul><li>指向存储区 s 的指针。</li></ul><h3 id="作用-4">作用</h3><p>​ memset是按照 c 的值（看作字节），按<strong>字节</strong>将 s赋值，因此我们最常见的就是</p><ul><li>将每一字节赋值全 0 ，整体就是 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><ul><li>将每一字节赋值全 1 ，整体就是 -1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">-1</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p>注意：-1 = 0XFF</p></blockquote><ul><li>将每一个字节赋值 0x3f，整体就是 INF【<strong>正无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/qq_42386788/article/details/116427457">关于memset函数和赋值0x3f</a></p></blockquote><ul><li>将每一个字节赋值 0xbf，整体就是 INF【<strong>正无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0xbf</span>, <span class="built_in">sizeof</span>(s))</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><p>memset可以方便的==<strong>清空</strong>或初始化一个<strong>数组</strong>。==</p><h3 id="举例-2">举例</h3><ol type="1"><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/weixin_44162361/article/details/115790452?ops_request_misc=%7B%22request%5Fid%22%3A%22169735623116800180650624%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169735623116800180650624&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115790452-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=memset&amp;spm=1018.2226.3001.4187">memset的用法详解_薛定谔的猫ovo的博客-CSDN博客</a></p></blockquote><h2 id="memcmp">memcmp</h2><h3 id="头文件-5">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="基本原型">基本原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf1, <span class="type">const</span> <span class="type">void</span> *buf2, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong></p><ul><li><p>当 buf1&lt;buf2 时，返回值&lt;0</p></li><li><p>当 buf1=buf2 时，返回值=0</p></li><li><p>当 buf1&gt;buf2 时，返回值&gt;0</p></li></ul><h3 id="作用-5">作用</h3><p>memcmp 是比较内存区域 buf1 和 buf2 的前 count个字节。该函数是按字节比较的</p><h3 id="举例-3">举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">r = <span class="built_in">memcmp</span>(&amp;s1,&amp;s2,<span class="built_in">strlen</span>(s1));</span><br><span class="line"><span class="keyword">if</span>(!r)<span class="comment">//！r 非零返回的是 1  这个是非运算，计算机是二进制的，不是零就是一了 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 and s2 are identical\n&quot;</span>);<span class="comment">/*s1等于s2*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);<span class="comment">/*s1小于s2*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);<span class="comment">/*s1大于s2*/</span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,!r); //输出是一， </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,r);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明-1">说明</h3><ol type="1"><li>该函数是按字节比较的：当s1,s2为字符串时</li></ol><ul><li><p><code>memcmp(s1,s2,1)</code>就是比较s1和s2的第一个字节的ascII码值；</p></li><li><p><code>memcmp(s1,s2,n)</code>就是比较s1和s2的前n个字节的ascII码值；</p><p>例如:</p></li></ul><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> *s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *s2=<span class="string">&quot;acd&quot;</span>;</span><br><span class="line">&gt;<span class="type">int</span> r=<span class="built_in">memcmp</span>(s1,s2,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>​比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了所以<spanclass="math display">\[r=-1\]</span>.</p></blockquote><ol start="2" type="1"><li><p>对于<code>memcmp()</code>，如果两个字符串相同而且<code>count</code>大于字符串长度的话，<code>memcmp</code>不会在<code>\0</code>处停下来，会继续比较<code>\0</code>后面的内存单元，直到<code>_res</code>不为零或者达到<code>count</code>次数。</p><p>例如：</p></li></ol><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> a1[]=<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">  <span class="type">char</span> a2[]=<span class="string">&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure></p><p>对于<code>memcmp(a1,a2,10)</code>，<code>memcmp</code>在两个字符串的<code>\0</code>之后继续比较。所以，如果想使用memcmp比较字符串，要保证count不能超过最短字符串的长度，否则结果有可能是错误的。</p></blockquote><h2 id="memcpy">memcpy</h2><h3 id="头文件-6">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="声明">声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>str1</strong> --指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li><li><strong>str2</strong> -- 指向要复制的数据源，类型强制转换为 void*指针。</li><li><strong>n</strong> -- 要被复制的字节数。</li></ul><p><strong>返回值：</strong></p><ul><li>该函数返回一个指向目标存储区 str1 的指针。</li></ul><h3 id="作用-6">作用</h3><p>​ 从存储区 <strong>str2</strong> 复制 <strong>n</strong>个字节到存储区 <strong>str1</strong></p><h3 id="实例">实例</h3><ul><li>将字符串复制到数组 dest 中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="keyword">sizeof</span> src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest = http://www.runoob.com</span><br></pre></td></tr></table></figure><ul><li>将 s 中第 11 个字符开始的 6个连续字符复制到 d 中：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(d, s + <span class="number">11</span>, <span class="number">6</span>); <span class="comment">// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob)</span></span><br><span class="line">    <span class="comment">// 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));</span></span><br><span class="line">    d[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob</span><br></pre></td></tr></table></figure><ul><li>覆盖原有部分数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;***&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 前: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 后: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 memcpy 前: abcdefg</span><br><span class="line">使用 memcpy 后: ***defg</span><br></pre></td></tr></table></figure><h2 id="strcmp">strcmp</h2><h3 id="头文件-7">头文件</h3><p><code>#include &lt;cstring&gt;</code></p><h3 id="作用-7">作用</h3><p>​ 比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较</p><h3 id="原型-2">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>第一个字符串大于第二个字符串，则返回大于 0 的数字</li><li>第一个字符串<font color='red'><strong>等于</strong></font>第二个字符串，则返回<font color='red'><strong>0</strong></font></li><li>第一个字符串小于第二个字符串，则返回小于 0 的数字</li></ul><h3 id="举例-4">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> p1[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p2[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p3[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">char</span> p4[] = <span class="string">&quot;bcdeffasd&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1, p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1, p3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p3, p4));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p3, <span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="new">new</h2><h3 id="作用-8">作用</h3><p><code>new()</code>使计算机开辟一块内存空间，并返回<strong>内存空间的首地址</strong></p><h3 id="格式">格式</h3><ol type="1"><li><p>使用new函数创建变量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType;</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建变量并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> <span class="built_in">ElementType</span>(val);</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size];</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size]&#123;&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="说明-2">说明</h3><ol type="1"><li>new开辟的空间在堆上，而一般声明的变量存放在栈上</li><li><strong><font color='red'>通常用new函数代替malloc函数</font></strong></li><li>new不需要头文件</li><li>使用 new 函数之后要<strong><font color='red'>使用 delete函数释放内存空间</font></strong></li></ol><h3 id="举例-5">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">example1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 可以在new后面直接赋值 */</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以单独赋值 */</span></span><br><span class="line">    <span class="comment">// int *p = new int;</span></span><br><span class="line">    <span class="comment">// *p = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">example2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 用new创建数组 */</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">/* 也可以依次赋值 */</span></span><br><span class="line">    <span class="comment">// int *q = new int[3];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        q[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *st = <span class="keyword">new</span> <span class="built_in">student</span>(&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *stlist = <span class="keyword">new</span> student[<span class="number">3</span>]&#123;&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;bac&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="string">&quot;ccd&quot;</span>, <span class="number">93</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> e1 = <span class="built_in">example1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e1: &quot;</span> &lt;&lt; e1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *e2 = <span class="built_in">example2</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; e2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st1 = <span class="built_in">example3</span>();</span><br><span class="line">    cout &lt;&lt; st1-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st1-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st2 = <span class="built_in">example4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; st2[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st2[i].score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e1: 3</span><br><span class="line">0 1 2</span><br><span class="line">abc 90</span><br><span class="line">abc 90</span><br><span class="line">bac 78</span><br><span class="line">ccd 93</span><br></pre></td></tr></table></figure><h2 id="swap">swap</h2><h3 id="作用-9">作用</h3><p><strong><code>swap(a,b);</code></strong>交换两个变量<strong><code>a,b</code></strong>的值</p><blockquote><p><strong><code>a,b</code></strong>可以是<strong><font color='red'>任何数据类型</font></strong></p></blockquote><h3 id="原型-3">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ElementType &amp;a, ElementType &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="举例-6">举例</h3><h4 id="例一">例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="例二">例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;ABCD&quot;</span>;     string b = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ABCD</span><br></pre></td></tr></table></figure><h2 id="log">log</h2><h3 id="头文件-8">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-4">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">log</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="作用-10">作用</h2><p>返回以 <span class="math inline">\(e\)</span> 为底数的对数 <spanclass="math inline">\(lnx\)</span></p><h2 id="应用">应用</h2><ul><li>计算 <span class="math inline">\(\log _ab\)</span></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> res = <span class="built_in">log</span>(b) / <span class="built_in">log</span>(a);</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">log</span>(b) / <span class="built_in">log</span>(a);<span class="comment">// C++ 默认是下取整</span></span><br></pre></td></tr></table></figure><h2 id="absfabs">abs/fabs</h2><h3 id="头文件-9">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-5">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span></span><br></pre></td></tr></table></figure><h3 id="作用-11">作用</h3><ul><li><code>abs</code> 是对<strong>整数</strong>取绝对值</li><li><code>fabs</code> 是对<strong>浮点数</strong>取绝对值</li></ul><h2 id="sqrt">sqrt</h2><h3 id="头文件-10">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-6">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-12">作用</h3><p><code>sqrt()</code> 用来求给定值的平方根</p><h3 id="常见错误">常见错误</h3><ol type="1"><li><strong>输出 36的开根号</strong></li></ol><ul><li><strong>错误写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152182.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><blockquote><p>忽略了sqrt()函数的返回值是 double型。导致出错</p></blockquote></blockquote><ul><li><strong>正确写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152197.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>常见的使用sqrt()函数的规范写法</strong> 例如:我们要判断一个数是不是质数，只需要判断 2 ~ n开根号之间有没有可以整除的数就可以了</p><ul><li><strong>错误写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，其实并不推荐这样写。虽然我也经常这样写。但是在一次做题的过程中，就因为这样写程序出现了bug。我就改用下面的这种稳妥的写法了</p><ul><li><strong>正确写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.0*n的目的是——隐式转换成浮点数，开根号后再强制转换成整型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span> * n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse">reverse</h2><h3 id="头文件-11">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-13">作用</h3><p>反转在<strong><font color='red'> [ first,last )</font></strong>范围内的顺序（包括first指向的元素，不包括last指向的元素）</p><h3 id="原型-7">原型</h3><p><strong><code>void reverse (BidirectionalIterator first,BidirectionalIterator last);</code></strong></p><ul><li>参数first：待排区域的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排区域的<strong><font color='blue'>末尾地址</font></strong></li></ul><h3 id="举例-7">举例</h3><ul><li>反转<strong>向量</strong><font color='blue'><strong>vector</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//v的值为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><ul><li>反转数组<strong><code>ElementType A[]</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[]=&#123;<span class="number">12</span>,<span class="number">-5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(A, A+<span class="number">6</span>);<span class="comment">//数组A为19,1,7,0,-5,12</span></span><br></pre></td></tr></table></figure><ul><li>反转<strong>字符串<font color='blue'>string</font></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;www.mathor.top&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//str结果为pot.rohtam.wwww</span></span><br></pre></td></tr></table></figure><h3 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="sort">sort</h2><h3 id="头文件-12">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-14">作用</h3><p>对==<strong><font color='red'>数组排序</font></strong>==</p><blockquote><ul><li>数组可以是<strong><code>ElementType A[]</code></strong>，也可以是<strong><code>vector &lt;ElementType&gt; A</code></strong><ul><li><strong><code>ElementType A[]</code></strong>：<strong><code>A</code></strong>表示<strong><font color='blue'>数组首地址</font></strong>，<strong><code>A+n</code></strong>表示<strong><font color='blue'>数组尾部</font></strong></li><li><strong><code>vector &lt;ElementType&gt; A</code></strong>：<strong><code>A.begin()</code></strong>和<strong><code>A.end()</code></strong>表示<strong><font color='blue'>头尾</font></strong></li></ul></li></ul></blockquote><h3 id="原型-8">原型</h3><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>默认</th><th><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last);</code></strong></th></tr></thead><tbody><tr class="odd"><td><strong>自定义</strong></td><td><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last,Compare comp);</code></strong></td></tr></tbody></table><ul><li>参数first：待排数组的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排数组的<strong><font color='blue'>末尾地址</font></strong></li><li>参数comp：自定义排序方法<ul><li>如果第三个参数不写，则<strong>默认的排序方法</strong>是<strong><font color='red'>从小到大</font></strong>排序。</li></ul></li></ul><h3 id="举例-8">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// cmp函数返回的值是bool类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 从大到⼩排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 因为这里没有传入参数cmp，所以按照默认,v从小到大排列</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, cmp); <span class="comment">// arr从大到小排列，因为cmp函数排序规则设置了从大到小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见cmp函数">常见cmp函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score!=b.score)</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">return</span> a.score!=b.score ? a.score&gt;b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> node a,<span class="keyword">struct</span> node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height!=b.height ? a.height&gt;b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注： <strong><code>sort</code></strong> 函数的<strong><code>cmp</code></strong> 必须按照规定来写，即必须只是<strong><code>&gt;</code></strong> 或者<strong><code>&lt;</code></strong> ，比如：<strong><code>return a &gt; b;</code></strong> 或者<strong><code>return a &lt; b;</code></strong> 而不能是<strong><code>&lt;=</code></strong> 或者<strong><code>&gt;=</code></strong></p></blockquote><h2 id="find">find</h2><h3 id="头文件-13">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-15">作用</h3><p>​可以在<strong>任何容器</strong>中<strong>查找指定元素</strong>，返回一个迭代器指向<strong>第一个匹配</strong>的元素</p><ul><li><p>string、map、set有内置的成员方法find()，所以对于string、map、set的查找通常使用内置的find()方法</p></li><li><p>但是vector、queue没有内置的成员方法find()，他们通常使用<algorithm>头文件下通用的find()函数</p></li></ul><h3 id="参数">参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>first</strong> 和 <strong>last</strong>为输入迭代器，<strong>[first,last)</strong>用于指定该函数的查找范围</li><li><strong>val</strong>为要查找的目标元素</li></ul><h3 id="返回值">返回值</h3><p>​该函数返回一个<strong>迭代器</strong>，指向范围内搜索元素的<strong>第一次</strong>出现。如果没有找到目标元素，则返回<strong>last</strong></p><h3 id="例子">例子</h3><ul><li>在<code>vector</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element found: 3</span><br></pre></td></tr></table></figure><ul><li>在<code>string</code>中查找指定字符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;This is a string&quot;</span>; <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  ^  ^  ^</span></span><br><span class="line"><span class="comment">                  1  2  3           */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>s.rfind()</code><strong>从左往右</strong>寻找、<code>s.lfind()</code><strong>从右往左</strong>寻找</p></blockquote><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从首个位置开始搜索，在下标 2 处找到子串 is</span><br><span class="line">从下标 5 开始搜索，在下标 5 处找到子串 is</span><br><span class="line">从首个位置开始搜索，在下标 3 处找到字符 s</span><br><span class="line">从下标 5 开始搜索，在下标 6 处找到字符 s</span><br></pre></td></tr></table></figure><ul><li>在<code>set</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法1：使用find方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">2</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法2：使用count方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy">copy</h2><h2 id="unique">unique</h2><h3 id="头文件-14">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-16">作用</h3><p>​ <code>unique</code>可以对 <strong>vector</strong>容器内的元素去重</p><h3 id="原型-9">原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a);</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>vector&lt;int&gt;</code></li><li><strong>返回值</strong>：指向去重后<strong>最后一个元素</strong>的迭代器<code>vector&lt;int&gt;::iterator</code></li></ul><h3 id="底层原理">底层原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) <span class="comment">// 如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];          <span class="comment">// 每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j; <span class="comment">// 返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next_permutation">next_permutation</h2><h3 id="头文件-15">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-17">作用</h3><p>​<code>next_permutation</code>是求当前排列的下一个排列（按字典序升序的下一个序列），如1234的next_permutation 是1243，在<strong>全排列</strong>当中经常会用。</p><h3 id="参数-1">参数</h3><p>​和<code>sort</code>的参数一样，一般传两个参数，第一个是排列开始的地址，第二个是排列结束的下一个地址，如实现数组第1-3排列的下一个排列：<code>next_permutation(a,a+3)</code>。一般作用对象是数组。</p><h3 id="返回值-1">返回值</h3><p>​ 返回值是 <span class="math inline">\(Ture\)</span> 或者 <spanclass="math inline">\(False\)</span>，若当前排列有下一个排列，则返回Ture，反之返回False：如54321的返回值为False。该函数会直接修改数组为下一个排列。</p><h3 id="原理">原理</h3><ul><li>从后往前找原数组中第一个<code>a[i] &lt; a[i+1]</code>的地方，其后面全是降序，说明已经排好了，所以我们就要将a[i]的值改大一点</li><li>将a[i]和其后面所有数中大于他的最小的数交换位置，则a[i]后面的数仍是个降序</li><li>然后将其后面这些降序的元素翻转，就得到了原排列的下一个增序排列了</li></ul><blockquote><blockquote><p>例如：对于排列2431来说</p><p>①我们先找到2和4处</p><p>②然后交换2和3的位置，就得到了3421</p><p>③最后翻转421，就得到了3124，则3124就是2431的下一个排列，如下图。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152332.png"alt="eg" /><figcaption aria-hidden="true">eg</figcaption></figure></blockquote></blockquote><h3 id="全排列">全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:sunny:如果你希望生成所有的排列方式，一定要<strong>先将序列按升序排列</strong>，这里可以与sort函数结合起来使用，先用sort升序排列，再调用next_permutation函数。</p><h2 id="int_maxint_min">INT_MAX，INT_MIN</h2><h3 id="头文件-16">头文件</h3><p><strong><code>#include &lt;climits&gt;</code></strong></p><h3 id="介绍">介绍</h3><p>C中<strong>常量</strong><code>INT_MAX</code>和<code>INT_MIN</code>分别表示int类型的最大值和最小值</p><blockquote><ol type="1"><li>``` INT_MAX = 2^31-1 = 2147483647; INT_MIN = -2^31 = -2147483648;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 所有超过该限值的int类型变量，都会出现溢出，出现warning，但是并不会出现error。</span><br><span class="line"></span><br><span class="line">3. 如果想表示的整数超过了该限值，可以使用长整型long long （占8字节64位）表示。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">### 建议</span><br><span class="line"></span><br><span class="line">-   由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对INT_MAX和INT_MIN的运算应当格外注意，在出现溢出的时候，不遵循数学规则：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">INT_MAX + 1 = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 = INT_MAX</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MAX + 1 &lt; INT_MAX</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 &gt; INT_MIN</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) &lt; 0</span><br></pre></td></tr></table></figure></li></ol></blockquote><ul><li><p>建议在表示正负无穷时：</p><ul><li><p>使用 <code>2e9</code> 表示<strong>正无穷</strong></p></li><li><p><code>-2e9</code> 表示<strong>负无穷</strong></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e9</span>;</span><br></pre></td></tr></table></figure><h3 id="实例-1">实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX = %d\n&quot;</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN = %d\n&quot;</span>, INT_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX + 1 = %d\n&quot;</span>, INT_MAX + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN - 1 = %d\n&quot;</span>, INT_MIN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;abs(INT_MIN) = %d\n&quot;</span>, <span class="built_in">abs</span>(INT_MIN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = 2147483647</span><br><span class="line">INT_MIN = -2147483648</span><br><span class="line">INT_MAX + 1 = -2147483648</span><br><span class="line">INT_MIN - 1 = 2147483647</span><br><span class="line">abs(INT_MIN) = -2147483648</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://blog.csdn.net/weixin_51635753/article/details/115434999?ops_request_misc=%7B%22request%5Fid%22%3A%22167049370716782414992762%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167049370716782414992762&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-21-115434999-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&amp;utm_term=C%2B%2B自带swap函数&amp;spm=1018.2226.3001.4187">(82条消息)C++ STL 常用函数_Mr.bei的博客-CSDN博客_c++stl常用函数</a></li><li><ahref="https://zh.cppreference.com/w/首页">cppreference.com</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;c标准库函数&quot;&gt;C++标准库函数&lt;/h1&gt;
&lt;h2 id=&quot;lower_bound-upper_bound&quot;&gt;lower_bound &amp;amp;&amp;amp; upper_bound&lt;/h2&gt;
&lt;h3 id=&quot;头文件&quot;&gt;头文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个&lt;strong&gt;排好序的数组&lt;/strong&gt;中进行&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;基于二分查找！数组或容器必须有序！&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;用法&quot;&gt;用法&lt;/h3&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142542.png&quot;
alt=&quot;image-20240331214206385&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20240331214206385&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142606.png&quot;
alt=&quot;image-20240331214221383&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20240331214221383&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Tips】</title>
    <link href="https://cuiluyi.gitee.io/2024/04/25/[object%20Object]/C++/%E3%80%90Tips%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/04/25/[object%20Object]/C++/%E3%80%90Tips%E3%80%91/</id>
    <published>2024-04-25T05:59:27.000Z</published>
    <updated>2024-05-04T00:56:41.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tips">Tips</h1><h2 id="i"><code>~i</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i != <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">~i;</span><br></pre></td></tr></table></figure><h2 id="大数组必须定义为全局变量">大数组必须定义为全局变量</h2><ul><li><p>在函数（包含main）内部声明的变量属于局部变量</p></li><li><p>局部变量存放在<strong>栈空间</strong>，栈空间默认为4MB，最多只能存储 <code>1e6</code> 大小的 <code>int</code> 数组</p></li><li><p>全局变量存放在<strong>堆空间</strong>，堆空间很大，如果内存为4GB，堆空间也可以达到 4GB</p></li></ul><p>​ 因此C++ 中若要设置长度大于 <code>1e6</code>的数组，不能在函数内部声明，因为这样属于局部变量，存放在栈空间上，容易造成内存溢出</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291023786.png" alt="image-20240329102329729" style="zoom: 50%;" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291024238.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><span id="more"></span><h2 id="puts">puts</h2><ul><li><strong>作用</strong>：输出一个字符串，然后加上回车</li></ul><blockquote><p>在用puts输出时会将字符串结束标志 <code>\0</code> 转换成<code>\n</code></p></blockquote><ul><li><strong>输出回车</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">// 字符串为空，相当于只输出一个回车</span></span><br></pre></td></tr></table></figure><ul><li><strong>输出字符串</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用puts函数输出的字符串中可以包含转义字符</span></span><br><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&quot;China\nBeijing&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">China</span><br><span class="line">Beijing</span><br></pre></td></tr></table></figure><h2 id="getlinecin">getline、cin</h2><ul><li><code>getline</code> <strong>功能：</strong><ul><li>从当前缓冲区中读取数据</li><li>直到遇到<strong>换行符 <code>\n</code></strong> 停止（<strong>换行符<code>\n</code></strong> 也会被读入指定的 string 中）</li><li>并将换行符 <code>\n</code> 替换成<strong>字符串结束符<code>\0</code></strong></li></ul></li></ul><h2 id="处理输入">处理输入</h2><h3 id="逗号表达式">逗号表达式</h3><ul><li><p>逗号表达式的值等于<strong>最后一个表达式的值</strong></p></li><li><p>通常用在处理输入，eg：</p><ul><li>“每个测试用例占一行，包含一个整数 <spanclass="math inline">\(n\)</span>​。当输入用例 <spanclass="math inline">\(n=−1\)</span>​时，表示输入终止，且该用例无需处理。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n, n != <span class="number">-1</span>)<span class="comment">// while(scanf(&quot;%d&quot;, &amp;n), n != -1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>“每个测试用例占一行，包含三个整数 a、b、c。当输入一行 “<spanclass="math inline">\(0\ 0\ 0\)</span>”时，表示输入终止，且该用例无需处理</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c)<span class="comment">// while(scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c), a || b || c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="whilecin">while(cin&gt;&gt;)</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8421970/">AcWing1010. 拦截导弹 - AcWing</a>的输入为例，有以下特点：</p><ul><li>输入数据只有一行</li><li>该行数据的个数未知</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 法一：使用scanf */</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[n]) != EOF)</span><br><span class="line">    n ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 法二：使用cin */</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a[n])</span><br><span class="line">    n ++;</span><br></pre></td></tr></table></figure><h3 id="sstream">sstream</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8466405/">AcWing920. 最优乘车 - AcWing</a>的输入为例，有以下特点：</p><ul><li>输入数据有多行</li><li>每行数据的个数未知</li></ul><blockquote><p>sstream 请参考：<ahref="https://njfjnkm.github.io/2024/03/30/%5Bobject%20Object%5D/C++/stringstream/">stringstream| 天道酬勤，厚德载物 (njfjnkm.github.io)</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline(<span class="built_in">cin</span>, line);</span><br><span class="line"><span class="keyword">while</span> (m -- )</span><br><span class="line">&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>, line);<span class="comment">// 把第一行末尾的回车过滤掉</span></span><br><span class="line">    <span class="built_in">stringstream</span> <span class="title function_">ssin</span><span class="params">(line)</span>;<span class="comment">// 使用 stringstream 接收字符串</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, p;</span><br><span class="line">    <span class="keyword">while</span> (ssin &gt;&gt; p) stop[cnt ++ ] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; cnt; k ++ )</span><br><span class="line">            g[stop[j]][stop[k]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坐标系">坐标系</h2><p>算法中有 <span class="math inline">\(2\)</span> 种常用的坐标系</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404142247048.png"alt="image-20240414224707942" /><figcaption aria-hidden="true">image-20240414224707942</figcaption></figure><h2 id="子串-vs-子序列">子串 vs 子序列</h2><h3 id="子串">子串</h3><ul><li><p><strong>定义：</strong>子串(sub-string)：串中任意个<strong>连续字符</strong>组成的子序列称为该串的子串</p></li><li><p><strong>举例：</strong></p><ul><li>ab的子串：a、b、ab、/0(空串）共 4 个即（2+1+1）个</li><li>abc的子串：a、 b、 c、 ab、 bc 、abc、/0(空串）共（3+2+1+1）个</li></ul></li></ul><p>所以若字符串的长度为 <span class="math inline">\(n\)</span>,则子串的个数就是 <span class="math inline">\([n(n+1)/2+1]\)</span>个</p><h3 id="子序列">子序列</h3><ul><li><p><strong>定义：</strong>子序列(sub-sequence)：一个给定的序列的子序列是在该序列中<strong>删除若干元素后</strong>得到的序列</p></li><li><p><strong>举例：</strong></p></li><li><p>ab的子串：/0(空串）、a、b、ab 共 4 个</p></li><li><p>abc的子串：/0(空串）、a、 b、 c、 ab、 ac、bc 、abc 共 8个</p></li></ul><p>所以若字符串的长度为 <span class="math inline">\(n\)</span>,则子串的个数就是 <span class="math inline">\(2^n\)</span> 个</p><h3 id="关系">关系</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404142316263.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2id="using-namespace-stddefinetypedefinclude-先后顺序"><code>using namespace std</code>、<code>#define</code>、<code>typedef</code>、<code>#include</code>先后顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q[N][N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h2 id="c默认向下取整">C++默认向下取整</h2><h2 id="区间长度与端点">区间长度与端点</h2><ul><li><p>如果区间长度为 <spanclass="math inline">\(len\)</span>、区间左端点为 <spanclass="math inline">\(l\)</span>，则区间右端点为 <spanclass="math inline">\(l+len-1\)</span></p></li><li><p>如果区间长度为 <spanclass="math inline">\(len\)</span>、区间右端点为 <spanclass="math inline">\(r\)</span>，则区间左端点为 <spanclass="math inline">\(r-len+1\)</span></p></li><li><p>如果区间左端点为 <spanclass="math inline">\(l\)</span>、区间右端点为 <spanclass="math inline">\(r\)</span>，则区间长度为 <spanclass="math inline">\(r-l+1\)</span></p></li><li><p>如果每连续 <span class="math inline">\(len\)</span> 个元素是 1个区间，那么这些区间对应位置元素模 <spanclass="math inline">\(len\)</span> 的结果相同 <spanclass="math inline">\(0,1,...,n-1\)</span>，根据这个性质可以准确地求出对应的坐标</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404281921995.jpg"alt="cebd9028783c4f471843d3455be20f6" /><figcaptionaria-hidden="true">cebd9028783c4f471843d3455be20f6</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tips&quot;&gt;Tips&lt;/h1&gt;
&lt;h2 id=&quot;i&quot;&gt;&lt;code&gt;~i&lt;/code&gt;&lt;/h2&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i != &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等价于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~i;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;大数组必须定义为全局变量&quot;&gt;大数组必须定义为全局变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在函数（包含main）内部声明的变量属于局部变量&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部变量存放在&lt;strong&gt;栈空间&lt;/strong&gt;，栈空间默认为
4MB，最多只能存储 &lt;code&gt;1e6&lt;/code&gt; 大小的 &lt;code&gt;int&lt;/code&gt; 数组&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全局变量存放在&lt;strong&gt;堆空间&lt;/strong&gt;，堆空间很大，如果内存为
4GB，堆空间也可以达到 4GB&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​ 因此C++ 中若要设置长度大于 &lt;code&gt;1e6&lt;/code&gt;
的数组，不能在函数内部声明，因为这样属于局部变量，存放在栈空间上，容易造成内存溢出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291023786.png&quot; alt=&quot;image-20240329102329729&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291024238.png&quot;
alt=&quot;在这里插入图片描述&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;在这里插入图片描述&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>100 numpy exercises</title>
    <link href="https://cuiluyi.gitee.io/2024/04/22/[object%20Object]/python/100%20numpy%20exercises/"/>
    <id>https://cuiluyi.gitee.io/2024/04/22/[object%20Object]/python/100%20numpy%20exercises/</id>
    <published>2024-04-22T06:33:49.000Z</published>
    <updated>2024-04-29T03:04:46.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy-exercises">100 numpy exercises</h1><p><ahref="https://colab.research.google.com/drive/1I-RFqhrOUz0Vq4aZ-iT_CfTNJdLIGdie#scrollTo=1a84bed8">100_Numpy_exercises.ipynb- Colab (google.com)</a></p><p>This is a collection of exercises that have been collected in thenumpy mailing list, on stack overflow and in the numpy documentation.The goal of this collection is to offer a quick reference for both oldand new users but also to provide a set of exercises for those whoteach.</p><h4 id="import-the-numpy-package-under-the-name-np">1. Import the numpypackage under the name <code>np</code> (★☆☆)</h4><p><code>hint: import … as</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="print-the-numpy-version-and-the-configuration">2. Print thenumpy version and the configuration (★☆☆)</h4><p><code>hint: np.__version__, np.show_config)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.__version__)</span><br><span class="line">np.show_config()</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="create-a-null-vector-of-size-10">3. Create a null vector of size10 (★☆☆)</h4><p><code>hint: np.zeros</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-find-the-memory-size-of-any-array">4. How to find thememory size of any array (★☆☆)</h4><p><code>hint: size, itemsize</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d bytes&quot;</span> % (Z.size * Z.itemsize))</span><br></pre></td></tr></table></figure><h4id="how-to-get-the-documentation-of-the-numpy-add-function-from-the-command-line">5.How to get the documentation of the numpy add function from the commandline? (★☆☆)</h4><p><code>hint: np.info</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%run `python -c <span class="string">&quot;import numpy; numpy.info(numpy.add)&quot;</span>`</span><br></pre></td></tr></table></figure><h4id="create-a-null-vector-of-size-10-but-the-fifth-value-which-is-1">6.Create a null vector of size 10 but the fifth value which is 1(★☆☆)</h4><p><code>hint: array[4]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line">Z[<span class="number">4</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-vector-with-values-ranging-from-10-to-49">7. Create avector with values ranging from 10 to 49 (★☆☆)</h4><p><code>hint: arange</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="reverse-a-vector-first-element-becomes-last">8. Reverse a vector(first element becomes last) (★☆☆)</h4><p><code>hint: array[::-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">50</span>)</span><br><span class="line">Z = Z[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-3x3-matrix-with-values-ranging-from-0-to-8">9. Create a3x3 matrix with values ranging from 0 to 8 (★☆☆)</h4><p><code>hint: reshape</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="find-indices下标-of-non-zero-elements-from-120040">10. Find<font color = 'blue'>indices(下标)</font> of non-zero elements from[1,2,0,0,4,0] (★☆☆)</h4><p><code>hint: np.nonzero</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nz = np.nonzero([<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(nz)</span><br></pre></td></tr></table></figure><h4 id="create-a-3x3-identity-matrix单位矩阵">11. Create a 3x3<font color = 'blue'> identity matrix(单位矩阵) </font> (★☆☆)</h4><p><code>hint: np.eye</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.eye(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-3x3x3-array-with-random-values">12. Create a 3x3x3array with random values (★☆☆)</h4><p><code>hint: np.random.random</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-10x10-array-with-random-values-and-find-the-minimum-and-maximum-values">13.Create a 10x10 array with random values and find the minimum and maximumvalues (★☆☆)</h4><p><code>hint: min, max</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">Zmin, Zmax = Z.<span class="built_in">min</span>(), Z.<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">print</span>(Zmin, Zmax)</span><br></pre></td></tr></table></figure><h4 id="create-a-random-vector-of-size-30-and-find-the-mean-value">14.Create a random vector of size 30 and find the mean value (★☆☆)</h4><p><code>hint: mean</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">30</span>)</span><br><span class="line">m = Z.mean()</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><h4 id="create-a-2d-array-with-1-on-the-border-and-0-inside">15. Createa 2d array with 1 on the border and 0 inside (★☆☆)</h4><p><code>hint: array[1:-1, 1:-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.ones((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-add-a-border-filled-with-0s-around-an-existing-array">16.How to add a border (filled with 0's) around an existing array?(★☆☆)</h4><p><code>hint: np.pad</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Z = np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z = np.pad(Z, pad_width=<span class="number">1</span>, mode=<span class="string">&#x27;constant&#x27;</span>, constant_values=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using fancy indexing</span></span><br><span class="line">Z[:, [<span class="number">0</span>, -<span class="number">1</span>]] = <span class="number">0</span></span><br><span class="line">Z[[<span class="number">0</span>, -<span class="number">1</span>], :] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="what-is-the-result-of-the-following-expression">17. What is theresult of the following expression? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> * np.nan</span><br><span class="line">np.nan == np.nan</span><br><span class="line">np.inf &gt; np.nan</span><br><span class="line">np.nan - np.nan</span><br><span class="line">np.nan <span class="keyword">in</span> <span class="built_in">set</span>([np.nan])</span><br><span class="line"><span class="number">0.3</span> == <span class="number">3</span> * <span class="number">0.1</span></span><br></pre></td></tr></table></figure><p><code>hint: NaN = not a number, inf = infinity</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0</span> * np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan == np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.inf &gt; np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan - np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan <span class="keyword">in</span> <span class="built_in">set</span>([np.nan]))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.3</span> == <span class="number">3</span> * <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><h4id="create-a-5x5-matrix-with-values-1234-just-below-the-diagonal">18.Create a 5x5 matrix with values 1,2,3,4 just below the diagonal(★☆☆)</h4><p><code>hint: np.diag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.diag(<span class="number">1</span>+np.arange(<span class="number">4</span>),k=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-8x8-matrix-and-fill-it-with-a-checkerboard-pattern">19.Create a 8x8 matrix and fill it with a checkerboard pattern (★☆☆)</h4><p><code>hint: array[::2]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">8</span>,<span class="number">8</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">Z[<span class="number">1</span>::<span class="number">2</span>,::<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">Z[::<span class="number">2</span>,<span class="number">1</span>::<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="consider-a-678-shape-array-what-is-the-index-xyz-of-the-100th-element">20.Consider a (6,7,8) shape array, what is the index (x,y,z) of the 100thelement? (★☆☆)</h4><p><code>hint: np.unravel_index</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.unravel_index(<span class="number">99</span>,(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)))</span><br></pre></td></tr></table></figure><h4 id="create-a-checkerboard-8x8-matrix-using-the-tile-function">21.Create a checkerboard 8x8 matrix using the tile function (★☆☆)</h4><p><code>hint: np.tile</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.tile( np.array([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]), (<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="normalize-a-5x5-random-matrix">22. Normalize a 5x5 random matrix(★☆☆)</h4><p><code>hint: (x -mean)/std</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z = (Z - np.mean (Z)) / (np.std (Z))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-custom-dtype-that-describes-a-color-as-four-unsigned-bytes-rgba">23.Create a custom dtype that describes a color as four unsigned bytes(RGBA) (★☆☆)</h4><p><code>hint: np.dtype</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color = np.dtype([(<span class="string">&quot;r&quot;</span>, np.ubyte),</span><br><span class="line">                  (<span class="string">&quot;g&quot;</span>, np.ubyte),</span><br><span class="line">                  (<span class="string">&quot;b&quot;</span>, np.ubyte),</span><br><span class="line">                  (<span class="string">&quot;a&quot;</span>, np.ubyte)])</span><br></pre></td></tr></table></figure><h4 id="multiply-a-5x3-matrix-by-a-3x2-matrix-real-matrix-product">24.Multiply a 5x3 matrix by a 3x2 matrix (real matrix product) (★☆☆)</h4><p><code>hint:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.dot(np.ones((<span class="number">5</span>,<span class="number">3</span>)), np.ones((<span class="number">3</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternative solution, in Python 3.5 and above</span></span><br><span class="line">Z = np.ones((<span class="number">5</span>,<span class="number">3</span>)) @ np.ones((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="given-a-1d-array-negate-all-elements-which-are-between-3-and-8-in-place.">25.Given a 1D array, negate all elements which are between 3 and 8, inplace. (★☆☆)</h4><p><code>hint: &gt;, &lt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">11</span>)</span><br><span class="line">Z[(<span class="number">3</span> &lt; Z) &amp; (Z &lt; <span class="number">8</span>)] *= -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="what-is-the-output-of-the-following-script">26. What is theoutput of the following script? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jake VanderPlas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><code>hint: np.sum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jake VanderPlas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4id="consider-an-integer-vector-z-which-of-these-expressions-are-legal">27.Consider an integer vector Z, which of these expressions are legal?(★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z**Z</span><br><span class="line"><span class="number">2</span> &lt;&lt; Z &gt;&gt; <span class="number">2</span></span><br><span class="line">Z &lt;- Z</span><br><span class="line"><span class="number">1j</span>*Z</span><br><span class="line">Z/<span class="number">1</span>/<span class="number">1</span></span><br><span class="line">Z&lt;Z&gt;Z</span><br></pre></td></tr></table></figure><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z**Z</span><br><span class="line"><span class="number">2</span> &lt;&lt; Z &gt;&gt; <span class="number">2</span></span><br><span class="line">Z &lt;- Z</span><br><span class="line"><span class="number">1j</span>*Z</span><br><span class="line">Z/<span class="number">1</span>/<span class="number">1</span></span><br><span class="line">Z&lt;Z&gt;Z</span><br></pre></td></tr></table></figure><h4 id="what-are-the-result-of-the-following-expressions">28. What arethe result of the following expressions? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.array(<span class="number">0</span>) / np.array(<span class="number">0</span>)</span><br><span class="line">np.array(<span class="number">0</span>) // np.array(<span class="number">0</span>)</span><br><span class="line">np.array([np.nan]).astype(<span class="built_in">int</span>).astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.array(<span class="number">0</span>) / np.array(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(np.array(<span class="number">0</span>) // np.array(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(np.array([np.nan]).astype(<span class="built_in">int</span>).astype(<span class="built_in">float</span>))</span><br></pre></td></tr></table></figure><h4 id="how-to-round-away-from-zero-a-float-array">29. How to round awayfrom zero a float array ? (★☆☆)</h4><p><code>hint: np.uniform, np.copysign, np.ceil, np.abs, np.where</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Charles R Harris</span></span><br><span class="line"></span><br><span class="line">Z = np.random.uniform(-<span class="number">10</span>,+<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(np.copysign(np.ceil(np.<span class="built_in">abs</span>(Z)), Z))</span><br><span class="line"></span><br><span class="line"><span class="comment"># More readable but less efficient</span></span><br><span class="line"><span class="built_in">print</span>(np.where(Z&gt;<span class="number">0</span>, np.ceil(Z), np.floor(Z)))</span><br></pre></td></tr></table></figure><h4 id="how-to-find-common-values-between-two-arrays">30. How to findcommon values between two arrays? (★☆☆)</h4><p><code>hint: np.intersect1d</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z1 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">Z2 = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(np.intersect1d(Z1,Z2))</span><br></pre></td></tr></table></figure><h4 id="how-to-ignore-all-numpy-warnings-not-recommended">31. How toignore all numpy warnings (not recommended)? (★☆☆)</h4><p><code>hint: np.seterr, np.errstate</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Suicide mode on</span></span><br><span class="line">defaults = np.seterr(<span class="built_in">all</span>=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line">Z = np.ones(<span class="number">1</span>) / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Back to sanity</span></span><br><span class="line">_ = np.seterr(**defaults)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalently with a context manager</span></span><br><span class="line"><span class="keyword">with</span> np.errstate(<span class="built_in">all</span>=<span class="string">&quot;ignore&quot;</span>):</span><br><span class="line">    np.arange(<span class="number">3</span>) / <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="is-the-following-expressions-true">32. Is the followingexpressions true? (★☆☆)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(-<span class="number">1</span>) == np.emath.sqrt(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>hint: imaginary number</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(-<span class="number">1</span>) == np.emath.sqrt(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="how-to-get-the-dates-of-yesterday-today-and-tomorrow">33. How toget the dates of yesterday, today and tomorrow? (★☆☆)</h4><p><code>hint: np.datetime64, np.timedelta64</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yesterday = np.datetime64(<span class="string">&#x27;today&#x27;</span>) - np.timedelta64(<span class="number">1</span>)</span><br><span class="line">today     = np.datetime64(<span class="string">&#x27;today&#x27;</span>)</span><br><span class="line">tomorrow  = np.datetime64(<span class="string">&#x27;today&#x27;</span>) + np.timedelta64(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4id="how-to-get-all-the-dates-corresponding-to-the-month-of-july-2016">34.How to get all the dates corresponding to the month of July 2016?(★★☆)</h4><p><code>hint: np.arange(dtype=datetime64['D'])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="string">&#x27;2016-07&#x27;</span>, <span class="string">&#x27;2016-08&#x27;</span>, dtype=<span class="string">&#x27;datetime64[D]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-compute-ab-a2-in-place-without-copy">35. How to compute((A+B)*(-A/2)) in place (without copy)? (★★☆)</h4><p><code>hint: np.add(out=), np.negative(out=), np.multiply(out=), np.divide(out=)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones(<span class="number">3</span>)*<span class="number">1</span></span><br><span class="line">B = np.ones(<span class="number">3</span>)*<span class="number">2</span></span><br><span class="line">np.add(A,B,out=B)</span><br><span class="line">np.divide(A,<span class="number">2</span>,out=A)</span><br><span class="line">np.negative(A,out=A)</span><br><span class="line">np.multiply(A,B,out=A)</span><br></pre></td></tr></table></figure><h4id="extract-the-integer-part-of-a-random-array-of-positive-numbers-using-4-different-methods">36.Extract the integer part of a random array of positive numbers using 4different methods (★★☆)</h4><p><code>hint: %, np.floor, astype, np.trunc</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Z - Z%<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z // <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np.floor(Z))</span><br><span class="line"><span class="built_in">print</span>(Z.astype(<span class="built_in">int</span>))</span><br><span class="line"><span class="built_in">print</span>(np.trunc(Z))</span><br></pre></td></tr></table></figure><h4 id="create-a-5x5-matrix-with-row-values-ranging-from-0-to-4">37.Create a 5x5 matrix with row values ranging from 0 to 4 (★★☆)</h4><p><code>hint: np.arange</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z += np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># without broadcasting</span></span><br><span class="line">Z = np.tile(np.arange(<span class="number">0</span>, <span class="number">5</span>), (<span class="number">5</span>,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="consider-a-generator-function-that-generates-10-integers-and-use-it-to-build-an-array">38.Consider a generator function that generates 10 integers and use it tobuild an array (★☆☆)</h4><p><code>hint: np.fromiter</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">Z = np.fromiter(generate(),dtype=<span class="built_in">float</span>,count=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-vector-of-size-10-with-values-ranging-from-0-to-1-both-excluded">39.Create a vector of size 10 with values ranging from 0 to 1, bothexcluded (★★☆)</h4><p><code>hint: np.linspace</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">11</span>,endpoint=<span class="literal">False</span>)[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="create-a-random-vector-of-size-10-and-sort-it">40. Create arandom vector of size 10 and sort it (★★☆)</h4><p><code>hint: sort</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z.sort()</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-sum-a-small-array-faster-than-np.sum">41. How to sum asmall array faster than np.sum? (★★☆)</h4><p><code>hint: np.add.reduce</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">10</span>)</span><br><span class="line">np.add.reduce(Z)</span><br></pre></td></tr></table></figure><h4 id="consider-two-random-array-a-and-b-check-if-they-are-equal">42.Consider two random array A and B, check if they are equal (★★☆)</h4><p><code>hint: np.allclose, np.array_equal</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">B = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assuming identical shape of the arrays and a tolerance for the comparison of values</span></span><br><span class="line">equal = np.allclose(A,B)</span><br><span class="line"><span class="built_in">print</span>(equal)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Checking both the shape and the element values, no tolerance (values have to be exactly equal)</span></span><br><span class="line">equal = np.array_equal(A,B)</span><br><span class="line"><span class="built_in">print</span>(equal)</span><br></pre></td></tr></table></figure><h4 id="make-an-array-immutable-read-only">43. Make an array immutable(read-only) (★★☆)</h4><p><code>hint: flags.writeable</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>)</span><br><span class="line">Z.flags.writeable = <span class="literal">False</span></span><br><span class="line">Z[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4id="consider-a-random-10x2-matrix-representing-cartesian-coordinates-convert-them-to-polar-coordinates">44.Consider a random 10x2 matrix representing cartesian coordinates,convert them to polar coordinates (★★☆)</h4><p><code>hint: np.sqrt, np.arctan2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">X,Y = Z[:,<span class="number">0</span>], Z[:,<span class="number">1</span>]</span><br><span class="line">R = np.sqrt(X**<span class="number">2</span>+Y**<span class="number">2</span>)</span><br><span class="line">T = np.arctan2(Y,X)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br><span class="line"><span class="built_in">print</span>(T)</span><br></pre></td></tr></table></figure><h4id="create-random-vector-of-size-10-and-replace-the-maximum-value-by-0">45.Create random vector of size 10 and replace the maximum value by 0(★★☆)</h4><p><code>hint: argmax</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random(<span class="number">10</span>)</span><br><span class="line">Z[Z.argmax()] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="create-a-structured-array-with-x-and-y-coordinates-covering-the-01x01-area">46.Create a structured array with <code>x</code> and <code>y</code>coordinates covering the [0,1]x[0,1] area (★★☆)</h4><p><code>hint: np.meshgrid</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros((<span class="number">5</span>,<span class="number">5</span>), [(<span class="string">&#x27;x&#x27;</span>,<span class="built_in">float</span>),(<span class="string">&#x27;y&#x27;</span>,<span class="built_in">float</span>)])</span><br><span class="line">Z[<span class="string">&#x27;x&#x27;</span>], Z[<span class="string">&#x27;y&#x27;</span>] = np.meshgrid(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>),</span><br><span class="line">                             np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="given-two-arrays-x-and-y-construct-the-cauchy-matrix-c-cij-1xi---yj">47.Given two arrays, X and Y, construct the Cauchy matrix C (Cij =1/(xi -yj)) (★★☆)</h4><p><code>hint: np.subtract.outer</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">X = np.arange(<span class="number">8</span>)</span><br><span class="line">Y = X + <span class="number">0.5</span></span><br><span class="line">C = <span class="number">1.0</span> / np.subtract.outer(X, Y)</span><br><span class="line"><span class="built_in">print</span>(np.linalg.det(C))</span><br></pre></td></tr></table></figure><h4id="print-the-minimum-and-maximum-representable-value-for-each-numpy-scalar-type">48.Print the minimum and maximum representable value for each numpy scalartype (★★☆)</h4><p><code>hint: np.iinfo, np.finfo, eps</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dtype <span class="keyword">in</span> [np.int8, np.int32, np.int64]:</span><br><span class="line">   <span class="built_in">print</span>(np.iinfo(dtype).<span class="built_in">min</span>)</span><br><span class="line">   <span class="built_in">print</span>(np.iinfo(dtype).<span class="built_in">max</span>)</span><br><span class="line"><span class="keyword">for</span> dtype <span class="keyword">in</span> [np.float32, np.float64]:</span><br><span class="line">   <span class="built_in">print</span>(np.finfo(dtype).<span class="built_in">min</span>)</span><br><span class="line">   <span class="built_in">print</span>(np.finfo(dtype).<span class="built_in">max</span>)</span><br><span class="line">   <span class="built_in">print</span>(np.finfo(dtype).eps)</span><br></pre></td></tr></table></figure><h4 id="how-to-print-all-the-values-of-an-array">49. How to print allthe values of an array? (★★☆)</h4><p><code>hint: np.set_printoptions</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>))</span><br><span class="line">Z = np.zeros((<span class="number">40</span>,<span class="number">40</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-find-the-closest-value-to-a-given-scalar-in-a-vector">50.How to find the closest value (to a given scalar) in a vector?(★★☆)</h4><p><code>hint: argmin</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">100</span>)</span><br><span class="line">v = np.random.uniform(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">index = (np.<span class="built_in">abs</span>(Z-v)).argmin()</span><br><span class="line"><span class="built_in">print</span>(Z[index])</span><br></pre></td></tr></table></figure><h4id="create-a-structured-array-representing-a-position-xy-and-a-color-rgb">51.Create a structured array representing a position (x,y) and a color(r,g,b) (★★☆)</h4><p><code>hint: dtype</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.zeros(<span class="number">10</span>, [ (<span class="string">&#x27;position&#x27;</span>, [ (<span class="string">&#x27;x&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),</span><br><span class="line">                                  (<span class="string">&#x27;y&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>)]),</span><br><span class="line">                   (<span class="string">&#x27;color&#x27;</span>,    [ (<span class="string">&#x27;r&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),</span><br><span class="line">                                  (<span class="string">&#x27;g&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>),</span><br><span class="line">                                  (<span class="string">&#x27;b&#x27;</span>, <span class="built_in">float</span>, <span class="number">1</span>)])])</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="consider-a-random-vector-with-shape-1002-representing-coordinates-find-point-by-point-distances">52.Consider a random vector with shape (100,2) representing coordinates,find point by point distances (★★☆)</h4><p><code>hint: np.atleast_2d, T, np.sqrt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">X,Y = np.atleast_2d(Z[:,<span class="number">0</span>], Z[:,<span class="number">1</span>])</span><br><span class="line">D = np.sqrt( (X-X.T)**<span class="number">2</span> + (Y-Y.T)**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Much faster with scipy</span></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="comment"># Thanks Gavin Heverly-Coulson (#issue 1)</span></span><br><span class="line"><span class="keyword">import</span> scipy.spatial</span><br><span class="line"></span><br><span class="line">Z = np.random.random((<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">D = scipy.spatial.distance.cdist(Z,Z)</span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure><h4id="how-to-convert-a-float-32-bits-array-into-an-integer-32-bits-in-place">53.How to convert a float (32 bits) array into an integer (32 bits) inplace?</h4><p><code>hint: view and [:] =</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Thanks Vikas (https://stackoverflow.com/a/10622758/5989906)</span></span><br><span class="line"><span class="comment"># &amp; unutbu (https://stackoverflow.com/a/4396247/5989906)</span></span><br><span class="line">Z = (np.random.rand(<span class="number">10</span>)*<span class="number">100</span>).astype(np.float32)</span><br><span class="line">Y = Z.view(np.int32)</span><br><span class="line">Y[:] = Z</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><h4 id="how-to-read-the-following-file">54. How to read the followingfile? (★★☆)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5</span><br><span class="line">6,  ,  , 7, 8</span><br><span class="line"> ,  , 9,10,11</span><br></pre></td></tr></table></figure><p><code>hint: np.genfromtxt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fake file</span></span><br><span class="line">s = StringIO(<span class="string">&#x27;&#x27;&#x27;1, 2, 3, 4, 5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                6,  ,  , 7, 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                 ,  , 9,10,11</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">Z = np.genfromtxt(s, delimiter=<span class="string">&quot;,&quot;</span>, dtype=np.<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="what-is-the-equivalent-of-enumerate-for-numpy-arrays">55. Whatis the equivalent of enumerate for numpy arrays? (★★☆)</h4><p><code>hint: np.ndenumerate, np.ndindex</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> np.ndenumerate(Z):</span><br><span class="line">    <span class="built_in">print</span>(index, value)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> np.ndindex(Z.shape):</span><br><span class="line">    <span class="built_in">print</span>(index, Z[index])</span><br></pre></td></tr></table></figure><h4 id="generate-a-generic-2d-gaussian-like-array">56. Generate ageneric 2D Gaussian-like array (★★☆)</h4><p><code>hint: np.meshgrid, np.exp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X, Y = np.meshgrid(np.linspace(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>), np.linspace(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">D = np.sqrt(X*X+Y*Y)</span><br><span class="line">sigma, mu = <span class="number">1.0</span>, <span class="number">0.0</span></span><br><span class="line">G = np.exp(-( (D-mu)**<span class="number">2</span> / ( <span class="number">2.0</span> * sigma**<span class="number">2</span> ) ) )</span><br><span class="line"><span class="built_in">print</span>(G)</span><br></pre></td></tr></table></figure><h4 id="how-to-randomly-place-p-elements-in-a-2d-array">57. How torandomly place p elements in a 2D array? (★★☆)</h4><p><code>hint: np.put, np.random.choice</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Divakar</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">Z = np.zeros((n,n))</span><br><span class="line">np.put(Z, np.random.choice(<span class="built_in">range</span>(n*n), p, replace=<span class="literal">False</span>),<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="subtract-the-mean-of-each-row-of-a-matrix">58. Subtract the meanof each row of a matrix (★★☆)</h4><p><code>hint: mean(axis=,keepdims=)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line">X = np.random.rand(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recent versions of numpy</span></span><br><span class="line">Y = X - X.mean(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Older versions of numpy</span></span><br><span class="line">Y = X - X.mean(axis=<span class="number">1</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><h4 id="how-to-sort-an-array-by-the-nth-column">59. How to sort an arrayby the nth column? (★★☆)</h4><p><code>hint: argsort</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Steve Tjoa</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="built_in">print</span>(Z[Z[:,<span class="number">1</span>].argsort()])</span><br></pre></td></tr></table></figure><h4 id="how-to-tell-if-a-given-2d-array-has-null-columns">60. How totell if a given 2D array has null columns? (★★☆)</h4><p><code>hint: any, ~</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># null : 0 </span></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">3</span>,(<span class="number">3</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>((~Z.<span class="built_in">any</span>(axis=<span class="number">0</span>)).<span class="built_in">any</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># null : np.nan</span></span><br><span class="line">Z=np.array([</span><br><span class="line">    [<span class="number">0</span>,<span class="number">1</span>,np.nan],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,np.nan],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">5</span>,np.nan]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">print</span>(np.isnan(Z).<span class="built_in">all</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h4 id="find-the-nearest-value-from-a-given-value-in-an-array">61. Findthe nearest value from a given value in an array (★★☆)</h4><p><code>hint: np.abs, argmin, flat</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">z = <span class="number">0.5</span></span><br><span class="line">m = Z.flat[np.<span class="built_in">abs</span>(Z - z).argmin()]</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><h4id="considering-two-arrays-with-shape-13-and-31-how-to-compute-their-sum-using-an-iterator">62.Considering two arrays with shape (1,3) and (3,1), how to compute theirsum using an iterator? (★★☆)</h4><p><code>hint: np.nditer</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">3</span>).reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">3</span>).reshape(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">it = np.nditer([A,B,<span class="literal">None</span>])</span><br><span class="line"><span class="keyword">for</span> x,y,z <span class="keyword">in</span> it: z[...] = x + y</span><br><span class="line"><span class="built_in">print</span>(it.operands[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h4 id="create-an-array-class-that-has-a-name-attribute">63. Create anarray class that has a name attribute (★★☆)</h4><p><code>hint: class method</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NamedArray</span>(np.ndarray):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, array, name=<span class="string">&quot;no name&quot;</span></span>):</span><br><span class="line">        obj = np.asarray(array).view(cls)</span><br><span class="line">        obj.name = name</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__array_finalize__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        self.name = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;no name&quot;</span>)</span><br><span class="line"></span><br><span class="line">Z = NamedArray(np.arange(<span class="number">10</span>), <span class="string">&quot;range_10&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> (Z.name)</span><br></pre></td></tr></table></figure><h4id="consider-a-given-vector-how-to-add-1-to-each-element-indexed-by-a-second-vector-be-careful-with-repeated-indices">64.Consider a given vector, how to add 1 to each element indexed by asecond vector (be careful with repeated indices)? (★★★)</h4><p><code>hint: np.bincount | np.add.at</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Brett Olsen</span></span><br><span class="line"></span><br><span class="line">Z = np.ones(<span class="number">10</span>)</span><br><span class="line">I = np.random.randint(<span class="number">0</span>,<span class="built_in">len</span>(Z),<span class="number">20</span>)</span><br><span class="line">Z += np.bincount(I, minlength=<span class="built_in">len</span>(Z))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Another solution</span></span><br><span class="line"><span class="comment"># Author: Bartosz Telenczuk</span></span><br><span class="line">np.add.at(Z, I, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4id="how-to-accumulate-elements-of-a-vector-x-to-an-array-f-based-on-an-index-list-i">65.How to accumulate elements of a vector (X) to an array (F) based on anindex list (I)? (★★★)</h4><p><code>hint: np.bincount</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Alan G Isaac</span></span><br><span class="line"></span><br><span class="line">X = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">I = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">F = np.bincount(I,X)</span><br><span class="line"><span class="built_in">print</span>(F)</span><br></pre></td></tr></table></figure><h4id="considering-a-wh3-image-of-dtypeubyte-compute-the-number-of-unique-colors">66.Considering a (w,h,3) image of (dtype=ubyte), compute the number ofunique colors (★★☆)</h4><p><code>hint: np.unique</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Fisher Wang</span></span><br><span class="line"></span><br><span class="line">w, h = <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">I = np.random.randint(<span class="number">0</span>, <span class="number">4</span>, (h, w, <span class="number">3</span>)).astype(np.ubyte)</span><br><span class="line">colors = np.unique(I.reshape(-<span class="number">1</span>, <span class="number">3</span>), axis=<span class="number">0</span>)</span><br><span class="line">n = <span class="built_in">len</span>(colors)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Faster version</span></span><br><span class="line"><span class="comment"># Author: Mark Setchell</span></span><br><span class="line"><span class="comment"># https://stackoverflow.com/a/59671950/2836621</span></span><br><span class="line"></span><br><span class="line">w, h = <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">I = np.random.randint(<span class="number">0</span>,<span class="number">4</span>,(h,w,<span class="number">3</span>), dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># View each pixel as a single 24-bit integer, rather than three 8-bit bytes</span></span><br><span class="line">I24 = np.dot(I.astype(np.uint32),[<span class="number">1</span>,<span class="number">256</span>,<span class="number">65536</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count unique colours</span></span><br><span class="line">n = <span class="built_in">len</span>(np.unique(I24))</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><h4id="considering-a-four-dimensions-array-how-to-get-sum-over-the-last-two-axis-at-once">67.Considering a four dimensions array, how to get sum over the last twoaxis at once? (★★★)</h4><p><code>hint: sum(axis=(-2,-1))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># solution by passing a tuple of axes (introduced in numpy 1.7.0)</span></span><br><span class="line"><span class="built_in">sum</span> = A.<span class="built_in">sum</span>(axis=(-<span class="number">2</span>,-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line"><span class="comment"># solution by flattening the last two dimensions into one</span></span><br><span class="line"><span class="comment"># (useful for functions that don&#x27;t accept tuples for axis argument)</span></span><br><span class="line"><span class="built_in">sum</span> = A.reshape(A.shape[:-<span class="number">2</span>] + (-<span class="number">1</span>,)).<span class="built_in">sum</span>(axis=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><h4id="considering-a-one-dimensional-vector-d-how-to-compute-means-of-subsets-of-d-using-a-vector-s-of-same-size-describing-subset-indices">68.Considering a one-dimensional vector D, how to compute means of subsetsof D using a vector S of same size describing subset indices? (★★★)</h4><p><code>hint: np.bincount</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line">D = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">S = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">D_sums = np.bincount(S, weights=D)</span><br><span class="line">D_counts = np.bincount(S)</span><br><span class="line">D_means = D_sums / D_counts</span><br><span class="line"><span class="built_in">print</span>(D_means)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pandas solution as a reference due to more intuitive code</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="built_in">print</span>(pd.Series(D).groupby(S).mean())</span><br></pre></td></tr></table></figure><h4 id="how-to-get-the-diagonal-of-a-dot-product">69. How to get thediagonal of a dot product? (★★★)</h4><p><code>hint: np.diag</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Mathieu Blondel</span></span><br><span class="line"></span><br><span class="line">A = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">B = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slow version</span></span><br><span class="line">np.diag(np.dot(A, B))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fast version</span></span><br><span class="line">np.<span class="built_in">sum</span>(A * B.T, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Faster version</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij,ji-&gt;i&quot;</span>, A, B)</span><br></pre></td></tr></table></figure><h4id="consider-the-vector-1-2-3-4-5-how-to-build-a-new-vector-with-3-consecutive-zeros-interleaved-between-each-value">70.Consider the vector [1, 2, 3, 4, 5], how to build a new vector with 3consecutive zeros interleaved between each value? (★★★)</h4><p><code>hint: array[::4]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line">Z = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">nz = <span class="number">3</span></span><br><span class="line">Z0 = np.zeros(<span class="built_in">len</span>(Z) + (<span class="built_in">len</span>(Z)-<span class="number">1</span>)*(nz))</span><br><span class="line">Z0[::nz+<span class="number">1</span>] = Z</span><br><span class="line"><span class="built_in">print</span>(Z0)</span><br></pre></td></tr></table></figure><h4id="consider-an-array-of-dimension-553-how-to-mulitply-it-by-an-array-with-dimensions-55">71.Consider an array of dimension (5,5,3), how to mulitply it by an arraywith dimensions (5,5)? (★★★)</h4><p><code>hint: array[:, :, None]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones((<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line">B = <span class="number">2</span>*np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(A * B[:,:,<span class="literal">None</span>])</span><br></pre></td></tr></table></figure><h4 id="how-to-swap-two-rows-of-an-array">72. How to swap two rows of anarray? (★★★)</h4><p><code>hint: array[[]] = array[[]]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Eelco Hoogendoorn</span></span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">25</span>).reshape(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">A[[<span class="number">0</span>,<span class="number">1</span>]] = A[[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><h4id="consider-a-set-of-10-triplets-describing-10-triangles-with-shared-vertices-find-the-set-of-unique-line-segments-composing-all-the-triangles">73.Consider a set of 10 triplets describing 10 triangles (with sharedvertices), find the set of unique line segments composing all thetriangles (★★★)</h4><p><code>hint: repeat, np.roll, np.sort, view, np.unique</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nicolas P. Rougier</span></span><br><span class="line"></span><br><span class="line">faces = np.random.randint(<span class="number">0</span>,<span class="number">100</span>,(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line">F = np.roll(faces.repeat(<span class="number">2</span>,axis=<span class="number">1</span>),-<span class="number">1</span>,axis=<span class="number">1</span>)</span><br><span class="line">F = F.reshape(<span class="built_in">len</span>(F)*<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">F = np.sort(F,axis=<span class="number">1</span>)</span><br><span class="line">G = F.view( dtype=[(<span class="string">&#x27;p0&#x27;</span>,F.dtype),(<span class="string">&#x27;p1&#x27;</span>,F.dtype)] )</span><br><span class="line">G = np.unique(G)</span><br><span class="line"><span class="built_in">print</span>(G)</span><br></pre></td></tr></table></figure><h4id="given-a-sorted-array-c-that-corresponds-to-a-bincount-how-to-produce-an-array-a-such-that-np.bincounta-c">74.Given a sorted array C that corresponds to a bincount, how to produce anarray A such that np.bincount(A) == C? (★★★)</h4><p><code>hint: np.repeat</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line">C = np.bincount([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>])</span><br><span class="line">A = np.repeat(np.arange(<span class="built_in">len</span>(C)), C)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><h4id="how-to-compute-averages-using-a-sliding-window-over-an-array">75.How to compute averages using a sliding window over an array? (★★★)</h4><p><code>hint: np.cumsum, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">moving_average</span>(<span class="params">a, n=<span class="number">3</span></span>) :</span><br><span class="line">    ret = np.cumsum(a, dtype=<span class="built_in">float</span>)</span><br><span class="line">    ret[n:] = ret[n:] - ret[:-n]</span><br><span class="line">    <span class="keyword">return</span> ret[n - <span class="number">1</span>:] / n</span><br><span class="line">Z = np.arange(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(moving_average(Z, n=<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"><span class="comment"># make sure your NumPy &gt;= 1.20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy.lib.stride_tricks <span class="keyword">import</span> sliding_window_view</span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=<span class="number">3</span>).mean(axis=-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4id="consider-a-one-dimensional-array-z-build-a-two-dimensional-array-whose-first-row-is-z0z1z2-and-each-subsequent-row-is-shifted-by-1-last-row-should-be-z-3z-2z-1">76.Consider a one-dimensional array Z, build a two-dimensional array whosefirst row is (Z[0],Z[1],Z[2]) and each subsequent row is shifted by 1(last row should be (Z[-3],Z[-2],Z[-1]) (★★★)</h4><p><code>hint: from numpy.lib import stride_tricks, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Joe Kington / Erik Rigtorp</span></span><br><span class="line"><span class="keyword">from</span> numpy.lib <span class="keyword">import</span> stride_tricks</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rolling</span>(<span class="params">a, window</span>):</span><br><span class="line">    shape = (a.size - window + <span class="number">1</span>, window)</span><br><span class="line">    strides = (a.strides[<span class="number">0</span>], a.strides[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> stride_tricks.as_strided(a, shape=shape, strides=strides)</span><br><span class="line">Z = rolling(np.arange(<span class="number">10</span>), <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4id="how-to-negate-a-boolean-or-to-change-the-sign-of-a-float-inplace">77.How to negate a boolean, or to change the sign of a float inplace?(★★★)</h4><p><code>hint: np.logical_not, np.negative</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nathaniel J. Smith</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">100</span>)</span><br><span class="line">np.logical_not(Z, out=Z)</span><br><span class="line"></span><br><span class="line">Z = np.random.uniform(-<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">100</span>)</span><br><span class="line">np.negative(Z, out=Z)</span><br></pre></td></tr></table></figure><h4id="consider-2-sets-of-points-p0p1-describing-lines-2d-and-a-point-p-how-to-compute-distance-from-p-to-each-line-i-p0ip1i">78.Consider 2 sets of points P0,P1 describing lines (2d) and a point p, howto compute distance from p to each line i (P0[i],P1[i])? (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">P0, P1, p</span>):</span><br><span class="line">    T = P1 - P0</span><br><span class="line">    L = (T**<span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">    U = -((P0[:,<span class="number">0</span>]-p[...,<span class="number">0</span>])*T[:,<span class="number">0</span>] + (P0[:,<span class="number">1</span>]-p[...,<span class="number">1</span>])*T[:,<span class="number">1</span>]) / L</span><br><span class="line">    U = U.reshape(<span class="built_in">len</span>(U),<span class="number">1</span>)</span><br><span class="line">    D = P0 + U*T - p</span><br><span class="line">    <span class="keyword">return</span> np.sqrt((D**<span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">P0 = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">P1 = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">p  = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,( <span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(distance(P0, P1, p))</span><br></pre></td></tr></table></figure><h4id="consider-2-sets-of-points-p0p1-describing-lines-2d-and-a-set-of-points-p-how-to-compute-distance-from-each-point-j-pj-to-each-line-i-p0ip1i">79.Consider 2 sets of points P0,P1 describing lines (2d) and a set ofpoints P, how to compute distance from each point j (P[j]) to each linei (P0[i],P1[i])? (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Italmassov Kuanysh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># based on distance function from previous question</span></span><br><span class="line">P0 = np.random.uniform(-<span class="number">10</span>, <span class="number">10</span>, (<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">P1 = np.random.uniform(-<span class="number">10</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">p = np.random.uniform(-<span class="number">10</span>, <span class="number">10</span>, (<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(np.array([distance(P0,P1,p_i) <span class="keyword">for</span> p_i <span class="keyword">in</span> p]))</span><br></pre></td></tr></table></figure><h4id="consider-an-arbitrary-array-write-a-function-that-extract-a-subpart-with-a-fixed-shape-and-centered-on-a-given-element-pad-with-a-fill-value-when-necessary">80.Consider an arbitrary array, write a function that extract a subpartwith a fixed shape and centered on a given element (pad with a<code>fill</code> value when necessary) (★★★)</h4><p><code>hint: minimum maximum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nicolas Rougier</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">shape = (<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">fill  = <span class="number">0</span></span><br><span class="line">position = (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">R = np.ones(shape, dtype=Z.dtype)*fill</span><br><span class="line">P  = np.array(<span class="built_in">list</span>(position)).astype(<span class="built_in">int</span>)</span><br><span class="line">Rs = np.array(<span class="built_in">list</span>(R.shape)).astype(<span class="built_in">int</span>)</span><br><span class="line">Zs = np.array(<span class="built_in">list</span>(Z.shape)).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">R_start = np.zeros((<span class="built_in">len</span>(shape),)).astype(<span class="built_in">int</span>)</span><br><span class="line">R_stop  = np.array(<span class="built_in">list</span>(shape)).astype(<span class="built_in">int</span>)</span><br><span class="line">Z_start = (P-Rs//<span class="number">2</span>)</span><br><span class="line">Z_stop  = (P+Rs//<span class="number">2</span>)+Rs%<span class="number">2</span></span><br><span class="line"></span><br><span class="line">R_start = (R_start - np.minimum(Z_start,<span class="number">0</span>)).tolist()</span><br><span class="line">Z_start = (np.maximum(Z_start,<span class="number">0</span>)).tolist()</span><br><span class="line">R_stop = np.maximum(R_start, (R_stop - np.maximum(Z_stop-Zs,<span class="number">0</span>))).tolist()</span><br><span class="line">Z_stop = (np.minimum(Z_stop,Zs)).tolist()</span><br><span class="line"></span><br><span class="line">r = [<span class="built_in">slice</span>(start,stop) <span class="keyword">for</span> start,stop <span class="keyword">in</span> <span class="built_in">zip</span>(R_start,R_stop)]</span><br><span class="line">z = [<span class="built_in">slice</span>(start,stop) <span class="keyword">for</span> start,stop <span class="keyword">in</span> <span class="built_in">zip</span>(Z_start,Z_stop)]</span><br><span class="line">R[r] = Z[z]</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br></pre></td></tr></table></figure><h4id="consider-an-array-z-1234567891011121314-how-to-generate-an-array-r-1234-2345-3456-...-11121314">81.Consider an array Z = [1,2,3,4,5,6,7,8,9,10,11,12,13,14], how togenerate an array R = [[1,2,3,4], [2,3,4,5], [3,4,5,6], ...,[11,12,13,14]]? (★★★)</h4><p><code>hint: stride_tricks.as_strided, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan van der Walt</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">1</span>,<span class="number">15</span>,dtype=np.uint32)</span><br><span class="line">R = stride_tricks.as_strided(Z,(<span class="number">11</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(R)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.arange(<span class="number">1</span>, <span class="number">15</span>, dtype=np.uint32)</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=<span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="compute-a-matrix-rank">82. Compute a matrix rank (★★★)</h4><p><code>hint: np.linalg.svd, np.linalg.matrix_rank</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan van der Walt</span></span><br><span class="line"></span><br><span class="line">Z = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">U, S, V = np.linalg.svd(Z) <span class="comment"># Singular Value Decomposition</span></span><br><span class="line">rank = np.<span class="built_in">sum</span>(S &gt; <span class="number">1e-10</span>)</span><br><span class="line"><span class="built_in">print</span>(rank)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternative solution:</span></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">rank = np.linalg.matrix_rank(Z)</span><br><span class="line"><span class="built_in">print</span>(rank)</span><br></pre></td></tr></table></figure><h4 id="how-to-find-the-most-frequent-value-in-an-array">83. How to findthe most frequent value in an array?</h4><p><code>hint: np.bincount, argmax</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(np.bincount(Z).argmax())</span><br></pre></td></tr></table></figure><h4id="extract-all-the-contiguous-3x3-blocks-from-a-random-10x10-matrix">84.Extract all the contiguous 3x3 blocks from a random 10x10 matrix(★★★)</h4><p><code>hint: stride_tricks.as_strided, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Chris Barker</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">i = <span class="number">1</span> + (Z.shape[<span class="number">0</span>]-<span class="number">3</span>)</span><br><span class="line">j = <span class="number">1</span> + (Z.shape[<span class="number">1</span>]-<span class="number">3</span>)</span><br><span class="line">C = stride_tricks.as_strided(Z, shape=(i, j, n, n), strides=Z.strides + Z.strides)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=(<span class="number">3</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure><h4 id="create-a-2d-array-subclass-such-that-zij-zji">85. Create a 2Darray subclass such that Z[i,j] == Z[j,i] (★★★)</h4><p><code>hint: class method</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Eric O. Lebigot</span></span><br><span class="line"><span class="comment"># Note: only works for 2d array and value setting using indices</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Symetric</span>(np.ndarray):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, index, value</span>):</span><br><span class="line">        i,j = index</span><br><span class="line">        <span class="built_in">super</span>(Symetric, self).__setitem__((i,j), value)</span><br><span class="line">        <span class="built_in">super</span>(Symetric, self).__setitem__((j,i), value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">symetric</span>(<span class="params">Z</span>):</span><br><span class="line">    <span class="keyword">return</span> np.asarray(Z + Z.T - np.diag(Z.diagonal())).view(Symetric)</span><br><span class="line"></span><br><span class="line">S = symetric(np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">5</span>,<span class="number">5</span>)))</span><br><span class="line">S[<span class="number">2</span>,<span class="number">3</span>] = <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><h4id="consider-a-set-of-p-matrices-with-shape-nn-and-a-set-of-p-vectors-with-shape-n1.-how-to-compute-the-sum-of-of-the-p-matrix-products-at-once-result-has-shape-n1">86.Consider a set of p matrices with shape (n,n) and a set of p vectorswith shape (n,1). How to compute the sum of of the p matrix products atonce? (result has shape (n,1)) (★★★)</h4><p><code>hint: np.tensordot</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan van der Walt</span></span><br><span class="line"></span><br><span class="line">p, n = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">M = np.ones((p,n,n))</span><br><span class="line">V = np.ones((p,n,<span class="number">1</span>))</span><br><span class="line">S = np.tensordot(M, V, axes=[[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># It works, because:</span></span><br><span class="line"><span class="comment"># M is (p,n,n)</span></span><br><span class="line"><span class="comment"># V is (p,n,1)</span></span><br><span class="line"><span class="comment"># Thus, summing over the paired axes 0 and 0 (of M and V independently),</span></span><br><span class="line"><span class="comment"># and 2 and 1, to remain with a (n,1) vector.</span></span><br></pre></td></tr></table></figure><h4id="consider-a-16x16-array-how-to-get-the-block-sum-block-size-is-4x4">87.Consider a 16x16 array, how to get the block-sum (block size is 4x4)?(★★★)</h4><p><code>hint: np.add.reduceat, from numpy.lib.stride_tricks import sliding_window_view (np&gt;=1.20.0)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Robert Kern</span></span><br><span class="line"></span><br><span class="line">Z = np.ones((<span class="number">16</span>,<span class="number">16</span>))</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">S = np.add.reduceat(np.add.reduceat(Z, np.arange(<span class="number">0</span>, Z.shape[<span class="number">0</span>], k), axis=<span class="number">0</span>),</span><br><span class="line">                                       np.arange(<span class="number">0</span>, Z.shape[<span class="number">1</span>], k), axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternative solution:</span></span><br><span class="line"><span class="comment"># Author: Sebastian Wallkötter (@FirefoxMetzger)</span></span><br><span class="line"></span><br><span class="line">Z = np.ones((<span class="number">16</span>,<span class="number">16</span>))</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">windows = np.lib.stride_tricks.sliding_window_view(Z, (k, k))</span><br><span class="line">S = windows[::k, ::k, ...].<span class="built_in">sum</span>(axis=(-<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Jeff Luo (@Jeff1999)</span></span><br><span class="line"></span><br><span class="line">Z = np.ones((<span class="number">16</span>, <span class="number">16</span>))</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(sliding_window_view(Z, window_shape=(k, k))[::k, ::k].<span class="built_in">sum</span>(axis=(-<span class="number">2</span>, -<span class="number">1</span>)))</span><br></pre></td></tr></table></figure><h4 id="how-to-implement-the-game-of-life-using-numpy-arrays">88. How toimplement the Game of Life using numpy arrays? (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Nicolas Rougier</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterate</span>(<span class="params">Z</span>):</span><br><span class="line">    <span class="comment"># Count neighbours</span></span><br><span class="line">    N = (Z[<span class="number">0</span>:-<span class="number">2</span>,<span class="number">0</span>:-<span class="number">2</span>] + Z[<span class="number">0</span>:-<span class="number">2</span>,<span class="number">1</span>:-<span class="number">1</span>] + Z[<span class="number">0</span>:-<span class="number">2</span>,<span class="number">2</span>:] +</span><br><span class="line">         Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">0</span>:-<span class="number">2</span>]                + Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">2</span>:] +</span><br><span class="line">         Z[<span class="number">2</span>:  ,<span class="number">0</span>:-<span class="number">2</span>] + Z[<span class="number">2</span>:  ,<span class="number">1</span>:-<span class="number">1</span>] + Z[<span class="number">2</span>:  ,<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Apply rules</span></span><br><span class="line">    birth = (N==<span class="number">3</span>) &amp; (Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">    survive = ((N==<span class="number">2</span>) | (N==<span class="number">3</span>)) &amp; (Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">    Z[...] = <span class="number">0</span></span><br><span class="line">    Z[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>][birth | survive] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,(<span class="number">50</span>,<span class="number">50</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>): Z = iterate(Z)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></table></figure><h4 id="how-to-get-the-n-largest-values-of-an-array">89. How to get then largest values of an array (★★★)</h4><p><code>hint: np.argsort | np.argpartition</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Z = np.arange(<span class="number">10000</span>)</span><br><span class="line">np.random.shuffle(Z)</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Slow</span></span><br><span class="line"><span class="built_in">print</span> (Z[np.argsort(Z)[-n:]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fast</span></span><br><span class="line"><span class="built_in">print</span> (Z[np.argpartition(-Z,n)[:n]])</span><br></pre></td></tr></table></figure><h4id="given-an-arbitrary-number-of-vectors-build-the-cartesian-product-every-combinations-of-every-item">90.Given an arbitrary number of vectors, build the cartesian product (everycombinations of every item) (★★★)</h4><p><code>hint: np.indices</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Stefan Van der Walt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cartesian</span>(<span class="params">arrays</span>):</span><br><span class="line">    arrays = [np.asarray(a) <span class="keyword">for</span> a <span class="keyword">in</span> arrays]</span><br><span class="line">    shape = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> arrays)</span><br><span class="line"></span><br><span class="line">    ix = np.indices(shape, dtype=<span class="built_in">int</span>)</span><br><span class="line">    ix = ix.reshape(<span class="built_in">len</span>(arrays), -<span class="number">1</span>).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n, arr <span class="keyword">in</span> <span class="built_in">enumerate</span>(arrays):</span><br><span class="line">        ix[:, n] = arrays[n][ix[:, n]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ix</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (cartesian(([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>])))</span><br></pre></td></tr></table></figure><h4 id="how-to-create-a-record-array-from-a-regular-array">91. How tocreate a record array from a regular array? (★★★)</h4><p><code>hint: np.core.records.fromarrays</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.array([(<span class="string">&quot;Hello&quot;</span>, <span class="number">2.5</span>, <span class="number">3</span>),</span><br><span class="line">              (<span class="string">&quot;World&quot;</span>, <span class="number">3.6</span>, <span class="number">2</span>)])</span><br><span class="line">R = np.core.records.fromarrays(Z.T,</span><br><span class="line">                               names=<span class="string">&#x27;col1, col2, col3&#x27;</span>,</span><br><span class="line">                               formats = <span class="string">&#x27;S8, f8, i8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br></pre></td></tr></table></figure><h4id="consider-a-large-vector-z-compute-z-to-the-power-of-3-using-3-different-methods">92.Consider a large vector Z, compute Z to the power of 3 using 3 differentmethods (★★★)</h4><p><code>hint: np.power, *, np.einsum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Ryan G.</span></span><br><span class="line"></span><br><span class="line">x = np.random.rand(<span class="built_in">int</span>(<span class="number">5e7</span>))</span><br><span class="line"></span><br><span class="line">%timeit np.power(x,<span class="number">3</span>)</span><br><span class="line">%timeit x*x*x</span><br><span class="line">%timeit np.einsum(<span class="string">&#x27;i,i,i-&gt;i&#x27;</span>,x,x,x)</span><br></pre></td></tr></table></figure><h4id="consider-two-arrays-a-and-b-of-shape-83-and-22.-how-to-find-rows-of-a-that-contain-elements-of-each-row-of-b-regardless-of-the-order-of-the-elements-in-b">93.Consider two arrays A and B of shape (8,3) and (2,2). How to find rowsof A that contain elements of each row of B regardless of the order ofthe elements in B? (★★★)</h4><p><code>hint: np.where</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Gabe Schwartz</span></span><br><span class="line"></span><br><span class="line">A = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">8</span>,<span class="number">3</span>))</span><br><span class="line">B = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">C = (A[..., np.newaxis, np.newaxis] == B)</span><br><span class="line">rows = np.where(C.<span class="built_in">any</span>((<span class="number">3</span>,<span class="number">1</span>)).<span class="built_in">all</span>(<span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(rows)</span><br></pre></td></tr></table></figure><h4id="considering-a-10x3-matrix-extract-rows-with-unequal-values-e.g.-223">94.Considering a 10x3 matrix, extract rows with unequal values (e.g.[2,2,3]) (★★★)</h4><p><code>No hints provided...</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Robert Kern</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">5</span>,(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="comment"># solution for arrays of all dtypes (including string arrays and record arrays)</span></span><br><span class="line">E = np.<span class="built_in">all</span>(Z[:,<span class="number">1</span>:] == Z[:,:-<span class="number">1</span>], axis=<span class="number">1</span>)</span><br><span class="line">U = Z[~E]</span><br><span class="line"><span class="built_in">print</span>(U)</span><br><span class="line"><span class="comment"># soluiton for numerical arrays only, will work for any number of columns in Z</span></span><br><span class="line">U = Z[Z.<span class="built_in">max</span>(axis=<span class="number">1</span>) != Z.<span class="built_in">min</span>(axis=<span class="number">1</span>),:]</span><br><span class="line"><span class="built_in">print</span>(U)</span><br></pre></td></tr></table></figure><h4id="convert-a-vector-of-ints-into-a-matrix-binary-representation">95.Convert a vector of ints into a matrix binary representation (★★★)</h4><p><code>hint: np.unpackbits</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Warren Weckesser</span></span><br><span class="line"></span><br><span class="line">I = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>])</span><br><span class="line">B = ((I.reshape(-<span class="number">1</span>,<span class="number">1</span>) &amp; (<span class="number">2</span>**np.arange(<span class="number">8</span>))) != <span class="number">0</span>).astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(B[:,::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Daniel T. McDonald</span></span><br><span class="line"></span><br><span class="line">I = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>], dtype=np.uint8)</span><br><span class="line"><span class="built_in">print</span>(np.unpackbits(I[:, np.newaxis], axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="given-a-two-dimensional-array-how-to-extract-unique-rows">96.Given a two dimensional array, how to extract unique rows? (★★★)</h4><p><code>hint: np.ascontiguousarray | np.unique</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jaime Fernández del Río</span></span><br><span class="line"></span><br><span class="line">Z = np.random.randint(<span class="number">0</span>,<span class="number">2</span>,(<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line">T = np.ascontiguousarray(Z).view(np.dtype((np.void, Z.dtype.itemsize * Z.shape[<span class="number">1</span>])))</span><br><span class="line">_, idx = np.unique(T, return_index=<span class="literal">True</span>)</span><br><span class="line">uZ = Z[idx]</span><br><span class="line"><span class="built_in">print</span>(uZ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Andreas Kouzelis</span></span><br><span class="line"><span class="comment"># NumPy &gt;= 1.13</span></span><br><span class="line">uZ = np.unique(Z, axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(uZ)</span><br></pre></td></tr></table></figure><h4id="considering-2-vectors-a-b-write-the-einsum-equivalent-of-inner-outer-sum-and-mul-function">97.Considering 2 vectors A &amp; B, write the einsum equivalent of inner,outer, sum, and mul function (★★★)</h4><p><code>hint: np.einsum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Alex Riley</span></span><br><span class="line"><span class="comment"># Make sure to read: http://ajcr.net/Basic-guide-to-einsum/</span></span><br><span class="line"></span><br><span class="line">A = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">B = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">np.einsum(<span class="string">&#x27;i-&gt;&#x27;</span>, A)       <span class="comment"># np.sum(A)</span></span><br><span class="line">np.einsum(<span class="string">&#x27;i,i-&gt;i&#x27;</span>, A, B) <span class="comment"># A * B</span></span><br><span class="line">np.einsum(<span class="string">&#x27;i,i&#x27;</span>, A, B)    <span class="comment"># np.inner(A, B)</span></span><br><span class="line">np.einsum(<span class="string">&#x27;i,j-&gt;ij&#x27;</span>, A, B)    <span class="comment"># np.outer(A, B)</span></span><br></pre></td></tr></table></figure><h4id="considering-a-path-described-by-two-vectors-xy-how-to-sample-it-using-equidistant-samples">98.Considering a path described by two vectors (X,Y), how to sample itusing equidistant samples (★★★)?</h4><p><code>hint: np.cumsum, np.interp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Bas Swinckels</span></span><br><span class="line"></span><br><span class="line">phi = np.arange(<span class="number">0</span>, <span class="number">10</span>*np.pi, <span class="number">0.1</span>)</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">x = a*phi*np.cos(phi)</span><br><span class="line">y = a*phi*np.sin(phi)</span><br><span class="line"></span><br><span class="line">dr = (np.diff(x)**<span class="number">2</span> + np.diff(y)**<span class="number">2</span>)**<span class="number">.5</span> <span class="comment"># segment lengths</span></span><br><span class="line">r = np.zeros_like(x)</span><br><span class="line">r[<span class="number">1</span>:] = np.cumsum(dr)                <span class="comment"># integrate path</span></span><br><span class="line">r_int = np.linspace(<span class="number">0</span>, r.<span class="built_in">max</span>(), <span class="number">200</span>) <span class="comment"># regular spaced path</span></span><br><span class="line">x_int = np.interp(r_int, r, x)       <span class="comment"># integrate path</span></span><br><span class="line">y_int = np.interp(r_int, r, y)</span><br></pre></td></tr></table></figure><h4id="given-an-integer-n-and-a-2d-array-x-select-from-x-the-rows-which-can-be-interpreted-as-draws-from-a-multinomial-distribution-with-n-degrees-i.e.-the-rows-which-only-contain-integers-and-which-sum-to-n.">99.Given an integer n and a 2D array X, select from X the rows which can beinterpreted as draws from a multinomial distribution with n degrees,i.e., the rows which only contain integers and which sum to n.(★★★)</h4><p><code>hint: np.logical_and.reduce, np.mod</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Evgeni Burovski</span></span><br><span class="line"></span><br><span class="line">X = np.asarray([[<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">3.0</span>, <span class="number">8.0</span>],</span><br><span class="line">                [<span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">                [<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">M = np.logical_and.reduce(np.mod(X, <span class="number">1</span>) == <span class="number">0</span>, axis=-<span class="number">1</span>)</span><br><span class="line">M &amp;= (X.<span class="built_in">sum</span>(axis=-<span class="number">1</span>) == n)</span><br><span class="line"><span class="built_in">print</span>(X[M])</span><br></pre></td></tr></table></figure><h4id="compute-bootstrapped-95-confidence-intervals-for-the-mean-of-a-1d-array-x-i.e.-resample-the-elements-of-an-array-with-replacement-n-times-compute-the-mean-of-each-sample-and-then-compute-percentiles-over-the-means.">100.Compute bootstrapped 95% confidence intervals for the mean of a 1D arrayX (i.e., resample the elements of an array with replacement N times,compute the mean of each sample, and then compute percentiles over themeans). (★★★)</h4><p><code>hint: np.percentile</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Jessica B. Hamrick</span></span><br><span class="line"></span><br><span class="line">X = np.random.randn(<span class="number">100</span>) <span class="comment"># random 1D array</span></span><br><span class="line">N = <span class="number">1000</span> <span class="comment"># number of bootstrap samples</span></span><br><span class="line">idx = np.random.randint(<span class="number">0</span>, X.size, (N, X.size))</span><br><span class="line">means = X[idx].mean(axis=<span class="number">1</span>)</span><br><span class="line">confint = np.percentile(means, [<span class="number">2.5</span>, <span class="number">97.5</span>])</span><br><span class="line"><span class="built_in">print</span>(confint)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;numpy-exercises&quot;&gt;100 numpy exercises&lt;/h1&gt;
&lt;p&gt;&lt;a
href=&quot;https://colab.research.google.com/drive/1I-RFqhrOUz0Vq4aZ-iT_CfTNJdLIGdie#scrollTo=1a84bed8&quot;&gt;100_Numpy_exercises.ipynb
- Colab (google.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is a collection of exercises that have been collected in the
numpy mailing list, on stack overflow and in the numpy documentation.
The goal of this collection is to offer a quick reference for both old
and new users but also to provide a set of exercises for those who
teach.&lt;/p&gt;
&lt;h4 id=&quot;import-the-numpy-package-under-the-name-np&quot;&gt;1. Import the numpy
package under the name &lt;code&gt;np&lt;/code&gt; (★☆☆)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;hint: import … as&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;print-the-numpy-version-and-the-configuration&quot;&gt;2. Print the
numpy version and the configuration (★☆☆)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;hint: np.__version__, np.show_config)&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(np.__version__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;np.show_config()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="numpy" scheme="https://cuiluyi.gitee.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】</title>
    <link href="https://cuiluyi.gitee.io/2024/04/13/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/04/13/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/</id>
    <published>2024-04-13T01:40:37.000Z</published>
    <updated>2024-05-03T09:50:34.313Z</updated>
    
    <content type="html"><![CDATA[<ul><li>以下<strong>数据结构</strong>都是采用<strong>数组</strong>模拟实现（而非 C++ STL容器），效率更高、支持更多操作</li></ul><h1 id="链表">链表</h1><h2 id="单向链表">单(向)链表</h2><ul><li><font color='red'><strong>空指针用 -1 表示</strong></font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7966770/">AcWing826. 单链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数 x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 x 插到下标是 k 的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是 k 的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="双向链表">双(向)链表</h2><ul><li>双链表实现中：0 号节点表示头节点，1 号节点表示尾节点</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7968200/">AcWing827. 双链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// l[i] 表示节点i的左指针</span></span><br><span class="line"><span class="comment">// r[i] 表示节点i的右指针是多少</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在节点 k 的右边插入一个数 x */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在节点 k 的左边插入一个数 x，则调用insert(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除节点 k */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈">栈</h1><h2 id="模板">模板</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7970372/">AcWing828. 模拟栈 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶元素下标</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt;= 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8210610/">AcWing3302. 表达式求值 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/decode-string/">394.字符串解码 - 力扣（LeetCode）</a></p></li></ul><h1 id="队列">队列</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405010825313.png"alt="image-20240501082529059" /><figcaption aria-hidden="true">image-20240501082529059</figcaption></figure><h2 id="普通队列">普通队列</h2><ul><li><p>缺点：如果元素多次进队出队，我们就需要将 <code>q[N]</code> 的大小<code>N</code> 设置的非常大，因此有可能出现 <spanclass="math inline">\(MLE\)</span></p></li><li><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7971050/">AcWing829. 模拟队列 - AcWing</a>】</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><p><strong>优点</strong>：</p><ul><li>假设在使用过程中，<strong>队列的最大长度为 <spanclass="math inline">\(N\)</span></strong>，则<code>int q[N]</code>，这样不会因为 <spanclass="math inline">\(N\)</span> 太大而 <spanclass="math inline">\(MLE\)</span>，节省空间</li><li><span class="math inline">\(C++ \ STL\)</span> 中的<code>queue&lt;&gt;</code> 就是循环队列</li><li>当我们需要使用<strong>循环队列</strong>的时候（如 SPFA算法），建议直接使用 <span class="math inline">\(C++ \ STL\)</span> 中的<code>queue&lt;&gt;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;<span class="comment">// Attention!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈">单调栈</h1><h2 id="模板-1">模板</h2><ul><li>找出每个数左边离它最近的比它<strong>小</strong>的数——维护（严格）递<strong>增</strong>栈</li><li>找出每个数左边离它最近的比它<strong>大</strong>的数——维护（严格）递<strong>减</strong>栈</li><li>单调栈既可以存储这个<strong>数本身</strong>，也可以存储这个<strong>数对应的下标</strong>【更常用】</li><li>单调栈对应的题目，建议数组<strong>下标从 <spanclass="math inline">\(1\)</span> 开始存储</strong>，这样可以设置<code>q[0]</code>、<code>q[n + 1]</code> 为哨兵</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> q[N], tt = <span class="number">-1</span>;<span class="comment">// tt == -1 说明单调栈空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(q[tt], i))</span><br><span class="line">        tt--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">    <span class="keyword">if</span>(tt == <span class="number">-1</span>)</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    q[++tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7971357/">AcWing830. 单调栈 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8360904/">AcWing131. 直方图中最大的矩形 - AcWing</a></p></li><li><p><a href="https://www.acwing.com/solution/content/230459/">AcWing1574. 接雨水 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8377166/">AcWing1413. 矩形牛棚（每日一题） - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/daily-temperatures/description/">739.每日温度 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/min-stack/description/">155. 最小栈 -力扣（LeetCode）</a></p></li></ul><h1 id="单调队列">单调队列</h1><p>​ <strong>单调队列</strong>实际上是<strong>双端队列</strong></p><h2 id="模板-2">模板</h2><p>常见模型：找出<strong>滑动窗口</strong>中的<strong>最大值/最小值</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181602001.png"alt="image-20240307130347476" /><figcaption aria-hidden="true">image-20240307130347476</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 此时，单调队列的 tt == i - 1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) <span class="comment">// 维持单调队列</span></span><br><span class="line">        tt--;</span><br><span class="line">    q[++tt] = i;                         <span class="comment">// 将数据加入队尾</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">        hh++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此时，单调队列的 tt == i */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据题目的要求，在第 4 行/第 12 行添加题目的具体逻辑</p></blockquote><p><font color ='red'><strong>单调栈/单调队列总结</strong></font></p><ul><li>先考虑用普通 栈/队列 暴力模拟</li><li>再将普通 栈/队列中没有用的元素删除，看一下<strong>剩下的元素是否有单调性</strong>——单调栈/单调队列</li><li>考虑优化（队头最小/队尾最大/二分查找…）</li></ul><h2 id="例题-2">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7971364/">AcWing154. 滑动窗口 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8405184/">AcWing135. 最大子序和（算法提高课） - AcWing</a></li></ul><h1 id="kmp">KMP</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849900.png"alt="image-20240307143945027" /><figcaption aria-hidden="true">image-20240307143945027</figcaption></figure><ol type="1"><li>若匹配成功，返回<strong>模式串T</strong>在<strong>目标串S</strong>中<strong><font color='red'>首次出现的有效位移</font></strong></li><li>若匹配失败，返回1</li></ol><!--more--><p>注意：</p><ul><li>主串 <code>S[]</code> 、模式串 <code>P[]</code>、<code>next[]</code> 均从下标 1 开始存储</li><li>每次 <code>S[i]</code> 与 <code>P[j + 1]</code> 比较<ul><li>当 <code>S[i] == P[j + 1]</code> 时，<code>i++, j++;</code></li><li>当 <code>S[i] != P[j + 1]</code> 时，<code>j = next[j];</code></li></ul></li><li><code>i</code>一直往前走，不会后退</li><li><code>j</code> 在 <code>S[i]</code> 与 <code>P[j + 1]</code>不匹配时会向后退，退到 <code>next[j]</code> 处</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849828.png"alt="a8e37396968a427a0efaffde2c68e78" /><figcaptionaria-hidden="true">a8e37396968a427a0efaffde2c68e78</figcaption></figure><ul><li><code>next[i]</code> 表示 <code>P[1…i]</code>最大前缀与后缀相等的长度（一定小于<code>i</code>，不能自己与自己相等~）</li><li><code>next[]</code>是通过模板串<strong>自己与自己匹配</strong>操作得出来的（代码和匹配操作几乎一样）<ul><li>next[0]=next[1]=0</li><li>由于是从 <code>i =2</code> 开始求<code>next[]</code>，所以：<ul><li>不可能匹配成功（不需要<code>j == m</code>的判断）</li><li><code>j &lt; i</code>，回退时 <code>next[j]</code> 一定存在</li></ul></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849565.jpeg"alt="3ff244326727713da33759bd2784289" /><figcaptionaria-hidden="true">3ff244326727713da33759bd2784289</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7973749/">AcWing831. KMP字符串 - AcWing</a>】</li><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n)\)</span>，<spanclass="math inline">\(n\)</span> 为长文本主串的长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本</span></span><br><span class="line"><span class="comment">// p[]是模式串</span></span><br><span class="line"><span class="comment">// n 是 s 的长度</span></span><br><span class="line"><span class="comment">// m 是 p 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求模式串的Next数组：*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到0处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 此时 j 的长度即为 next[i] 最大前缀与后缀相等的长度</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配过程 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到0处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 j 移动到下一次比较的位置</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">/* 匹配成功后的逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><h1 id="trie树">Trie树</h1><h2 id="模板-3">模板</h2><p>​<strong>Trie</strong>：高效地<strong>存储</strong>和<strong>查找</strong>字符串/二进制数 集合的数据结构</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403071732565.png"alt="image-20240307173227428" /><figcaption aria-hidden="true">image-20240307173227428</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[i][j]存储树中每个节点的子节点下标</span></span><br><span class="line"><span class="comment">// cnt[i]存储以 i 号节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入一个字符串 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++idx;<span class="comment">// 不能是 idx++，因为son[0][]存放的是根节点，从下标 1 开始存储</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询字符串出现的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>]</span><br></pre></td></tr></table></figure><ul><li><p>存储 <span class="math inline">\(Trie\)</span>树的<strong>所有边</strong></p></li><li><p><code>N</code>为 Trie树中的<strong>节点总数</strong>，每个节点存储一个字符</p><p><span class="math inline">\(26\)</span> 为字符集大小，每个节点最多有<span class="math inline">\(26\)</span>​个<strong>子</strong>节点</p></li><li><p><code>cnt[i][]</code> 存储 <span class="math inline">\(i\)</span>号节点的所有出边</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt[N]</span><br></pre></td></tr></table></figure><ul><li><p><code>cnt[i]</code> 存储以 <span class="math inline">\(i\)</span>号节点结尾的单词数量</p></li><li><p><code>N</code>为 Trie树中的<strong>节点总数</strong>，每个节点存储一个字符</p></li></ul><blockquote><p><code>N</code> 为Trie树的节点总数，通常设置为<strong>字符串总长度（字符串个数 *每个字符串的最大长度）</strong>，尽管实际用到的并没有这么大</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405030901945.jpg"alt="39a1de1f1123e8398c88060337b97c8" /><figcaptionaria-hidden="true">39a1de1f1123e8398c88060337b97c8</figcaption></figure><h2 id="例题-3">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7975276/">AcWing835. Trie字符串统计 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8469979/">AcWing142. 前缀统计 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8217089/">AcWing143. 最大异或对 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8470950/">AcWing144. 最长异或值路径 - AcWing</a></li></ul><h1 id="并查集">并查集</h1><ul><li><strong>核心操作</strong></li></ul><ol type="1"><li>合并两个集合</li><li>查询某个元素的祖宗节点</li></ol><ul><li><strong>基本原理：</strong></li></ul><p>​每个集合用一棵树来表示。<strong>树根</strong>的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code>表示 <code>x</code> 的父节点</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081538288.png"alt="image-20240308153805104" /><figcaption aria-hidden="true">image-20240308153805104</figcaption></figure><h2 id="朴素并查集">朴素并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集是可以用来维护很多额外信息的，如集合大小sz，到祖宗节点距离 d等等</p></blockquote><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7986586/">AcWing836. 合并集合 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8359238/">AcWing528. 奶酪（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8368371/">AcWing1250. 格子游戏（算法提高课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8405592/">AcWing1252. 搭配购买 - AcWing</a></p></li></ul><h2 id="维护大小-sz-的并查集">维护大小 sz 的并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// sz[]只对祖宗节点有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"><span class="type">int</span> p[N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    sz[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">sz[<span class="built_in">find</span>(b)] += sz[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7986712/">AcWing837. 连通块中点的数量 - AcWing</a></li></ul><h2 id="维护到祖宗节点距离-d-的并查集">维护到祖宗节点距离 d的并查集</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181631186.jpeg"alt="JIE.jpg" /><figcaption aria-hidden="true">JIE.jpg</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// d[x]存储 x 到 p[x] 的距离</span></span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];<span class="comment">// d[x]存储 x 到 p[x] 的距离，</span></span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7987057/">AcWing240. 食物链 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8407527/">AcWing238. 银河英雄传说 - AcWing</a></p></li></ul><h1 id="堆">堆</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036286.png"alt="image-20230916123313335" /><figcaption aria-hidden="true">image-20230916123313335</figcaption></figure><p><strong>堆的特性：</strong></p><ul><li>结构性：==采用<strong><font color='blue'>数组存储</font></strong>的<strong><font color='red'>完全二叉树</font></strong>==<ul><li>从<font color='red'><code>h[1]</code>开始存储数据</font>，<code>h[0]</code>用来存放==<strong>哨兵</strong>==</li><li><code>i</code> 的左儿子 <code>2 * i</code>，右儿子<code>2 * i + 1</code></li></ul></li><li>有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)<ul><li>“<strong>最大堆(MaxHeap)</strong>”，也称“<strong>大顶堆</strong>”：任一结点的<code>data</code>大于其所有子树结点的<code>data</code></li><li>“<strong>最小堆(MinHeap)</strong>”，也称“<strong>小顶堆</strong>”：任一结点的<code>data</code>小于其所有子树结点的<code>data</code></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036053.png"alt="image-20230916123453824" /><figcaption aria-hidden="true">image-20230916123453824</figcaption></figure><p><strong>堆的实现：</strong></p><ul><li><p>使用数组来模拟堆，堆中的数据从 <code>h[1]</code> 开始存储</p><blockquote><p>因为如果从0开始存储，根节点0按照公式计算得到的左右节点都是0，显然不成了，需要特判，麻烦</p></blockquote></li><li><p>所有关于堆的操作均建立在堆的 <code>down()</code> 和<code>up()</code> 函数基础上</p></li></ul><h2 id="模板1">模板1</h2><p>​ 如果只希望实现与C++ STL堆中相同的功能1、2、3，则堆的下滤和上滤操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N] 存储堆中的值, h[1] 是堆顶，x 的左儿子是 2x, 右儿子是 2x + 1</span></span><br><span class="line"><span class="comment">// sz 是堆中元素的个数</span></span><br><span class="line"><span class="type">int</span> h[N], sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= sz &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= sz &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>down() 注意：</p><ol type="1"><li>down 操作需要保证左右儿子是堆</li><li>t 是根节点 <code>h[u]</code>, 左儿子 <code>h[2 * u]</code>, 右儿子<code>h[2 * u + 1]</code>中最小值的下标</li><li><code>2 * u &lt;= sz</code>说明存在左儿子，<code>2 * u + 1 &lt;= sz</code> 说明存在右儿子</li></ol><p>up() 注意：</p><ol type="1"><li><code>u / 2 != 0</code> 说明存在父节点</li></ol></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[++sz] = x;</span><br><span class="line"><span class="built_in">up</span>(sz);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>] = h[sz--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">sz = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="模板2">模板2</h2><p>​ 如果希望实现在 C++ STL堆中功能的基础上，添加在任意位置修改/删除的功能，需要存储映射：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036897.png" alt="image-20240308101556244" style="zoom:15%;" /></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036983.jpeg" alt="b9b669b4a3a28e34e104b0c5bda7d7c" style="zoom:13%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N] 存储堆中的值, h[1] 是堆顶，x 的左儿子是 2x, 右儿子是 2x + 1</span></span><br><span class="line"><span class="comment">// ph[k] 存储第 k 个插入的点在堆中的下标p:pointer</span></span><br><span class="line"><span class="comment">// hp[k] 存储堆中下标是 k 的点是第几个插入的h:heap</span></span><br><span class="line"><span class="comment">// sz 是堆中元素的个数</span></span><br><span class="line"><span class="comment">// m 是当前堆中插入操作的次数</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], sz, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换 h[] 中的两个点，及其映射关系 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= sz &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= sz &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>p:pointer</li><li>h:heap</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sz++, m++;</span><br><span class="line">h[sz] = x, hp[sz] = m, ph[m] = sz;</span><br><span class="line"><span class="built_in">up</span>(sz);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">heap_swap</span>(<span class="number">1</span>, sz--);</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除第 k 个插入的数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line"><span class="built_in">heap_swap</span>(k, sz--);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改第 k 个插入的数,将其变为 x</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><blockquote><p>修改后的值与原来值相比，有3种情况</p><ul><li>相等：不需要调整堆</li><li>小于：up(k)</li><li>大于：down(k)</li></ul><p>把上面 3 种情况综合考虑，不管是相等/大于/小于，为了简单起见:</p><ul><li>如果修改h[1]：down(1)</li><li>在最后插入数据：up(++size)</li><li>如果修改其他： up(k); down(k)</li></ul><p>【实际运行时要么都不执行，要么只 up(k) ，要么只 down(k) 】</p></blockquote><ol start="6" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">sz = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="例题-4">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7979479/">AcWing838. 堆排序 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7983190/">AcWing839. 模拟堆 - AcWing</a></li></ul><h1 id="哈希表">哈希表</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081905012.png" alt="image-20240308190529753" style="zoom: 25%;" /></p><ul><li>离散化是一种<strong>极其特殊</strong>的哈希方式（数据有序排列）</li><li>在算法题中，通常在哈希表 查找/添加 元素，而不会 删除 元素</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081918152.png"alt="image-20240308191829923" /><figcaption aria-hidden="true">image-20240308191829923</figcaption></figure><h2 id="一般哈希">一般哈希</h2><h3 id="拉链法">拉链法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x,ne[idx] = h[k],h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这里的 N 通常取质数eg：100003</li></ul></blockquote><h3 id="开放寻址法">开放寻址法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span> (t == N)</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希">字符串哈希</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403082108366.png" alt="image-20240308210833057" style="zoom: 50%;" /></p><ul><li><strong>核心思想</strong>：将字符串（注意不能把某个字符映射成0）看成 P 进制数， P 的经验值是 131 或13331，取这两个值的冲突概率低</li><li><strong>小技巧</strong>：取模的数Q用 <spanclass="math inline">\(2^{64}\)</span>​，这样直接用<code>unsigned long long</code>存储，溢出的结果就是取模的结果</li><li><strong>注意</strong>：字符串哈希非常有用的利器，是KMP的劲敌，字符串哈希除了循环节不能处理，其他均可代替KMP</li><li><code>str[]</code> 从下标 1 开始存储</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">// h[k]存储字符串前k个字母 str[1 ~ k] 的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 h[ ], p[ ]</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结</p><ol type="1"><li>把字符串看成是一个 P 进制数，每个字符的 ASCII 码对应数的一位</li><li>ASCII 范围 0 - 127，最少 128 进制，经验上取 131 或 13331冲突率低</li><li>字符串很长，对应的数太大，通过模 <spanclass="math inline">\(2^{64}\)</span> 把它映射到 <spanclass="math inline">\([0, 2^{64} - 1]\)</span></li><li>用 <code>unsigned long long</code> 存储，溢出相当于对 <spanclass="math inline">\(2^{64}\)</span> 取模，省略了手动运算</li><li>该方法的好处是，可以利用前缀哈希直接求出子串哈希（减去高位）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(DEF) = <span class="built_in">hash</span>(ABCDEF) - <span class="built_in">hash</span>(ABC) x P^<span class="number">3</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">    A       B       C       D       E       F  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">5</span> + <span class="number">2</span>xP^<span class="number">4</span> + <span class="number">3</span>xP^<span class="number">3</span> + <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                            D       E       F</span><br><span class="line">                          <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    A       B       C  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">2</span> + <span class="number">2</span>xP^<span class="number">1</span> + <span class="number">3</span>xP^<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意点</p><ol type="1"><li><strong>不要把某一位映射成 P 进制 0</strong>，例如，A 如果是 0，则AA 也是 0，就会出现冲突</li><li><code>\0</code> 的 ASCII 是 0，本题不出现该字符，不用担心上一点</li><li>使用这种方法就假定了人品足够好，不出现冲突</li></ol><h2 id="例题-5">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7988981/">AcWing840. 模拟散列表 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7992616/">AcWing841. 字符串哈希 - AcWing</a></li></ul><h1 id="树状数组">树状数组</h1><ul><li>作用：动态维护前缀和</li><li>基本操作：<ul><li><strong>单点修改</strong>：给某个位置上的数加上一个数——<spanclass="math inline">\(O(logn)\)</span></li><li><strong>区间查询</strong>：求某一个前缀和——<spanclass="math inline">\(O(logn)\)</span>​</li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404141335555.png"alt="image-20240414133510262" /><figcaption aria-hidden="true">image-20240414133510262</figcaption></figure><ul><li>树状数组 vs 前缀和</li></ul><table><thead><tr class="header"><th></th><th>单点修改</th><th>区间查询</th></tr></thead><tbody><tr class="odd"><td>树状数组</td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="even"><td>前缀和</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td></tr></tbody></table><h1 id="线段树">线段树</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;以下&lt;strong&gt;数据结构&lt;/strong&gt;
都是采用&lt;strong&gt;数组&lt;/strong&gt;模拟实现（而非 C++ STL
容器），效率更高、支持更多操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;链表&quot;&gt;链表&lt;/h1&gt;
&lt;h2 id=&quot;单向链表&quot;&gt;单(向)链表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#39;red&#39;&gt;&lt;strong&gt;空指针用 -1 表示&lt;/strong&gt;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;【&lt;strong&gt;模板题：&lt;/strong&gt;&lt;a
href=&quot;https://www.acwing.com/activity/content/code/content/7966770/&quot;&gt;AcWing
826. 单链表 - AcWing&lt;/a&gt;】&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; N = &lt;span class=&quot;number&quot;&gt;100005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// head 表示头结点的下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// e[i] 表示节点i的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ne[i] 表示节点i的next指针是多少&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// idx 存储当前已经用到了哪个点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; head, e[N], ne[N], idx;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    idx = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在链表头插入一个数 x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert_to_head&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e[idx] = x, ne[idx] = head, head = idx++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将 x 插到下标是 k 的点后面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; k, &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将头结点删除，需要保证头结点存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove_head&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head = ne[head];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 将下标是 k 的点后面的点删掉&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ne[k] = ne[ne[k]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>联邦学习</title>
    <link href="https://cuiluyi.gitee.io/2024/04/08/[object%20Object]/AI/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cuiluyi.gitee.io/2024/04/08/[object%20Object]/AI/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-04-08T05:59:27.000Z</published>
    <updated>2024-04-12T01:12:54.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联邦学习">联邦学习</h1><p>​ 联邦学习（Federated Learning, a.k.a. Federated MachineLearning）可以分为三类：横向联邦学习（Horizontal FederatedLearning），纵向联邦学习（Vertical FederatedLearning），联邦迁移学习（Federated Transfer Learning）[1, 2]。</p><p>​有不少读者说，横向联邦学习和纵向联邦学习容易混淆，不太清楚为什么这么分类。我在这里再解释一下横向联邦学习和纵向联邦学习。</p><h2 id="横向联邦学习"><strong>横向联邦学习</strong></h2><p>​数据矩阵（也可以是表格，例如，Excel表格）的横向的一行表示一条训练样本，纵向的一列表示一个数据特征（或者标签）。通常用表格查看数据（例如，病例数据），用一行表示一条训练样本比较好，因为可能有很多条数据。</p><p>​横向联邦学习，适用于参与者的<font color = 'red'><strong>数据特征重叠较多，而样本ID重叠较少</strong></font>的情况，例如，两家<strong>不同地区</strong>的银行的客户数据[1, 2]。“横向”二字来源于数据的“<strong>横向划分（horizontalpartitioning, a.k.a.sharding）</strong>”。如图1所示例，联合多个参与者的具有<strong>相同特征</strong>的多行样本进行联邦学习，即各个参与者的训练数据是<strong>横向划分</strong>的，称为<strong>横向联邦学习</strong>。图2给出了一个<strong>横向划分</strong>表格的示例。横向联邦使训练样本的<strong>总数量增加</strong>。</p><p>​横向联邦学习也称为<strong>特征对齐的联邦学习</strong>（Feature-AlignedFederatedLearning），即横向联邦学习的参与者的数据特征是对齐的，如图3所示例。“特征对齐的联邦学习”这个名字有点长，还是用“横向联邦学习”比较好。</p><span id="more"></span><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922927.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图1 横向联邦学习示例，横向联邦使训练样本量增大    &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922833.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图2 横向（按行）划分数据示例 &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922372.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图3 横向联邦学习，也称为特征对齐的联邦学习，横向联邦使训练样本量增大 &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="纵向联邦学习">纵向联邦学习</h2><p>​纵向联邦学习，适用于参与者<font color = 'red'><strong>训练样本ID重叠较多，而数据特征重叠较少</strong></font>的情况，例如，<strong>同一地区</strong>的银行和电商的共同的客户数据[1, 2]。“纵向”二字来源于数据的“<strong>纵向划分（verticalpartitioning）</strong>”。如图4所示例，联合多个参与者的共同样本的不同数据特征进行联邦学习，即各个参与者的训练数据是<strong>纵向划分</strong>的，称为<strong>纵向联邦学习</strong>。图5给出了一个<strong>纵向划分</strong>表格的示例。纵向联邦学习需要先做样本对齐，即找出参与者拥有的<strong>共同样本</strong>，也就叫“数据库撞库（entityresolution, a.k.a. entityalignment）”。只有联合多个参与者的共同样本的不同特征进行纵向联邦学习，才有意义。纵向联邦使训练样本的<strong>特征维度增多</strong>。</p><p>​纵向联邦学习也称为<strong>样本对齐的联邦学习</strong>（Sample-AlignedFederatedLearning），即纵向联邦学习的参与者的训练样本是对齐的，如图6所示例。“样本对齐的联邦学习”这个名字有点长，还是用“纵向联邦学习”比较好。</p><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-9bccacdd69689d782c0e9d896df3e3c4_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图4 纵向联邦学习示例，纵向联邦使训练数据特征维度增加&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-6a71c9b0697c4afb7bfc17569442ffc6_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图5 纵向（按列）划分数据示例&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-cfb91e1c746ea4343f4b3ac27ba204ca_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图6 纵向联邦学习，也称为样本对齐的联邦学习，纵向联邦使训练数据特征维度增加&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="小节">小节</h2><p>​<strong>横向联邦学习</strong>的名称来源于训练数据的“<strong>横向划分</strong>”，也就是数据矩阵或者表格的按行（横向）划分。不同行的数据有相同的数据特征，即数据特征是对齐的。</p><p>​<strong>纵向联邦学习</strong>的名称来源于训练数据的“<strong>纵向划分</strong>”，也就是数据矩阵或者表格的按列（纵向）划分。不同列的数据有相同的样本ID，即训练样本是对齐的。</p><p>[1] Qiang Yang, Yang Liu, Tianjian Chen, and Yongxin Tong, "FederatedMachine Learning: Concept and Applications," Feb. 2019. Available: <ahref="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1902.04885">https://arxiv.org/abs/1902.04885</a></p><p>[2] 杨强，刘洋，陈天健，童咏昕，“联邦学习”，Nov. 2018. Available: <ahref="https://link.zhihu.com/?target=https%3A//dl.ccf.org.cn/institude/institudeDetail%3Fid%3D4150944238307328%26from%3Dgroupmessage%26isappinstalled%3D0%26_ack%3D1">https://dl.ccf.org.cn/institude/institudeDetail?id=4150944238307328&amp;from=groupmessage&amp;isappinstalled=0&amp;_ack=1</a>,or <ahref="https://link.zhihu.com/?target=https%3A//wemp.app/posts/a3771dc7-6722-4690-bf25-23ba36f7b78c%3Futm_source%3Dlatest-posts">https://wemp.app/posts/a3771dc7-6722-4690-bf25-23ba36f7b78c?utm_source=latest-posts</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;联邦学习&quot;&gt;联邦学习&lt;/h1&gt;
&lt;p&gt;​ 联邦学习（Federated Learning, a.k.a. Federated Machine
Learning）可以分为三类：横向联邦学习（Horizontal Federated
Learning），纵向联邦学习（Vertical Federated
Learning），联邦迁移学习（Federated Transfer Learning）[1, 2]。&lt;/p&gt;
&lt;p&gt;​
有不少读者说，横向联邦学习和纵向联邦学习容易混淆，不太清楚为什么这么分类。我在这里再解释一下横向联邦学习和纵向联邦学习。&lt;/p&gt;
&lt;h2 id=&quot;横向联邦学习&quot;&gt;&lt;strong&gt;横向联邦学习&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​
数据矩阵（也可以是表格，例如，Excel表格）的横向的一行表示一条训练样本，纵向的一列表示一个数据特征（或者标签）。通常用表格查看数据（例如，病例数据），用一行表示一条训练样本比较好，因为可能有很多条数据。&lt;/p&gt;
&lt;p&gt;​
横向联邦学习，适用于参与者的&lt;font color = &#39;red&#39;&gt;&lt;strong&gt;数据特征重叠较多，而样本ID重叠较少&lt;/strong&gt;&lt;/font&gt;的情况，例如，两家&lt;strong&gt;不同地区&lt;/strong&gt;的银行的客户数据
[1, 2]。“横向”二字来源于数据的“&lt;strong&gt;横向划分（horizontal
partitioning, a.k.a.
sharding）&lt;/strong&gt;”。如图1所示例，联合多个参与者的具有&lt;strong&gt;相同特征&lt;/strong&gt;的多行样本进行联邦学习，即各个参与者的训练数据是&lt;strong&gt;横向划分&lt;/strong&gt;的，称为&lt;strong&gt;横向联邦学习&lt;/strong&gt;。图2给出了一个&lt;strong&gt;横向划分&lt;/strong&gt;表格的示例。横向联邦使训练样本的&lt;strong&gt;总数量增加&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​
横向联邦学习也称为&lt;strong&gt;特征对齐的联邦学习&lt;/strong&gt;（Feature-Aligned
Federated
Learning），即横向联邦学习的参与者的数据特征是对齐的，如图3所示例。“特征对齐的联邦学习”这个名字有点长，还是用“横向联邦学习”比较好。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://cuiluyi.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>FLOPs&amp;&amp;FLOPS</title>
    <link href="https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/FLOPs&amp;&amp;FLOPS/"/>
    <id>https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/FLOPs&amp;&amp;FLOPS/</id>
    <published>2024-04-06T05:59:27.000Z</published>
    <updated>2024-04-07T07:50:01.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flopsflops">FLOPs&amp;&amp;FLOPS</h1><h2 id="什么是flops">什么是flops</h2><p>对flops有疑惑，首先得先捋清这个概念：</p><ul><li><strong>FLOPS</strong>：注意全大写，是floating point operations per<strong>second</strong>的缩写，意指<strong>每秒浮点运算次数</strong>，理解为<strong>计算速度</strong>。是一个<strong>衡量硬件性能</strong>的指标。</li><li><strong>FLOPs</strong>：注意s小写，是floating pointoperations的缩写（<strong>s表复数</strong>），意指<strong>浮点运算数</strong>，理解为<strong>计算量</strong>。可以用来<strong>衡量算法/模型的复杂度</strong>。</li></ul><p>网上打字很容易全小写，造成混淆，本问题针对模型，应指的是FLOPs。</p><p>我们知道，通常我们去<strong>评价一个模型时，首先看的应该是它的精确度</strong>，当你精确度不行的时候，你和别人说我的模型预测的多么多么的快，部署的时候占的内存多么多么的小，都是白搭。但当你模型达到一定的精确度之后，就需要更<strong>进一步的评价指标来评价你模型</strong>：1）<strong>前向传播时所需的计算力</strong>，它反应了对硬件如GPU性能要求的高低；2）<strong>参数个数</strong>，它反应所占内存大小。为什么要加上这两个指标呢？因为这事关你模型算法的落地。比如你要在手机和汽车上部署深度学习模型，对模型大小和计算力就有严格要求。模型参数想必大家都知道是什么怎么算了，而前向传播时所需的计算力可能还会带有一点点疑问。所以这里总计一下前向传播时所需的计算力。它正是由<strong>FLOPs</strong>体现，那么<strong>FLOPs</strong>该怎么计算呢？</p><h2 id="如何计算flops">如何计算flops</h2><p>我们知道，在一个模型进行前向传播的时候，会进行卷积、池化、BatchNorm、Relu、Upsample等操作。这些操作的进行都会有其对应的计算力消耗产生，其中，卷积所对应的计算力消耗是所占比重最高的。所以，我们这里主要讲一下卷积操作所对应的计算力。</p><p>我们以下图为例进行讲解：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421083.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>先说结论：卷积层 计算力消耗 等于上图中两个立方体 (绿色和橙色)体积的乘积。即flops =</p><p><strong>推导过程：</strong>卷积层 wx + b需要计算两部分，首先考虑前半部分 wx 的计算量：</p><p>令 :</p><ul><li>k 表示卷积核大小;</li><li>c 表示输入 feature map 的数量;</li></ul><p>则对于输出 feature map 上的<strong>单个</strong> Unit 有：</p><p><strong><code>k \* k \* c 次乘法，以及 k \* k \* c - 1 次加法</code></strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421090.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>用上图形象化解释就是：</p><p>Image大小为 5x5，卷积核大小为3x3，那么一次3x3的卷积（求右图矩阵一个元素的值）所需运算量：(3x3)个乘法+(3x3-1)个加法= 17。要得到右图convolved feature （3x3的大小）：17x9 = 153</p><p>如果输出 feature map 的分辨率是 H * W ，且输出 o 个 featuremap，则输出 feature map 包含 Unit的总数就是 H * W * o。</p><p>因此，该卷积层在计算 wx 时有:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k * k * c * H * W * o 次乘法          --（1）</span><br><span class="line">(k * k * c - 1) * H * W * o 次加法    --（2）</span><br></pre></td></tr></table></figure><p>再考虑偏置项 b 包含的计算量：</p><p>由于 b 只存在加法运算，输出 feature map 上的每个 Unit做一次偏置项加法。因此，该卷积层在计算偏置项时总共包含：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H * W * o 次加法      --（3）</span><br></pre></td></tr></table></figure><p>将该卷积层的 wx 和 b 两部分的计算次数累计起来就有：</p><p><strong>式(1) 次乘法:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k * k * c * H * W * o 次乘法</span><br></pre></td></tr></table></figure><p><strong>式(2) + 式(3) 次加法:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(k * k * c - 1) * H * W * o  + H * W * o  = k * k * c * H * W * o</span><br></pre></td></tr></table></figure><p><strong>可见，式(2) + 式(3) = 式 (1)</strong></p><p>对于带偏置项的卷积层，乘法运算和加法运算的次数相等，刚好配对。定义一次加法和乘法表示一个flop，该层的计算力消耗为：</p><p><strong><code>k \* k \* c \* H \* W \* o</code></strong></p><p>刚好等于图中两个立方体（绿色和橙色）体积的乘积。全连接层的算法也是一样。</p><h2 id="计算flops的开源库">计算flops的开源库</h2><blockquote><p>作者：留德华叫兽@知乎</p></blockquote><p>示例代码如下，它求出了VGG16的flops和参数量：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421109.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以看到，算上import 和print（）也仅仅6行代码！不仅输出了整个框架的复杂度，还能输出每一层的复杂度以及 该层占整个网络的比重</p><p>最后贴出常见backbone的flops：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421115.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flopsflops&quot;&gt;FLOPs&amp;amp;&amp;amp;FLOPS&lt;/h1&gt;
&lt;h2 id=&quot;什么是flops&quot;&gt;什么是flops&lt;/h2&gt;
&lt;p&gt;对flops有疑惑，首先得先捋清这个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FLOPS&lt;/stron</summary>
      
    
    
    
    
    <category term="AI" scheme="https://cuiluyi.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>throughput</title>
    <link href="https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/throughput/"/>
    <id>https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/throughput/</id>
    <published>2024-04-06T05:59:27.000Z</published>
    <updated>2024-04-06T13:24:22.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="throughput">throughput</h1><p>哟哟哟！！看图了。大模型性能比较指标中，到处都是throughput！到处都是！！！</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061752165.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>真的是到处都是呢！！</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061752217.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><hr /><p>​ <ahref="https://www.zhihu.com/search?q=神经网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">神经网络</a>的吞吐量（Throughput）定义为网络模型在<strong>单位时间内</strong>（例如，1s）<strong>可以处理的最大输入的训练样本数据</strong>。</p><p>​ 与涉及单个样本数据处理的延迟 Latency 不同，为了实现最大吞吐量Throughput，希望在集群训练的过程中并行处理尽可能多的样本数据。有效的并行性显然依赖于数据、模型和设备规模。</p><p>​ 因此，为了正确测量吞吐量，可以执行以下两个步骤：</p><ol type="1"><li>估计允许最大<ahref="https://www.zhihu.com/search?q=并行度&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">并行度</a>的最佳训练样本数据批量大小，即Batch Size</li><li>在AI训练集群中给定这个最佳批量大小，<ahref="https://www.zhihu.com/search?q=测量网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">测量网络</a>在1秒钟内可以处理的训练样本数据。</li></ol><p>​ 要找到最佳批量大小，一个好的经验法则是达到 Ascend <ahref="https://www.zhihu.com/search?q=昇腾处理器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">昇腾处理器</a>对给定数据类型的内存限制，即BatchSize塞满内存。这个大小当然取决于硬件类型和网络的大小。</p><p>​ 找到这个最大批量大小 Batch Size的最快方法是执行二进制搜索。当时间不重要时，简单的<ahref="https://www.zhihu.com/search?q=顺序搜索&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">顺序搜索</a>就足够了。不过在大模型训练的过程中，因为BatchSize比较重要，设计到重计算、Pipeline并行、Tensor并行等不同并行模式的配比，还有包括microBatch Size的数据配比。因此默认Batch Size会为16的倍数增长比较合理。</p><p>​ 这确定了 AI加速卡上可以处理的最大批量大小，用于训练大模型及其处理的输入训练样本数据。在找到最佳批量大小后，可以计算实际吞吐量，然后使用以下公式：<span class="math display">\[sample_{throughput}=BS*N/step_{time}\]</span> 其中，BS 为 Batch Size，N 为集群中AI加速卡的数量，steptime为在分布式集群中，执行完一个BatchSize的时间（单位为s）。大模型训练的<ahref="https://www.zhihu.com/search?q=吞吐率&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">吞吐率</a>的单位在CV和部分NLP任务重为Samples/s，在固定 Shape 的 NLP任务有seqlen，因此单位为tokens/s，计算公式为： <span class="math display">\[tokens_{throughout}=sample_{throughput}*seq_{len}\]</span> ​ 假设GLM10B<ahref="https://www.zhihu.com/search?q=网络模型&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">网络模型</a>的吞吐为25Samples/s，max seq_len 为1024，那么按照tokens来计算吞吐率为 25 * 1024 =25600 tokens/s。也就是每秒能处理2万多个tokens啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;throughput&quot;&gt;throughput&lt;/h1&gt;
&lt;p&gt;哟哟哟！！看图了。大模型性能比较指标中，到处都是throughput！到处都是！！！&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing</summary>
      
    
    
    
    
    <category term="AI" scheme="https://cuiluyi.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AI 集群基础设施&amp;&amp;InfiniBand</title>
    <link href="https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/AI%20%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD&amp;&amp;InfiniBand/"/>
    <id>https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/AI%20%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD&amp;&amp;InfiniBand/</id>
    <published>2024-04-06T05:59:27.000Z</published>
    <updated>2024-04-06T06:47:39.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ai-集群基础设施infiniband">AI集群基础设施&amp;&amp;InfiniBand</h1><p>GPU在高性能计算和深度学习加速中扮演着非常重要的角色，GPU的强大的并行计算能力，大大提升了运算性能。随着运算数据量的不断攀升，GPU间需要大量的交换数据，因此，GPU通信性能成为了非常重要的指标。</p><p>在 AI集群中进行分布式训练时，通信是必要环节，同时也是相比于单机训练而言多出来的系统开销。通信与计算的时间比例往往决定了分布式机器学习系统加速比的上限。</p><p>因此，分布式机器学习的关键是设计通信机制，从而降低通信与计算的时间比例，更加高效地训练出高精度模型。</p><p>下面给大家介绍AI集群通信的软硬件、NCLL集合通信库、InfiniBand网络通信技术协议、AI集群和AI框架中对于InfiniBand的应用。</p><blockquote><p>文章较长，建议先点赞收藏，后续再慢慢观看。另外，我撰写的<strong>大模型相关的博客及配套代码</strong>均整理放置在Github：<strong><ahref="https://link.zhihu.com/?target=https%3A//github.com/liguodongiot/llm-action/tree/main">llm-action</a></strong>，有需要的朋友自取。</p></blockquote><h2 id="通信硬件"><strong>通信硬件</strong></h2><h3 id="通信硬件的实现方式"><strong>通信硬件的实现方式</strong></h3><p>通信的实现方式分为两种类型：机器内通信与机器间通信。</p><ul><li><p>机器内通信：</p><ul><li><p>共享内存（QPI/UPI），比如：CPU与CPU之间的通信可以通过共享内存。</p></li><li><p>PCIe，通常是CPU与GPU之间的通信。</p></li><li><p>NVLink，通常是GPU与GPU之间的通信，也可以用于CPU与GPU之间的通信。</p></li></ul></li><li><p>机器间通信：</p><ul><li><p>TCP/IP 网络协议。</p></li><li><p>RDMA (Remote Direct Memory Access) 网络协议。</p><ul><li>InfiniBand</li><li>iWARP</li><li>RoCE</li></ul></li></ul></li></ul><h3 id="pcie"><strong>PCIe</strong></h3><p>PCI-Express（peripheral component interconnectexpress），简称PCIe，是一种高速串行计算机扩展总线标准，主要用于扩充计算机系统总线数据吞吐量以及提高设备通信速度。</p><p>PCIE本质上是一种全双工的的连接总线，传输数据量的大小由通道数（lane，信道）决定的。</p><p>通常，1个连接通道lane称为X1，<strong>每个通道lane由两对数据线组成，一对发送，一对接收，每对数据线包含两根差分线。即X1只有1个lane，4根数据线</strong>，每个时钟每个方向1bit数据传输。依此类推，X2就有2个lane，由8根数据线组成，每个时钟传输2bit。类似的还有X12、X16、X32。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444411.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>2003 年 PCIe 1.0 正式发布，可支持每通道传输速率为250MB/s，总传输速率为 2.5 GT/s。</p><p>2007 年推出 PCIe 2.0 规范。在 PCIe 1.0的基础上将总传输速率提高了一倍，达到 5 GT/s，每通道传输速率从 250 MB/s上升至 500 MB/s。</p><p>2022 年 PCIe 6.0 规范正式发布，总传输速率提高至 64 GT/s。</p><p>2022年6月，PCI-SIG 联盟宣布 PCIe 7.0版规范，单条通道（x1）单向可实现128 GT/s传输速率，计划于2025年推出最终版本。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444467.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>PCIe吞吐量(可用带宽)计算方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量=传输速率*编码方案</span><br></pre></td></tr></table></figure><p>传输速率为每秒传输量（GT/s），而不是每秒位数（Gbps），是因为传输量包括<strong>不提供额外吞吐量的开销位</strong>，比如：PCIe1x和PCIe 2x使用8b/10b编码方案，导致占用了20%(=2/10)的原始信道带宽。</p><ul><li>GT/s，Giga transtion per second(千兆传输/秒)，即每一秒内传输的次数，重点在于描述物理层通信协议的速率属性，可以不和链路宽度等关联。</li><li>Gbps，Giga Bits per second(千兆位/秒)。GT/s和Gbps之间不存在成比例的换算关系。</li></ul><p>PCIe2.0协议支持5.0GT/s，即每一条Lane上支持每秒钟传输5G个Bit，但这并不意味着PCIe2.0协议的每一条Lane支持5Gbps的速率。为什么这么说呢，因为PCIe2.0的物理层协议中使用的是8b/10b编码方案，即每传输8个Bit，需要发送10个Bit，这多出来的2Bit并不是对上层有意义的信息。那么，PCIe2.0协议的每一条Lane支持<code>5*8/10=4Gbps=500MB/s</code>的速率。以一个PCIe2.0 x8的通道为例，x8的可用带宽为<code>4*8=32Gbps=4GB/s</code>。</p><p>同理，PCIe3.0协议支持8.0GT/s，即每一条Lane上支持每秒钟传输8G个Bit。而PCIe3.0的物理层协议中使用的是128b/130b编码方案，即每传输128个Bit，需要发送130个Bit，那么，PCIe3.0协议的每一条Lane支持<code>8*128/130=7.877GB/s=984.6MB/s</code>的速率。以一个PCIe3.0x16的通道为例，x16的可用带宽为<code>7.877*16=126.032 Gbps=15.754GB/s</code>。</p><p><strong>PCIE体系架构</strong>：</p><p>PCIE体系架构一般包含根组件RC（root-complex），交换器switch，终端设备EP（endpoint）等类型的PCIE设备组成。RC在总线架构中只有一个，用于处理器和内存子系统与I/O设备之间的连接，而switch的功能通常是以软件形式提供的，它包括两个或更多的逻辑PCI到PCI的连接桥（PCI-PCIBridge），以保持与现有PCI兼容。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444428.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvlink"><strong>NVLink</strong></h3><p><strong>背景</strong>：</p><p>算力的提升不仅依靠单张 GPU 卡的性能提升，往往还需要多 GPU卡组合。在多 GPU 系统内部，GPU间通信的带宽通常在数百GB/s以上，PCIe总线的数据传输速率容易成为瓶颈，且PCIe链路接口的串并转换会产生较大延时，影响GPU并行计算的效率和性能。</p><p>GPU发出的信号需要先传递到PCIe Switch, PCIeSwitch中涉及到数据的处理，CPU会对数据进行分发调度，这些都会引入额外的网络延迟，限制了系统性能。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444403.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>为此，NVIDIA推出了能够提升GPU通信性能的技术——GPUDirectP2P技术，使GPU可以通过 PCI Express直接访问目标GPU的显存，避免了通过拷贝到CPU hostmemory作为中转，大大降低了数据交换的延迟，但受限于PCIExpress总线协议以及拓扑结构的一些限制，无法做到更高的带宽。此后，NVIDIA提出了 NVLink 总线协议。</p><p><strong>NVLink简介</strong>：</p><p>NVLink 是一种高速互连技术，旨在加快 CPU 与 GPU、GPU 与 GPU之间的数据传输速度，提高系统性能。NVLink通过GPU之间的直接互联，可扩展服务器内的多GPUI/O，相较于传统PCIe总线可提供更高效、低延迟的互联解决方案。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444911.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>NVLink的首个版本于2014年发布，首次引入了高速GPU互连。2016年发布的P100搭载了第一代NVLink，提供160GB/s 的带宽，相当于当时 PCIe 3.0 x16 带宽（双向）的 5倍。之后陆续发布了很多新版本，V100搭载的 NVLink2 将带宽提升到300GB/s，A100搭载了NVLink3带宽为600GB/s。H100中包含18条第四代NVLink链路，总带宽（双向）达到900 GB/s，是PCIe 5.0 x16带宽（双向）的7倍。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444966.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444983.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>NVLink高速互联主要有两种：</p><ul><li>第一种是以桥接器的形式实现。</li><li>另一种是在主板上集成 <code>NVLink</code> 接口。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444035.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvswitch"><strong>NVSwitch</strong></h3><p>为了解决GPU之间通讯不均衡问题，NVIDIA引入NVSwitch。NVSwitch芯片是一种类似交换机的物理芯片（ASIC），通过NVLink接口可以将多个GPU高速互联到一起，可创建无缝、高带宽的多节点GPU集群，实现所有GPU在一个具有全带宽连接的集群中协同工作，从而提升服务器内部多个GPU之间的通讯效率和带宽。NVLink和NVSwitch的结合使NVIDIA得以高效地将AI性能扩展到多个GPU。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444026.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>第一代 NVSwitch于2018年发布，采用台积电 12nm FinFET 工艺制造，共有 18个 NVLink 2.0 接口。目前 NVSwitch 已经迭代至第三代。第三代 NVSwitch采用台积电 4N 工艺（台积电 4N工艺专为NVIDIA定制设计，并进行了一系列优化，它与普通台积电5nm节点相比，可实现更好的电源效率与性能，并且密度有所提升）构建，每个NVSwitch 芯片上拥有 64 个 NVLink 4.0 端口，GPU 间通信速率可达900GB/s。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444101.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvidia-gpu-服务器-pcie-版-和-sxm-版的区别"><strong>Nvidia GPU服务器 PCIe 版 和 SXM 版的区别</strong></h3><p>英伟达GPU卡间互连的内存插槽有2种，一种是PCIe口，一种是SXM口。</p><p>PCIe口是一个相对通用的协议，PCIe口相对慢一些，SXM是专门用来做卡间互连的，SXM协议是铺在电路板上，SXM协议做卡间互连会更快，对NVLink原生支持更好，显存带宽比PCIe高一些。PCIe和SXM都可以用NVLink，但是SXM是更好使用NVLink的方法。</p><p>SXM 架构是一种高带宽插座式解决方案，用于将 GPU 连接到 NVIDIA 专有的DGX 和 HGX 系统。SXM 版 GPU 通过主板上集成的 NVSwitch 实现 NVLink的连接，不需要通过主板上的PCIe进行通信，它能支持8块GPU卡的互联互通，实现了GPU之间的高带宽。未阉割的A100是600GB/s、H100是900GB/s，阉割过的A800、H800为400GB/s。</p><p>把 PCIe 版 GPU 卡插到 PCIe插槽上，就可以和CPU、同一个服务器上其他的GPU卡进行通信，也可以通过网卡与其他的服务器节点上的设备进行通信，这种就是PCIe的通信方式，但是这种传输速度不快。如果想要和SXM一样，有很快的传输速度，可以使用NVlink桥接器实现GPU和CPU之间的通信，但是和SXM不一样的地方就是它只能实现2块GPU卡之间的通信。即PCIe 版只有成对的 GPU 通过 NVLink Bridge 连接，通过 PCIe通道进行数据通信。同时，最新的PCIe网络带宽有128GB/s的限制。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444612.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="tcpip"><strong>TCP/IP</strong></h3><p>TCP/TP （或传输控制协议/Internet 协议）用于通过 Internet互连网络设备。它确定了数据应该如何被打包、寻址、传输、路由和接收。TCP/IP非常重视两台计算机之间的准确数据传输。如果系统在一次发送消息时遇到问题，则必须重新发送整个消息。</p><p>此外，TCP/IP的功能分为四个不同的层：<strong>数据链路层、互联网层、传输层和应用层</strong>。数据在被另一端接收之前必须经过这四层。然后，TCP/IP将通过以相反顺序传递层来重组数据并将其呈现给接收器。这样，您可以通过升级某些层而不是整个系统来提高数据中心的性能或安全性。</p><h3 id="rdma"><strong>RDMA</strong></h3><p>RDMA(远程直接数据存取)就是为了解决网络传输中服务器端数据处理的延迟而产生的，<strong>无需使用CPU，就可以从一个主机或服务器的内存直接访问另一主机或服务器的内存</strong>。它释放了CPU去执行其应做的工作，比如：运行应用程序和处理大量数据。这既提高了带宽又降低了延迟、抖动和CPU 消耗。</p><p>对比传统的网络传输机制，RDMA无需操作系统和TCP/IP协议栈的介入。<strong>RDMA的内核旁路机制，允许应用与网卡之间的直接数据读写</strong>，将服务器内的数据传输时延降低到1us以下。同时，RDMA的内存零拷贝机制，允许接收端直接从发送端的内存读取数据，极大的减少了CPU的负担，提升CPU的效率。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444661.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>大致有三类RDMA网络，分别是Infiniband、RoCE、iWARP。其中，Infiniband是一种专为RDMA设计的网络，从硬件级别保证可靠传输，而RoCE 和 iWARP都是基于以太网的RDMA技术，支持相应的verbs接口。</p><p>RDMA最早在Infiniband传输网络上实现，技术先进，但是价格高昂(<strong>只有Mellanox（现已被英伟达收购）和Intel（2012年，英特尔公司出资收购了QLogic的InfiniBand技术）供应商提供全套网络解决方案</strong>)，后来业界厂家把RDMA移植到传统Ethernet以太网上，降低了RDMA的使用成本，推动了RDMA技术普及。在Ethernet以太网上，根据协议栈融合度的差异，分为iWARP和RoCE两种技术，而RoCE又包括<strong>RoCEv1和RoCEv2两个</strong>版本(RoCEv2的最大改进是支持IP路由)。各RDMA网络协议栈的对比，如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444703.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>IB（InfiniBand）：</strong> 基于 InfiniBand 架构的 RDMA技术，由 IBTA（InfiniBand Trade Association）提出。搭建基于 IB 技术的RDMA 网络需要专用的 IB 网卡和 IB 交换机。</p><p><strong>iWARP（Internet Wide Area RDMA Protocal）：</strong> 基于TCP/IP 协议的 RDMA 技术，由 IETF 标 准定义。iWARP支持在标准以太网基础设施上使用 RDMA 技术，但服务器需要使用支持iWARP的网卡。</p><p><strong>RoCE（RDMA over Converged Ethernet）：</strong> 基于以太网的RDMA 技术，也是由 IBTA 提出。RoCE支持在标准以太网基础设施上使用RDMA技术，但是需要交换机支持无损以太网传输，需要服务器使用RoCE 网卡。</p><p>在三种主流的RDMA技术中，可以划分为两大阵营。一个是IB技术，另一个是支持RDMA的以太网技术(RoCE和iWARP)。其中,IBTA力挺的技术自然是IB和RoCE,Mellanox公司是这方面的急先锋。而iWARP则是IEEE/IETF力挺的技术，主要是Chelsio公司在推进。</p><p>在存储领域，支持RDMA的技术早就存在，比如：SRP(SCSI RDMAProtocol)和iSER(iSCSI Extensions for RDMA)。如今兴起的NVMe overFabrics如果使用的不是FC网络的话，本质上就是 NVMe over RDMA。换句话说，NVMe over InfiniBand, NVMe over RoCE 和 NVMe over iWARP 都是NVMe over RDMA。</p><h2 id="infiniband"><strong>InfiniBand</strong></h2><p>InfiniBand（直译为 “无限带宽”技术，缩写为IB）是一个为大规模、易扩展机群而设计的<strong>网络通信技术协议</strong>。可用于计算机内部或外部的数据互连，服务器与存储系统之间直接或交换互连，以及存储系统之间的互连。</p><p>InfiniBand最重要的一个特点就是<strong>高带宽</strong>、<strong>低延迟</strong>，因此在高性能计算项目中广泛的应用。主要用于高性能计算（HPC）、高性能集群应用服务器和高性能存储。</p><h3 id="infiniband-链路速率"><strong>InfiniBand 链路速率</strong></h3><p>InfiniBand在物理层定义了多种链路速度，例如：1X，4X，12X。每个单独的链路是四线串行差分连接（每个方向两根线）。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444802.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>以早期的SDR（单数据速率）规范为例，1X链路的原始信号带宽为2.5Gbps，4X链路是10Gbps，12X链路是30Gbps。1X链路的实际数据带宽为2.0Gbps（因为采用8b/10b编码）。由于链路是双向的，因此相对于总线的总带宽是4Gbps。</p><p>随着时间的推移，InfiniBand的网络带宽不断升级，下图展示了 InfiniBand从SDR、DDR、QDR、FDR、EDR发展到HDR、NDR的网络带宽，其速度是基于 4x链路速度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444850.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li>SDR（Single Data Rate）：2.5Gb/s (10Gb/s for 4x)。</li><li>DDR（Double Data Rate）：5 Gb/s (20Gb/s for 4x)。</li><li>QDR（Quad Data Rate）：10 Gb/s (40Gb/s for 4x)。</li><li>FDR（Fourteen Data Rate）：14Gb/s (56Gb/s for 4x)。</li><li>EDR（Enhanced Data Rate）：25 Gb/s (100Gb/s for 4x)。</li><li>HDR（High Data Rate）：50 Gb/s (200Gb/s for 4x)。</li><li>NDR（Next Data Rate）：100 Gb/s (400Gb/s for 4x)。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444956.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-网络互连产品"><strong>InfiniBand网络互连产品</strong></h3><p>InfiniBand网络中，使用的线缆区别于传统的以太网线缆和光纤线缆。针对不同的连接场景，需使用专用的InfiniBand线缆。</p><p>InfiniBand网络互连产品包括：<strong>DAC高速铜缆</strong>、<strong>AOC有源线缆</strong>以及<strong>光模块</strong>。</p><p>DAC高速线缆和AOC有源光缆都是用于数据中心、高性能计算机等大容量储存器设备间的传输设备。</p><p><strong>DAC高速线缆</strong>，也叫直连铜缆（Direct Attach Coppercable）,它的线材是铜缆，是低压脉冲传输信号；因为材料的不同导致功耗、传输距离和价格的不同，DAC高速线缆的功耗比较低，但传输距离相对比较短，低于10米。价格方面相对便宜一些。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444144.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>AOC有源光缆</strong>（Active OptialCable），它的线材是光缆，为光信号传输，通过电-光-电的转换；功耗相对比较大些但传输的距离可达到100米，价格方面相对高些。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444200.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>光模块</strong>的作用也是光电信号之间的转换，主要用于交换机与设备之间传输的载体，和光纤收发器的原理相同，只是光模块相比收发器更具效率性、安全性。光模块按照封装形式分类，常见的有SFP，SFP+，XFP，SFP28,QSFP+,QSFP28 等。</p><p><strong>光纤收发器</strong>是将短距离的电信号和长距离的光信号进行转换的设备，一般应用在远距离传输中，通过光纤进行传输，将电信号转换成光信号发送出去，同时，在接收端将接收到的光信号转换成电信号。在很多地方也被称之为光电转换器(FiberConverter)。光纤收发器为需要将系统从铜线升级到光纤，为缺少资金、人力或时间的用户提供了一种廉价的方案。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444278.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>光模块与光纤收发器如何配对使用？</strong></p><ol type="1"><li>波长和传输距离必须一致，比如：采用1310nm波长，传输距离应该是10KM/20KM。</li><li>光纤跳线尾纤接口选择需注意，一般光纤收发器采用的SC口，光模块采用的是LC口。</li><li>速率必须一样，比如：千兆收发器对应 1.25G光模块，百兆连百兆，千兆连千兆。4、光模块类型需要采用相同类型，单纤对单纤，双纤对双纤。</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444281.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-的网络架构"><strong>InfiniBand的网络架构</strong></h3><p>InfiniBand 是一种基于通道的结构，组成单元主要分为四类：</p><ul><li>HCA（Host Channel Adapter，主机通道适配器）</li><li>TCA（Target Channel Adapter，目标通道适配器）</li><li>InfiniBand link（连接通道，可以是电缆或光纤，也可以是板上链路）</li><li>InfiniBand交换机和路由器（组网用的）</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444357.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>通道适配器就是搭建InfiniBand通道用的。所有传输均以通道适配器开始或结束，以确保安全或在给定的QoS（服务质量）级别下工作。</p><p>使用 InfiniBand 的系统可以由多个子网（Subnet）组成，每个子网最大可由6 万多个节点组成。</p><ul><li>子网内部，InfiniBand 交换机进行二级处理。</li><li>子网之间，使用路由器或网桥进行连接。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444436.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>InfiniBand 的二级处理过程非常简单，每个 InfiniBand子网都会设一个子网管理器，生成16位的 LID（本地标识符）。InfiniBand交换机包含多个 InfiniBand端口，并根据第二级本地路由标头中包含的LID，将数据包从其中一个端口转发到另一个端口。<strong>除管理数据包外，交换机不会消耗或生成数据包</strong>。</p><p>简单的处理过程，加上自有的Cut-Through技术，InfiniBand将转发时延大幅降低至 100ns 以下，明显快于传统以太网交换机。</p><p>在 InfiniBand网络中，数据同样以数据包（最大4KB）的形式传输，采用的是串行方式。</p><h3 id="infiniband-的协议栈"><strong>InfiniBand 的协议栈</strong></h3><p>InfiniBand协议同样采用了分层结构，各层相互独立，下层为上层提供服务，如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444628.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li><strong>物理层</strong>定义了在线路上如何将比特信号组成符号，然后再组成帧、数据符号以及包之间的数据填充等，详细说明了<strong>构建有效包的信令协议</strong>等。</li><li><strong>链路层</strong>定义了数据包的格式以及数据包操作的协议，如：流控、路由选择、编码、解码等。</li><li><strong>网络层</strong>通过在数据包上添加一个40字节的全局的路由报头（GlobalRoute Header,GRH）来进行路由的选择，对数据进行转发。<strong>在转发的过程中，路由器仅仅进行可变的CRC校验，这样就保证了端到端的数据传输的完整性</strong>。Infiniband报文封装格式如下图所示：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444690.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li><strong>传输层</strong>再将数据包传送到某个指定的队列偶（Queue Pair,QP）中，并指示 QP 如何处理该数据包。</li></ul><p>可以看出，InfiniBand 拥有自己定义的 1-4层格式，是一个完整的网络协议。端到端流量控制，是 InfiniBand网络数据包发送和接收的基础，可以实现无损网络。</p><blockquote><p>QP（队列偶）说明：QP是RDMA技术中通信的基本单元。队列偶就是一对队列，SQ（SendQueue，发送工作队列）和 RQ（ReceiveQueue，接收工作队列）。用户调用API发送接收数据的时候，实际上是将数据放入QP当中，然后以轮询的方式，将QP中的请求一条条的处理。</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444761.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="mellanox-ofed-软件栈"><strong>Mellanox OFED 软件栈</strong></h3><p>Mellanox OFED是一个单一的软件堆栈，包括驱动、中间件、用户接口，以及一系列的标准协议IPoIB、SDP、SRP、iSER、RDS、DAPL(Direct Access ProgrammingLibrary)，支持 MPI、Lustre/NFS over RDMA 等协议，并提供 Verbs编程接口；Mellanox OFED 由开源 OpenFabrics 组织维护。</p><p>Mellanox OFED 软件堆栈是承载在 InfiniBand硬件和协议之上的，软件通过协议和硬件进行有效的数据传输。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444831.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="opensm-子网管理器"><strong>OpenSM 子网管理器</strong></h3><p>OpenSM 软件是符合InfiniBand的子网管理器(SM)，运行在MellanoxOFED软件堆栈进行 IB网络管理，管理控制流走业务通道，属于带内管理方式。</p><p>OpenSM包括<strong>子网管理器、背板管理器和性能管理器</strong>三个组件，绑定在交换机内部的必备部件。提供非常完备的管理和监控能力，如：<strong>设备自动发现、设备管理、Fabric可视化、智能分析、健康监测</strong>等等。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444856.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-组网"><strong>InfiniBand 组网</strong></h3><p>InfiniBand 组网跟普通的交换机不太一样，InfiniBand的组网成本很高。如果希望这个网络中任何两个计算节点的网卡之间互相无损地通信，需要使用一种叫做胖树（FatTree）的网络拓扑，大概是如下一种拓扑结构，方块是交换机，椭圆是计算节点。</p><p>胖树主要有两层，上面一层是核心层，不连任何计算节点，它的功能就是转发流量；下面一层是接入层，接入各类计算节点。</p><p>胖树拓扑成本高的主要原因是：某一个汇聚交换机上，假如有36个口，那如果为了达到无损速率，一半的口，也就是18个口可以给计算节点连，剩下一半要连到上层的核心交换机上。要知道，任何一根线，就是1万多块钱呢，如果达到无损，就要冗余地做这些连接。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444939.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvidia-infiniband-商用产品"><strong>NVIDIA InfiniBand商用产品</strong></h3><p>Mellanox 在全球 InfiniBand 市场的占有率基本上无敌的存在，在英伟达收购Mellanox 之后，也于2021年推出了自己的第七代 NVIDIA InfiniBand架构：NVIDIA Quantum-2。</p><p>NVIDIA Quantum-2 平台包括：NVIDIA Quantum-2 系列交换机、NVIDIAConnectX-7 InfiniBand 适配器、BlueField-3 InfiniBand DPU以及电缆。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444126.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>NVIDIA Quantum-2系列交换机</strong>采用紧凑型1U设计，包括风冷和液冷版本。交换机的芯片制程工艺为7nm，单芯片拥有570亿个晶体管（比A100GPU还多）。单个交换机采用64个400Gb/s端口或128个200Gb/s端口的灵活搭配，提供总计51.2Tb/s的双向吞吐量。NVIDIA NDR 400Gb/s InfiniBand交换机如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444198.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>NVIDIA ConnectX-7 InfiniBand 适配器</strong>支持PCIeGen4和Gen5，具有多种外形规格，可提供 400Gb/s 吞吐量。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444299.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-常用命令"><strong>InfiniBand 常用命令</strong></h3><ul><li><code>ibv_asyncwatch</code>：监视 InfiniBand 异步事件</li><li><code>ibv_devices</code> 或 <code>ibv_devinfo</code>： 列举InfiniBand 设备或设备信息 - <code>ibstatus</code>：查询 IB设备的基本状态</li><li><code>ibping</code>： 验证 IB 节点之间的连通性</li><li><code>ibtracert</code>：跟踪 IB 路径</li><li><code>iblinkinfo</code>：查看IB交换模块的所有端口的连接状态。此命令会将集群内所有的IB交换模块都进行列举。</li></ul><h2 id="通信软件"><strong>通信软件</strong></h2><p>通信软件指用于分布式训练时，多个计算设备之间的集合通信。在分布式系统中，各个节点间往往存在大量的集合通信需求，而我们可以用消息传递接口(Message Passing Interface，MPI，一套集合通信相关的接口标准)来定义一些比较底层的消息通信行为。譬如Reduce、AllReduce、Scatter、Gather、AllGather 等。</p><p>常见的集合通信库（如：Open MPI、Gloo、NCCL等）都在 MPI的基础上，对各种集合通信的模式和算法作了各自的实现。</p><p><strong>Open MPI</strong>：</p><p>Open MPI 是一个开源 MPI（消息传递接口）的实现，由学术，研究和行业合作伙伴联盟开发和维护。因此，Open MPI可以整合高性能计算社区中所有专家，技术和资源，以构建可用的最佳 MPI库。</p><p><strong>Gloo</strong>：</p><p>Gloo 是 Facebook开源的一套集体通信库，提供了对机器学习中有用的一些集合通信算法。如：Barrier，Broadcast，AllReduce。</p><p><strong>NCCL</strong>：</p><p>NCCL（Nvidia Collective multi-GPU Communication Library）是英伟达基于NVIDIA GPU 的一套开源的集合通信库，如其官网描述：NVIDIA集合通信库（NCCL）实现了针对 NVIDIA GPU 性能优化的多 GPU和多节点集合通信原语。NCCL 提供了诸如 All Gather，AllReduce，Broadcast，Reduce，Reduce-Scatter 等实现，这些实现优化后可以通过PCIe、 NVLink、InfiniBand 等高速互联，从而实现高带宽和低延迟。</p><p>因为 NCCL 是 NVIDIA基于自身硬件定制的，能做到更有针对性且更方便优化，故在英伟达硬件上，NCCL的效果往往比其它的通信库更好。</p><p>NCCL主要做几件事：<strong>探测计算节点的网络设备和拓扑结构</strong>，使用算法自动调优选择一个最优的通信方式。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444373.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="nccl-集合通信库"><strong>NCCL 集合通信库</strong></h2><h3 id="通信原语"><strong>通信原语</strong></h3><p>并行任务的通信一般可以分为 Point-to-point communication 和 Collectivecommunication 。</p><p>P2P 通信这种模式只有一个sender和一个receiver，实现起来比较简单。</p><p>集合通信包含多个sender多个receiver，一般的通信原语包括broadcast，gather，all-gather，scatter，reduce，all-reduce，reduce-scatter，all-to-all等。</p><p>简单介绍几个常用的操作：</p><p><strong>Reduce</strong>：从多个sender那里接收数据，最终combine到一个节点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444484.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>All-reduce</strong>：从多个sender那里接收数据，最终combine到每一个节点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444737.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nccl-实现"><strong>NCCL 实现</strong></h3><p>NCCL 实现成 CUDA C++ kernels，包含3种 primitive operations：Copy，Reduce，ReduceAndCopy。</p><ul><li>NCCL 1.0 版本只支持单机多卡，卡之间通过 PCIe、NVlink、GPUDirect P2P来通信。</li><li>NCCL 2.0 支持多机多卡，多机间通过 Sockets (Ethernet) 或者 InfiniBandwith GPUDirect RDMA 通信。</li></ul><p>单机内多卡通过PCIe以及CPU socket通信。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444882.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>多机通过InfiniBand通信，在多机多卡内部，也要构成一个通信环。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444963.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="对比-nccl-在不同硬件架构下网络带宽"><strong>对比 NCCL在不同硬件架构下网络带宽</strong></h3><p>下图是 Allreduce 在单机不同架构下的速度比较：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444081.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>前面三个是单机多卡典型的三种连接方式：</p><ul><li>第一种是两个GPU通过CPU然后通过QPI和另一个CPU上的两块卡相连，因此速度最慢，但也能达到&gt;5GB/s。</li><li>第二种是两个GPU通过PCIeswitch相连后再经过CPU连接，速度会稍微低一点。</li><li>第三种是四张卡都在一个PCIe switch上，所以带宽较高，能达到&gt;10GB/sPCIe的带宽大小。</li></ul><p>第四种是DGX-1架构，这是Nvidia推出的深度学习平台，带宽能达到60GB/s。</p><p>下图是 Allreduce多机下的速度表现。其中，左图2机8卡，机内PCIe，机间InfiniBand能达到&gt;10GB/s的速度，InfiniBand基本上能达到机内的通信速度；右图4机32卡，机内NVLink，机间InfiniBand，带宽能达到&gt;40GB/s。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444202.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>下图是 NCCL 在 CNTK ResNet50 上的可扩展性（scalability），32卡基本能达到线性加速比。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444295.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nccl-常见的环境变量设置"><strong>NCCL常见的环境变量设置</strong></h3><p><strong>NCCL_P2P_DISABLE</strong></p><p>该变量禁用 P2P 传输，该传输使用 NVLink 或 PCI在GPU之间使用CUDA直接访问。</p><p>设定为 1 相当于设置 <code>NCCL_P2P_LEVEL=0</code>，并且会被NCCL_P2P_LEVEL 的值所覆盖。</p><p><strong>NCCL_P2P_LEVEL</strong>：</p><p>该变量允许用户精细地控制何时在GPU之间使用 P2P传输。该级别定义了NCCL将使用P2P传输的GPU之间的最大距离。</p><p>如果未指定，NCCL将尝试根据其运行的体系结构和环境来最佳选择一个值。</p><p>可选值：</p><ul><li>LOC：从不使用P2P（始终禁用）</li><li>NVL ：当 GPU 通过 NVLink 连接时使用 P2P</li><li>PIX ：当 GPU 位于同一 PCI 交换机上时使用 P2P。</li><li>PXB：当 GPU 通过 PCI 交换机（可能是多跳）连接时使用 P2P。</li><li>PHB ：当 GPU 位于同一 NUMA 节点上时使用 P2P。 流量将通过 CPU。</li><li>SYS ：在 NUMA 节点之间使用 P2P，可能跨越 SMP互连（例如：QPI/UPI）。</li></ul><p><strong>NCCL_NET_GDR_LEVEL</strong>：</p><p>该变量允许用户精细控制何时在NIC和GPU之间使用GPUDirectRDMA。该级别定义NIC和GPU之间的最大距离。</p><p>如果未指定，NCCL将尝试根据其运行的体系结构和环境来最佳选择一个值。</p><p>可选值：</p><ul><li>LOC：从不使用 GPU Direct RDMA。（始终禁用）</li><li>PIX：当 GPU 和 NIC 位于同一 PCI 交换机上时，使用 GPU DirectRDMA。</li><li>PXB：当 GPU 和 NIC 通过 PCI 交换机（可能是多跳）连接时，使用 GPUDirect RDMA。</li><li>PHB ：当 GPU 和 NIC 位于同一 NUMA 节点上时，使用 GPU Direct RDMA。流量将通过 CPU。</li><li>SYS ：即使跨 NUMA 节点之间的 SMP 互连（例如 QPI/UPI）也使用 GPUDirect RDMA。 （始终启用）</li></ul><p><strong>NCCL_NET_GDR_READ</strong>：</p><p>只要 GPU-NIC 距离在 NCCL_NET_GDR_LEVEL指定的距离内，NCCL_NET_GDR_READ 变量就会在发送数据时启用 GPU DirectRDMA。</p><ul><li>2.4.2之前，默认情况下禁用GDR读取，即发送数据时，数据先存储在 CPU内存中，然后再发送到 InfiniBand 卡。</li><li>自 2.4.2 起，基于 NVLink 的平台默认启用 GDR 读取。</li></ul><p>注意：已知在某些平台（例如：PCI-E）上，发送数据时直接从 GPU内存读取比从 CPU 内存读取稍慢。</p><p>可选值为0或1。定义并设置为1以使用GPU DirectRDMA直接将数据发送到NIC（绕过CPU）。</p><p>在 2.4.2 之前，所有平台的默认值都是 0。 自 2.4.2 起，基于 NVLink的平台的默认值为 1，否则为 0。</p><p><strong>NCCL_IB_DISABLE</strong>：</p><p>该变量将禁用 NCCL 要使用的IB传输。NCCL 将使用IP sockets 。</p><p>定义并设置为1以强制使用IP sockets 。</p><p><strong>NCCL_SOCKET_IFNAME</strong>：</p><p>指定NCCL使用的SOCKET网卡。如：<code>NCCL_SOCKET_IFNAME=bond0,eth0</code>。</p><p><strong>NCCL_IB_HCA</strong>：</p><p>该变量指定要用于通信的 RDMA接口。使用IB通信必须要设置的（指定NCCL使用的IB网卡）。 可以通过 ibstat查看IB网卡名。</p><p>用法：</p><p>定义一个前缀列表来过滤要由 NCCL 使用的接口。使用 ^ 符号，NCCL将排除以列表中任何前缀开头的接口。还可以使用 :符号来指定特定的端口。要匹配（或不匹配）确切的接口名称而不是前缀，在字符串前面加上= 字符。</p><p>示例：</p><ul><li><code>mlx5</code>：使用以 mlx5 开头的所有卡的所有端口。</li><li><code>=mlx5_0:1,mlx5_1:1</code>：使用卡 mlx5_0 和 mlx5_1 的端口1。</li><li><code>^=mlx5_1</code>：不使用卡 mlx5_1。</li></ul><p>比如： NCCL_IB_HCA=mlx5_2,mlx5_3,mlx5_4,mlx5_5</p><blockquote><p>注意： 如果不加前缀 =，使用 mlx5_1 将同时选择 mlx5_1 和 mlx5_10 到mlx5_19（如果存在）。因此，始终建议添加前缀 = 以确保精确匹配。</p></blockquote><p>使用建议：</p><p>通过这个环境变量可以调整NIC（Network Interface Controller）数量，NIC通常是一块插入计算机主板上的扩展卡，更多NIC，节点带宽更大。通过控制NIC数量可以控制节点间通信带宽。</p><p><strong>NCCL_IB_TIMEOUT</strong>：</p><p>该变量用于控制InfiniBand Verbs超时。取值范围1-22。</p><p>超时时间的计算公式为4.096微秒 * 2 ^timeout，正确的值取决于网络的大小。增加该值可以在非常大的网络上提供帮助，例如，如果NCCL在调用ibv_poll_cq时出现错误12。</p><p>使用建议：</p><p>在大模型训练任务中设置成最大值22，可以减少不少nccl timeout异常。</p><p><strong>NCCL_IB_RETRY_CNT</strong></p><p>该变量控制 InfiniBand 的重试次数。</p><p>使用建议：</p><p>在大模型训练任务中设置成13，尽可能多重试。</p><p><strong>NCCL_PXN_DISABLE</strong>：</p><p>禁止使用非本地 NIC 的进行节点间通信，使用 NVLink 和一个中间 GPU。</p><p>使用建议：</p><p>设置成1。在PyTorch中进行跨节点all-to-all通信时，如果该环境变量是0会出现异常。</p><p><strong>NCCL_DEBUG_FILE</strong>：</p><p>设置一个文件地址，变量用于将NCCL的调试日志输出到文件中，有助于调试NCCL。</p><p><strong>NCCL_IB_PCI_RELAXED_ORDERING</strong>：</p><p>启用 IB Verbs 传输的 Relaxed Ordering。RelaxedOrdering可以极大地提高虚拟化环境下 InfiniBand 网络的性能。</p><p>传统的顺序执行（StrictOrdering）要求数据在发送和接收之间按照严格的顺序进行传输和处理。这种机制可以确保数据的顺序性，但可能会导致性能瓶颈，特别是在高负载和复杂通信模式下。</p><p>而RelaxedOrdering允许数据在发送和接收之间进行乱序传输和处理。这意味着系统可以更灵活地调度和处理数据，提高并行性和吞吐量。RelaxedOrdering机制在虚拟化环境中尤其有益，因为它可以减少虚拟机之间的争用和延迟，提高整体性能。</p><p>接受的取值：</p><ul><li>设置为 2，如果可用，自动使用Relaxed Ordering。</li><li>设置为 1，强制使用Relaxed Ordering，如果不可用，则失败。</li><li>设置为 0，禁用使用Relaxed Ordering。</li></ul><p>默认值为 2。建议设置成 1。</p><p><strong>NCCL_SHM_DISABLE</strong>：</p><p>该变量禁用共享内存（SHM）传输。</p><p>在P2P不能生效的情况下，是否使用CPU的共享内存来传输数据。 当 SHM禁用时，NCCL 使用网络（ InfiniBand 或 IP sockets）在 CPU sockets之间进行通信。</p><h2 id="infiniband-在-ai-集群中的应用"><strong>InfiniBand 在 AI集群中的应用</strong></h2><h3 id="gpudirect-简介"><strong>GPUDirect 简介</strong></h3><p>GPUDirect 是 NVIDIA 开发的一项技术，可实现 GPU与其他设备（例如网络接口卡 (NIC)和存储设备）之间的直接通信和数据传输，而不涉及 CPU。</p><p>传统上，当数据需要在 GPU 和另一个设备之间传输时，数据必须通过CPU，从而导致潜在的瓶颈并增加延迟。使用GPUDirect，网络适配器和存储驱动器可以直接读写 GPU内存，减少不必要的内存消耗，减少 CPU开销并降低延迟，从而显著提高性能。GPU Direct 技术包括 GPUDirectStorage、GPUDirect RDMA、GPUDirect P2P 和 GPUDirect Video。</p><h3 id="gpudirect-发展简史"><strong>GPUDirect 发展简史</strong></h3><ul><li>GPUDirect Shared Memory (2012) ：Nvidia在PCIe上实现了单机上的GPUDirect Shared Memory 技术；</li><li>GPUDirect P2P (2014)： Nvidia在PCIe上实现了单机上的GPUDirectP2P技术；</li><li>NVLink（2014） ：解决了单机多卡通信时PCIe瓶颈问题；</li><li>GPUDirect RDMA（2014）：提升多机多卡通信性能；</li></ul><h3 id="gpudirect-peer-to-peerp2p简介"><strong>GPUDirect Peer toPeer（P2P）简介</strong></h3><p>GPUDirect Peer-to-Peer(P2P)技术主要用于单机GPU间的高速通信，它使得<strong>GPU可以通过PCIExpress直接访问目标GPU的显存</strong>，避免了通过拷贝到CPU hostmemory作为中转，大大降低了数据交换的延迟。</p><p>以深度学习应用为例，主流的开源深度学习框架（如：TensorFlow、MXNet）都提供了对GPUDirectP2P的支持，NVIDIA开发的NCCL(NVIDIA Collective CommunicationsLibrary)也提供了针对GPUDirect P2P的特别优化。</p><p>通过使用GPUDirectP2P技术可以大大提升深度学习应用单机多卡的扩展性，使得深度学习框架可以获得接近线性的训练性能加速比。</p><h3 id="gpudirect-rdma-简介"><strong>GPUDirect RDMA 简介</strong></h3><p>所谓 GPUDirectRDMA，就是计算机1的GPU可以直接访问计算机2的GPU内存。而在没有这项技术之前，GPU需要先将数据从GPU内存搬移到系统内存，然后再利用RDMA传输到计算机2，计算机2的GPU还要做一次数据从系统内存到GPU内存的搬移动作。GPUDirectRDMA技术使得进一步减少了GPU通信的数据复制次数，通信延迟进一步降低。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444358.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>使用 GPUDirect RDMA 两个 GPU 设备必须共享相同的上游 PCI Express rootcomplex。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444350.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="infiniband-在-nvidia-dgx-集群中应用"><strong>InfiniBand 在NVIDIA DGX 集群中应用</strong></h2><p><strong>DGX-1 集群中应用 InfiniBand</strong>：</p><p>下图展示了 DGX-1 配有四个 EDR InfiniBand 卡（每个 100 Gb/s）和两个10Gb/s 以太网卡（铜质）。 这些网络接口可用于将 DGX-1连接到网络以进行通信和存储。</p><p>每两个 GPU 都连接到系统板上的一个 PCIe 交换机。 该交换机还连接到InfiniBand (IB) 网卡。 为了减少延迟并提高吞吐量，来自这两个 GPU的网络流量应流向关联的 IB 卡。 这就是 DGX-1 设备中有四张 IB卡的原因。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444419.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>如果您想使用InfiniBand（IB）网络连接DGX设备，理论上，您只需使用其中一张IB卡即可。然而，这些数据流量将强行通过 CPU 之间的 QPI 链路，这对于 GPU流量来说是一个非常慢的链路（即，它成为瓶颈）。更好的解决方案是使用两张IB 卡，一张连接到每个 CPU。这可以是 IB0 和 IB2，或者 IB1 和 IB3，或者IB0 和 IB3，或者 IB1 和 IB2。 这将大大减少必须穿越 QPI 链路的流量。最佳性能始终是使用 IB 交换机的所有四个 IB 链路。</p><p>使用 IB 链路是将所有四个 IB 卡连接到 IB 结构的最佳方法。如果您使用多个 DGX设备进行训练，这将带来最佳性能（完全的平分带宽和最低延迟）。</p><p>通常，最小的 IB 交换机配有 36 个端口。 这意味着单个 IB交换机可容纳使用全部四张 IB 卡的九个 DGX-1 设备。 这允许从 DGX-1到交换机的带宽为 400 Gb/s。</p><p>如果您的应用程序不需要 DGX-1 设备之间的带宽，则可以如前所述为每个DGX-1 使用两个 IB 连接。 这允许您将最多 18 个 DGX-1 设备连接到单个 36端口 IB 交换机。</p><p>注意：<strong>不建议仅使用单个 IB卡</strong>，但如果由于某种原因采用这种配置，则您最多可以将 36 个 DGX-1设备连接到单个交换机。</p><p>对于大量 DGX-1 设备，您可能必须使用两级交换网络。 经典的 HPC配置是在第一级使用 36 端口 IB交换机（有时称为叶子（Leaf）交换机），并将它们连接到单个大型核心交换机，有时称为导向器级（directorclass）交换机。最大的导向器级InfiniBand交换机有648个端口。当然您也可以使用多个核心交换机，但配置会变得相当复杂。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444513.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>对于两级交换网络，如果每个 DGX-1 设备的全部 4 个 IB 卡都用于连接到 36端口交换机，并且没有过度订阅，则每个交换机的 DGX-1 设备的最大数量为4。这时每个 DGX-1 有 4 个端口进入交换机，总共 16个端口。然后，从叶子交换机到核心交换机（导向器级交换机）有 16个上行链路。总共 40 台 36 端口叶子交换机可连接到 648 端口核心交换机(648/16)。 这导致 160（40 * 4） 个 DGX-1设备（共640卡）以全对分带宽连接。</p><p>当然您还可以在设计 IB网络时使用所谓的过度订阅。过度订阅意味着来自<strong>上行链路的带宽小于进入设备的带宽</strong>（换句话说，带宽性能较差）。如果我们使用从DGX-1 设备到第一级交换机（36 端口叶交换机）的 2:1 超额订阅，则每个 DGX-1设备仅使用两个 IB卡连接到交换机。与使用所有四张卡相比，这会导致带宽更少，并且延迟也会更高。</p><p>如果我们保持从叶子交换机到核心交换机的网络带宽为1:1（换句话说，没有过度订阅，全对分带宽），那么我们可以将九个 DGX-1设备放入一个单叶子交换机（从 DGX 设备到叶子交换机的总共 18个端口以及到核心交换机的 18个上行链路端口）。结果是总共36（648/18）台叶子交换机可以连接到核心交换机。这使得总共 324（36 * 9） 个 DGX-1 设备可以连接在一起。</p><p>您还可以通过使用从叶子交换机到核心交换机的超额订阅来进一步定制 IB网络。 这可以通过<strong>使用每个 DGX 设备到叶子交换机的四个 IB连接</strong>，然后对核心交换机进行 2:1超额订阅，甚至使用到叶子交换机的两个 IB 连接，然后对核心交换机进行 2:1超额订阅来完成。</p><p>InfiniBand 网络的另一个重要方面是子网管理器 (SM)。 SM仅管理IB网络。任何时候都有一个 SM 管理 IB 结构，但您可以让其他 SM 运行并准备好在第一个SM 崩溃时接管。 选择运行多少个 SM以及在何处运行它们会对集群的设计产生重大影响。</p><p>首先要做的决定是<strong>在哪里运行 SM</strong>。</p><p>如果您愿意，它们可以在 IB 交换机上运行。 这称为硬件SM，因为它在交换机硬件上运行。 这样做的优点是您不需要任何其他也可以运行SM 的服务器。</p><p>在节点上运行 SM 称为软件 SM。 运行硬件 SM 的一个缺点是，如果 IB流量很大，SM 可能会遇到困难。 对于大量 IB流量和较大的网络，最佳实践是在专用服务器上使用软件 SM。</p><p>要做的第二个决定是您<strong>想要运行多少个 SM</strong>。您至少必须运行一个 SM。 最便宜的解决方案是运行单个硬件 SM。 这对于 DGX-1设备的小集群（可能是 2-4 个）来说效果很好。随着单元数量的增加，您将需要考虑同时运行两个 SM 以获得HA（高可用性）功能。 您需要 HA的原因是集群上有更多用户，并且集群故障比少量设备故障产生的影响更大。</p><p>随着设备数量的增长，请考虑在专用服务器（软件 SM）上运行 SM。您还需要为集群运行至少两个 SM。 理想情况下，这意味着 SM有两台专用服务器。</p><p><strong>DGX SuperPOD 中广泛应用InfiniBand</strong>：</p><p>下图为 DGX A100/H100 256 SuperPOD 网络拓扑图：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444669.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>下图为 DGX A100/H100 1K POD 网络拓扑图：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444765.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="infiniband-在-ai-框架中的应用"><strong>InfiniBand 在 AI框架中的应用</strong></h2><p>在之前文章（<strong><ahref="https://link.zhihu.com/?target=https%3A//juejin.cn/post/7311604023184162835">AI集群基础设施 NVMe SSD 详解</a></strong>）中谈到了 NVMe 在 DeepSpeed中的应用。DeepSpeed 通过 ZeRO-Infinity 技术尝试<strong>利用 NVMe的空间进一步打破内存墙的限制训练超大模型</strong>。除此之外，该方法也充分利用了InfiniBand网络进行多机通信，具体如下图所示。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444828.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>另外，像NCCL、Gloo等集合通信库都继承了InfiniBand，Pytorch框架也能够通过通信库轻松应用InfiniBand进行分布式训练。</p><h2 id="总结"><strong>总结</strong></h2><p>本文讲述了AI集群通信的软硬件；同时，针对NCLL集合通信库以及InfiniBand网络通信技术协议进行了更为详细的介绍；另外，也讲述了AI集群以及AI框架中对于InfiniBand的应用。</p><p>码字不易，如果觉得有帮助，欢迎点赞收藏加关注。</p><h2 id="参考文档"><strong>参考文档</strong></h2><ul><li><strong><ahref="https://zhuanlan.zhihu.com/p/454282470">带你了解PCIE通信原理</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/662904805">电脑硬件冷知识：主板北桥芯片为何消失了，南桥也有同样的命运？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/FlRc2q8r0fUOzxJFWulGfw">必看:原来PCIe技术原理这么简单</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.sdnlab.com/26316.html">AI网络互联，PCIe还是NVLink？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.sohu.com/a/229080366_632967">RDMA技术原理分析、主流实现对比和解析</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/FgKjDjZsPlweVJ03OVr3SA">详谈RDMA技术原理和三种实现方式</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/u013253075/article/details/119843611">RDMA技术详解——RDMA的三种实现方式</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.nvidia.cn/networking/interconnect/">【英伟达官网】线缆和收发器</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=http%3A//www.rhopto.com/articles/dacgsx.html">DAC高速线缆和AOC有源光缆有什么区别呢？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.etulink.com/blog/-_b268">你会区分光模块和光纤收发器吗？</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/139294038">都是光电转换作用，光模块和光纤收发器有什么区别？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//baijiahao.baidu.com/s%3Fid%3D1760941961023057651%26wfr%3Dspider%26for%3Dpc">态路小课堂丨关于InfiniBand网络相关内容简介！</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.51cto.com/u_14408894/8031135">态路小课堂丨InfiniBandAOC有源光缆简介</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NTA0MDUyMA%3D%3D%26mid%3D2456692454%26idx%3D1%26sn%3D031a11b931edee5504b15045cd863d37%26chksm%3Dfda68b81cad10297e4dd53bc97f63e0c47c26a27cdbb3c584cce6fc49fc6b4367b1531cbfcb6%26scene%3D0%26xtrack%3D1%23rd">InfiniBand，到底是个啥？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/networking/display/mlnxofedv583070101/introduction">NVIDIAMLNX_OFED Documentation v5.8-3.0.7.0.101 for DGX H100Systems</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/deeplearning/nccl/user-guide/docs/env.html">NCCL环境变量</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/653001915">大模型训练场景下NCCL环境变量设置</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//github.com/FelixFu520/README/blob/main/envs/pytorch/cuda_gpu.md">【GitHub】CUDA_GPU详细介绍</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/e40059d5c832">GPU卡的底层通信原理</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.nvidia.cn/networking/infiniband-adapters/">NVIDIAConnectX InfiniBand 网卡</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.h3c.com/cn/d_202007/1317229_30005_0.htm%23_Toc46935211">H3CIB网卡常用命令</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_42319496/article/details/125942763">IB常用命令</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/591403">浅析GPU通信技术（上）-GPUDirectP2P</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/603617">浅析GPU通信技术（下）-GPUDirectRDMA</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/cuda/gpudirect-rdma/index.html">GPUDirectRDMA 12.3 文档</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/622853211">【大模型训练】RDMA高速网络与集合通讯</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//cloud.baidu.com/doc/GPU/s/Yl3mr0ren">百度智能云-NCCL环境搭建</a></strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ai-集群基础设施infiniband&quot;&gt;AI
集群基础设施&amp;amp;&amp;amp;InfiniBand&lt;/h1&gt;
&lt;p&gt;GPU在高性能计算和深度学习加速中扮演着非常重要的角色，
GPU的强大的并行计算能力，大大提升了运算性能。随着运算数据量的不断攀升，GPU间</summary>
      
    
    
    
    
    <category term="AI" scheme="https://cuiluyi.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>矩阵乘法复杂度分析</title>
    <link href="https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://cuiluyi.gitee.io/2024/04/06/[object%20Object]/AI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2024-04-06T05:59:27.000Z</published>
    <updated>2024-04-06T06:19:34.307Z</updated>
    
    <content type="html"><![CDATA[<p># 矩阵乘法复杂度分析</p><h2 id="前言">前言</h2><p><strong>矩阵乘法</strong>：<strong>矩阵乘法（英语：matrixmultiplication）</strong>是一种根据两个矩阵得到<strong>第三个矩阵</strong>的<strong>二元运算</strong>（需要2个对象参与，这里指2个矩阵），第三个矩阵即前两者的乘积，称为<strong>矩阵积</strong></p><p><strong>条件：</strong>它只有在第一个矩阵的<strong>列数（column）</strong>和第二个矩阵的<strong>行数（row）</strong>相同时才有意义</p><h2 id="矩阵乘法">矩阵乘法</h2><h3 id="个矩阵相乘">2个矩阵相乘</h3><p>对于矩阵 <span class="math inline">\(A_{a*b}\)</span>、<spanclass="math inline">\(B_{b*c}\)</span>，那么 <spanclass="math inline">\(A*B\)</span> 的复杂度为 <spanclass="math inline">\(O(a*b*c)\)</span>，准确是 <spanclass="math inline">\(2abc\)</span></p><ul><li>加法计算了 <span class="math inline">\(abc\)</span> 次</li><li>乘法计算了 <span class="math inline">\(abc\)</span> 次</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)         <span class="comment">// A矩阵中的n 行</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)     <span class="comment">// B矩阵中的n  列</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; m; k++) <span class="comment">// A矩阵中的m 或者B矩阵中的m ,一样的</span></span><br><span class="line">            C[i][j] = C[i][j] + A[i][k] * B[k][j];</span><br></pre></td></tr></table></figure><h3 id="个矩阵相乘-1">3个矩阵相乘</h3><p>对于矩阵 <span class="math inline">\(A_{a*b}\)</span>、<spanclass="math inline">\(B_{b*c}\)</span>、<spanclass="math inline">\(C_{c*d}\)</span>，那么 <spanclass="math inline">\(A*B*C\)</span> 的复杂度为 <spanclass="math inline">\(O(abc + acd)\)</span></p><ul><li><span class="math inline">\(A*B\)</span> 的复杂度为 <spanclass="math inline">\(O(a*b*c)\)</span>，得到 <spanclass="math inline">\(a*c\)</span> 的矩阵</li><li><span class="math inline">\((A*B)_{a*c}*C\)</span> 的复杂度为 <spanclass="math inline">\(O(abc + acd)\)</span></li></ul><h3 id="推广">推广</h3><p>对于矩阵 <spanclass="math inline">\({A_1}_{_{a_1*a_2}}\)</span>、<spanclass="math inline">\({A_2}_{_{a_2*a_3}}\)</span>、… 、<spanclass="math inline">\({A_n}_{_{a_n*a_{n+1}}}\)</span>，那么 <spanclass="math inline">\(A*B*C\)</span> 的复杂度为 $a_1*(a_2a_3+a_3a_4++a_na_{n+1} ) $</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;# 矩阵乘法复杂度分析&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;矩阵乘法&lt;/strong&gt;：&lt;strong&gt;矩阵乘法（英语：matrix
multiplication）&lt;/strong&gt;是一种根据两个矩阵得到&lt;strong&gt;第三个矩阵&lt;/</summary>
      
    
    
    
    
    <category term="AI" scheme="https://cuiluyi.gitee.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>【模拟】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/31/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%A8%A1%E6%8B%9F%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/31/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%A8%A1%E6%8B%9F%E3%80%91/</id>
    <published>2024-03-31T02:27:16.000Z</published>
    <updated>2024-05-03T16:08:25.793Z</updated>
    
    <content type="html"><![CDATA[<p><ahref="https://www.acwing.com/activity/content/code/content/8472379/">AcWing1324. 五子棋 - AcWing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a
href=&quot;https://www.acwing.com/activity/content/code/content/8472379/&quot;&gt;AcWing
1324. 五子棋 - AcWing&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cuiluyi.gitee.io/2024/03/31/[object%20Object]/%E6%89%93%E5%8D%B0/"/>
    <id>https://cuiluyi.gitee.io/2024/03/31/[object%20Object]/%E6%89%93%E5%8D%B0/</id>
    <published>2024-03-31T02:17:10.273Z</published>
    <updated>2024-03-31T14:12:16.200Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ssize_t&amp;&amp;size_t</title>
    <link href="https://cuiluyi.gitee.io/2024/03/30/[object%20Object]/C++/ssize_t&amp;&amp;size_t/"/>
    <id>https://cuiluyi.gitee.io/2024/03/30/[object%20Object]/C++/ssize_t&amp;&amp;size_t/</id>
    <published>2024-03-30T09:49:49.000Z</published>
    <updated>2024-03-30T14:59:32.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="size_t">size_t</h2><p>​ <strong><code>size_t</code></strong> 是一些C/C++标准在<code>stddef.h</code> 中定义的，<code>size_t</code> 类型表示 C中任何对象所能达到的最大长度，它是无符号整数。</p><p>​ 它是为了方便系统之间的移植而定义的，不同的系统上，定义<code>size_t</code> 可能不一样。<code>size_t</code> 在 32 位系统上定义为<code>unsigned int</code>，也就是 32 位无符号整型。在64位系统上定义为<code>unsigned long</code> ，也就是 64 位无符号整形。<code>size_t</code>的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。</p><p>​ <code>size_t</code>在数组下标和内存管理函数之类的地方广泛使用。例如，<code>size_t</code>用做 <code>sizeof</code>操作符的返回值类型，同时也是很多函数的参数类型，包括 <code>malloc</code>和 <code>strlen</code>。</p><p>​ 在声明诸如字符数或者数组索引这样的长度变量时用 <code>size_t</code>是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。<code>size_t</code>的声明是实现相关的。它出现在一个或多个标准头文件中，比如<code>stdio.h</code> 和 <code>stblib.h</code>，典型的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZE_T</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><p>​ <code>define</code>指令确保它只被定义一次。实际的长度取决于实现。通常在 32位系统上它的长度是 32 位，而在 64 位系统上则是 64位。一般来说，<code>size_t</code> 可能的最大值是<code>SIZE_MAX</code></p><p>​ 打印 <code>size_t</code>类型的值时要小心。这是无符号值，如果选错格式说明符，可能会得到不可靠的结果。推荐的格式说明符是<code>%zu</code>。不过，某些情况下不能用这个说明符， 作为替代，可以考虑<code>%u</code> 或 <code>%lu</code>。下面这个例子将一个变量定义为<code>size_t</code>，然后用两种不同的格式说明符来打印：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sizet = <span class="number">-5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet);</span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code>本来是用于表示正整数的，如果用来表示负数就会出问题。如果为其赋一个负数，然后用<code>%d</code> 和 <code>%zu</code> 格式说明符打印，就得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-5</span><br><span class="line">4294967291</span><br></pre></td></tr></table></figure><p>​ <code>%d</code> 把 <code>size_t</code> 当做有符号整数，它打印出-5。因为变量中存放的就是 -5。<code>%zu</code> 把 <code>size_t</code>当做无符号整数。当 -5 被解析为有符号数时，高位置为1，表示这个数是负数。当它被解析为无符号数时，高位的 1 被当做 2的乘幂。所以在用 <code>%zu</code> 格式说明符时才会看到那个大整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizet = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code> 是无符号的，一定要给这种类型的变量赋正数。</p><h2 id="ssize_t">ssize_t</h2><p><strong><code>ssize_t</code></strong> 和 <code>size_t</code>类似，但必需是<strong>signed</strong>（表示 <code>signed size_t</code>类型）， 用来表示可以被执行读写操作的数据块的大小。</p><h2 id="size_t-和-int-比较">size_t 和 int 比较</h2><ul><li><code>size_t</code>在32位架构中定义为：<code>typedef  unsigned int size_t</code></li><li><code>size_t</code>在64位架构中被定义为：<code>typedef  unsigned long size_t</code></li><li><code>size_t</code> 是无符号的，并且是平台无关的，表示 0 ~MAXINT的范围；<code>int</code> 为是有符号的；</li><li><code>int</code> 在不同架构上都是4字节，<code>size_t</code>在32位和64位架构上分别是 4 字节和 8字节，在不同架构上进行编译时需要注意这个问题。</li><li><strong><code>ssize_t</code></strong>是<strong>有符号</strong>整型，在32 位机器上等同与 <code>int</code>，在 64 位机器上等同与<code>long int</code>.</li></ul><h2id="c语言编程需要注意的64位和32机器的区别">C语言编程需要注意的64位和32机器的区别</h2><table><thead><tr class="header"><th></th><th>char</th><th>short</th><th>int</th><th>long</th><th>long long</th><th>指针</th></tr></thead><tbody><tr class="odd"><td>16 位 平台</td><td>1Byte</td><td>2Byte</td><td>2Byte</td><td>4Byte</td><td></td><td>2 Byte</td></tr><tr class="even"><td>32 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>4Byte</td><td>8Byte</td><td>4 Byte</td></tr><tr class="odd"><td>64 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>8Byte</td><td>8Byte</td><td>8Byte</td></tr></tbody></table><h2 id="编程注意事项">编程注意事项</h2><p>​ 为了保证平台的通用性，程序中尽量不要使用 <code>long</code>数据库型。可以使用固定大小的数据类型宏定义，这些宏定义需要引用<code>stdint.h</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __extension__</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="intptr_t">intptr_t</h2><p>​ 使用 <code>int</code> 时也可以使用 <code>intptr_t</code>来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台字长，比如64 位机器它的长度就是 8 字节，32位机器它的长度是4字节，使用它可以安全地进行整数与指针的转换运算，也就是说当需要将指针作为整数运算时，将它转换成<code>intptr_t</code> 进行运算才是安全的。<code>intptr_t</code>需要引用<code>stddef.h</code> 头文件，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​ 编程中要尽量使用 <code>sizeof</code>来计算数据类型的大小。以上类型定义都有相应的无符号类型。</p><h2 id="使用ssize_t和size_t">使用ssize_t和size_t</h2><p>​ 它们分别是 <code>unsigned</code> 和 <code>signed</code> size ofcomputer word size。它们也是表示<strong>计算机的字长</strong>，在 32位机器上是 <code>int</code>型，在64位机器上 <code>long</code>型。使用它们对于增加平台的通用性有很大好处，从某种意义上来说它们等同于<code>intptr_t</code> 和 <code>uintptr_t</code>。使用它们也需要引用<code>stddef.h</code> 头文件。</p><p>​ socket 的 <code>accept</code> 函数在有些操作系统上使用<code>size_t</code> 是不正确的，因为 <code>accept</code> 接收的<code>int</code> 类型，而size_t的长度可能会超过 <code>int*</code>的长度限制，导致错误。后来BSD使用 <code>sock_t</code> 来替代它。</p><blockquote><p>参考：</p><ul><li>https://blog.csdn.net/bzhxuexi/article/details/19899803</li><li>https://blog.csdn.net/qq_30866297/article/details/51465473</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;size_t&quot;&gt;size_t&lt;/h2&gt;
&lt;p&gt;​ &lt;strong&gt;&lt;code&gt;size_t&lt;/code&gt;&lt;/strong&gt; 是一些C/C++标准在
&lt;code&gt;stddef.h&lt;/code&gt; 中定义的，&lt;code&gt;size_t&lt;/code&gt; 类型表示 C
中任何对象所能达到的最大长度，它是无符号整数。&lt;/p&gt;
&lt;p&gt;​ 它是为了方便系统之间的移植而定义的，不同的系统上，定义
&lt;code&gt;size_t&lt;/code&gt; 可能不一样。&lt;code&gt;size_t&lt;/code&gt; 在 32 位系统上定义为
&lt;code&gt;unsigned int&lt;/code&gt;，也就是 32 位无符号整型。在64位系统上定义为
&lt;code&gt;unsigned long&lt;/code&gt; ，也就是 64 位无符号整形。&lt;code&gt;size_t&lt;/code&gt;
的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;size_t&lt;/code&gt;
在数组下标和内存管理函数之类的地方广泛使用。例如，&lt;code&gt;size_t&lt;/code&gt;
用做 &lt;code&gt;sizeof&lt;/code&gt;
操作符的返回值类型，同时也是很多函数的参数类型，包括 &lt;code&gt;malloc&lt;/code&gt;
和 &lt;code&gt;strlen&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;​ 在声明诸如字符数或者数组索引这样的长度变量时用 &lt;code&gt;size_t&lt;/code&gt;
是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。&lt;code&gt;size_t&lt;/code&gt;
的声明是实现相关的。它出现在一个或多个标准头文件中，比如
&lt;code&gt;stdio.h&lt;/code&gt; 和 &lt;code&gt;stblib.h&lt;/code&gt;，典型的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;ifndef&lt;/span&gt; __SIZE_T&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; __SIZE_T&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;size_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>stringstream</title>
    <link href="https://cuiluyi.gitee.io/2024/03/30/[object%20Object]/C++/stringstream/"/>
    <id>https://cuiluyi.gitee.io/2024/03/30/[object%20Object]/C++/stringstream/</id>
    <published>2024-03-30T09:49:49.000Z</published>
    <updated>2024-05-01T15:57:55.644Z</updated>
    
    <content type="html"><![CDATA[<p># stringstream类</p><h2 id="概述">概述</h2><p><strong><sstream></strong>定义了三个<strong>类</strong>：<strong>istringstream</strong>、<strong>ostringstream</strong>和<strong>stringstream</strong>，分别用来进行流的输入、输出和输入输出操作。本文以stringstream 为主，介绍流的输入和输出操作。</p><p><sstream> 主要用来进行数据类型转换，由于 <sstream> 使用<strong>string 对象</strong>来代替字符数组（snprintf方式），避免了缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符号的问题。简单说，相比C 编程语言库的数据类型转换，<sstream> 更加安全、自动和直接。</p><h2 id="示例代码">示例代码</h2><h3 id="数据类型转换">数据类型转换</h3><p>这里展示一份示例代码，介绍将 int 类型转换为 string 类型的过程。</p><p>示例代码（stringstream_test1.cpp）的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    string strResult;</span><br><span class="line">    <span class="type">int</span> nValue = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将int类型的值放入输入流中</span></span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    <span class="comment">// 从sstream中抽取前面插入的int类型的值，赋给string类型</span></span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[cout]strResult is: &quot;</span> &lt;&lt; strResult &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[printf]strResult is: %s\n&quot;</span>, strResult.<span class="built_in">c_str</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上述代码，结果如下：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351103.png" /></p><h3 id="多个字符串拼接">多个字符串拼接</h3><p>本示例介绍在 stringstream中存放多个字符串，实现多个字符串拼接的目的（其实完全可以使用 string类实现），同时，介绍 stringstream 类的清空方法。</p><p>示例代码（stringstream_test2.cpp）的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;string,&quot;</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot; second string&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 清空 sstream</span></span><br><span class="line">    sstream.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;third string&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After clear, strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上述代码，结果如下：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351129.png" /></p><p>从上述代码执行结果能够知道：</p><ul><li>可以使用 str() 方法，将 stringstream 类型转换为 string 类型；</li><li>可以将多个字符串放入 stringstream 中，实现字符串的拼接目的；</li><li>如果想清空 stringstream，必须使用 sstream.str(""); 方式；clear()方法适用于进行多次数据类型转换的场景。详见示例 2.3。</li></ul><h3 id="stringstream的清空">stringstream的清空</h3><p>清空 stringstream 有两种方法：clear() 方法以及 str("")方法，这两种方法对应不同的使用场景。str("")方法的使用场景，在上面的示例中已经介绍过了，这里介绍 clear()方法的使用场景。</p><p>示例代码（stringstream_test3.cpp）的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    <span class="type">int</span> first, second;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在进行多次类型转换前，必须先运行clear()</span></span><br><span class="line">    sstream.<span class="built_in">clear</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入bool值</span></span><br><span class="line">    sstream &lt;&lt; <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    cout &lt;&lt; second &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上述代码，结果如下：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351190.png" /></p><p>注意：在本示例涉及的场景下（多次数据类型转换），必须使用 clear()方法清空 stringstream，不使用 clear() 方法或使用 str("")方法，都不能得到数据类型转换的正确结果。下图分别是未使用 clear()方法、使用 str("") 方法代替 clear() 方法时的运行结果：</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202405012351119.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;# stringstream类&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;sstream&gt;&lt;/strong&gt;
定义了三个&lt;strong&gt;类&lt;/strong&gt;：&lt;strong&gt;istringstream&lt;/strong&gt;、&lt;strong&gt;o</summary>
      
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《计算几何中的精度问题》</title>
    <link href="https://cuiluyi.gitee.io/2024/03/29/[object%20Object]/C++/%E3%80%8A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E3%80%8B/"/>
    <id>https://cuiluyi.gitee.io/2024/03/29/[object%20Object]/C++/%E3%80%8A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%E3%80%8B/</id>
    <published>2024-03-29T05:59:27.000Z</published>
    <updated>2024-04-09T14:04:55.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算几何中的精度问题">《计算几何中的精度问题》</h1><p>​计算几何头疼的地方一般在于代码量大和精度问题，代码量问题只要平时注意积累模板一般就不成问题了。精度问题则不好说，有时候一个<ahref="https://www.zhihu.com/search?q=精度问题&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">精度问题</a>就可能成为一道题的瓶颈，简直“画龙点睛”。这些年的题目基本是朝着越来越不卡精度的方向发展了，但是也不乏一些%^&amp;%题#<spanclass="math inline">\(%\)</span>^，另外有些常识不管题目卡不卡，都是应该知道的。今天我就开膛回顾下见过且还有印象的精度问题。</p><p>​ 计算几何的精度问题说到底其实是<ahref="https://www.zhihu.com/search?q=浮点数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">浮点数</a>的精度问题，但我觉得“<ahref="https://www.zhihu.com/search?q=计算几何&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">计算几何</a>”比“浮点数”更能吸引眼球，所以选了这个标题。</p><h2 id="浮点数为啥会有精度问题">浮点数为啥会有精度问题？</h2><p>​浮点数(以C/C++为准)，一般用的较多的是<code>float</code>、<code>double</code></p><table><colgroup><col style="width: 8%" /><col style="width: 8%" /><col style="width: 19%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th></th><th>占字节数</th><th>数值范围</th><th><ahref="https://www.zhihu.com/search?q=十进制精度位数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">十进制精度位数</a></th></tr></thead><tbody><tr class="odd"><td><code>float</code></td><td>4</td><td>-3.4e-38～3.4e38</td><td>6~7</td></tr><tr class="even"><td><code>double</code></td><td>8</td><td>-1.7e-308～1.7e308</td><td>14~15</td></tr></tbody></table><p>​如果内存不是很紧张或者精度要求不是很低，一般选用<code>double</code>。14位的精度(是有效数字位，不是小数点后的位数)通常够用了。注意，问题来了，数据精度位数达到了14位，但有些<ahref="https://www.zhihu.com/search?q=浮点运算&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">浮点运算</a>的结果精度并达不到这么高，可能准确的结果只有10~12位左右。那低几位呢？自然就是不可预料的数字了。这给我们带来这样的问题：即使是理论上相同的值，由于是经过不同的运算过程得到的，他们在低几位有可能(一般来说都是)是不同的。这种现象看似没太大的影响，却会一种运算产生致命的影响：==。恩，就是判断相等。注意，C/C++中浮点数的==需要完全一样才能返回true。来看下面这个例子：</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="built_in">asin</span>(<span class="built_in">sqrt</span>(<span class="number">2.0</span>) / <span class="number">2</span>) * <span class="number">4.0</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; a = %.20lf\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; b = %.20lf\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; a - b = %.20lf\n&quot;</span>, a - b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a == b = %d\n&quot;</span>, a == b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a = 3.14159265358979360000</span><br><span class="line"> b = 3.14159265358979310000</span><br><span class="line"> a - b = 0.00000000000000044409</span><br><span class="line">a == b = 0</span><br></pre></td></tr></table></figure><p>​ 我们解决的办法是引进<code>eps</code>，来辅助判断浮点数的相等。</p><h2 id="eps">eps</h2><p>​ <span class="math inline">\(eps\)</span> 缩写自 <spanclass="math inline">\(epsilon\)</span>，表示一个小量，但这个小量又要确保远大于浮点运算结果的不确定量。<spanclass="math inline">\(eps\)</span>最常见的取值是<code>1e-8</code>左右。引入 <spanclass="math inline">\(eps\)</span> 后，我们判断两浮点数 <spanclass="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>相等的方式如下:</p><p>​ 定义<ahref="https://www.zhihu.com/search?q=三出口函数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">三出口函数</a>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sgn</span><span class="params">(<span class="type">double</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; -eps ? <span class="number">-1</span> : a &lt; eps ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 则各种判断大小的运算都应做如下修正：</p><table><thead><tr class="header"><th>传统意义</th><th>修正写法1</th><th>修正写法2</th></tr></thead><tbody><tr class="odd"><td><code>a == b</code></td><td><code>sgn(a - b) == 0</code></td><td><code>fabs(a – b) &lt; eps</code></td></tr><tr class="even"><td><code>a != b</code></td><td><code>sgn(a - b) != 0</code></td><td><code>fabs(a – b) &gt; eps</code></td></tr><tr class="odd"><td><code>a &lt; b</code></td><td><code>sgn(a - b) &lt; 0</code></td><td><code>a – b &lt; -eps</code></td></tr><tr class="even"><td><code>a &lt;= b</code></td><td><code>sgn(a - b) &lt;= 0</code></td><td><code>a – b &lt; eps</code></td></tr><tr class="odd"><td><code>a &gt; b</code></td><td><code>sgn(a - b) &gt; 0</code></td><td><code>a – b &gt; eps</code></td></tr><tr class="even"><td><code>a &gt;= b</code></td><td><code>sgn(a - b) &gt;= 0</code></td><td><code>a – b &gt; -eps</code></td></tr></tbody></table><p>​这样，我们才能把相差非常近的浮点数判为相等；同时把确实相差较大(差值大于<span class="math inline">\(eps\)</span> )的数判为不相等。</p><p>PS: 养成好习惯，尽量不要再对浮点数做==判断。例如，我的修正写法<spanclass="math inline">\(2\)</span>里就没有出现==。</p><h2 id="eps带来的函数越界">eps带来的函数越界</h2><p>​ 如果<code>sqrt(a)</code>、<code>asin(a)</code>、<code>acos(a)</code>中的a是你自己算出来并传进来的，那就得小心了。</p><p>​ 如果 <span class="math inline">\(a\)</span> 本来应该是 <spanclass="math inline">\(0\)</span>的，由于浮点误差，可能实际是一个绝对值很小的负数（比如<code>1e-12</code>），这样<code>sqrt(a)</code> 应得 <span class="math inline">\(0\)</span>的，直接因 <span class="math inline">\(a\)</span> 不在定义域而出错。</p><p>​ 类似地，如果 <span class="math inline">\(a\)</span> 本来应该是 ±1,则<code>asin(a)</code>、<code>acos(a)</code> 也有可能出错。</p><p>​ 因此，对于此种函数，必需事先对 <spanclass="math inline">\(a\)</span> 进行校正。</p><h2 id="输出陷阱i">输出陷阱I</h2><p>​这一节和下一节一样，都是因为题目要求输出浮点数，导致的问题。而且都和四舍五入有关。</p><p>​ 说到四舍五入，就再扯一下相关内容,据我所知有三种常见的方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“% <span class="number">.3</span>lf”, a); <span class="comment">// 保留a的三位小数，按照第四位四舍五入</span></span><br><span class="line">(<span class="type">int</span>)a;              <span class="comment">// 将a靠进0取整</span></span><br><span class="line"><span class="built_in">ceil</span>(a);<span class="built_in">floor</span>(a);    <span class="comment">// 顾名思义，向上取证、向下取整。需要注意的是，这两个函数都返回double，而非int</span></span><br></pre></td></tr></table></figure><p>​ 其中第一种很常见于输出(nonsense…)。</p><p>​现在考虑一种情况,题目要求输出保留两位小数。有个case的正确答案的精确值是<span class="math inline">\(0.005\)</span> ,按理应该输出 <spanclass="math inline">\(0.01\)</span>，但你的结果可能是 <spanclass="math inline">\(0.005000000001\)</span>(恭喜)，也有可能是 <spanclass="math inline">\(0.004999999999\)</span>(悲剧),如果按照<code>printf(“%.2lf”, a);</code>输出，那你的遭遇将和括号里的字相同。</p><p>​ 解决办法是，如果 <span class="math inline">\(a\)</span> 为正，则输出<code>a+eps</code>，否则输出<ahref="https://www.zhihu.com/search?q=a-eps&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">a-eps</a></p><blockquote><p>典型案例：<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/POJ-2826">POJ-2826</a></p></blockquote><h2 id="输出陷阱ii">输出陷阱II</h2><p>​ ICPC题目输出有个不成文的规定(有时也成文)，不要输出: <spanclass="math inline">\(-0.000\)</span></p><p>那我们首先要弄清，什么时候按 <code>printf(“%.3lf\n”, a);</code>输出会出现这个结果。</p><p>​ 直接给出结果好了：<span class="math inline">\(a∈(-0.000499999……,-0.000……1)\)</span></p><p>​ 所以，如果你发现a落在这个范围内，请直接输出0.000。更保险的做法是用<ahref="https://www.zhihu.com/search?q=sprintf&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">sprintf</a>直接判断输出结果是不是-0.000再予处理。</p><blockquote><p>典型案例：<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/UVA-746">UVA-746</a></p></blockquote><p><strong>6. 范围越界</strong></p><p>​ 这个严格来说不属于精度范畴了，不过凑数还是可以的。请注意，虽然<code>double</code>可以表示的数的范围很大，却不是不穷大，上面说过最大是<code>1e308</code>。所以有些时候你得小心了，比如做连乘的时候，必要的时候要换成对数的和。</p><blockquote><p>典型案例:<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/HDU-3558">HDU-3558</a></p></blockquote><h2 id="关于sett">关于<code>set&lt;T&gt;</code></h2><p>​ 有时候我们可能会有这种需求，对浮点数进行 插入、查询是否插入过的操作。手写 <span class="math inline">\(hash\)</span> 表是一个方法（<ahref="https://www.zhihu.com/search?q=hash函数&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D">hash函数</a>一样要小心设计），但<code>set</code> 不是更方便吗。但 <code>set</code>好像是按==来判重的呀？貌似行不通呢。经观察，set不是通过==来判断相等的，是通过<span class="math inline">\(&lt;\)</span> 来进行的，具体说来，只要<spanclass="math inline">\(a&lt;b\)</span> 和 <spanclass="math inline">\(b&lt;a\)</span> 都不成立，就认为 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 相等，可以发现，</p><p>​如果将小于定义成：<code>bool operator &lt; (const Dat dat)const&#123;return val &lt; dat.val - eps;&#125;</code>就可以解决问题了。 (基本类型不能重载运算符，所以封装了下)</p><h2 id="输入值波动过大">输入值波动过大</h2><p>​ 这种情况不常见，不过可以帮助你更熟悉 <spanclass="math inline">\(eps\)</span>。假如一道题输入说，给一个浮点数 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(1e-20 &lt;a &lt; 1e20\)</span>。那你还敢用 <spanclass="math inline">\(1e-8\)</span> 做 <spanclass="math inline">\(eps\)</span> 么？合理的做法是把 <spanclass="math inline">\(eps\)</span> 按照输入规模缩放到合适大小。</p><blockquote><p>典型案例：<ahref="https://link.zhihu.com/?target=https%3A//vjudge.net/problem/HUST-1361">HUST-1361</a></p></blockquote><h2 id="一些建议">一些建议</h2><p>​ 容易产生较大浮点误差的函数有<code>asin</code>、<code>acos</code>。欢迎尽量使用<code>atan2</code></p><p>​ 另外，如果数据明确说明是整数，而且范围不大的话，使用<code>int</code> 或者 <code>long long</code> 代替 <code>double</code>都是极佳选择，因为就不存在浮点误差了(尽管我几乎从来都只用<code>double</code> !)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算几何中的精度问题&quot;&gt;《计算几何中的精度问题》&lt;/h1&gt;
&lt;p&gt;​
计算几何头疼的地方一般在于代码量大和精度问题，代码量问题只要平时注意积累模板一般就不成问题了。精度问题则不好说，有时候一个&lt;a
href=&quot;https://www.zhihu.com/search?q=精度问题&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D&quot;&gt;精度问题&lt;/a&gt;就可能成为一道题的瓶颈，简直“画龙点睛”。这些年的题目基本是朝着越来越不卡精度的方向发展了，但是也不乏一些%^&amp;amp;%题#&lt;span
class=&quot;math inline&quot;&gt;&#92;(%&#92;)&lt;/span&gt;^，另外有些常识不管题目卡不卡，都是应该知道的。今天我就开膛回顾下见过且还有印象的精度问题。&lt;/p&gt;
&lt;p&gt;​ 计算几何的精度问题说到底其实是&lt;a
href=&quot;https://www.zhihu.com/search?q=浮点数&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D&quot;&gt;浮点数&lt;/a&gt;的精度问题，但我觉得“&lt;a
href=&quot;https://www.zhihu.com/search?q=计算几何&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D&quot;&gt;计算几何&lt;/a&gt;”比“浮点数”更能吸引眼球，所以选了这个标题。&lt;/p&gt;
&lt;h2 id=&quot;浮点数为啥会有精度问题&quot;&gt;浮点数为啥会有精度问题？&lt;/h2&gt;
&lt;p&gt;​
浮点数(以C/C++为准)，一般用的较多的是&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 8%&quot; /&gt;
&lt;col style=&quot;width: 8%&quot; /&gt;
&lt;col style=&quot;width: 19%&quot; /&gt;
&lt;col style=&quot;width: 63%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;占字节数&lt;/th&gt;
&lt;th&gt;数值范围&lt;/th&gt;
&lt;th&gt;&lt;a
href=&quot;https://www.zhihu.com/search?q=十进制精度位数&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D&quot;&gt;十进制精度位数&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-3.4e-38～3.4e38&lt;/td&gt;
&lt;td&gt;6~7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-1.7e-308～1.7e308&lt;/td&gt;
&lt;td&gt;14~15&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​
如果内存不是很紧张或者精度要求不是很低，一般选用&lt;code&gt;double&lt;/code&gt;。14位的精度(是有效数字位，不是小数点后的位数)通常够用了。注意，问题来了，数据精度位数达到了14位，但有些&lt;a
href=&quot;https://www.zhihu.com/search?q=浮点运算&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A38414169%7D&quot;&gt;浮点运算&lt;/a&gt;的结果精度并达不到这么高，可能准确的结果只有10~12位左右。那低几位呢？自然就是不可预料的数字了。这给我们带来这样的问题：即使是理论上相同的值，由于是经过不同的运算过程得到的，他们在低几位有可能(一般来说都是)是不同的。这种现象看似没太大的影响，却会一种运算产生致命的影响：==。恩，就是判断相等。注意，C/C++中浮点数的==需要完全一样才能返回true。来看下面这个例子：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://cuiluyi.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/25/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/</id>
    <published>2024-03-24T17:02:27.000Z</published>
    <updated>2024-04-30T05:42:38.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><h2 id="概念了解">概念【了解】</h2><ol type="1"><li><p><strong>动态规划：</strong>将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解</p><ul><li>动态规划会将每个求解过的子问题的解记录下来，这样下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算</li><li>采用<strong>递归</strong>（又叫<strong>记忆化搜索</strong>）实现</li></ul></li><li><p><strong>重叠子问题：</strong>如果<strong>一个问题可以被分解成若干个子问题</strong>，且这些子问题会重复出现，就称这个问题拥有重叠子问题。一个问题必须拥有重叠子问题，才能用动态规划去解决。</p></li><li><p><strong>最优子结构：</strong>如果<strong>一个问题的最优解可以由其子问题的最优解有效地构造出来</strong>，那么称为这个问题拥有的最优子结构。最优子结构保证了动态规划中的原问题的最优解可以由子问题的最优解推导而来</p></li><li><p><strong>动态规划</strong> vs<strong>分治：</strong>都是分解为子问题然后合并子问题得到解，但是：</p><ul><li>动态规划分解出的子问题是重叠的</li><li>分治分解出的子问题是不重叠的</li></ul></li><li><p><strong>动态规划 vs 贪心：</strong>都有最优子结构，但是：</p><ul><li>贪心直接选择一个子问题去求解，会抛弃一些子问题，这种选择的正确性需要用归纳法证明</li><li>而动态规划会考虑所有的子问题，所以这种选择一定是正确的</li></ul></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png"alt="Snipaste_2019-09-13_17-06-58.png" /><figcaptionaria-hidden="true">Snipaste_2019-09-13_17-06-58.png</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403231407219.jpeg"alt="闫式dp.jpg" /><figcaption aria-hidden="true">闫式dp.jpg</figcaption></figure><ol type="1"><li>集合划分原则</li></ol><ul><li><p>不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】</p></li><li><p>如何将现有的集合划分为更小的子集，使得<strong>所有子集</strong>都可以计算出来</p></li></ul><ol start="2" type="1"><li>所有数组的下标从 <span class="math inline">\(0\)</span>开始递归还是下标从 <span class="math inline">\(1\)</span>开始递归？</li></ol><ul><li>如果涉及到 <code>f[i-1]</code>，建议下标从 1开始递归，<code>f[0]</code>存储初始值</li><li>否则下标从 0 开始递归</li></ul><ol start="3" type="1"><li>考虑状态函数初始化</li></ol><ul><li>只需要对递归入口/起点（往往是下标 <spanclass="math inline">\(0\)</span>）进行初始化，之后的会通过迭代进行更新，不需要初始化<ul><li>若状态函数的递归入口/起点有意义，则初始化为实际含义的状态属性值</li><li>若状态函数的递归入口/起点无意义，则初始化为INF（求最小值）、-INF（求最大值）</li></ul></li><li>迭代从递归入口/起点的下一个位置开始</li><li>如果要找min的话别忘了INF，要找有负数的max的话别忘了</li></ul><span id="more"></span><h2 id="背包问题">背包问题</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404191746465.png"alt="image-20240419174617174" /><figcaption aria-hidden="true">image-20240419174617174</figcaption></figure><ul><li>0/1 背包：每种物品只有 1 个</li><li>完全背包：每种物品有无限个</li><li>多重背包：每种物品有 <span class="math inline">\(S_i\)</span>个</li><li>分组背包：有 N组物品，每组物品有若干个，同一组内的物品最多只能选一个</li><li>混合背包：第一类物品只能用1次（01背包），第二类物品可以用无限次（完全背包），第三类物品最多只能用<span class="math inline">\(s_i\)</span> 次（多重背包）</li></ul><p>标记(<span class="math inline">\(Notations\)</span>)</p><ul><li>N：物品种数</li><li>V：背包容量</li><li>S：物品数量</li></ul><p>:smile:<strong><ahref="https://www.acwing.com/blog/content/46542/">背包问题中体积至多/恰好/至少是 j 的初始化问题的研究 - AcWing</a></strong></p><!--more--><h3 id="背包">0/1 背包</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404182045086.png"alt="image-20240418204511783" /><figcaption aria-hidden="true">image-20240418204511783</figcaption></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8133547/">AcWing2. 01背包问题 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&amp;envId=top-100-liked">279.完全平方数 - 力扣（LeetCode）</a></p></li><li><p><a href="https://www.acwing.com/solution/content/241925/">AcWing1047. 糖果 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8420088/">AcWing423. 采药 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8420167/">AcWing1024. 装箱问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8426205/">AcWing278. 数字组合 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8440400/">AcWing426. 开心的金明 - AcWing</a></p></li></ul><h3 id="完全背包问题">完全背包问题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8134352/">AcWing3. 完全背包问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8229758/">AcWing4700. 何以包邮？ - AcWing</a></li><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11788635/">AcWing1371. 货币系统（每日一题） - AcWing</a></li><li><a href="https://www.acwing.com/solution/content/242408/">LeetCode322. 零钱兑换 - AcWing</a></li></ul><h3 id="多重背包">多重背包</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8140913/">AcWing4. 多重背包问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8430914/">AcWing1019. 庆功会 - AcWing</a></p></li></ul><h3 id="分组背包">分组背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8144220/">AcWing9. 分组背包问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8436618/">AcWing1013. 机器分配 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8440415/">AcWing487. 金明的预算方案 - AcWing</a></li></ul><h3 id="混合背包">混合背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8442455/">AcWing7. 混合背包问题 - AcWing</a></li></ul><h3 id="二维费用背包">二维费用背包</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8426248/">AcWing8. 二维费用的背包问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8420612/">AcWing1022. 宠物小精灵之收服 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8429100/">AcWing1020. 潜水员 - AcWing</a></p></li></ul><h3 id="背包问题求具体方案">背包问题求具体方案</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8436139/">AcWing12. 背包问题求具体方案 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8436618/">AcWing1013. 机器分配 - AcWing</a></li></ul><h3 id="背包问题求方案数">背包问题求方案数</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8426205/">AcWing278. 数字组合 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8430848/">AcWing1023. 买书 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8430971/">AcWing1021. 货币系统 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8442259/">AcWing532. 货币系统 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8449881/">AcWing11. 背包问题求方案数 - AcWing</a></li></ul><h2 id="状态机模型">状态机模型</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8190672/">AcWing285. 没有上司的舞会 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8449405/">AcWing1049. 大盗阿福 - AcWing</a></li></ul><h2 id="线性dp">线性DP</h2><p>线性DP指的是<strong>状态转移方程</strong>存在某种线性关系</p><h3 id="数字三角形">数字三角形</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404172005650.png"alt="image-20240417200506233" /><figcaption aria-hidden="true">image-20240417200506233</figcaption></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8147866/">AcWing898. 数字三角形 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8411489/">AcWing1015. 摘花生 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8411972/">AcWing1018. 最低通行费 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8413140/">AcWing1027. 方格取数 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8413877/">AcWing275. 传纸条 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/pascals-triangle/description/">118.杨辉三角 - 力扣（LeetCode）</a></p></li></ul><h3 id="最长上升子序列">最长上升子序列</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8155307/">AcWing895. 最长上升子序列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8414494/">AcWing1017. 怪盗基德的滑翔翼 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8414507/">AcWing1014. 登山 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/problem/content/1261/">AcWing482. 合唱队形 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8415527/">AcWing1012. 友好城市 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8415508/">AcWing1016. 最大上升子序列和 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8421970/">AcWing1010. 拦截导弹 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8423647/">AcWing187. 导弹防御系统 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8423515/">AcWing272. 最长公共上升子序列 - AcWing</a></p></li></ul><h3 id="最长公共子序列lcs">最长公共子序列（LCS）</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8155566/">AcWing897. 最长公共子序列 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8161653/">AcWing902. 最短编辑距离 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8178931/">AcWing899. 编辑距离 - AcWing</a></li></ul><blockquote><p><strong>最长公共字串</strong>问题——参考KMP</p></blockquote><h3 id="乘积最大子数组">乘积最大子数组</h3><ul><li><ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">152.乘积最大子数组 - 力扣（LeetCode）</a></li></ul><h3 id="其他">其他</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8372861/">AcWing312. 乌龟棋（每日一题） - AcWing</a></li></ul><h2 id="区间dp">区间DP</h2><h3 id="模板">模板</h3><ul><li><p>区间 DP的状态<code>f[i][j]</code>是一个<strong>区间</strong></p></li><li><p>区间 DP要注意<strong>循环的先后顺序</strong>，否则可能会出现当前要计算的状态值并未在先前循环计算过，通常按照以下顺序进行循环</p><ol type="1"><li><strong>从小到大</strong>枚举<strong>区间长度</strong><ol type="1"><li>一般 len = 1 时用来初始化</li><li>枚举从 len = 2 开始</li></ol></li><li>枚举<strong>区间左端点</strong></li><li>枚举决策</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = 初始值</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8157696/">AcWing282. 石子合并 - AcWing</a></li></ul><h2 id="计数dp">计数DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8179224/">AcWing900. 整数划分 - AcWing</a></li></ul><h2 id="树形dp">树形DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8190672/">AcWing285. 没有上司的舞会 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8386701/">AcWing3465. 病毒溯源（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8442105/">AcWing10. 有依赖的背包问题 - AcWing</a></li></ul><h2 id="数位统计dp">数位统计DP</h2><h2 id="状态压缩dp">状态压缩DP</h2><blockquote><p>参考<ahref="https://njfjnkm.github.io/2024/03/03/%5Bobject%20Object%5D/算法/【基本算法】/#二进制状态压缩">【基本算法】</a>——位运算——二进制状态压缩</p></blockquote><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8182668/">AcWing291. 蒙德里安的梦想 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8228208/">AcWing91. 最短Hamilton路径 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8458005/">AcWing1064. 小国王 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8458721/">AcWing327. 玉米田 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8461679/">AcWing292. 炮兵阵地 - AcWing</a></p></li></ul><h2 id="单调队列优化dp">单调队列优化DP</h2><h3 id="最大子列和">最大子列和</h3><h4 id="类型一">类型一</h4><p>​ 给定 <span class="math inline">\(N\)</span> 个整数的序列${A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ 0,_{k=i}^j{A_k} } $ 的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = 0;</code></p></blockquote><h4 id="类型二">类型二</h4><p>​ 给定 <span class="math inline">\(N\)</span> 个整数的序列${A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ _{k=i}^j{A_k} } $ 的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = -MAX_INT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = -MAX_INT;</code></p></blockquote><p>:package:一定是先更新<code>maxsum = max(maxsum, thissum);</code>，再判断是否重新<code>thissum = 0;</code></p><h2 id="斜率优化dp">斜率优化DP</h2><h2 id="记忆化搜索">记忆化搜索</h2><ul><li><ahref="https://www.acwing.com/activity/content/problem/content/1013/">AcWing901. 滑雪 - AcWing</a></li></ul><h1 id="技巧">技巧</h1><h2 id="空间优化">空间优化</h2><p>​ 动态规划的状态函数 <code>f</code>如果<strong>维度过高</strong>，可能会导致变量 <code>f</code> <spanclass="math inline">\(MLE\)</span>，这时我们可以采用以下 <spanclass="math inline">\(2\)</span> 种方法优化空间</p><h3 id="状态压缩">状态压缩</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8133547/">AcWing2. 01背包问题 - AcWing</a>为例，我们发现：</p><ul><li><code>f[i]</code> 仅用到了 <code>f[i - 1]</code> 层</li></ul><ol start="2" type="1"><li><code>j</code> 与 <code>j - v[i]</code> 均小于<code>j</code></li></ol><ul><li>若用到上一层的状态时，从大到小枚举，反之从小到大枚举</li></ul><p>:taco:注意：状态压缩通常只能用于类似背包问题状态转移方程，需要严格满足</p><ul><li><code>f[i]</code> 仅与 <code>f[i - 1]</code>、<code>f[i]</code>有关</li><li>其余维度必须是<strong>线性表达式</strong></li></ul><h3 id="滚动数组">滚动数组</h3><p>以<ahref="https://www.acwing.com/activity/content/code/content/8461679/">AcWing292. 炮兵阵地 - AcWing</a>为例</p><ul><li>滚动数组的思想很简单，通常情况下 <code>f[i]</code> 只与<code>f[i - 1]</code>、<code>f[i - 2]</code>、……、<code>f[i - k + 1]</code>有关，因此我们定义 <code>f</code> 时，可以将其第一维指定为 <spanclass="math inline">\(k\)</span> 维，从而减小空间复杂度</li><li>函数编写时按照原来的定义写，只需要将 <code>f[i]</code> 换成<code>f[i % k]</code> 即可，其余部分不需要做任何改变</li></ul><p>:taco:相较于状态压缩，滚动数组的适用条件宽松很多，也<strong>适用于更多类型的状态转移方程</strong>，<strong>只需满足1 个条件</strong>：</p><ul><li><code>f[i]</code> 只与<code>f[i - 1]</code>、<code>f[i - 2]</code>、……、<code>f[i - k + 1]</code>有关</li></ul><h2 id="循环次数加1">循环次数加1</h2><p>以<ahref="https://www.acwing.com/activity/content/code/content/8458005/">AcWing1064. 小国王 - AcWing</a>为例</p><ul><li>最终答案是 <code>f[n][m][所有合法状态]</code>中的最大值，因此我们需要枚举所有合法状态，计算最大值</li><li>:smile:这里我们可以在计算时循环到到<code>n + 1</code>，这样我们最终的答案就是<code>f[n + 1][m][0]</code>，这样我们就不需要最后枚举所有合法状态了，这也是为什么状态函数<code>f</code> 定义时，第一维度要多 <spanclass="math inline">\(1\)</span> 的原因（ <code>N = 12</code>）的原因</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;动态规划&lt;/h1&gt;
&lt;h2 id=&quot;概念了解&quot;&gt;概念【了解】&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划：&lt;/strong&gt;将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态规划会将每个求解过的子问题的解记录下来，这样下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;递归&lt;/strong&gt;（又叫&lt;strong&gt;记忆化搜索&lt;/strong&gt;）实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;重叠子问题：&lt;/strong&gt;如果&lt;strong&gt;一个问题可以被分解成若干个子问题&lt;/strong&gt;，且这些子问题会重复出现，就称这个问题拥有重叠子问题。
一个问题必须拥有重叠子问题，才能用动态规划去解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;最优子结构：&lt;/strong&gt;如果&lt;strong&gt;一个问题的最优解可以由其子问题的最优解有效地构造出来&lt;/strong&gt;，那么称为这个问题拥有的最优子结构。最优子结构保证了动态规划中的原问题的最优解可以由子问题的最优解推导而来&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt; vs
&lt;strong&gt;分治：&lt;/strong&gt;都是分解为子问题然后合并子问题得到解，但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态规划分解出的子问题是重叠的&lt;/li&gt;
&lt;li&gt;分治分解出的子问题是不重叠的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态规划 vs 贪心：&lt;/strong&gt;都有最优子结构，但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贪心直接选择一个子问题去求解，会抛弃一些子问题，这种选择的正确性需要用归纳法证明&lt;/li&gt;
&lt;li&gt;而动态规划会考虑所有的子问题，所以这种选择一定是正确的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png&quot;
alt=&quot;Snipaste_2019-09-13_17-06-58.png&quot; /&gt;
&lt;figcaption
aria-hidden=&quot;true&quot;&gt;Snipaste_2019-09-13_17-06-58.png&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403231407219.jpeg&quot;
alt=&quot;闫式dp.jpg&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;闫式dp.jpg&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;集合划分原则&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何将现有的集合划分为更小的子集，使得&lt;strong&gt;所有子集&lt;/strong&gt;都可以计算出来&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot; type=&quot;1&quot;&gt;
&lt;li&gt;所有数组的下标从 &lt;span class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;
开始递归还是下标从 &lt;span class=&quot;math inline&quot;&gt;&#92;(1&#92;)&lt;/span&gt;
开始递归？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果涉及到 &lt;code&gt;f[i-1]&lt;/code&gt;，建议下标从 1
开始递归，&lt;code&gt;f[0]&lt;/code&gt;存储初始值&lt;/li&gt;
&lt;li&gt;否则下标从 0 开始递归&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;考虑状态函数初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;只需要对递归入口/起点（往往是下标 &lt;span
class=&quot;math inline&quot;&gt;&#92;(0&#92;)&lt;/span&gt;）进行初始化，之后的会通过迭代进行更新，不需要初始化
&lt;ul&gt;
&lt;li&gt;若状态函数的递归入口/起点有意义，则初始化为实际含义的状态属性值&lt;/li&gt;
&lt;li&gt;若状态函数的递归入口/起点无意义，则初始化为INF（求最小值）、-INF（求最大值）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;迭代从递归入口/起点的下一个位置开始&lt;/li&gt;
&lt;li&gt;如果要找min的话别忘了INF，要找有负数的max的话别忘了&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>时空复杂度分析</title>
    <link href="https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/others/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/others/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2024-03-17T06:33:49.000Z</published>
    <updated>2024-04-30T05:31:35.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度分析">时间复杂度分析</h1><ul><li><p><strong>C++ 1s 的运行数量大概在 <spanclass="math inline">\(1*10^7\)</span> ~ <spanclass="math inline">\(10*10^7 =10^8\)</span></strong>，所以运算量要控制在 <spanclass="math inline">\(10^8\)</span> 以内</p></li><li><p>一般ACM或者笔试题的<strong>时间限制</strong>是<strong>1秒</strong>或<strong>2秒</strong>，在这种情况下，C++代码中的操作次数控制在<span class="math inline">\(10^7\)</span>​~ <spanclass="math inline">\(10^8\)</span>​ 为最佳</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403302109655.png"alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress" /><figcaptionaria-hidden="true">aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress</figcaption></figure><ul><li>【由<strong>数据范围</strong>反推<strong>算法复杂度</strong>以及<strong>算法内容</strong>】下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</li></ul><ol type="1"><li><span class="math inline">\(n \leqslant 30\)</span> =&gt;指数级别：dfs+剪枝、状态压缩 dp</li><li><span class="math inline">\(n \leqslant 10^2\)</span> =&gt; <spanclass="math inline">\(O(n^3)\)</span>：floyd、dp、高斯消元</li><li><span class="math inline">\(n \leqslant 10^3\)</span> =&gt; <spanclass="math inline">\(O(n^2)\)</span>、<spanclass="math inline">\(O(n^2logn)\)</span>：dp、二分、朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li><span class="math inline">\(n \leqslant 10^4\)</span> =&gt; <spanclass="math inline">\(O(n\sqrt{n})\)</span>：块状链表、分块、莫队</li><li><span class="math inline">\(n \leqslant 10^5\)</span> =&gt; <spanclass="math inline">\(O(nlogn)\)</span>：各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li><span class="math inline">\(n \leqslant 10^6\)</span>​<ol type="1"><li><span class="math inline">\(O(n)\)</span>​​：单调队列、hash、双指针扫描、BFS、并查集、kmp、AC自动机</li><li>常数比较小的 <span class="math inline">\(O(nlogn)\)</span>​算法：sort、树状数组、heap、dijkstra、spfa</li></ol></li><li><span class="math inline">\(n \leqslant 10^7\)</span>​ =&gt;O(n)：双指针扫描、kmp、AC自动机、线性筛素数</li><li><span class="math inline">\(n \leqslant 10^9\)</span>​ =&gt; <spanclass="math inline">\(O(\sqrt{n})\)</span>​：判断质数</li><li><span class="math inline">\(n \leqslant 10^{18}\)</span>​ =&gt; <spanclass="math inline">\(O(logn)\)</span>​：最大公约数、快速幂、数位DP</li><li><span class="math inline">\(n \leqslant 10^{1000}\)</span> =&gt;<span class="math inline">\(O((logn)^2)\)</span>：高精度加减乘除</li><li><span class="math inline">\(n \leqslant 10^{100000}\)</span> =&gt;<span class="math inline">\(O(logk *loglogk)\)</span>，k表示位数：高精度加减、FFT/NTT</li></ol><span id="more"></span><h1 id="空间复杂度">空间复杂度</h1><h2 id="单位换算">单位换算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> KB= <span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> MB=<span class="number">1024</span>*<span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> Byte</span><br></pre></td></tr></table></figure><h2 id="数据类型空间大小">数据类型空间大小</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="number">4</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>, <span class="type">long</span> <span class="type">long</span>   <span class="number">6B</span>yte</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line">*指针 <span class="number">32</span>位系统 <span class="number">4B</span><span class="number">64</span>位系统 <span class="number">8B</span></span><br></pre></td></tr></table></figure><h2 id="空间分析">空间分析</h2><ul><li>一般 ACM或者笔试题的<strong>空间限制</strong>是<strong>64MB</strong>，最多只能<strong>使用/声明</strong><span class="math inline">\(1.6*10^7\)</span>个<code>int</code>类型变量</li></ul><p><span class="math display">\[64MB=2^{26}Byte=2^{24} int =1.6*10^7 int\]</span></p><ul><li><p>分析时要注意，计算全局<strong>变量</strong>的空间复杂度要看<strong>实际运行时会用到的空间</strong>，而不是总空间，因为全局变量在未被使用时分配的是<strong>虚拟内存</strong>，但<font color = 'red'><strong>声明时</strong>仍然不能超过<strong>64MB</strong>的空间限制</font></p></li><li><p>当代码里有<strong>递归</strong>函数或需要<strong>大量调用函数</strong>时，需要调用系统栈，因此分析空间复杂度还要加上<strong>栈空间</strong></p><ul><li>快速排序：需要递归 <span class="math inline">\(log\ n\)</span>​层，因此空间复杂度是 <span class="math inline">\(O(log n)\)</span></li><li>归并排序：而归并排序在递归时每一层还需要开一个长度为 <spanclass="math inline">\(n\)</span> 的数组，因此空间复杂度是 <spanclass="math inline">\(O(nlog\ n)\)</span></li></ul></li></ul><h2 id="实例">实例</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261751495.png"alt="image-20240326175147312" /><figcaption aria-hidden="true">image-20240326175147312</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;时间复杂度分析&quot;&gt;时间复杂度分析&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;C++ 1s 的运行数量大概在 &lt;span
class=&quot;math inline&quot;&gt;&#92;(1*10^7&#92;)&lt;/span&gt; ~ &lt;span
class=&quot;math inline&quot;&gt;&#92;(10*10^7 =
10^8&#92;)&lt;/span&gt;&lt;/strong&gt;，所以运算量要控制在 &lt;span
class=&quot;math inline&quot;&gt;&#92;(10^8&#92;)&lt;/span&gt; 以内&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一般ACM或者笔试题的&lt;strong&gt;时间限制&lt;/strong&gt;是&lt;strong&gt;1秒&lt;/strong&gt;或&lt;strong&gt;2秒&lt;/strong&gt;，在这种情况下，C++代码中的操作次数控制在
&lt;span class=&quot;math inline&quot;&gt;&#92;(10^7&#92;)&lt;/span&gt;​~ &lt;span
class=&quot;math inline&quot;&gt;&#92;(10^8&#92;)&lt;/span&gt;​ 为最佳&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403302109655.png&quot;
alt=&quot;aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress&quot; /&gt;
&lt;figcaption
aria-hidden=&quot;true&quot;&gt;aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;【由&lt;strong&gt;数据范围&lt;/strong&gt;反推&lt;strong&gt;算法复杂度&lt;/strong&gt;以及&lt;strong&gt;算法内容&lt;/strong&gt;】下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 30&#92;)&lt;/span&gt; =&amp;gt;
指数级别：dfs+剪枝、状态压缩 dp&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^2&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n^3)&#92;)&lt;/span&gt;：floyd、dp、高斯消元&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^3&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n^2)&#92;)&lt;/span&gt;、&lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n^2logn)&#92;)&lt;/span&gt;：dp、二分、朴素版Dijkstra、朴素版Prim、Bellman-Ford&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^4&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(n&#92;sqrt{n})&#92;)&lt;/span&gt;：块状链表、分块、莫队&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^5&#92;)&lt;/span&gt; =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(nlogn)&#92;)&lt;/span&gt;：各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^6&#92;)&lt;/span&gt;​
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(O(n)&#92;)&lt;/span&gt;​​：单调队列、
hash、双指针扫描、BFS、并查集、kmp、AC自动机&lt;/li&gt;
&lt;li&gt;常数比较小的 &lt;span class=&quot;math inline&quot;&gt;&#92;(O(nlogn)&#92;)&lt;/span&gt;​
算法：sort、树状数组、heap、dijkstra、spfa&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^7&#92;)&lt;/span&gt;​ =&amp;gt;
O(n)：双指针扫描、kmp、AC自动机、线性筛素数&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^9&#92;)&lt;/span&gt;​ =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(&#92;sqrt{n})&#92;)&lt;/span&gt;​：判断质数&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^{18}&#92;)&lt;/span&gt;​ =&amp;gt; &lt;span
class=&quot;math inline&quot;&gt;&#92;(O(logn)&#92;)&lt;/span&gt;​：最大公约数、快速幂、数位DP&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^{1000}&#92;)&lt;/span&gt; =&amp;gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(O((logn)^2)&#92;)&lt;/span&gt;：高精度加减乘除&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(n &#92;leqslant 10^{100000}&#92;)&lt;/span&gt; =&amp;gt;
&lt;span class=&quot;math inline&quot;&gt;&#92;(O(logk *
loglogk)&#92;)&lt;/span&gt;，k表示位数：高精度加减、FFT/NTT&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="others" scheme="https://cuiluyi.gitee.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>咖啡</title>
    <link href="https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/"/>
    <id>https://cuiluyi.gitee.io/2024/03/17/[object%20Object]/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/</id>
    <published>2024-03-17T01:46:27.000Z</published>
    <updated>2024-03-19T07:03:18.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有关咖啡">有关咖啡</h1><h2id="咖啡因每日的安全使用量是多少">咖啡因每日的安全使用量是多少？</h2><p>一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。</p><span id="more"></span><h2id="雀巢咖啡伴侣是否含反式脂肪酸">雀巢咖啡伴侣是否含反式脂肪酸？</h2><p>在雀巢咖啡伴侣的包装上有明确的标识：反式脂肪酸为0克，所以您可以放心使用。</p><h2id="为什么咖啡伴侣的瓶子是棕色的">为什么咖啡伴侣的瓶子是棕色的？</h2><p>适量的咖啡因摄取对普通大多数的人都是安全的。可能会有一些人群对咖啡因较一般人敏感，与那些对咖啡因不太敏感的人相比，这类人群可能会对少量的咖啡感到不适。通常情况下，孕妇和老年人可能会相对更加敏感一些。</p><h2id="为什么咖啡伴侣的瓶子是棕色的-1">为什么咖啡伴侣的瓶子是棕色的？</h2><p>用棕色瓶子主要是为了避光，咖啡伴侣里某些营养成分是对光敏感的。我们为了在保质期内保证食品的安全和风味，采用了能避光的棕色玻璃瓶。</p><h2 id="喝咖啡对身体有害吗">喝咖啡对身体有害吗？</h2><p>咖啡是一种天然而且健康的饮料。咖啡中除含有咖啡因之外，它还含有对人体健康有利的多种生物活性物质和营养素，如抗氧化物质、矿物质、烟酸和内脂。咖啡能提高警觉性，让我们更有效地利用前额部的大脑皮层，提高注意力和记忆力。关于咖啡因，人们从古代的时候起就开始饮用咖啡类的饮品了。咖啡因是咖啡中的天然含有的成份。目前，人类在大约60种植物中发现了咖啡因，其中最为人知的便是茶和咖啡。而一些常见的食品，如巧克力、可乐中都含有少量咖啡因。</p><h2id="经常喝咖啡是否会导致人体内的钙流失">经常喝咖啡是否会导致人体内的钙流失?</h2><p>咖啡因对钙吸收的不良影响非常小，喝1-2勺牛奶就足以弥补了。所有证据显示，中量饮用咖啡不会改变对钙的消化吸收，不会增加尿钙排泄，也不会从大便中丢失。如果每日摄入咖啡超过1升，尿钙排泄和钙丢失就会增加，但将牛奶加到咖啡里面就可以解决这个问题。适量咖啡因摄入不会对骨代谢产生直接影响。（摘自《咖啡无罪的101个理由》）</p><h2 id="喝咖啡可以减肥吗">喝咖啡可以减肥吗？</h2><p>研究表明，适量喝咖啡有助于控制体重，咖啡中含有膳食纤维，有利于帮助肠道蠕动，促进代谢。如果您想要达到减肥的效果，我们建议您咨询专业的营养师。</p><h2 id="雀巢咖啡是如何诞生的">雀巢咖啡是如何诞生的？</h2><p>二十世纪三十年代，雀巢公司受巴西政府的委托，为其过剩的咖啡寻找保存方法。雀巢公司勇敢地接受了这一技术上的挑战，并于1938年成功开发出速溶咖啡生产工艺。采用该工艺，咖啡粉可以长久地保存而不失其香醇风味。从此，人们可以随时方便地享用美味咖啡。雀巢速溶咖啡便由此诞生了，雀巢咖啡(Nescafe)品牌名称就是由公司名称Nestlé及英文中代表咖啡的CAFE组成。</p><h2 id="咖啡中的12是什么意思">1+2咖啡中的1+2是什么意思？</h2><p>1+2咖啡中的1+2是指：1=咖啡，2=植脂末+糖</p><h2 id="每天在什么时间喝咖啡比较好">每天在什么时间喝咖啡比较好？</h2><p>建议白天饮用咖啡。如果想保持规律的生理周期，晚上不要饮用咖啡。</p><h2id="雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏">雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏？</h2><p>即饮咖啡产品冷热饮均可，如加热饮用，加热温度不宜超过55度，勿将瓶装产品放置于火上或微波炉中直接加热，以免发生危险。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;有关咖啡&quot;&gt;有关咖啡&lt;/h1&gt;
&lt;h2
id=&quot;咖啡因每日的安全使用量是多少&quot;&gt;咖啡因每日的安全使用量是多少？&lt;/h2&gt;
&lt;p&gt;一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:
研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="生活" scheme="https://cuiluyi.gitee.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【数学知识】</title>
    <link href="https://cuiluyi.gitee.io/2024/03/15/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/"/>
    <id>https://cuiluyi.gitee.io/2024/03/15/[object%20Object]/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/</id>
    <published>2024-03-15T02:27:16.000Z</published>
    <updated>2024-04-15T12:01:26.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学知识">数学知识</h1><p>:smile:<strong>数论</strong> 经常会出现 <strong>数的大小越界</strong>情况：</p><ul><li>尤其是在做<strong>乘法</strong>、其次是<strong>加法</strong>的时候非常容易溢出，此时可以使用<code>long long</code> 局部转换</li><li>比较稳妥的、一劳永逸的办法是<strong>变量类型</strong>不使用int，<strong>全部使用</strong> <code>long long</code></li><li>数论部分的题目通常需要对结果取模，以下统一使用<code>mod</code>代表取模的数，具体何时取余需要根据<code>mod</code>范围进行确定</li></ul><h2 id="质数">质数</h2><ul><li><strong>质数</strong>：在大于 1 的整数中，如果只包含 1和本身这两个约数，就被成为质数，或者叫素数。</li><li><strong>算数基本定理</strong>：任一大于1的整数 <spanclass="math inline">\(n\)</span>​ 能够唯一地表示成</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_s}^{\alpha _s},  \alpha_i&gt;0,  i=1,2,\cdots ,s\left( * \right)\]</span></p><p>​ 分解式(*)叫做 的 n 的标准分解式</p><p>注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 n表成下面形式： <span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><span id="more"></span><h3 id="判定质数试除法">判定质数——试除法</h3><ul><li>一个数的因数都是成对出现的（例如 12 的因数有 3 和 4，2 和6）所以我们可以只枚举较小的那一个。假设较小的为 <spanclass="math inline">\(d\)</span>，较大的为 <spanclass="math inline">\(n/d\)</span>，则：</li></ul><p><span class="math display">\[d\leqslant \frac{n}{d}\Longrightarrow d\leqslant \sqrt{n}\]</span></p><ul><li>时间复杂度：<span class="math inline">\(O(\sqrt{n})\)</span>​</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8063046/">AcWing866. 试除法判定质数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="comment">// 注意是小于等于</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数试除法">分解质因数——试除法</h3><ul><li><strong>性质</strong>：整数 n 中最多只含有一个<strong>大于</strong>sqrt(n) 的<font color ='red'><strong>质因子</strong></font><ul><li>证明：通过反证法：如果有两个大于 sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</li><li>eg：6 的质因子 3 &gt; sqrt(6)</li></ul></li><li><strong>证明</strong>：循环里面的 <spanclass="math inline">\(i\)</span> 一定是一个质数:</li></ul><blockquote><p>假如 i是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是n 的质因子且比 i 要小，而比 i小的数在之前的循环过程中一定是被条件除完了的，所以 i不可能是合数，只可能是质数</p></blockquote><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8065120/">AcWing867. 分解质因数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 输出最后一个大于sqrt(n)的质数，注意这里的n可能已经被上面的代码更新过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eg：<span class="math inline">\(n = 96 = 2^5 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span> 且 <spanclass="math inline">\(3&gt;\sqrt{6}\)</span> ）</li><li>eg：<span class="math inline">\(n = 6 = 2 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span>）</li><li>eg：n=17，循环不会输出，直接跳到最后判断输出 17（<spanclass="math inline">\(17&gt;\sqrt{17}\)</span>）</li><li>eg：<spanclass="math inline">\(n=16=2^4\)</span>，循环输出后，直接跳到最后判断，不会输出（<spanclass="math inline">\(1=\sqrt{1}\)</span>）</li></ul><h3 id="求-1-n-中的所有素数">求 1 ~ n 中的所有素数</h3><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8068049/">AcWing868. 筛质数 - AcWing</a>】</p><h4 id="朴素筛法不用">朴素筛法（不用）</h4><ul><li><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span>​ <spanclass="math display">\[\frac{n}{2}+\frac{n}{3}+\cdots +\frac{n}{n}=n\left(\frac{1}{2}+\frac{1}{3}+\cdots +\frac{1}{n} \right) \approx n\log n\]</span></p></li><li><p>原理：任意<strong>整数</strong> x <spanclass="math inline">\((x&gt;1)\)</span>​ 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)<span class="comment">// 循环n/i次</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eratosthenes筛法不用">Eratosthenes筛法（不用）</h4><ul><li><p>时间复杂度：<spanclass="math inline">\(O(nloglogn)\)</span></p></li><li><p>原理：任意<font color='red'><strong>素数</strong></font> x <spanclass="math inline">\((x&gt;1)\)</span> 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="literal">true</span>;<span class="comment">// 可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法">线性筛法</h4><ul><li><p>朴素筛法和Eratosthenes筛法存在<strong>重复筛掉</strong>的情况（例如 12 既会被 2 筛掉，又会被 3筛掉：在标记 2 的倍数时，12 = 2 ∗ 6；在标记 3 的倍数时，12 = 3 ∗ 4）如何避免某个数被重复筛掉的情况呢？很简单，我们只需让 45只被它的最小质数（3）筛掉即可</p></li><li><p>原理：合数 x只会被其<font color='red'><strong>最小质因子</strong></font>筛掉一次</p></li><li><p>时间复杂度：<span class="math inline">\(O(n)\)</span>​</p></li></ul><p>第二层循环<code>st[primes[j] * i] = true;</code>只会对所有<strong>合数</strong>执行一次，所以时间复杂度为<span class="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为什么不需要写 j &lt; cnt？ */</span></span><br><span class="line">        <span class="comment">// 1.   primes 数组中存有 &lt;= i 的所有质数</span></span><br><span class="line">        <span class="comment">// 2.   当 i 是合数时, 肯定会在中间就 break 掉</span></span><br><span class="line">        <span class="comment">// 3.   当 i 是质数时, 那么 primes[cnt - 1] = i，因此 j == cnt - 1 时，break，依然不越界</span></span><br><span class="line">        <span class="comment">/* 为什么循环条件是primes[j] &lt;= n / i */</span></span><br><span class="line">        <span class="comment">// 1. 下面筛掉的数是 primes[j] * i</span></span><br><span class="line">        <span class="comment">// 2. 我们要求的是1~n之间的所有素数</span></span><br><span class="line">        <span class="comment">// 3. 当 primes[j] &gt; n / i，下面筛掉的数大于n，不符合我们的要求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">            <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">            <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">            <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">            <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">            <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>证明：</p><ul><li>合数 x 的最小质因子只有一个</li></ul><blockquote><p>显然成立</p></blockquote><ul><li>合数 x<font color='red'><strong>只会</strong></font>被其<font color='red'><strong>最小质因子</strong></font>筛掉<font color='blue'><strong>一次</strong></font></li></ul><blockquote><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">    <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">    <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">    st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">    <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">    <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">    <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">    <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>所有的合数一定会被筛掉</li></ul><blockquote><p>证明：对于合数 <span class="math inline">\(x\)</span>，假设 <spanclass="math inline">\(prime[k]\)</span> 是 <spanclass="math inline">\(x\)</span> 的最小质因子，当 <spanclass="math inline">\(i\)</span> 枚举到 <spanclass="math inline">\(x/primes[k]\)</span> 的时候，x一定会被 <spanclass="math inline">\(prime[k]\)</span> 筛掉（<spanclass="math inline">\(st[primes[k]*(x/primes[k])]=true\)</span>)</p></blockquote><p>因此，所有合数一定<strong>只</strong>会被<strong>最小质因子</strong><strong>筛掉一次</strong>，所以是线性的</p></li></ul><h2 id="约数">约数</h2><h3 id="求所有约数试除法">求所有约数——试除法</h3><ul><li><strong>原理</strong>：<ul><li>若 <span class="math inline">\(d|n\)</span>​，则 <spanclass="math inline">\(\frac{n}{d}|n\)</span>​. 所以一个数 n的约数肯定是成对存在的，对称轴是<spanclass="math inline">\(\sqrt{n}\)</span></li><li>因此只需要用 n 除以 1 到 <spanclass="math inline">\(\sqrt{n}\)</span>​之间的数，如果余数是0，则把<code>除数</code>、<code>n / 除数</code>加到答案中</li></ul></li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8068610/">AcWing869. 试除法求约数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != n / i)</span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><ul><li><strong>约束个数</strong>定理：任一大于 <spanclass="math inline">\(1\)</span> 的整数 <spanclass="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数的个数为 $( _1+1 )( _1+1 ) ( _k+1 ) $</p><ul><li><strong>证明</strong>：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150912687.png"alt="image-20240315091200551" /><figcaption aria-hidden="true">image-20240315091200551</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8070605/">AcWing870. 约数个数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的 n 在 int 范围内，因此约数一定也在 int 范围内</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            res *= s + <span class="number">1</span>;<span class="comment">// 运算的逻辑就是先算完等号右侧的数值，然后再 *=</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和">约数之和</h3><ul><li><strong>约束之和</strong>定理：任一正整数 <spanclass="math inline">\(n(n&gt;=2)\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},\alpha_i&gt;0,i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n(n&gt;=2)\)</span> 的正约数之和为 $(p_{1}<sup>{0}+p_{1}</sup>{1}++p_{1}<sup>{<em>1} ) (p</em>{2}</sup>{0}+p_{2}<sup>{1}++p_{2}</sup>{<em>2} ) (p</em>{k}<sup>{0}+p_{k}</sup>{1}++p_{k}^{_k} ) $</p><ul><li><strong>证明</strong>：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150917791.png"alt="image-20240315091535903" /><figcaption aria-hidden="true">image-20240315091535903</figcaption></figure><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>一个数的<strong>约数之和</strong>一定会<strong>大于这个数本身</strong>（因为这个数本身也是自己的约数）</li></ul><h4 id="原版">原版</h4><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071116/">AcWing871. 约数之和 - AcWing</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s = s * i + <span class="number">1</span>;</span><br><span class="line">            res *= s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化">优化</h4><p>采用分治计算 <span class="math inline">\(1 + p + p^2 + ... +p^k\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % mod;</span><br><span class="line">        a = (LL)a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优化：采用分治计算 1 + p + p^2 + ... + p^k */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">qmi</span>(p, (k + <span class="number">1</span>) / <span class="number">2</span>)) * <span class="built_in">sum</span>(p, (k - <span class="number">1</span>) / <span class="number">2</span>)) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">qmi</span>(p, k / <span class="number">2</span>)) * <span class="built_in">sum</span>(p, k / <span class="number">2</span> - <span class="number">1</span>) + <span class="built_in">qmi</span>(p, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算约数之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_sum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s ++;</span><br><span class="line">            res = res * <span class="built_in">sum</span>(i, s) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res * n % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><ul><li><strong>欧几里得算法/辗转相除法</strong>：</li></ul><p><span class="math display">\[\begin{cases}    gcd\left( a,b \right) =gcd\left( b,a\%b \right)\\    gcd\left( a,0 \right) =a\\\end{cases}\]</span></p><ul><li><span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的最大公约数 <spanclass="math inline">\(gcd(a,b)\)</span> 被记作 <spanclass="math inline">\((a,b)\)</span>​</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071167/">AcWing872. 最大公约数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><h3 id="欧拉函数-varphi-left-n-right-01-n-1-中与-n-互素的个数">欧拉函数<span class="math inline">\(\varphi \left( n \right)\)</span>—— <spanclass="math inline">\(0/1\)</span> ~ <spanclass="math inline">\(n-1\)</span> 中与 <spanclass="math inline">\(n\)</span> 互素的个数</h3><ul><li><strong>定理</strong>：设正整数 <span class="math inline">\(n\(n&gt;=2)\)</span> 的标准分解式为：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},\alpha_i&gt;0,i=1,2,\cdots ,k\]</span></p><p>​ 则欧拉函数 <span class="math display">\[\varphi \left( n \right) =n\left( 1-\frac{1}{p_1} \right) \left(1-\frac{1}{p_2} \right) \cdots \left( 1-\frac{1}{p_k} \right)\]</span></p><ul><li><strong>含义</strong>： <span class="math inline">\(0/1\)</span> ~<span class="math inline">\(n-1\)</span> 中与 <spanclass="math inline">\(n\)</span>​<strong>互素</strong>的<strong>个数</strong></li><li><strong>性质：</strong><ol type="1"><li>若 <span class="math inline">\(p\)</span> 为素数，则 <spanclass="math inline">\(\varphi \left( p \right) = p-1\)</span></li><li>若<span class="math inline">\((n, m) =1\)</span>，则 <spanclass="math inline">\(\varphi \left( nm \right) =(n-1)(m-1)\)</span>​</li><li><span class="math inline">\(\varphi \left( a^b \right) =a^{b-1}\cdot\varphi \left( a \right)\)</span>，<spanclass="math inline">\(a&gt;=2\)</span></li></ol></li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8072352/">AcWing873. 欧拉函数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求 n &gt;= 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);<span class="comment">// 注意是先除再乘，不要使用逆元求解，因为某些数可能没有逆元</span></span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);<span class="comment">// 注意是先除再乘，不要使用逆元求解，因为某些数可能没有逆元</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性筛法求-1-n-中每个数的欧拉函数">线性筛法——求 1 ~ n中每个数的欧拉函数</h3><ul><li>给定一个正整数 <span class="math inline">\(n\)</span> ，求 <spanclass="math inline">\(1\)</span> ∼ <spanclass="math inline">\(n\)</span>中<strong>每个数的</strong>欧拉函数</li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8073032/">AcWing874. 筛法求欧拉函数 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> eulers[N];       <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉(状态state)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eulers[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求素数 i 的欧拉函数 phi(i) = i - 1</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            eulers[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 求合数 t = primes[j] * i 的欧拉函数</span></span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 情况1：i % primes[j] == 0，此时 primes[j] 既是 i 的最小质因数，也是 t 的最小质因数，phi(t) = phi(primes[j]*i) = primes[j] * phi(i)</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                eulers[t] = primes[j] * eulers[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2：i % primes[j] != 0，此时 primes[j] 不是 i 的质因数（primes[j] &lt; i的最小质因数），但却是 t 的最小质因数，此时 (primes[j], 1) == 1，因此phi(t) = phi(primes[j] * i) = phi(primes[j]) * phi(i) = (primes[j] - 1) * phi(i)</span></span><br><span class="line">            eulers[t] = (primes[j] - <span class="number">1</span>) * eulers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8373629/">AcWing4968. 互质数的个数（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="快速幂">快速幂</h2><p>快速求出 <span class="math inline">\(a^b\,\,mod\,\,p\)</span>​</p><ul><li><strong>原理：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151618057.png"alt="04a91bf62e0bd92e3db3b3a73c76793" /><figcaptionaria-hidden="true">04a91bf62e0bd92e3db3b3a73c76793</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151619524.png"alt="bb9db9bc6547be4cfcf9dba7ac9190a" /><figcaptionaria-hidden="true">bb9db9bc6547be4cfcf9dba7ac9190a</figcaption></figure><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(logb)\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8074336/">AcWing875. 快速幂 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 特判：p == 1</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left. \begin{array}{r}    a^{2^0}=a^1\\    a^{2^1}=a^2\\    a^{2^2}=a^4\\    \cdots\\    a^{2^{k-1}}\\\end{array} \right\} \Rightarrow a^{2^i}=\left( a^{2^{i-1}} \right) ^2\]</span></p><ul><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11777233/">AcWing504. 转圈游戏（每日一题） - AcWing</a></li></ul><h2 id="拓展欧几里得算法">拓展欧几里得算法</h2><ul><li><strong>Bezout(贝祖等式)</strong></li></ul><p>设 <strong><span class="math inline">\(a, b\)</span></strong>是任意两个正整数，则存在整数 <strong><span class="math inline">\(x,y\)</span></strong> 使得 <span class="math display">\[ax+by=\left( a,b \right)\]</span></p><ul><li>如何求解上述等式的解 <strong><span class="math inline">\(x,y\)</span></strong> ？</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151722173.png"alt="image-20240315172217936" /><figcaption aria-hidden="true">image-20240315172217936</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8074640/">AcWing877. 扩展欧几里得算法 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求逆">求逆</h2><ul><li><strong>定义</strong>：当 <span class="math inline">\(ax≡1 \ mod \p\)</span>, <span class="math inline">\(a^{-1}\)</span> <spanclass="math inline">\(mod\)</span> <spanclass="math inline">\(p\)</span> 称为 <spanclass="math inline">\(a∈{1,2,…,p-1}\)</span> 的乘法逆</li><li><strong>定理</strong>：当且仅当 <spanclass="math inline">\(gcd(a,p)=1, \ a^{-1} \ mod \ p\)</span>​ 存在</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8078478/">AcWing876. 求逆元 - AcWing</a>】</li></ul><h3 id="费马小定理求逆元">费马小定理——求逆元</h3><ul><li><p><strong>前提要求</strong>：<font color='red'> <spanclass="math inline">\(p\)</span> 为素数 </font></p></li><li><p><strong>有解判断</strong>：</p></li></ul><p><span class="math display">\[gcd\left( a,p \right) =1\xLeftrightarrow{p\text{为素数}}a\not \equiv0\,\, mod\,\,p\]</span></p><ul><li><strong>费马小定理</strong>：若 <spanclass="math inline">\(p\)</span> 为素数，则</li></ul><p><span class="math display">\[a^{p-1}\equiv 1 \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><ul><li>因此，<span class="math inline">\(a\)</span> 的逆为</li></ul><p><span class="math display">\[a^{-1}=a^{p-2}\, \, \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(logp)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在逆元</span></span><br><span class="line"><span class="keyword">if</span> (a % p == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)<span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p) % p + p) % p);</span><br></pre></td></tr></table></figure><h3 id="拓展欧几里得求逆元">拓展欧几里得——求逆元</h3><ul><li><p>不要求 <span class="math inline">\(p\)</span> 为素数， <spanclass="math inline">\(p\)</span> 为任意数即可</p></li><li><p>使用拓展欧几里得算法求一个元素的逆</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断逆元是否存在</span></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line"><span class="keyword">if</span> (g != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x + p) % p); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x+p可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">+p %p 是为了将 x 转换到 0 ~ p-1</span></span><br><span class="line"><span class="comment">/ % 的优先级要高于 + -，所以这里必须加上括号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="求解同余式">求解同余式</h2><ul><li><strong>定理：</strong>一次同余式</li></ul><p><span class="math display">\[ax\equiv b\left( mod\,\,m \right) \text{，}a\not \equiv 0\left( mod\,\,m\right)\]</span></p><ol type="1"><li>有解<span class="math inline">\(\Longleftrightarrow \left( a,m\right) |b\)</span>​</li><li>当同余式有解时<ol type="1"><li>其解数为 <span class="math inline">\(d=(a,m).\)</span>​​</li><li>求解 <span class="math inline">\(x\)</span>，满足 <spanclass="math inline">\(ax≡b(mod \ m)\)</span> &lt;==&gt; 求解 <spanclass="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>满足 <span class="math inline">\(ax+my=b\)</span><ol type="1"><li>使用 拓展欧几里得算法 ，求出 <spanclass="math inline">\(x_0\)</span>、<spanclass="math inline">\(y_0\)</span>，使得 <spanclass="math inline">\(ax_0+my_0=(a,m)\)</span></li><li>左右两侧同时乘以 <span class="math inline">\(\frac{b}{\left( a,m\right)}\)</span>，得到 $ a+m=b$</li><li>因此解 <span class="math inline">\(x=x_0*\frac{b}{\left( a,m\right)}\)</span></li></ol></li></ol></li></ol><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8082881/">AcWing878. 线性同余方程 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (b % g)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x * b / g + m)% m);</span><br><span class="line"><span class="comment">// x * b可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">// * / % 的优先级相同，按照顺序从左到右依次运行</span></span><br><span class="line"><span class="comment">// + m % m 是为了将 x 转换到 0 ~ p-1</span></span><br></pre></td></tr></table></figure><h2 id="求解一次同余组">求解一次同余组</h2><h3 id="中国剩余定理">中国剩余定理</h3><ul><li>要求： <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161457480.png"alt="image-20240316145735216" /><figcaption aria-hidden="true">image-20240316145735216</figcaption></figure><h3 id="拓展中国剩余定理">拓展中国剩余定理</h3><ul><li>不要求 <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8086576/">AcWing204. 表达整数的奇怪方式 - AcWing</a>】</strong></li></ul><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161857618.png" /></p><h2 id="高斯消元">高斯消元</h2><h3 id="解线性方程组">解线性方程组</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192214816.png"alt="image-20240319221424411" /><figcaption aria-hidden="true">image-20240319221424411</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192222282.png"alt="image-20240319222223978" /><figcaption aria-hidden="true">image-20240319222223978</figcaption></figure><p>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8128731/">AcWing883. 高斯消元解线性方程组 - AcWing</a>】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断是否有解</span></span><br><span class="line"><span class="comment">- 返回0，表示无解</span></span><br><span class="line"><span class="comment">- 返回1：表示有无穷多组解</span></span><br><span class="line"><span class="comment">- 返回2：表示有解a[0][n]~a[n-1][n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r; <span class="comment">// c 代表 列 col ， r 代表 行 row</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先找到当前这一列绝对值最大的一个数字所在的行号 t</span></span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行，换到最上面（不是第一行，是第 r 行）去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行的第一个数，变成 1，方程两边同时除以第一个数，必须倒着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--)</span><br><span class="line">            a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把【当前列】下面的所有数，全部消成 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--) <span class="comment">// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];</span></span><br><span class="line">                a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r++; <span class="comment">// 这一行的工作做完，换下一行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r &lt; n 表明剩下方程的个数是小于 n 的，不是唯一解，判断是无解还是无穷多解</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;                                <span class="comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps) <span class="comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一解，从下往上回代，得到方程的解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n]; <span class="comment">// 因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要找绝对值最大的那一行？</p><ol type="1"><li>一是因为可以寻找一个非零行</li><li>二是作浮点数除法时，显然<strong>除以一个大数会让精度更好</strong>，误差更小</li></ol></blockquote><h3 id="解异或方程组">解异或方程组</h3><ul><li><strong>核心思想</strong>：<strong>异或</strong>&lt;==&gt;<strong>不进位的加法</strong></li><li>等式与等式间的异或要一起进行才能保证等式左右两边依然是相等关系：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a^b^c = x</span><br><span class="line">   d^f = y</span><br><span class="line">则</span><br><span class="line"> a^b^d^c^f = x^y</span><br></pre></td></tr></table></figure><ul><li><strong>算法步骤</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 左下角消0</span><br><span class="line">  1.1 枚举列</span><br><span class="line">  1.2 找第一个非零行</span><br><span class="line">  1.3 交换</span><br><span class="line">  1.4 把同列下面行消零(异或)</span><br><span class="line">2 判断3种情况</span><br><span class="line">  2.1 唯一解</span><br><span class="line">  2.2 秩&lt;n</span><br><span class="line">      2.2.1 有矛盾 无解</span><br><span class="line">      2.2.2 无矛盾 无穷多解</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8161242/">AcWing884. 高斯消元解异或线性方程组 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">            &#123;</span><br><span class="line">                t = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!a[t][c])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= n; j++)</span><br><span class="line">                    a[i][j] ^= a[r][j];</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][n])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 无解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无穷解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] ^= a[i][j] * a[j][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数">组合数</h2><p><span class="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}=C_{a}^{a-b}\\    \\    \,\,C_{a}^{0}=1\\\end{cases}\,\,         0\leqslant a\leqslant b\]</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061551561.png"alt="image-20240406155131232" /><figcaption aria-hidden="true">image-20240406155131232</figcaption></figure><h3 id="模板一">模板一</h3><ul><li><strong>适用条件</strong>：<ul><li>询问次数 n 非常多</li><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^5\\1&lt;=b&lt;=a&lt;=2000\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong>：</li></ul><p><span class="math display">\[C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}\]</span></p><ul><li><strong>时间复杂度</strong>：<font color='red'><spanclass="math inline">\(O(n^2)\)</span>​</font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8108970/">AcWing885. 求组合数 I - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)<span class="comment">// 注意：这里是 j &lt;= i</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板二">模板二</h3><ul><li><strong>适用条件</strong><ul><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^4\\1&lt;=b&lt;=a&lt;=10^5\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong></li></ul><p><span class="math display">\[\frac{a}{b}mod\,\,p=a*b^{-1}\,\,mod\,\,p\ne\frac{a\,\,mod\,\,p}{b\,\,mod\,\,p}\]</span></p><p><span class="math display">\[\left( a*b \right) ^{-1}\,\,mod\,\,p=a^{-1}*b^{-1}\,\,mod\,\,p\]</span></p><p><span class="math display">\[C_{a}^{b}=\frac{a!}{b!\left( a-b \right) !}=fact\left( a \right) \,\,*infact\left( b \right) \,\,* infact\left( a-b \right)\,\,   \text{其中}\begin{cases}    fact\left( a \right) =a! \% mod\\    infact\left( a \right) =\left( a! \right) ^{-1}\,\,\% mod\\\end{cases}\\\\\]</span> :smile:注意：<span class="math inline">\(mod=1e^9+7\)</span>为质数，所以计算逆元 <span class="math inline">\(i^{-1}\)</span>可以采用<strong>费马小定理</strong> <span class="math display">\[\text{递推公式：}\begin{cases}    fact\left( a \right) =fact\left( a-1 \right) \,\,* a\,\,\% mod\\    infact\left( a \right) =infact\left( a-1 \right) \,\,* a^{-1}\,\,\%mod\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8110941/">AcWing886. 求组合数 II - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0! = 1, 1^&#123;-1&#125; = 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2个 int 相乘会爆 int ，使用类型转化为 long long</span></span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">// 三个 int 相乘会爆 long long，所以每2个数相乘就对 mod 取模</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)fact[a] * infact[b]) % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板三">模板三</h3><ul><li><strong>适用条件</strong></li></ul><p><span class="math display">\[1&lt;= n &lt;= 20\\1&lt;=b&lt;=a&lt;=10^{18}\\1&lt;=p&lt;=10^5，且\ p\ 为质数\]</span></p><ul><li><strong>卢卡斯定理 <span class="math inline">\(Lucas \Theory\)</span></strong></li></ul><p><span class="math display">\[C_{a}^{b}\equiv C_{a\,\,mod\,\,p}^{b\,\,mod\,\,p}\,\,*C_{a/p}^{b/p}\,\,mod\,\,p   \ \ \ \ \ \ p\ 为素数\]</span></p><p>​ 当 <span class="math inline">\(a&lt;p\)</span> 且 <spanclass="math inline">\(b&lt;p\)</span> 时，适用组合数定义求 <spanclass="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}\\    \,\,C_{a}^{0}=1\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121840/">AcWing887. 求组合数 III - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这里的 a 和 b 需要保证小于 p , 因此(b!,p)=1, b!的逆元一定存在</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * j % p;</span><br><span class="line">        y = (LL)y * i % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)x * <span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lucas</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板四">模板四</h3><ul><li><strong>适用条件</strong><ul><li>只计算一个组合数</li><li>p 为质数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Cab mod p</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i ++, j --)</span><br><span class="line">&#123;</span><br><span class="line">    res = (LL)res * j % p;</span><br><span class="line">    res = (LL)res * qmi(i, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板五">模板五</h3><ul><li><strong>使用条件</strong></li></ul><p>当我们需要求出<strong>组合数的真实值</strong>，而非对某个数的余数时，分解质因数的方式比较好用：</p><ul><li><strong>原理</strong></li></ul><ol type="1"><li>筛法求出范围内的所有质数</li><li>通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n!中p的次数是</li></ol><p><span class="math display">\[n / p + n / p^2 + n / p^3 + ...\]</span></p><ol start="3" type="1"><li>用高精度乘法将所有质因子相乘</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403191527951.png"alt="image-20240319152754655" /><figcaption aria-hidden="true">image-20240319152754655</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121842/">AcWing888. 求组合数 IV - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];         <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求n！分解质因数后， p 的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高精度乘低精度模板 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a); <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j++)</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><h3 id="例题-1">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8311244/">AcWing211. 计算系数（每日一题） - AcWing</a></li></ul><h2 id="卡特兰数">卡特兰数</h2><h3 id="原理">原理</h3><p>​ 给定 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(1\)</span>，它们按照某种顺序排成长度为 <spanclass="math inline">\(2n\)</span> 的序列，满足任意前缀中 <spanclass="math inline">\(0\)</span> 的个数都不少于 <spanclass="math inline">\(1\)</span> 的个数的序列的数量为： <spanclass="math display">\[Cat_n=\frac{C_{2n}^{n}}{n+1}\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403282301866.png"alt="image-20240328230128530" /></p><h3 id="例题-2">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8121833/">AcWing889. 满足条件的01序列 - AcWing</a></li></ul><h2 id="容斥原理">容斥原理</h2><h3 id="原理-1">原理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201238750.png"alt="image-20240319184649042" /><figcaption aria-hidden="true">image-20240319184649042</figcaption></figure><h3 id="例题-3">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8129504/">AcWing890. 能被整除的数 - AcWing</a></li></ul><h2 id="博弈论之sg函数">博弈论之SG函数</h2><h3 id="nim游戏">NIM游戏</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403281718365.png"alt="image-20240328171850955" /><figcaption aria-hidden="true">image-20240328171850955</figcaption></figure><h4 id="定理">定理</h4><p>​ 假设 <span class="math inline">\(n\)</span>​ 堆石子，数目分别是 <spanclass="math inline">\(A_1,A_1,\cdots,A_n\)</span>​</p><ul><li>如果 <span class="math inline">\(A_1\oplus A_2\oplus \cdots \oplusA_n\ne 0\)</span>​​，则先手必胜</li><li>否则先手必败</li></ul><h4 id="证明">证明</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403281928376.png"alt="image-20240328192818930" /><figcaption aria-hidden="true">image-20240328192818930</figcaption></figure><p>:tomato:基于上述三个证明：</p><ol type="1"><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n\ne0\)</span>，那么先手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，最后一定是后手面临最终没有石子可拿的状态，先手必胜。</li><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n=0\)</span>，那么无论先手怎么拿，都会将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplus a_n\ne0\)</span>，那么后手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，后一定是先手面临最终没有石子可拿的状态，先手必败。</li></ol><h3 id="公平组合游戏icg">公平组合游戏ICG</h3><p>若一个游戏满足：</p><ol type="1"><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个<strong>公平组合游戏</strong>。</p><p>​NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h3 id="有向图游戏">有向图游戏</h3><p>​给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为<strong>有向图游戏</strong>。​<strong>任何一个公平组合游戏都可以转化为有向图游戏</strong>。具体方法是，<font color ='red'>把每个<strong>局面</strong>看成图中的一个<strong>节点</strong>，并且从<strong>每个局面</strong>向沿着合法行动能够到达的<strong>下一个局面</strong>连<strong>有向边</strong>。</font></p><h3 id="mex运算">Mex运算</h3><p>​ 设 <span class="math inline">\(S\)</span> 表示一个非负整数集合。定义<span class="math inline">\(mex(S)\)</span>为求出<strong>不属于</strong>集合 <span class="math inline">\(S\)</span>的最小非负整数的运算，即： <span class="math display">\[mex(S) = min\{x\},\ x\ 属于自然数，且\ x\ 不属于\ S\]</span></p><h3 id="sg函数">SG函数</h3><p>​ 在有向图游戏中，对于每个节点 <spanclass="math inline">\(x\)</span>，设从 <spanclass="math inline">\(x\)</span> 出发共有 <spanclass="math inline">\(k\)</span> 条有向边，分别到达节点 <spanclass="math inline">\(y_1, y_2, …, y_k\)</span> ，定义 SG(x) 为 x的后继节点 <span class="math inline">\(y_1, y_2, …, y_k\)</span> 的SG函数值 构成的集合再执行 mex(S) 运算的结果，即： <spanclass="math display">\[SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})\]</span> 特别地，整个有向图游戏 G 的 SG 函数值被定义为有向图游戏起点 s的 SG 函数值，即： <span class="math display">\[SG(G) = SG(s)\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201408408.png"alt="image-20240320140827062" /></p><h3 id="有向图游戏的和">有向图游戏的和</h3><p>​ 设 G1，G2,····,Gm 是 m 个有向图游戏。定义有向图游戏G，他的行动规则是任选某个有向图游戏 Gi，并在 Gi 上行动一步。G被称为<strong>有向图游戏 G1，G2，·····，Gm的和</strong></p><p>​有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的<strong>异或和</strong>，即：<span class="math display">\[SG\left( G \right) =SG\left( G_1 \right) \oplus SG\left( G_2 \right)\oplus \cdots \oplus SG\left( G_m \right)\]</span></p><h3 id="定理-1">定理</h3><ul><li>有向图游戏的某个局面<strong>必胜</strong>，当且仅当该局面对应节点的<strong>SG函数值大于0</strong></li><li>有向图游戏的某个局面<strong>必败</strong>，当且仅当该局面对应节点的<strong>SG函数值等于0</strong></li></ul><p>我们不再详细证明该定理。读者可以这样理解：</p><ul><li>在一个<strong>没有出边</strong>的节点上，棋子<strong>不能</strong>移动，它的SG 值为 0，对应必败局面。</li><li>若一个节点的某个后继节点 SG 值为 0，在 mex 运算后，该节点的 SG值大于0。这等价于，若一个局面的后继局面中存在必败局面，则当前局面为必胜局面。</li><li>若一个节点的后继节点 SG 值均不为 0，在mex运算后，该节点的 SG 值为0。这等价于，若一个局面的后继局面全部为必胜局面，则当前局面为必败局面。</li></ul><p>对于若干个有向图游戏的和，其证明方法与 NIM 博弈类似。</p><h3 id="例题-4">例题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8129672/">AcWing891. Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8221695/">AcWing892. 台阶-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8131666/">AcWing893. 集合-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8223036/">AcWing894. 拆分-Nim游戏 - AcWing</a></p></li></ul><h2 id="斐波那契">斐波那契</h2><p>在斐波那契数列中：<span class="math inline">\(f_0=0, f_1=1,f_n=f_{n-1}+f_{n-2} (n&gt;1)\)</span></p><p><strong><ahref="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法- AcWing</a></strong></p><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8388593/">AcWing205. 斐波那契（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8389363/">AcWing1303. 斐波那契前 n 项和 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8396571/">AcWing1304. 佳佳的斐波那契 - AcWing</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数学知识&quot;&gt;数学知识&lt;/h1&gt;
&lt;p&gt;:smile:&lt;strong&gt;数论&lt;/strong&gt; 经常会出现 &lt;strong&gt;数的大小越界&lt;/strong&gt;
情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尤其是在做&lt;strong&gt;乘法&lt;/strong&gt;、其次是&lt;strong&gt;加法&lt;/strong&gt;的时候非常容易溢出，此时可以使用
&lt;code&gt;long long&lt;/code&gt; 局部转换&lt;/li&gt;
&lt;li&gt;比较稳妥的、一劳永逸的办法是&lt;strong&gt;变量类型&lt;/strong&gt;不使用
int，&lt;strong&gt;全部使用&lt;/strong&gt; &lt;code&gt;long long&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数论部分的题目通常需要对结果取模，以下统一使用&lt;code&gt;mod&lt;/code&gt;代表取模的数，具体何时取余需要根据&lt;code&gt;mod&lt;/code&gt;范围进行确定&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;质数&quot;&gt;质数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;质数&lt;/strong&gt;：在大于 1 的整数中，如果只包含 1
和本身这两个约数，就被成为质数，或者叫素数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算数基本定理&lt;/strong&gt;：任一大于1的整数 &lt;span
class=&quot;math inline&quot;&gt;&#92;(n&#92;)&lt;/span&gt;​ 能够唯一地表示成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[
n={p_1}^{&#92;alpha _1}{p_1}^{&#92;alpha _1}&#92;cdots {p_s}^{&#92;alpha _s},  &#92;alpha
_i&amp;gt;0,  i=1,2,&#92;cdots ,s&#92;left( * &#92;right)
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 分解式(*)叫做 的 n 的标准分解式&lt;/p&gt;
&lt;p&gt;注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 n
表成下面形式： &lt;span class=&quot;math display&quot;&gt;&#92;[
n={p_1}^{&#92;alpha _1}{p_1}^{&#92;alpha _1}&#92;cdots {p_k}^{&#92;alpha _k},  &#92;alpha
_i&#92;geqslant 0,  i=1,2,&#92;cdots ,k
&#92;]&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cuiluyi.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>优先队列priority_queue</title>
    <link href="https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/"/>
    <id>https://cuiluyi.gitee.io/2024/03/08/[object%20Object]/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/</id>
    <published>2024-03-08T05:29:27.000Z</published>
    <updated>2024-05-01T00:24:51.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列priority_queue">优先队列priority_queue</h1><p>:smile: priority_queue实际上就是 <strong>堆</strong></p><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为大根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>堆大小</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>插入</font></strong>堆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分别返回<strong><font color='red'>堆顶元素</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p><font color='blue'><strong>删除</strong></font>堆顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 queue 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><hr /><p>:smile:注意： 使用 <code>q.front()</code>和<code>q.pop()</code>函数前，必须用<code>q.empty()</code>判断队列==<strong>是否为空</strong>==，否则可能因为<strong>队空</strong>而出现<strong>SegmentationFault</strong>错误</p><h2 id="举例">举例</h2><ol type="1"><li>基本类型例子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(i);</span><br><span class="line">        c.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">cbd abcd abc</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>pari的比较，先比较第一个元素，第一个相等比较第二个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>对于自定义类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;优先队列priority_queue&quot;&gt;优先队列priority_queue&lt;/h1&gt;
&lt;p&gt;:smile: priority_queue实际上就是 &lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;头文件&quot;&gt;头文件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#include &amp;lt;queue&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认为大根堆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;priority_queue &amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; heap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 小根堆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;priority_queue &amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;,vector&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt;,greater&amp;lt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;&amp;gt; &amp;gt;q;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="STL" scheme="https://cuiluyi.gitee.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>《致谢》——黄国平</title>
    <link href="https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/"/>
    <id>https://cuiluyi.gitee.io/2024/03/04/[object%20Object]/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/</id>
    <published>2024-03-04T05:59:27.000Z</published>
    <updated>2024-03-19T07:05:15.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="致谢">致谢</h1><p>​<strong>我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。</strong></p><p>​出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。<strong>每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。</strong></p><p>​<strong>人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。</strong>家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。</p><span id="more"></span><p>​<strong>人后的苦尚旦还能克服，人前的尊严却无比脆弱。</strong>上课的时候，因拖欠学费而经常被老师叫出教室约谈。雨天湿漉着上课，屁股后面说不定还是泥。夏天光着脚走在滚烫的路上。冬天穿着破旧衣服打着寒颤穿过那条长长的过道领作业本。这些都可能成为压垮骆驼的最后一根稻草。如果不是考试后常能从主席台领奖金，顺便能贴一墙奖状满足最后的虚荣心，我可能早已放弃。</p><p>​<strong>身处命运的旋涡，耗尽心力去争取那些可能本就是稀松平常的东西，每次转折都显得那么的身不由己。幸运的是，命运到底还有一丝怜惜。</strong>进入高中后,学校免了全部学杂费，■■■一家帮助解决了生活费。进入大学后，计算机终于成了我一生的事业与希望，胃溃疡和胃出血也终与我作别。</p><p>​我很庆幸保研时选择了自动化所，感谢研究生部的老师们将我从别的部门调剂到模式识别实验室，感谢导师宗成庆老师选择了我，宗老师将我引入了科学研究的大门，博士这五年无疑是我过去最幸福的时光。惭愧的是，离宗老师的期望显然还有很远的距离，我也知道本可以做得更好。这一段经历已经成为我这一生值得回味的美好瞬间之一。我很喜欢人机交互式机器翻译这个题目，但也仅开了个头。在未来，希望能有机会弥补这段遗憾。</p><p>​从家出发坐大巴需要两个半小时才能到县城，一直盼着走出大山。从炬光乡小学、大寅镇中学、仪陇县中学、绵阳市南山中学，到重庆的西南大学，再到中科院自动化所，我也记不清有多少次因为现实的压力而觉得自己快扛不下去了。<strong>这一路，信念很简单。把书念下去，然后走出去，不枉活一世。世事难科，未来注定还会面对更为复杂的局面。但因为有了这些点点滴滴，我已经有勇气和耐心面对任何困难和挑战。理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。</strong></p><p>​ 最近这些年，特别感谢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■重塑了我的人生。</p><p>​感谢■■■老师和■■■老师为我的研究提出诸多建设性的意见和建议。与他们的交流过程中，我也被他们坦诚为人、踏实做事的处事风格所感染。感谢所有和我一起在课题组工作的老师们和学习的同学们：■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■。我们在研究上共同努力，互相学习，如亲兄弟姐妹一般谈笑风生。不论大家将来在何处，我想我们都不会忘记这些年一起度过的时光。感谢课题组■■■女士，感谢模式识别综合办实验室的■■■、■■■和■■■等老师，感谢研究生部的■■■、■■■、■■■和■■■等老师，他们为我的学习和工作给予了极大的帮助。这会成为我日后工作的动力，希望最后能成为课题组值得骄傲的学生。</p><p>​感谢父母给了我生命，感谢婆婆和叔辈对我的抚养，感谢■■■■■■■■■■■■■■■■■■对我的牵挂，感谢■■■和■■■对我的支持，感谢一路上让我生活变得美好或者不那么美好的人和事。</p><p>​ 最后，对参加论文评审、答辩的各位老师表示衷心的感谢！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;致谢&quot;&gt;致谢&lt;/h1&gt;
&lt;p&gt;​
&lt;strong&gt;我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​
出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。&lt;strong&gt;每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​
&lt;strong&gt;人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。&lt;/strong&gt;家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，
黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。&lt;/p&gt;</summary>
    
    
    
    
    <category term="fighting" scheme="https://cuiluyi.gitee.io/tags/fighting/"/>
    
  </entry>
  
</feed>
