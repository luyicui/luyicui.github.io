<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>联邦学习</title>
      <link href="/2024/04/08/%5Bobject%20Object%5D/AI/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/08/%5Bobject%20Object%5D/AI/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="联邦学习">联邦学习</h1><p>联邦学习（Federated Learning, a.k.a. Federated MachineLearning）可以分为三类：横向联邦学习（Horizontal FederatedLearning），纵向联邦学习（Vertical FederatedLearning），联邦迁移学习（Federated Transfer Learning）[1, 2]。</p><p>有不少读者说，横向联邦学习和纵向联邦学习容易混淆，不太清楚为什么这么分类。我在这里再解释一下横向联邦学习和纵向联邦学习。</p><h2 id="横向联邦学习"><strong>横向联邦学习</strong></h2><p>​数据矩阵（也可以是表格，例如，Excel表格）的横向的一行表示一条训练样本，纵向的一列表示一个数据特征（或者标签）。通常用表格查看数据（例如，病例数据），用一行表示一条训练样本比较好，因为可能有很多条数据。</p><p>​横向联邦学习，适用于参与者的<font color = 'red'><strong>数据特征重叠较多，而样本ID重叠较少</strong></font>的情况，例如，两家<strong>不同地区</strong>的银行的客户数据[1, 2]。“横向”二字来源于数据的“<strong>横向划分（horizontalpartitioning, a.k.a.sharding）</strong>”。如图1所示例，联合多个参与者的具有<strong>相同特征</strong>的多行样本进行联邦学习，即各个参与者的训练数据是<strong>横向划分</strong>的，称为<strong>横向联邦学习</strong>。图2给出了一个<strong>横向划分</strong>表格的示例。横向联邦使训练样本的<strong>总数量增加</strong>。</p><p>​横向联邦学习也称为<strong>特征对齐的联邦学习</strong>（Feature-AlignedFederatedLearning），即横向联邦学习的参与者的数据特征是对齐的，如图3所示例。“特征对齐的联邦学习”这个名字有点长，还是用“横向联邦学习”比较好。</p><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922927.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图1 横向联邦学习示例，横向联邦使训练样本量增大    &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922833.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图2 横向（按行）划分数据示例 &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922372.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图3 横向联邦学习，也称为特征对齐的联邦学习，横向联邦使训练样本量增大 &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="纵向联邦学习">纵向联邦学习</h2><p>​纵向联邦学习，适用于参与者<font color = 'red'><strong>训练样本ID重叠较多，而数据特征重叠较少</strong></font>的情况，例如，<strong>同一地区</strong>的银行和电商的共同的客户数据[1, 2]。“纵向”二字来源于数据的“<strong>纵向划分（verticalpartitioning）</strong>”。如图4所示例，联合多个参与者的共同样本的不同数据特征进行联邦学习，即各个参与者的训练数据是<strong>纵向划分</strong>的，称为<strong>纵向联邦学习</strong>。图5给出了一个<strong>纵向划分</strong>表格的示例。纵向联邦学习需要先做样本对齐，即找出参与者拥有的<strong>共同样本</strong>，也就叫“数据库撞库（entityresolution, a.k.a. entityalignment）”。只有联合多个参与者的共同样本的不同特征进行纵向联邦学习，才有意义。纵向联邦使训练样本的<strong>特征维度增多</strong>。</p><p>​纵向联邦学习也称为<strong>样本对齐的联邦学习</strong>（Sample-AlignedFederatedLearning），即纵向联邦学习的参与者的训练样本是对齐的，如图6所示例。“样本对齐的联邦学习”这个名字有点长，还是用“纵向联邦学习”比较好。</p><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-9bccacdd69689d782c0e9d896df3e3c4_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图4 纵向联邦学习示例，纵向联邦使训练数据特征维度增加&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-6a71c9b0697c4afb7bfc17569442ffc6_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图5 纵向（按列）划分数据示例&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-cfb91e1c746ea4343f4b3ac27ba204ca_1440w.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;    图6 纵向联邦学习，也称为样本对齐的联邦学习，纵向联邦使训练数据特征维度增加&lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="小节">小节</h2><p>​<strong>横向联邦学习</strong>的名称来源于训练数据的“<strong>横向划分</strong>”，也就是数据矩阵或者表格的按行（横向）划分。不同行的数据有相同的数据特征，即数据特征是对齐的。</p><p>​<strong>纵向联邦学习</strong>的名称来源于训练数据的“<strong>纵向划分</strong>”，也就是数据矩阵或者表格的按列（纵向）划分。不同列的数据有相同的样本ID，即训练样本是对齐的。</p><p>[1] Qiang Yang, Yang Liu, Tianjian Chen, and Yongxin Tong, "FederatedMachine Learning: Concept and Applications," Feb. 2019. Available: <ahref="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1902.04885">https://arxiv.org/abs/1902.04885</a></p><p>[2] 杨强，刘洋，陈天健，童咏昕，“联邦学习”，Nov. 2018. Available: <ahref="https://link.zhihu.com/?target=https%3A//dl.ccf.org.cn/institude/institudeDetail%3Fid%3D4150944238307328%26from%3Dgroupmessage%26isappinstalled%3D0%26_ack%3D1">https://dl.ccf.org.cn/institude/institudeDetail?id=4150944238307328&amp;from=groupmessage&amp;isappinstalled=0&amp;_ack=1</a>,or <ahref="https://link.zhihu.com/?target=https%3A//wemp.app/posts/a3771dc7-6722-4690-bf25-23ba36f7b78c%3Futm_source%3Dlatest-posts">https://wemp.app/posts/a3771dc7-6722-4690-bf25-23ba36f7b78c?utm_source=latest-posts</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FLOPs&amp;&amp;FLOPS</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/FLOPs&amp;&amp;FLOPS/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/FLOPs&amp;&amp;FLOPS/</url>
      
        <content type="html"><![CDATA[<h1 id="flopsflops">FLOPs&amp;&amp;FLOPS</h1><h2 id="什么是flops">什么是flops</h2><p>对flops有疑惑，首先得先捋清这个概念：</p><ul><li><strong>FLOPS</strong>：注意全大写，是floating point operations per<strong>second</strong>的缩写，意指<strong>每秒浮点运算次数</strong>，理解为<strong>计算速度</strong>。是一个<strong>衡量硬件性能</strong>的指标。</li><li><strong>FLOPs</strong>：注意s小写，是floating pointoperations的缩写（<strong>s表复数</strong>），意指<strong>浮点运算数</strong>，理解为<strong>计算量</strong>。可以用来<strong>衡量算法/模型的复杂度</strong>。</li></ul><p>网上打字很容易全小写，造成混淆，本问题针对模型，应指的是FLOPs。</p><p>我们知道，通常我们去<strong>评价一个模型时，首先看的应该是它的精确度</strong>，当你精确度不行的时候，你和别人说我的模型预测的多么多么的快，部署的时候占的内存多么多么的小，都是白搭。但当你模型达到一定的精确度之后，就需要更<strong>进一步的评价指标来评价你模型</strong>：1）<strong>前向传播时所需的计算力</strong>，它反应了对硬件如GPU性能要求的高低；2）<strong>参数个数</strong>，它反应所占内存大小。为什么要加上这两个指标呢？因为这事关你模型算法的落地。比如你要在手机和汽车上部署深度学习模型，对模型大小和计算力就有严格要求。模型参数想必大家都知道是什么怎么算了，而前向传播时所需的计算力可能还会带有一点点疑问。所以这里总计一下前向传播时所需的计算力。它正是由<strong>FLOPs</strong>体现，那么<strong>FLOPs</strong>该怎么计算呢？</p><h2 id="如何计算flops">如何计算flops</h2><p>我们知道，在一个模型进行前向传播的时候，会进行卷积、池化、BatchNorm、Relu、Upsample等操作。这些操作的进行都会有其对应的计算力消耗产生，其中，卷积所对应的计算力消耗是所占比重最高的。所以，我们这里主要讲一下卷积操作所对应的计算力。</p><p>我们以下图为例进行讲解：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421083.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>先说结论：卷积层 计算力消耗 等于上图中两个立方体 (绿色和橙色)体积的乘积。即flops =</p><p><strong>推导过程：</strong>卷积层 wx + b需要计算两部分，首先考虑前半部分 wx 的计算量：</p><p>令 :</p><ul><li>k 表示卷积核大小;</li><li>c 表示输入 feature map 的数量;</li></ul><p>则对于输出 feature map 上的<strong>单个</strong> Unit 有：</p><p><strong><code>k \* k \* c 次乘法，以及 k \* k \* c - 1 次加法</code></strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421090.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>用上图形象化解释就是：</p><p>Image大小为 5x5，卷积核大小为3x3，那么一次3x3的卷积（求右图矩阵一个元素的值）所需运算量：(3x3)个乘法+(3x3-1)个加法= 17。要得到右图convolved feature （3x3的大小）：17x9 = 153</p><p>如果输出 feature map 的分辨率是 H * W ，且输出 o 个 featuremap，则输出 feature map 包含 Unit的总数就是 H * W * o。</p><p>因此，该卷积层在计算 wx 时有:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k * k * c * H * W * o 次乘法          --（1）</span><br><span class="line">(k * k * c - 1) * H * W * o 次加法    --（2）</span><br></pre></td></tr></table></figure><p>再考虑偏置项 b 包含的计算量：</p><p>由于 b 只存在加法运算，输出 feature map 上的每个 Unit做一次偏置项加法。因此，该卷积层在计算偏置项时总共包含：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H * W * o 次加法      --（3）</span><br></pre></td></tr></table></figure><p>将该卷积层的 wx 和 b 两部分的计算次数累计起来就有：</p><p><strong>式(1) 次乘法:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k * k * c * H * W * o 次乘法</span><br></pre></td></tr></table></figure><p><strong>式(2) + 式(3) 次加法:</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(k * k * c - 1) * H * W * o  + H * W * o  = k * k * c * H * W * o</span><br></pre></td></tr></table></figure><p><strong>可见，式(2) + 式(3) = 式 (1)</strong></p><p>对于带偏置项的卷积层，乘法运算和加法运算的次数相等，刚好配对。定义一次加法和乘法表示一个flop，该层的计算力消耗为：</p><p><strong><code>k \* k \* c \* H \* W \* o</code></strong></p><p>刚好等于图中两个立方体（绿色和橙色）体积的乘积。全连接层的算法也是一样。</p><h2 id="计算flops的开源库">计算flops的开源库</h2><blockquote><p>作者：留德华叫兽@知乎</p></blockquote><p>示例代码如下，它求出了VGG16的flops和参数量：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421109.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以看到，算上import 和print（）也仅仅6行代码！不仅输出了整个框架的复杂度，还能输出每一层的复杂度以及 该层占整个网络的比重</p><p>最后贴出常见backbone的flops：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061421115.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI 集群基础设施&amp;&amp;InfiniBand</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/AI%20%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD&amp;&amp;InfiniBand/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/AI%20%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD&amp;&amp;InfiniBand/</url>
      
        <content type="html"><![CDATA[<h1 id="ai-集群基础设施infiniband">AI集群基础设施&amp;&amp;InfiniBand</h1><p>GPU在高性能计算和深度学习加速中扮演着非常重要的角色，GPU的强大的并行计算能力，大大提升了运算性能。随着运算数据量的不断攀升，GPU间需要大量的交换数据，因此，GPU通信性能成为了非常重要的指标。</p><p>在 AI集群中进行分布式训练时，通信是必要环节，同时也是相比于单机训练而言多出来的系统开销。通信与计算的时间比例往往决定了分布式机器学习系统加速比的上限。</p><p>因此，分布式机器学习的关键是设计通信机制，从而降低通信与计算的时间比例，更加高效地训练出高精度模型。</p><p>下面给大家介绍AI集群通信的软硬件、NCLL集合通信库、InfiniBand网络通信技术协议、AI集群和AI框架中对于InfiniBand的应用。</p><blockquote><p>文章较长，建议先点赞收藏，后续再慢慢观看。另外，我撰写的<strong>大模型相关的博客及配套代码</strong>均整理放置在Github：<strong><ahref="https://link.zhihu.com/?target=https%3A//github.com/liguodongiot/llm-action/tree/main">llm-action</a></strong>，有需要的朋友自取。</p></blockquote><h2 id="通信硬件"><strong>通信硬件</strong></h2><h3 id="通信硬件的实现方式"><strong>通信硬件的实现方式</strong></h3><p>通信的实现方式分为两种类型：机器内通信与机器间通信。</p><ul><li><p>机器内通信：</p><ul><li><p>共享内存（QPI/UPI），比如：CPU与CPU之间的通信可以通过共享内存。</p></li><li><p>PCIe，通常是CPU与GPU之间的通信。</p></li><li><p>NVLink，通常是GPU与GPU之间的通信，也可以用于CPU与GPU之间的通信。</p></li></ul></li><li><p>机器间通信：</p><ul><li><p>TCP/IP 网络协议。</p></li><li><p>RDMA (Remote Direct Memory Access) 网络协议。</p><ul><li>InfiniBand</li><li>iWARP</li><li>RoCE</li></ul></li></ul></li></ul><h3 id="pcie"><strong>PCIe</strong></h3><p>PCI-Express（peripheral component interconnectexpress），简称PCIe，是一种高速串行计算机扩展总线标准，主要用于扩充计算机系统总线数据吞吐量以及提高设备通信速度。</p><p>PCIE本质上是一种全双工的的连接总线，传输数据量的大小由通道数（lane，信道）决定的。</p><p>通常，1个连接通道lane称为X1，<strong>每个通道lane由两对数据线组成，一对发送，一对接收，每对数据线包含两根差分线。即X1只有1个lane，4根数据线</strong>，每个时钟每个方向1bit数据传输。依此类推，X2就有2个lane，由8根数据线组成，每个时钟传输2bit。类似的还有X12、X16、X32。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444411.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>2003 年 PCIe 1.0 正式发布，可支持每通道传输速率为250MB/s，总传输速率为 2.5 GT/s。</p><p>2007 年推出 PCIe 2.0 规范。在 PCIe 1.0的基础上将总传输速率提高了一倍，达到 5 GT/s，每通道传输速率从 250 MB/s上升至 500 MB/s。</p><p>2022 年 PCIe 6.0 规范正式发布，总传输速率提高至 64 GT/s。</p><p>2022年6月，PCI-SIG 联盟宣布 PCIe 7.0版规范，单条通道（x1）单向可实现128 GT/s传输速率，计划于2025年推出最终版本。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444467.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>PCIe吞吐量(可用带宽)计算方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量=传输速率*编码方案</span><br></pre></td></tr></table></figure><p>传输速率为每秒传输量（GT/s），而不是每秒位数（Gbps），是因为传输量包括<strong>不提供额外吞吐量的开销位</strong>，比如：PCIe1x和PCIe 2x使用8b/10b编码方案，导致占用了20%(=2/10)的原始信道带宽。</p><ul><li>GT/s，Giga transtion per second(千兆传输/秒)，即每一秒内传输的次数，重点在于描述物理层通信协议的速率属性，可以不和链路宽度等关联。</li><li>Gbps，Giga Bits per second(千兆位/秒)。GT/s和Gbps之间不存在成比例的换算关系。</li></ul><p>PCIe2.0协议支持5.0GT/s，即每一条Lane上支持每秒钟传输5G个Bit，但这并不意味着PCIe2.0协议的每一条Lane支持5Gbps的速率。为什么这么说呢，因为PCIe2.0的物理层协议中使用的是8b/10b编码方案，即每传输8个Bit，需要发送10个Bit，这多出来的2Bit并不是对上层有意义的信息。那么，PCIe2.0协议的每一条Lane支持<code>5*8/10=4Gbps=500MB/s</code>的速率。以一个PCIe2.0 x8的通道为例，x8的可用带宽为<code>4*8=32Gbps=4GB/s</code>。</p><p>同理，PCIe3.0协议支持8.0GT/s，即每一条Lane上支持每秒钟传输8G个Bit。而PCIe3.0的物理层协议中使用的是128b/130b编码方案，即每传输128个Bit，需要发送130个Bit，那么，PCIe3.0协议的每一条Lane支持<code>8*128/130=7.877GB/s=984.6MB/s</code>的速率。以一个PCIe3.0x16的通道为例，x16的可用带宽为<code>7.877*16=126.032 Gbps=15.754GB/s</code>。</p><p><strong>PCIE体系架构</strong>：</p><p>PCIE体系架构一般包含根组件RC（root-complex），交换器switch，终端设备EP（endpoint）等类型的PCIE设备组成。RC在总线架构中只有一个，用于处理器和内存子系统与I/O设备之间的连接，而switch的功能通常是以软件形式提供的，它包括两个或更多的逻辑PCI到PCI的连接桥（PCI-PCIBridge），以保持与现有PCI兼容。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444428.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvlink"><strong>NVLink</strong></h3><p><strong>背景</strong>：</p><p>算力的提升不仅依靠单张 GPU 卡的性能提升，往往还需要多 GPU卡组合。在多 GPU 系统内部，GPU间通信的带宽通常在数百GB/s以上，PCIe总线的数据传输速率容易成为瓶颈，且PCIe链路接口的串并转换会产生较大延时，影响GPU并行计算的效率和性能。</p><p>GPU发出的信号需要先传递到PCIe Switch, PCIeSwitch中涉及到数据的处理，CPU会对数据进行分发调度，这些都会引入额外的网络延迟，限制了系统性能。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444403.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>为此，NVIDIA推出了能够提升GPU通信性能的技术——GPUDirectP2P技术，使GPU可以通过 PCI Express直接访问目标GPU的显存，避免了通过拷贝到CPU hostmemory作为中转，大大降低了数据交换的延迟，但受限于PCIExpress总线协议以及拓扑结构的一些限制，无法做到更高的带宽。此后，NVIDIA提出了 NVLink 总线协议。</p><p><strong>NVLink简介</strong>：</p><p>NVLink 是一种高速互连技术，旨在加快 CPU 与 GPU、GPU 与 GPU之间的数据传输速度，提高系统性能。NVLink通过GPU之间的直接互联，可扩展服务器内的多GPUI/O，相较于传统PCIe总线可提供更高效、低延迟的互联解决方案。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444911.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>NVLink的首个版本于2014年发布，首次引入了高速GPU互连。2016年发布的P100搭载了第一代NVLink，提供160GB/s 的带宽，相当于当时 PCIe 3.0 x16 带宽（双向）的 5倍。之后陆续发布了很多新版本，V100搭载的 NVLink2 将带宽提升到300GB/s，A100搭载了NVLink3带宽为600GB/s。H100中包含18条第四代NVLink链路，总带宽（双向）达到900 GB/s，是PCIe 5.0 x16带宽（双向）的7倍。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444966.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444983.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>NVLink高速互联主要有两种：</p><ul><li>第一种是以桥接器的形式实现。</li><li>另一种是在主板上集成 <code>NVLink</code> 接口。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444035.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvswitch"><strong>NVSwitch</strong></h3><p>为了解决GPU之间通讯不均衡问题，NVIDIA引入NVSwitch。NVSwitch芯片是一种类似交换机的物理芯片（ASIC），通过NVLink接口可以将多个GPU高速互联到一起，可创建无缝、高带宽的多节点GPU集群，实现所有GPU在一个具有全带宽连接的集群中协同工作，从而提升服务器内部多个GPU之间的通讯效率和带宽。NVLink和NVSwitch的结合使NVIDIA得以高效地将AI性能扩展到多个GPU。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444026.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>第一代 NVSwitch于2018年发布，采用台积电 12nm FinFET 工艺制造，共有 18个 NVLink 2.0 接口。目前 NVSwitch 已经迭代至第三代。第三代 NVSwitch采用台积电 4N 工艺（台积电 4N工艺专为NVIDIA定制设计，并进行了一系列优化，它与普通台积电5nm节点相比，可实现更好的电源效率与性能，并且密度有所提升）构建，每个NVSwitch 芯片上拥有 64 个 NVLink 4.0 端口，GPU 间通信速率可达900GB/s。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444101.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvidia-gpu-服务器-pcie-版-和-sxm-版的区别"><strong>Nvidia GPU服务器 PCIe 版 和 SXM 版的区别</strong></h3><p>英伟达GPU卡间互连的内存插槽有2种，一种是PCIe口，一种是SXM口。</p><p>PCIe口是一个相对通用的协议，PCIe口相对慢一些，SXM是专门用来做卡间互连的，SXM协议是铺在电路板上，SXM协议做卡间互连会更快，对NVLink原生支持更好，显存带宽比PCIe高一些。PCIe和SXM都可以用NVLink，但是SXM是更好使用NVLink的方法。</p><p>SXM 架构是一种高带宽插座式解决方案，用于将 GPU 连接到 NVIDIA 专有的DGX 和 HGX 系统。SXM 版 GPU 通过主板上集成的 NVSwitch 实现 NVLink的连接，不需要通过主板上的PCIe进行通信，它能支持8块GPU卡的互联互通，实现了GPU之间的高带宽。未阉割的A100是600GB/s、H100是900GB/s，阉割过的A800、H800为400GB/s。</p><p>把 PCIe 版 GPU 卡插到 PCIe插槽上，就可以和CPU、同一个服务器上其他的GPU卡进行通信，也可以通过网卡与其他的服务器节点上的设备进行通信，这种就是PCIe的通信方式，但是这种传输速度不快。如果想要和SXM一样，有很快的传输速度，可以使用NVlink桥接器实现GPU和CPU之间的通信，但是和SXM不一样的地方就是它只能实现2块GPU卡之间的通信。即PCIe 版只有成对的 GPU 通过 NVLink Bridge 连接，通过 PCIe通道进行数据通信。同时，最新的PCIe网络带宽有128GB/s的限制。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444612.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="tcpip"><strong>TCP/IP</strong></h3><p>TCP/TP （或传输控制协议/Internet 协议）用于通过 Internet互连网络设备。它确定了数据应该如何被打包、寻址、传输、路由和接收。TCP/IP非常重视两台计算机之间的准确数据传输。如果系统在一次发送消息时遇到问题，则必须重新发送整个消息。</p><p>此外，TCP/IP的功能分为四个不同的层：<strong>数据链路层、互联网层、传输层和应用层</strong>。数据在被另一端接收之前必须经过这四层。然后，TCP/IP将通过以相反顺序传递层来重组数据并将其呈现给接收器。这样，您可以通过升级某些层而不是整个系统来提高数据中心的性能或安全性。</p><h3 id="rdma"><strong>RDMA</strong></h3><p>RDMA(远程直接数据存取)就是为了解决网络传输中服务器端数据处理的延迟而产生的，<strong>无需使用CPU，就可以从一个主机或服务器的内存直接访问另一主机或服务器的内存</strong>。它释放了CPU去执行其应做的工作，比如：运行应用程序和处理大量数据。这既提高了带宽又降低了延迟、抖动和CPU 消耗。</p><p>对比传统的网络传输机制，RDMA无需操作系统和TCP/IP协议栈的介入。<strong>RDMA的内核旁路机制，允许应用与网卡之间的直接数据读写</strong>，将服务器内的数据传输时延降低到1us以下。同时，RDMA的内存零拷贝机制，允许接收端直接从发送端的内存读取数据，极大的减少了CPU的负担，提升CPU的效率。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444661.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>大致有三类RDMA网络，分别是Infiniband、RoCE、iWARP。其中，Infiniband是一种专为RDMA设计的网络，从硬件级别保证可靠传输，而RoCE 和 iWARP都是基于以太网的RDMA技术，支持相应的verbs接口。</p><p>RDMA最早在Infiniband传输网络上实现，技术先进，但是价格高昂(<strong>只有Mellanox（现已被英伟达收购）和Intel（2012年，英特尔公司出资收购了QLogic的InfiniBand技术）供应商提供全套网络解决方案</strong>)，后来业界厂家把RDMA移植到传统Ethernet以太网上，降低了RDMA的使用成本，推动了RDMA技术普及。在Ethernet以太网上，根据协议栈融合度的差异，分为iWARP和RoCE两种技术，而RoCE又包括<strong>RoCEv1和RoCEv2两个</strong>版本(RoCEv2的最大改进是支持IP路由)。各RDMA网络协议栈的对比，如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444703.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>IB（InfiniBand）：</strong> 基于 InfiniBand 架构的 RDMA技术，由 IBTA（InfiniBand Trade Association）提出。搭建基于 IB 技术的RDMA 网络需要专用的 IB 网卡和 IB 交换机。</p><p><strong>iWARP（Internet Wide Area RDMA Protocal）：</strong> 基于TCP/IP 协议的 RDMA 技术，由 IETF 标 准定义。iWARP支持在标准以太网基础设施上使用 RDMA 技术，但服务器需要使用支持iWARP的网卡。</p><p><strong>RoCE（RDMA over Converged Ethernet）：</strong> 基于以太网的RDMA 技术，也是由 IBTA 提出。RoCE支持在标准以太网基础设施上使用RDMA技术，但是需要交换机支持无损以太网传输，需要服务器使用RoCE 网卡。</p><p>在三种主流的RDMA技术中，可以划分为两大阵营。一个是IB技术，另一个是支持RDMA的以太网技术(RoCE和iWARP)。其中,IBTA力挺的技术自然是IB和RoCE,Mellanox公司是这方面的急先锋。而iWARP则是IEEE/IETF力挺的技术，主要是Chelsio公司在推进。</p><p>在存储领域，支持RDMA的技术早就存在，比如：SRP(SCSI RDMAProtocol)和iSER(iSCSI Extensions for RDMA)。如今兴起的NVMe overFabrics如果使用的不是FC网络的话，本质上就是 NVMe over RDMA。换句话说，NVMe over InfiniBand, NVMe over RoCE 和 NVMe over iWARP 都是NVMe over RDMA。</p><h2 id="infiniband"><strong>InfiniBand</strong></h2><p>InfiniBand（直译为 “无限带宽”技术，缩写为IB）是一个为大规模、易扩展机群而设计的<strong>网络通信技术协议</strong>。可用于计算机内部或外部的数据互连，服务器与存储系统之间直接或交换互连，以及存储系统之间的互连。</p><p>InfiniBand最重要的一个特点就是<strong>高带宽</strong>、<strong>低延迟</strong>，因此在高性能计算项目中广泛的应用。主要用于高性能计算（HPC）、高性能集群应用服务器和高性能存储。</p><h3 id="infiniband-链路速率"><strong>InfiniBand 链路速率</strong></h3><p>InfiniBand在物理层定义了多种链路速度，例如：1X，4X，12X。每个单独的链路是四线串行差分连接（每个方向两根线）。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444802.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>以早期的SDR（单数据速率）规范为例，1X链路的原始信号带宽为2.5Gbps，4X链路是10Gbps，12X链路是30Gbps。1X链路的实际数据带宽为2.0Gbps（因为采用8b/10b编码）。由于链路是双向的，因此相对于总线的总带宽是4Gbps。</p><p>随着时间的推移，InfiniBand的网络带宽不断升级，下图展示了 InfiniBand从SDR、DDR、QDR、FDR、EDR发展到HDR、NDR的网络带宽，其速度是基于 4x链路速度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444850.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li>SDR（Single Data Rate）：2.5Gb/s (10Gb/s for 4x)。</li><li>DDR（Double Data Rate）：5 Gb/s (20Gb/s for 4x)。</li><li>QDR（Quad Data Rate）：10 Gb/s (40Gb/s for 4x)。</li><li>FDR（Fourteen Data Rate）：14Gb/s (56Gb/s for 4x)。</li><li>EDR（Enhanced Data Rate）：25 Gb/s (100Gb/s for 4x)。</li><li>HDR（High Data Rate）：50 Gb/s (200Gb/s for 4x)。</li><li>NDR（Next Data Rate）：100 Gb/s (400Gb/s for 4x)。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444956.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-网络互连产品"><strong>InfiniBand网络互连产品</strong></h3><p>InfiniBand网络中，使用的线缆区别于传统的以太网线缆和光纤线缆。针对不同的连接场景，需使用专用的InfiniBand线缆。</p><p>InfiniBand网络互连产品包括：<strong>DAC高速铜缆</strong>、<strong>AOC有源线缆</strong>以及<strong>光模块</strong>。</p><p>DAC高速线缆和AOC有源光缆都是用于数据中心、高性能计算机等大容量储存器设备间的传输设备。</p><p><strong>DAC高速线缆</strong>，也叫直连铜缆（Direct Attach Coppercable）,它的线材是铜缆，是低压脉冲传输信号；因为材料的不同导致功耗、传输距离和价格的不同，DAC高速线缆的功耗比较低，但传输距离相对比较短，低于10米。价格方面相对便宜一些。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444144.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>AOC有源光缆</strong>（Active OptialCable），它的线材是光缆，为光信号传输，通过电-光-电的转换；功耗相对比较大些但传输的距离可达到100米，价格方面相对高些。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444200.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>光模块</strong>的作用也是光电信号之间的转换，主要用于交换机与设备之间传输的载体，和光纤收发器的原理相同，只是光模块相比收发器更具效率性、安全性。光模块按照封装形式分类，常见的有SFP，SFP+，XFP，SFP28,QSFP+,QSFP28 等。</p><p><strong>光纤收发器</strong>是将短距离的电信号和长距离的光信号进行转换的设备，一般应用在远距离传输中，通过光纤进行传输，将电信号转换成光信号发送出去，同时，在接收端将接收到的光信号转换成电信号。在很多地方也被称之为光电转换器(FiberConverter)。光纤收发器为需要将系统从铜线升级到光纤，为缺少资金、人力或时间的用户提供了一种廉价的方案。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444278.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>光模块与光纤收发器如何配对使用？</strong></p><ol type="1"><li>波长和传输距离必须一致，比如：采用1310nm波长，传输距离应该是10KM/20KM。</li><li>光纤跳线尾纤接口选择需注意，一般光纤收发器采用的SC口，光模块采用的是LC口。</li><li>速率必须一样，比如：千兆收发器对应 1.25G光模块，百兆连百兆，千兆连千兆。4、光模块类型需要采用相同类型，单纤对单纤，双纤对双纤。</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444281.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-的网络架构"><strong>InfiniBand的网络架构</strong></h3><p>InfiniBand 是一种基于通道的结构，组成单元主要分为四类：</p><ul><li>HCA（Host Channel Adapter，主机通道适配器）</li><li>TCA（Target Channel Adapter，目标通道适配器）</li><li>InfiniBand link（连接通道，可以是电缆或光纤，也可以是板上链路）</li><li>InfiniBand交换机和路由器（组网用的）</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444357.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>通道适配器就是搭建InfiniBand通道用的。所有传输均以通道适配器开始或结束，以确保安全或在给定的QoS（服务质量）级别下工作。</p><p>使用 InfiniBand 的系统可以由多个子网（Subnet）组成，每个子网最大可由6 万多个节点组成。</p><ul><li>子网内部，InfiniBand 交换机进行二级处理。</li><li>子网之间，使用路由器或网桥进行连接。</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444436.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>InfiniBand 的二级处理过程非常简单，每个 InfiniBand子网都会设一个子网管理器，生成16位的 LID（本地标识符）。InfiniBand交换机包含多个 InfiniBand端口，并根据第二级本地路由标头中包含的LID，将数据包从其中一个端口转发到另一个端口。<strong>除管理数据包外，交换机不会消耗或生成数据包</strong>。</p><p>简单的处理过程，加上自有的Cut-Through技术，InfiniBand将转发时延大幅降低至 100ns 以下，明显快于传统以太网交换机。</p><p>在 InfiniBand网络中，数据同样以数据包（最大4KB）的形式传输，采用的是串行方式。</p><h3 id="infiniband-的协议栈"><strong>InfiniBand 的协议栈</strong></h3><p>InfiniBand协议同样采用了分层结构，各层相互独立，下层为上层提供服务，如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444628.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li><strong>物理层</strong>定义了在线路上如何将比特信号组成符号，然后再组成帧、数据符号以及包之间的数据填充等，详细说明了<strong>构建有效包的信令协议</strong>等。</li><li><strong>链路层</strong>定义了数据包的格式以及数据包操作的协议，如：流控、路由选择、编码、解码等。</li><li><strong>网络层</strong>通过在数据包上添加一个40字节的全局的路由报头（GlobalRoute Header,GRH）来进行路由的选择，对数据进行转发。<strong>在转发的过程中，路由器仅仅进行可变的CRC校验，这样就保证了端到端的数据传输的完整性</strong>。Infiniband报文封装格式如下图所示：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444690.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><ul><li><strong>传输层</strong>再将数据包传送到某个指定的队列偶（Queue Pair,QP）中，并指示 QP 如何处理该数据包。</li></ul><p>可以看出，InfiniBand 拥有自己定义的 1-4层格式，是一个完整的网络协议。端到端流量控制，是 InfiniBand网络数据包发送和接收的基础，可以实现无损网络。</p><blockquote><p>QP（队列偶）说明：QP是RDMA技术中通信的基本单元。队列偶就是一对队列，SQ（SendQueue，发送工作队列）和 RQ（ReceiveQueue，接收工作队列）。用户调用API发送接收数据的时候，实际上是将数据放入QP当中，然后以轮询的方式，将QP中的请求一条条的处理。</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444761.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="mellanox-ofed-软件栈"><strong>Mellanox OFED 软件栈</strong></h3><p>Mellanox OFED是一个单一的软件堆栈，包括驱动、中间件、用户接口，以及一系列的标准协议IPoIB、SDP、SRP、iSER、RDS、DAPL(Direct Access ProgrammingLibrary)，支持 MPI、Lustre/NFS over RDMA 等协议，并提供 Verbs编程接口；Mellanox OFED 由开源 OpenFabrics 组织维护。</p><p>Mellanox OFED 软件堆栈是承载在 InfiniBand硬件和协议之上的，软件通过协议和硬件进行有效的数据传输。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444831.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="opensm-子网管理器"><strong>OpenSM 子网管理器</strong></h3><p>OpenSM 软件是符合InfiniBand的子网管理器(SM)，运行在MellanoxOFED软件堆栈进行 IB网络管理，管理控制流走业务通道，属于带内管理方式。</p><p>OpenSM包括<strong>子网管理器、背板管理器和性能管理器</strong>三个组件，绑定在交换机内部的必备部件。提供非常完备的管理和监控能力，如：<strong>设备自动发现、设备管理、Fabric可视化、智能分析、健康监测</strong>等等。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444856.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-组网"><strong>InfiniBand 组网</strong></h3><p>InfiniBand 组网跟普通的交换机不太一样，InfiniBand的组网成本很高。如果希望这个网络中任何两个计算节点的网卡之间互相无损地通信，需要使用一种叫做胖树（FatTree）的网络拓扑，大概是如下一种拓扑结构，方块是交换机，椭圆是计算节点。</p><p>胖树主要有两层，上面一层是核心层，不连任何计算节点，它的功能就是转发流量；下面一层是接入层，接入各类计算节点。</p><p>胖树拓扑成本高的主要原因是：某一个汇聚交换机上，假如有36个口，那如果为了达到无损速率，一半的口，也就是18个口可以给计算节点连，剩下一半要连到上层的核心交换机上。要知道，任何一根线，就是1万多块钱呢，如果达到无损，就要冗余地做这些连接。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444939.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nvidia-infiniband-商用产品"><strong>NVIDIA InfiniBand商用产品</strong></h3><p>Mellanox 在全球 InfiniBand 市场的占有率基本上无敌的存在，在英伟达收购Mellanox 之后，也于2021年推出了自己的第七代 NVIDIA InfiniBand架构：NVIDIA Quantum-2。</p><p>NVIDIA Quantum-2 平台包括：NVIDIA Quantum-2 系列交换机、NVIDIAConnectX-7 InfiniBand 适配器、BlueField-3 InfiniBand DPU以及电缆。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444126.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>NVIDIA Quantum-2系列交换机</strong>采用紧凑型1U设计，包括风冷和液冷版本。交换机的芯片制程工艺为7nm，单芯片拥有570亿个晶体管（比A100GPU还多）。单个交换机采用64个400Gb/s端口或128个200Gb/s端口的灵活搭配，提供总计51.2Tb/s的双向吞吐量。NVIDIA NDR 400Gb/s InfiniBand交换机如下图所示：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444198.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>NVIDIA ConnectX-7 InfiniBand 适配器</strong>支持PCIeGen4和Gen5，具有多种外形规格，可提供 400Gb/s 吞吐量。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444299.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="infiniband-常用命令"><strong>InfiniBand 常用命令</strong></h3><ul><li><code>ibv_asyncwatch</code>：监视 InfiniBand 异步事件</li><li><code>ibv_devices</code> 或 <code>ibv_devinfo</code>： 列举InfiniBand 设备或设备信息 - <code>ibstatus</code>：查询 IB设备的基本状态</li><li><code>ibping</code>： 验证 IB 节点之间的连通性</li><li><code>ibtracert</code>：跟踪 IB 路径</li><li><code>iblinkinfo</code>：查看IB交换模块的所有端口的连接状态。此命令会将集群内所有的IB交换模块都进行列举。</li></ul><h2 id="通信软件"><strong>通信软件</strong></h2><p>通信软件指用于分布式训练时，多个计算设备之间的集合通信。在分布式系统中，各个节点间往往存在大量的集合通信需求，而我们可以用消息传递接口(Message Passing Interface，MPI，一套集合通信相关的接口标准)来定义一些比较底层的消息通信行为。譬如Reduce、AllReduce、Scatter、Gather、AllGather 等。</p><p>常见的集合通信库（如：Open MPI、Gloo、NCCL等）都在 MPI的基础上，对各种集合通信的模式和算法作了各自的实现。</p><p><strong>Open MPI</strong>：</p><p>Open MPI 是一个开源 MPI（消息传递接口）的实现，由学术，研究和行业合作伙伴联盟开发和维护。因此，Open MPI可以整合高性能计算社区中所有专家，技术和资源，以构建可用的最佳 MPI库。</p><p><strong>Gloo</strong>：</p><p>Gloo 是 Facebook开源的一套集体通信库，提供了对机器学习中有用的一些集合通信算法。如：Barrier，Broadcast，AllReduce。</p><p><strong>NCCL</strong>：</p><p>NCCL（Nvidia Collective multi-GPU Communication Library）是英伟达基于NVIDIA GPU 的一套开源的集合通信库，如其官网描述：NVIDIA集合通信库（NCCL）实现了针对 NVIDIA GPU 性能优化的多 GPU和多节点集合通信原语。NCCL 提供了诸如 All Gather，AllReduce，Broadcast，Reduce，Reduce-Scatter 等实现，这些实现优化后可以通过PCIe、 NVLink、InfiniBand 等高速互联，从而实现高带宽和低延迟。</p><p>因为 NCCL 是 NVIDIA基于自身硬件定制的，能做到更有针对性且更方便优化，故在英伟达硬件上，NCCL的效果往往比其它的通信库更好。</p><p>NCCL主要做几件事：<strong>探测计算节点的网络设备和拓扑结构</strong>，使用算法自动调优选择一个最优的通信方式。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444373.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="nccl-集合通信库"><strong>NCCL 集合通信库</strong></h2><h3 id="通信原语"><strong>通信原语</strong></h3><p>并行任务的通信一般可以分为 Point-to-point communication 和 Collectivecommunication 。</p><p>P2P 通信这种模式只有一个sender和一个receiver，实现起来比较简单。</p><p>集合通信包含多个sender多个receiver，一般的通信原语包括broadcast，gather，all-gather，scatter，reduce，all-reduce，reduce-scatter，all-to-all等。</p><p>简单介绍几个常用的操作：</p><p><strong>Reduce</strong>：从多个sender那里接收数据，最终combine到一个节点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444484.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p><strong>All-reduce</strong>：从多个sender那里接收数据，最终combine到每一个节点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444737.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nccl-实现"><strong>NCCL 实现</strong></h3><p>NCCL 实现成 CUDA C++ kernels，包含3种 primitive operations：Copy，Reduce，ReduceAndCopy。</p><ul><li>NCCL 1.0 版本只支持单机多卡，卡之间通过 PCIe、NVlink、GPUDirect P2P来通信。</li><li>NCCL 2.0 支持多机多卡，多机间通过 Sockets (Ethernet) 或者 InfiniBandwith GPUDirect RDMA 通信。</li></ul><p>单机内多卡通过PCIe以及CPU socket通信。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444882.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>多机通过InfiniBand通信，在多机多卡内部，也要构成一个通信环。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444963.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="对比-nccl-在不同硬件架构下网络带宽"><strong>对比 NCCL在不同硬件架构下网络带宽</strong></h3><p>下图是 Allreduce 在单机不同架构下的速度比较：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444081.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>前面三个是单机多卡典型的三种连接方式：</p><ul><li>第一种是两个GPU通过CPU然后通过QPI和另一个CPU上的两块卡相连，因此速度最慢，但也能达到&gt;5GB/s。</li><li>第二种是两个GPU通过PCIeswitch相连后再经过CPU连接，速度会稍微低一点。</li><li>第三种是四张卡都在一个PCIe switch上，所以带宽较高，能达到&gt;10GB/sPCIe的带宽大小。</li></ul><p>第四种是DGX-1架构，这是Nvidia推出的深度学习平台，带宽能达到60GB/s。</p><p>下图是 Allreduce多机下的速度表现。其中，左图2机8卡，机内PCIe，机间InfiniBand能达到&gt;10GB/s的速度，InfiniBand基本上能达到机内的通信速度；右图4机32卡，机内NVLink，机间InfiniBand，带宽能达到&gt;40GB/s。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444202.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>下图是 NCCL 在 CNTK ResNet50 上的可扩展性（scalability），32卡基本能达到线性加速比。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444295.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h3 id="nccl-常见的环境变量设置"><strong>NCCL常见的环境变量设置</strong></h3><p><strong>NCCL_P2P_DISABLE</strong></p><p>该变量禁用 P2P 传输，该传输使用 NVLink 或 PCI在GPU之间使用CUDA直接访问。</p><p>设定为 1 相当于设置 <code>NCCL_P2P_LEVEL=0</code>，并且会被NCCL_P2P_LEVEL 的值所覆盖。</p><p><strong>NCCL_P2P_LEVEL</strong>：</p><p>该变量允许用户精细地控制何时在GPU之间使用 P2P传输。该级别定义了NCCL将使用P2P传输的GPU之间的最大距离。</p><p>如果未指定，NCCL将尝试根据其运行的体系结构和环境来最佳选择一个值。</p><p>可选值：</p><ul><li>LOC：从不使用P2P（始终禁用）</li><li>NVL ：当 GPU 通过 NVLink 连接时使用 P2P</li><li>PIX ：当 GPU 位于同一 PCI 交换机上时使用 P2P。</li><li>PXB：当 GPU 通过 PCI 交换机（可能是多跳）连接时使用 P2P。</li><li>PHB ：当 GPU 位于同一 NUMA 节点上时使用 P2P。 流量将通过 CPU。</li><li>SYS ：在 NUMA 节点之间使用 P2P，可能跨越 SMP互连（例如：QPI/UPI）。</li></ul><p><strong>NCCL_NET_GDR_LEVEL</strong>：</p><p>该变量允许用户精细控制何时在NIC和GPU之间使用GPUDirectRDMA。该级别定义NIC和GPU之间的最大距离。</p><p>如果未指定，NCCL将尝试根据其运行的体系结构和环境来最佳选择一个值。</p><p>可选值：</p><ul><li>LOC：从不使用 GPU Direct RDMA。（始终禁用）</li><li>PIX：当 GPU 和 NIC 位于同一 PCI 交换机上时，使用 GPU DirectRDMA。</li><li>PXB：当 GPU 和 NIC 通过 PCI 交换机（可能是多跳）连接时，使用 GPUDirect RDMA。</li><li>PHB ：当 GPU 和 NIC 位于同一 NUMA 节点上时，使用 GPU Direct RDMA。流量将通过 CPU。</li><li>SYS ：即使跨 NUMA 节点之间的 SMP 互连（例如 QPI/UPI）也使用 GPUDirect RDMA。 （始终启用）</li></ul><p><strong>NCCL_NET_GDR_READ</strong>：</p><p>只要 GPU-NIC 距离在 NCCL_NET_GDR_LEVEL指定的距离内，NCCL_NET_GDR_READ 变量就会在发送数据时启用 GPU DirectRDMA。</p><ul><li>2.4.2之前，默认情况下禁用GDR读取，即发送数据时，数据先存储在 CPU内存中，然后再发送到 InfiniBand 卡。</li><li>自 2.4.2 起，基于 NVLink 的平台默认启用 GDR 读取。</li></ul><p>注意：已知在某些平台（例如：PCI-E）上，发送数据时直接从 GPU内存读取比从 CPU 内存读取稍慢。</p><p>可选值为0或1。定义并设置为1以使用GPU DirectRDMA直接将数据发送到NIC（绕过CPU）。</p><p>在 2.4.2 之前，所有平台的默认值都是 0。 自 2.4.2 起，基于 NVLink的平台的默认值为 1，否则为 0。</p><p><strong>NCCL_IB_DISABLE</strong>：</p><p>该变量将禁用 NCCL 要使用的IB传输。NCCL 将使用IP sockets 。</p><p>定义并设置为1以强制使用IP sockets 。</p><p><strong>NCCL_SOCKET_IFNAME</strong>：</p><p>指定NCCL使用的SOCKET网卡。如：<code>NCCL_SOCKET_IFNAME=bond0,eth0</code>。</p><p><strong>NCCL_IB_HCA</strong>：</p><p>该变量指定要用于通信的 RDMA接口。使用IB通信必须要设置的（指定NCCL使用的IB网卡）。 可以通过 ibstat查看IB网卡名。</p><p>用法：</p><p>定义一个前缀列表来过滤要由 NCCL 使用的接口。使用 ^ 符号，NCCL将排除以列表中任何前缀开头的接口。还可以使用 :符号来指定特定的端口。要匹配（或不匹配）确切的接口名称而不是前缀，在字符串前面加上= 字符。</p><p>示例：</p><ul><li><code>mlx5</code>：使用以 mlx5 开头的所有卡的所有端口。</li><li><code>=mlx5_0:1,mlx5_1:1</code>：使用卡 mlx5_0 和 mlx5_1 的端口1。</li><li><code>^=mlx5_1</code>：不使用卡 mlx5_1。</li></ul><p>比如： NCCL_IB_HCA=mlx5_2,mlx5_3,mlx5_4,mlx5_5</p><blockquote><p>注意： 如果不加前缀 =，使用 mlx5_1 将同时选择 mlx5_1 和 mlx5_10 到mlx5_19（如果存在）。因此，始终建议添加前缀 = 以确保精确匹配。</p></blockquote><p>使用建议：</p><p>通过这个环境变量可以调整NIC（Network Interface Controller）数量，NIC通常是一块插入计算机主板上的扩展卡，更多NIC，节点带宽更大。通过控制NIC数量可以控制节点间通信带宽。</p><p><strong>NCCL_IB_TIMEOUT</strong>：</p><p>该变量用于控制InfiniBand Verbs超时。取值范围1-22。</p><p>超时时间的计算公式为4.096微秒 * 2 ^timeout，正确的值取决于网络的大小。增加该值可以在非常大的网络上提供帮助，例如，如果NCCL在调用ibv_poll_cq时出现错误12。</p><p>使用建议：</p><p>在大模型训练任务中设置成最大值22，可以减少不少nccl timeout异常。</p><p><strong>NCCL_IB_RETRY_CNT</strong></p><p>该变量控制 InfiniBand 的重试次数。</p><p>使用建议：</p><p>在大模型训练任务中设置成13，尽可能多重试。</p><p><strong>NCCL_PXN_DISABLE</strong>：</p><p>禁止使用非本地 NIC 的进行节点间通信，使用 NVLink 和一个中间 GPU。</p><p>使用建议：</p><p>设置成1。在PyTorch中进行跨节点all-to-all通信时，如果该环境变量是0会出现异常。</p><p><strong>NCCL_DEBUG_FILE</strong>：</p><p>设置一个文件地址，变量用于将NCCL的调试日志输出到文件中，有助于调试NCCL。</p><p><strong>NCCL_IB_PCI_RELAXED_ORDERING</strong>：</p><p>启用 IB Verbs 传输的 Relaxed Ordering。RelaxedOrdering可以极大地提高虚拟化环境下 InfiniBand 网络的性能。</p><p>传统的顺序执行（StrictOrdering）要求数据在发送和接收之间按照严格的顺序进行传输和处理。这种机制可以确保数据的顺序性，但可能会导致性能瓶颈，特别是在高负载和复杂通信模式下。</p><p>而RelaxedOrdering允许数据在发送和接收之间进行乱序传输和处理。这意味着系统可以更灵活地调度和处理数据，提高并行性和吞吐量。RelaxedOrdering机制在虚拟化环境中尤其有益，因为它可以减少虚拟机之间的争用和延迟，提高整体性能。</p><p>接受的取值：</p><ul><li>设置为 2，如果可用，自动使用Relaxed Ordering。</li><li>设置为 1，强制使用Relaxed Ordering，如果不可用，则失败。</li><li>设置为 0，禁用使用Relaxed Ordering。</li></ul><p>默认值为 2。建议设置成 1。</p><p><strong>NCCL_SHM_DISABLE</strong>：</p><p>该变量禁用共享内存（SHM）传输。</p><p>在P2P不能生效的情况下，是否使用CPU的共享内存来传输数据。 当 SHM禁用时，NCCL 使用网络（ InfiniBand 或 IP sockets）在 CPU sockets之间进行通信。</p><h2 id="infiniband-在-ai-集群中的应用"><strong>InfiniBand 在 AI集群中的应用</strong></h2><h3 id="gpudirect-简介"><strong>GPUDirect 简介</strong></h3><p>GPUDirect 是 NVIDIA 开发的一项技术，可实现 GPU与其他设备（例如网络接口卡 (NIC)和存储设备）之间的直接通信和数据传输，而不涉及 CPU。</p><p>传统上，当数据需要在 GPU 和另一个设备之间传输时，数据必须通过CPU，从而导致潜在的瓶颈并增加延迟。使用GPUDirect，网络适配器和存储驱动器可以直接读写 GPU内存，减少不必要的内存消耗，减少 CPU开销并降低延迟，从而显著提高性能。GPU Direct 技术包括 GPUDirectStorage、GPUDirect RDMA、GPUDirect P2P 和 GPUDirect Video。</p><h3 id="gpudirect-发展简史"><strong>GPUDirect 发展简史</strong></h3><ul><li>GPUDirect Shared Memory (2012) ：Nvidia在PCIe上实现了单机上的GPUDirect Shared Memory 技术；</li><li>GPUDirect P2P (2014)： Nvidia在PCIe上实现了单机上的GPUDirectP2P技术；</li><li>NVLink（2014） ：解决了单机多卡通信时PCIe瓶颈问题；</li><li>GPUDirect RDMA（2014）：提升多机多卡通信性能；</li></ul><h3 id="gpudirect-peer-to-peerp2p简介"><strong>GPUDirect Peer toPeer（P2P）简介</strong></h3><p>GPUDirect Peer-to-Peer(P2P)技术主要用于单机GPU间的高速通信，它使得<strong>GPU可以通过PCIExpress直接访问目标GPU的显存</strong>，避免了通过拷贝到CPU hostmemory作为中转，大大降低了数据交换的延迟。</p><p>以深度学习应用为例，主流的开源深度学习框架（如：TensorFlow、MXNet）都提供了对GPUDirectP2P的支持，NVIDIA开发的NCCL(NVIDIA Collective CommunicationsLibrary)也提供了针对GPUDirect P2P的特别优化。</p><p>通过使用GPUDirectP2P技术可以大大提升深度学习应用单机多卡的扩展性，使得深度学习框架可以获得接近线性的训练性能加速比。</p><h3 id="gpudirect-rdma-简介"><strong>GPUDirect RDMA 简介</strong></h3><p>所谓 GPUDirectRDMA，就是计算机1的GPU可以直接访问计算机2的GPU内存。而在没有这项技术之前，GPU需要先将数据从GPU内存搬移到系统内存，然后再利用RDMA传输到计算机2，计算机2的GPU还要做一次数据从系统内存到GPU内存的搬移动作。GPUDirectRDMA技术使得进一步减少了GPU通信的数据复制次数，通信延迟进一步降低。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444358.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>使用 GPUDirect RDMA 两个 GPU 设备必须共享相同的上游 PCI Express rootcomplex。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444350.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="infiniband-在-nvidia-dgx-集群中应用"><strong>InfiniBand 在NVIDIA DGX 集群中应用</strong></h2><p><strong>DGX-1 集群中应用 InfiniBand</strong>：</p><p>下图展示了 DGX-1 配有四个 EDR InfiniBand 卡（每个 100 Gb/s）和两个10Gb/s 以太网卡（铜质）。 这些网络接口可用于将 DGX-1连接到网络以进行通信和存储。</p><p>每两个 GPU 都连接到系统板上的一个 PCIe 交换机。 该交换机还连接到InfiniBand (IB) 网卡。 为了减少延迟并提高吞吐量，来自这两个 GPU的网络流量应流向关联的 IB 卡。 这就是 DGX-1 设备中有四张 IB卡的原因。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444419.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>如果您想使用InfiniBand（IB）网络连接DGX设备，理论上，您只需使用其中一张IB卡即可。然而，这些数据流量将强行通过 CPU 之间的 QPI 链路，这对于 GPU流量来说是一个非常慢的链路（即，它成为瓶颈）。更好的解决方案是使用两张IB 卡，一张连接到每个 CPU。这可以是 IB0 和 IB2，或者 IB1 和 IB3，或者IB0 和 IB3，或者 IB1 和 IB2。 这将大大减少必须穿越 QPI 链路的流量。最佳性能始终是使用 IB 交换机的所有四个 IB 链路。</p><p>使用 IB 链路是将所有四个 IB 卡连接到 IB 结构的最佳方法。如果您使用多个 DGX设备进行训练，这将带来最佳性能（完全的平分带宽和最低延迟）。</p><p>通常，最小的 IB 交换机配有 36 个端口。 这意味着单个 IB交换机可容纳使用全部四张 IB 卡的九个 DGX-1 设备。 这允许从 DGX-1到交换机的带宽为 400 Gb/s。</p><p>如果您的应用程序不需要 DGX-1 设备之间的带宽，则可以如前所述为每个DGX-1 使用两个 IB 连接。 这允许您将最多 18 个 DGX-1 设备连接到单个 36端口 IB 交换机。</p><p>注意：<strong>不建议仅使用单个 IB卡</strong>，但如果由于某种原因采用这种配置，则您最多可以将 36 个 DGX-1设备连接到单个交换机。</p><p>对于大量 DGX-1 设备，您可能必须使用两级交换网络。 经典的 HPC配置是在第一级使用 36 端口 IB交换机（有时称为叶子（Leaf）交换机），并将它们连接到单个大型核心交换机，有时称为导向器级（directorclass）交换机。最大的导向器级InfiniBand交换机有648个端口。当然您也可以使用多个核心交换机，但配置会变得相当复杂。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444513.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>对于两级交换网络，如果每个 DGX-1 设备的全部 4 个 IB 卡都用于连接到 36端口交换机，并且没有过度订阅，则每个交换机的 DGX-1 设备的最大数量为4。这时每个 DGX-1 有 4 个端口进入交换机，总共 16个端口。然后，从叶子交换机到核心交换机（导向器级交换机）有 16个上行链路。总共 40 台 36 端口叶子交换机可连接到 648 端口核心交换机(648/16)。 这导致 160（40 * 4） 个 DGX-1设备（共640卡）以全对分带宽连接。</p><p>当然您还可以在设计 IB网络时使用所谓的过度订阅。过度订阅意味着来自<strong>上行链路的带宽小于进入设备的带宽</strong>（换句话说，带宽性能较差）。如果我们使用从DGX-1 设备到第一级交换机（36 端口叶交换机）的 2:1 超额订阅，则每个 DGX-1设备仅使用两个 IB卡连接到交换机。与使用所有四张卡相比，这会导致带宽更少，并且延迟也会更高。</p><p>如果我们保持从叶子交换机到核心交换机的网络带宽为1:1（换句话说，没有过度订阅，全对分带宽），那么我们可以将九个 DGX-1设备放入一个单叶子交换机（从 DGX 设备到叶子交换机的总共 18个端口以及到核心交换机的 18个上行链路端口）。结果是总共36（648/18）台叶子交换机可以连接到核心交换机。这使得总共 324（36 * 9） 个 DGX-1 设备可以连接在一起。</p><p>您还可以通过使用从叶子交换机到核心交换机的超额订阅来进一步定制 IB网络。 这可以通过<strong>使用每个 DGX 设备到叶子交换机的四个 IB连接</strong>，然后对核心交换机进行 2:1超额订阅，甚至使用到叶子交换机的两个 IB 连接，然后对核心交换机进行 2:1超额订阅来完成。</p><p>InfiniBand 网络的另一个重要方面是子网管理器 (SM)。 SM仅管理IB网络。任何时候都有一个 SM 管理 IB 结构，但您可以让其他 SM 运行并准备好在第一个SM 崩溃时接管。 选择运行多少个 SM以及在何处运行它们会对集群的设计产生重大影响。</p><p>首先要做的决定是<strong>在哪里运行 SM</strong>。</p><p>如果您愿意，它们可以在 IB 交换机上运行。 这称为硬件SM，因为它在交换机硬件上运行。 这样做的优点是您不需要任何其他也可以运行SM 的服务器。</p><p>在节点上运行 SM 称为软件 SM。 运行硬件 SM 的一个缺点是，如果 IB流量很大，SM 可能会遇到困难。 对于大量 IB流量和较大的网络，最佳实践是在专用服务器上使用软件 SM。</p><p>要做的第二个决定是您<strong>想要运行多少个 SM</strong>。您至少必须运行一个 SM。 最便宜的解决方案是运行单个硬件 SM。 这对于 DGX-1设备的小集群（可能是 2-4 个）来说效果很好。随着单元数量的增加，您将需要考虑同时运行两个 SM 以获得HA（高可用性）功能。 您需要 HA的原因是集群上有更多用户，并且集群故障比少量设备故障产生的影响更大。</p><p>随着设备数量的增长，请考虑在专用服务器（软件 SM）上运行 SM。您还需要为集群运行至少两个 SM。 理想情况下，这意味着 SM有两台专用服务器。</p><p><strong>DGX SuperPOD 中广泛应用InfiniBand</strong>：</p><p>下图为 DGX A100/H100 256 SuperPOD 网络拓扑图：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444669.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>下图为 DGX A100/H100 1K POD 网络拓扑图：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444765.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><h2 id="infiniband-在-ai-框架中的应用"><strong>InfiniBand 在 AI框架中的应用</strong></h2><p>在之前文章（<strong><ahref="https://link.zhihu.com/?target=https%3A//juejin.cn/post/7311604023184162835">AI集群基础设施 NVMe SSD 详解</a></strong>）中谈到了 NVMe 在 DeepSpeed中的应用。DeepSpeed 通过 ZeRO-Infinity 技术尝试<strong>利用 NVMe的空间进一步打破内存墙的限制训练超大模型</strong>。除此之外，该方法也充分利用了InfiniBand网络进行多机通信，具体如下图所示。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061444828.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>image.png</p><p>另外，像NCCL、Gloo等集合通信库都继承了InfiniBand，Pytorch框架也能够通过通信库轻松应用InfiniBand进行分布式训练。</p><h2 id="总结"><strong>总结</strong></h2><p>本文讲述了AI集群通信的软硬件；同时，针对NCLL集合通信库以及InfiniBand网络通信技术协议进行了更为详细的介绍；另外，也讲述了AI集群以及AI框架中对于InfiniBand的应用。</p><p>码字不易，如果觉得有帮助，欢迎点赞收藏加关注。</p><h2 id="参考文档"><strong>参考文档</strong></h2><ul><li><strong><ahref="https://zhuanlan.zhihu.com/p/454282470">带你了解PCIE通信原理</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/662904805">电脑硬件冷知识：主板北桥芯片为何消失了，南桥也有同样的命运？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/FlRc2q8r0fUOzxJFWulGfw">必看:原来PCIe技术原理这么简单</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.sdnlab.com/26316.html">AI网络互联，PCIe还是NVLink？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.sohu.com/a/229080366_632967">RDMA技术原理分析、主流实现对比和解析</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/FgKjDjZsPlweVJ03OVr3SA">详谈RDMA技术原理和三种实现方式</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/u013253075/article/details/119843611">RDMA技术详解——RDMA的三种实现方式</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.nvidia.cn/networking/interconnect/">【英伟达官网】线缆和收发器</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=http%3A//www.rhopto.com/articles/dacgsx.html">DAC高速线缆和AOC有源光缆有什么区别呢？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.etulink.com/blog/-_b268">你会区分光模块和光纤收发器吗？</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/139294038">都是光电转换作用，光模块和光纤收发器有什么区别？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//baijiahao.baidu.com/s%3Fid%3D1760941961023057651%26wfr%3Dspider%26for%3Dpc">态路小课堂丨关于InfiniBand网络相关内容简介！</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.51cto.com/u_14408894/8031135">态路小课堂丨InfiniBandAOC有源光缆简介</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1NTA0MDUyMA%3D%3D%26mid%3D2456692454%26idx%3D1%26sn%3D031a11b931edee5504b15045cd863d37%26chksm%3Dfda68b81cad10297e4dd53bc97f63e0c47c26a27cdbb3c584cce6fc49fc6b4367b1531cbfcb6%26scene%3D0%26xtrack%3D1%23rd">InfiniBand，到底是个啥？</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/networking/display/mlnxofedv583070101/introduction">NVIDIAMLNX_OFED Documentation v5.8-3.0.7.0.101 for DGX H100Systems</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/deeplearning/nccl/user-guide/docs/env.html">NCCL环境变量</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/653001915">大模型训练场景下NCCL环境变量设置</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//github.com/FelixFu520/README/blob/main/envs/pytorch/cuda_gpu.md">【GitHub】CUDA_GPU详细介绍</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/e40059d5c832">GPU卡的底层通信原理</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.nvidia.cn/networking/infiniband-adapters/">NVIDIAConnectX InfiniBand 网卡</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//www.h3c.com/cn/d_202007/1317229_30005_0.htm%23_Toc46935211">H3CIB网卡常用命令</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_42319496/article/details/125942763">IB常用命令</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/591403">浅析GPU通信技术（上）-GPUDirectP2P</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/603617">浅析GPU通信技术（下）-GPUDirectRDMA</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//docs.nvidia.com/cuda/gpudirect-rdma/index.html">GPUDirectRDMA 12.3 文档</a></strong></li><li><strong><ahref="https://zhuanlan.zhihu.com/p/622853211">【大模型训练】RDMA高速网络与集合通讯</a></strong></li><li><strong><ahref="https://link.zhihu.com/?target=https%3A//cloud.baidu.com/doc/GPU/s/Yl3mr0ren">百度智能云-NCCL环境搭建</a></strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>throughput</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/throughput/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/throughput/</url>
      
        <content type="html"><![CDATA[<h1 id="throughput">throughput</h1><p>哟哟哟！！看图了。大模型性能比较指标中，到处都是throughput！到处都是！！！</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061752165.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>真的是到处都是呢！！</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061752217.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><hr /><p>​ <ahref="https://www.zhihu.com/search?q=神经网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">神经网络</a>的吞吐量（Throughput）定义为网络模型在<strong>单位时间内</strong>（例如，1s）<strong>可以处理的最大输入的训练样本数据</strong>。</p><p>​ 与涉及单个样本数据处理的延迟 Latency 不同，为了实现最大吞吐量Throughput，希望在集群训练的过程中并行处理尽可能多的样本数据。有效的并行性显然依赖于数据、模型和设备规模。</p><p>​ 因此，为了正确测量吞吐量，可以执行以下两个步骤：</p><ol type="1"><li>估计允许最大<ahref="https://www.zhihu.com/search?q=并行度&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">并行度</a>的最佳训练样本数据批量大小，即Batch Size</li><li>在AI训练集群中给定这个最佳批量大小，<ahref="https://www.zhihu.com/search?q=测量网络&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">测量网络</a>在1秒钟内可以处理的训练样本数据。</li></ol><p>​ 要找到最佳批量大小，一个好的经验法则是达到 Ascend <ahref="https://www.zhihu.com/search?q=昇腾处理器&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">昇腾处理器</a>对给定数据类型的内存限制，即BatchSize塞满内存。这个大小当然取决于硬件类型和网络的大小。</p><p>​ 找到这个最大批量大小 Batch Size的最快方法是执行二进制搜索。当时间不重要时，简单的<ahref="https://www.zhihu.com/search?q=顺序搜索&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">顺序搜索</a>就足够了。不过在大模型训练的过程中，因为BatchSize比较重要，设计到重计算、Pipeline并行、Tensor并行等不同并行模式的配比，还有包括microBatch Size的数据配比。因此默认Batch Size会为16的倍数增长比较合理。</p><p>​ 这确定了 AI加速卡上可以处理的最大批量大小，用于训练大模型及其处理的输入训练样本数据。在找到最佳批量大小后，可以计算实际吞吐量，然后使用以下公式：<span class="math display">\[sample_{throughput}=BS*N/step_{time}\]</span> 其中，BS 为 Batch Size，N 为集群中AI加速卡的数量，steptime为在分布式集群中，执行完一个BatchSize的时间（单位为s）。大模型训练的<ahref="https://www.zhihu.com/search?q=吞吐率&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">吞吐率</a>的单位在CV和部分NLP任务重为Samples/s，在固定 Shape 的 NLP任务有seqlen，因此单位为tokens/s，计算公式为： <span class="math display">\[tokens_{throughout}=sample_{throughput}*seq_{len}\]</span> ​ 假设GLM10B<ahref="https://www.zhihu.com/search?q=网络模型&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2989554131%7D">网络模型</a>的吞吐为25Samples/s，max seq_len 为1024，那么按照tokens来计算吞吐率为 25 * 1024 =25600 tokens/s。也就是每秒能处理2万多个tokens啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵乘法复杂度分析</title>
      <link href="/2024/04/06/%5Bobject%20Object%5D/AI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2024/04/06/%5Bobject%20Object%5D/AI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p># 矩阵乘法复杂度分析</p><h2 id="前言">前言</h2><p><strong>矩阵乘法</strong>：<strong>矩阵乘法（英语：matrixmultiplication）</strong>是一种根据两个矩阵得到<strong>第三个矩阵</strong>的<strong>二元运算</strong>（需要2个对象参与，这里指2个矩阵），第三个矩阵即前两者的乘积，称为<strong>矩阵积</strong></p><p><strong>条件：</strong>它只有在第一个矩阵的<strong>列数（column）</strong>和第二个矩阵的<strong>行数（row）</strong>相同时才有意义</p><h2 id="矩阵乘法">矩阵乘法</h2><h3 id="个矩阵相乘">2个矩阵相乘</h3><p>对于矩阵 <span class="math inline">\(A_{a*b}\)</span>、<spanclass="math inline">\(B_{b*c}\)</span>，那么 <spanclass="math inline">\(A*B\)</span> 的复杂度为 <spanclass="math inline">\(O(a*b*c)\)</span>，准确是 <spanclass="math inline">\(2abc\)</span></p><ul><li>加法计算了 <span class="math inline">\(abc\)</span> 次</li><li>乘法计算了 <span class="math inline">\(abc\)</span> 次</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)         <span class="comment">// A矩阵中的n 行</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)     <span class="comment">// B矩阵中的n  列</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; m; k++) <span class="comment">// A矩阵中的m 或者B矩阵中的m ,一样的</span></span><br><span class="line">            C[i][j] = C[i][j] + A[i][k] * B[k][j];</span><br></pre></td></tr></table></figure><h3 id="个矩阵相乘-1">3个矩阵相乘</h3><p>对于矩阵 <span class="math inline">\(A_{a*b}\)</span>、<spanclass="math inline">\(B_{b*c}\)</span>、<spanclass="math inline">\(C_{c*d}\)</span>，那么 <spanclass="math inline">\(A*B*C\)</span> 的复杂度为 <spanclass="math inline">\(O(abc + acd)\)</span></p><ul><li><span class="math inline">\(A*B\)</span> 的复杂度为 <spanclass="math inline">\(O(a*b*c)\)</span>，得到 <spanclass="math inline">\(a*c\)</span> 的矩阵</li><li><span class="math inline">\((A*B)_{a*c}*C\)</span> 的复杂度为 <spanclass="math inline">\(O(abc + acd)\)</span></li></ul><h3 id="推广">推广</h3><p>对于矩阵 <spanclass="math inline">\({A_1}_{_{a_1*a_2}}\)</span>、<spanclass="math inline">\({A_2}_{_{a_2*a_3}}\)</span>、… 、<spanclass="math inline">\({A_n}_{_{a_n*a_{n+1}}}\)</span>，那么 <spanclass="math inline">\(A*B*C\)</span> 的复杂度为 $a_1*(a_2a_3+a_3a_4++a_na_{n+1} ) $</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/31/%5Bobject%20Object%5D/%E6%89%93%E5%8D%B0/"/>
      <url>/2024/03/31/%5Bobject%20Object%5D/%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssize_t&amp;&amp;size_t</title>
      <link href="/2024/03/30/%5Bobject%20Object%5D/C++/ssize_t&amp;&amp;size_t/"/>
      <url>/2024/03/30/%5Bobject%20Object%5D/C++/ssize_t&amp;&amp;size_t/</url>
      
        <content type="html"><![CDATA[<h2 id="size_t">size_t</h2><p>​ <strong><code>size_t</code></strong> 是一些C/C++标准在<code>stddef.h</code> 中定义的，<code>size_t</code> 类型表示 C中任何对象所能达到的最大长度，它是无符号整数。</p><p>​ 它是为了方便系统之间的移植而定义的，不同的系统上，定义<code>size_t</code> 可能不一样。<code>size_t</code> 在 32 位系统上定义为<code>unsigned int</code>，也就是 32 位无符号整型。在64位系统上定义为<code>unsigned long</code> ，也就是 64 位无符号整形。<code>size_t</code>的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。</p><p>​ <code>size_t</code>在数组下标和内存管理函数之类的地方广泛使用。例如，<code>size_t</code>用做 <code>sizeof</code>操作符的返回值类型，同时也是很多函数的参数类型，包括 <code>malloc</code>和 <code>strlen</code>。</p><p>​ 在声明诸如字符数或者数组索引这样的长度变量时用 <code>size_t</code>是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。<code>size_t</code>的声明是实现相关的。它出现在一个或多个标准头文件中，比如<code>stdio.h</code> 和 <code>stblib.h</code>，典型的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZE_T</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><p>​ <code>define</code>指令确保它只被定义一次。实际的长度取决于实现。通常在 32位系统上它的长度是 32 位，而在 64 位系统上则是 64位。一般来说，<code>size_t</code> 可能的最大值是<code>SIZE_MAX</code></p><p>​ 打印 <code>size_t</code>类型的值时要小心。这是无符号值，如果选错格式说明符，可能会得到不可靠的结果。推荐的格式说明符是<code>%zu</code>。不过，某些情况下不能用这个说明符， 作为替代，可以考虑<code>%u</code> 或 <code>%lu</code>。下面这个例子将一个变量定义为<code>size_t</code>，然后用两种不同的格式说明符来打印：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sizet = <span class="number">-5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet);</span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code>本来是用于表示正整数的，如果用来表示负数就会出问题。如果为其赋一个负数，然后用<code>%d</code> 和 <code>%zu</code> 格式说明符打印，就得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-5</span><br><span class="line">4294967291</span><br></pre></td></tr></table></figure><p>​ <code>%d</code> 把 <code>size_t</code> 当做有符号整数，它打印出-5。因为变量中存放的就是 -5。<code>%zu</code> 把 <code>size_t</code>当做无符号整数。当 -5 被解析为有符号数时，高位置为1，表示这个数是负数。当它被解析为无符号数时，高位的 1 被当做 2的乘幂。所以在用 <code>%zu</code> 格式说明符时才会看到那个大整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizet = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet); <span class="comment">// 显示5</span></span><br></pre></td></tr></table></figure><p>​ 因为 <code>size_t</code> 是无符号的，一定要给这种类型的变量赋正数。</p><h2 id="ssize_t">ssize_t</h2><p><strong><code>ssize_t</code></strong> 和 <code>size_t</code>类似，但必需是<strong>signed</strong>（表示 <code>signed size_t</code>类型）， 用来表示可以被执行读写操作的数据块的大小。</p><h2 id="size_t-和-int-比较">size_t 和 int 比较</h2><ul><li><code>size_t</code>在32位架构中定义为：<code>typedef  unsigned int size_t</code></li><li><code>size_t</code>在64位架构中被定义为：<code>typedef  unsigned long size_t</code></li><li><code>size_t</code> 是无符号的，并且是平台无关的，表示 0 ~MAXINT的范围；<code>int</code> 为是有符号的；</li><li><code>int</code> 在不同架构上都是4字节，<code>size_t</code>在32位和64位架构上分别是 4 字节和 8字节，在不同架构上进行编译时需要注意这个问题。</li><li><strong><code>ssize_t</code></strong>是<strong>有符号</strong>整型，在32 位机器上等同与 <code>int</code>，在 64 位机器上等同与<code>long int</code>.</li></ul><h2id="c语言编程需要注意的64位和32机器的区别">C语言编程需要注意的64位和32机器的区别</h2><table><thead><tr class="header"><th></th><th>char</th><th>short</th><th>int</th><th>long</th><th>long long</th><th>指针</th></tr></thead><tbody><tr class="odd"><td>16 位 平台</td><td>1Byte</td><td>2Byte</td><td>2Byte</td><td>4Byte</td><td></td><td>2 Byte</td></tr><tr class="even"><td>32 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>4Byte</td><td>8Byte</td><td>4 Byte</td></tr><tr class="odd"><td>64 位 平台</td><td>1Byte</td><td>2Byte</td><td>4Byte</td><td>8Byte</td><td>8Byte</td><td>8Byte</td></tr></tbody></table><h2 id="编程注意事项">编程注意事项</h2><p>​ 为了保证平台的通用性，程序中尽量不要使用 <code>long</code>数据库型。可以使用固定大小的数据类型宏定义，这些宏定义需要引用<code>stdint.h</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> <span class="type">int8_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    __extension__</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="intptr_t">intptr_t</h2><p>​ 使用 <code>int</code> 时也可以使用 <code>intptr_t</code>来保证平台的通用性，它在不同的平台上编译时长度不同，但都是标准的平台字长，比如64 位机器它的长度就是 8 字节，32位机器它的长度是4字节，使用它可以安全地进行整数与指针的转换运算，也就是说当需要将指针作为整数运算时，将它转换成<code>intptr_t</code> 进行运算才是安全的。<code>intptr_t</code>需要引用<code>stddef.h</code> 头文件，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​ 编程中要尽量使用 <code>sizeof</code>来计算数据类型的大小。以上类型定义都有相应的无符号类型。</p><h2 id="使用ssize_t和size_t">使用ssize_t和size_t</h2><p>​ 它们分别是 <code>unsigned</code> 和 <code>signed</code> size ofcomputer word size。它们也是表示<strong>计算机的字长</strong>，在 32位机器上是 <code>int</code>型，在64位机器上 <code>long</code>型。使用它们对于增加平台的通用性有很大好处，从某种意义上来说它们等同于<code>intptr_t</code> 和 <code>uintptr_t</code>。使用它们也需要引用<code>stddef.h</code> 头文件。</p><p>​ socket 的 <code>accept</code> 函数在有些操作系统上使用<code>size_t</code> 是不正确的，因为 <code>accept</code> 接收的<code>int</code> 类型，而size_t的长度可能会超过 <code>int*</code>的长度限制，导致错误。后来BSD使用 <code>sock_t</code> 来替代它。</p><blockquote><p>参考：</p><ul><li>https://blog.csdn.net/bzhxuexi/article/details/19899803</li><li>https://blog.csdn.net/qq_30866297/article/details/51465473</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数组模拟数据结构】</title>
      <link href="/2024/03/29/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/"/>
      <url>/2024/03/29/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/</url>
      
        <content type="html"><![CDATA[<ul><li>以下<strong>数据结构</strong>都是采用<strong>数组</strong>模拟实现（而非 C++ STL容器），效率更高、支持更多操作</li></ul><h1 id="链表">链表</h1><h2 id="单向链表">单(向)链表</h2><ul><li><font color='red'><strong>空指针用 -1 表示</strong></font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7966770/">AcWing826. 单链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数 x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 x 插到下标是 k 的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是 k 的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="双向链表">双(向)链表</h2><ul><li>双链表实现中：0 号节点表示头节点，1 号节点表示尾节点</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7968200/">AcWing827. 双链表 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// l[i] 表示节点i的左指针</span></span><br><span class="line"><span class="comment">// r[i] 表示节点i的右指针是多少</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在节点 k 的右边插入一个数 x */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在节点 k 的左边插入一个数 x，则调用insert(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除节点 k */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈">栈</h1><h2 id="模板">模板</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7970372/">AcWing828. 模拟栈 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶元素下标</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt;= 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8210610/">AcWing3302. 表达式求值 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/decode-string/">394.字符串解码 - 力扣（LeetCode）</a></p></li></ul><h1 id="队列">队列</h1><h2 id="普通队列">普通队列</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7971050/">AcWing829. 模拟队列 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列">循环队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈">单调栈</h1><h2 id="模板-1">模板</h2><ul><li>找出每个数左边离它最近的比它<strong>小</strong>的数——维护递<strong>增</strong>栈</li><li>找出每个数左边离它最近的比它<strong>大</strong>的数——维护递<strong>减</strong>栈</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i))</span><br><span class="line">        tt--;</span><br><span class="line">    stk[++tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7971357/">AcWing830. 单调栈 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/daily-temperatures/description/">739.每日温度 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/min-stack/description/">155. 最小栈 -力扣（LeetCode）</a></p></li></ul><h1 id="单调队列">单调队列</h1><h2 id="模板-2">模板</h2><p>常见模型：找出<strong>滑动窗口</strong>中的<strong>最大值/最小值</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181602001.png"alt="image-20240307130347476" /><figcaption aria-hidden="true">image-20240307130347476</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) <span class="comment">// 维持单调队列</span></span><br><span class="line">        tt--;</span><br><span class="line">    q[++tt] = i;                         <span class="comment">// 将数据加入队尾</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">        hh++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color ='red'><strong>单调栈/单调队列总结</strong></font></p><ul><li>先考虑用普通 栈/队列 暴力模拟</li><li>再将普通 栈/队列中没有用的元素删除，看一下<strong>剩下的元素是否有单调性</strong>——单调栈/单调队列</li><li>考虑优化（队头最小/队尾最大/二分查找…）</li></ul><h2 id="例题-2">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7971364/">AcWing154. 滑动窗口 - AcWing</a></li></ul><h1 id="kmp">KMP</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849900.png"alt="image-20240307143945027" /><figcaption aria-hidden="true">image-20240307143945027</figcaption></figure><ol type="1"><li>若匹配成功，返回<strong>模式串T</strong>在<strong>目标串S</strong>中<strong><font color='red'>首次出现的有效位移</font></strong></li><li>若匹配失败，返回1</li></ol><!--more--><p>注意：</p><ul><li>主串 <code>S[]</code> 、模式串 <code>P[]</code>、<code>next[]</code> 均从下标 1 开始存储</li><li>每次 <code>S[i]</code> 与 <code>P[j + 1]</code> 比较<ul><li>当 <code>S[i] == P[j + 1]</code> 时，<code>i++, j++;</code></li><li>当 <code>S[i] != P[j + 1]</code> 时，<code>j = next[j];</code></li></ul></li><li><code>i</code>一直往前走，不会后退</li><li><code>j</code> 在 <code>S[i]</code> 与 <code>P[j + 1]</code>不匹配时会向后退，退到 <code>next[j]</code> 处</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849828.png"alt="a8e37396968a427a0efaffde2c68e78" /><figcaptionaria-hidden="true">a8e37396968a427a0efaffde2c68e78</figcaption></figure><ul><li><code>next[i]</code> 表示 <code>P[1…i]</code>最大前缀与后缀相等的长度（一定小于<code>i</code>，不能自己与自己相等~）</li><li><code>next[]</code>是通过模板串<strong>自己与自己匹配</strong>操作得出来的（代码和匹配操作几乎一样）<ul><li>next[0]=next[1]=0</li><li>由于是从 <code>i =2</code> 开始求<code>next[]</code>，所以：<ul><li>不可能匹配成功（不需要<code>j == m</code>的判断）</li><li><code>j &lt; i</code>，回退时 <code>next[j]</code> 一定存在</li></ul></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291849565.jpeg"alt="3ff244326727713da33759bd2784289" /><figcaptionaria-hidden="true">3ff244326727713da33759bd2784289</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7973749/">AcWing831. KMP字符串 - AcWing</a>】</li><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(n)\)</span>，<spanclass="math inline">\(n\)</span> 为长文本主串的长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本</span></span><br><span class="line"><span class="comment">// p[]是模式串</span></span><br><span class="line"><span class="comment">// n 是 s 的长度</span></span><br><span class="line"><span class="comment">// m 是 p 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求模式串的Next数组：*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到0处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 此时 j 的长度即为 next[i] 最大前缀与后缀相等的长度</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配过程 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  匹配失败，j 往后退，直到 s[i] == p[j + 1]或 j 退到0处（无路可退）</span></span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        j = ne[j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 j 移动到下一次比较的位置</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">/* 匹配成功后的逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><h1 id="trie树">Trie树</h1><h2 id="模板-3">模板</h2><p>​<strong>Trie</strong>：高效地<strong>存储</strong>和<strong>查找</strong>字符串/二进制数 集合的数据结构</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403071732565.png"alt="image-20240307173227428" /><figcaption aria-hidden="true">image-20240307173227428</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点下标</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx表示当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入一个字符串 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            son[p][u] = ++idx;<span class="comment">// 不能是 idx++，因为son[0][]存放的是根节点，从下标 1 开始存储</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询字符串出现的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-3">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7975276/">AcWing835. Trie字符串统计 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8217089/">AcWing143. 最大异或对 - AcWing</a></li></ul><h1 id="并查集">并查集</h1><h2 id="模板-4">模板</h2><p><strong>作用</strong></p><ol type="1"><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><p><strong>基本原理：</strong></p><p>​每个集合用一棵树来表示。<strong>树根</strong>的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code>表示 <code>x</code> 的父节点</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081538288.png"alt="image-20240308153805104" /><figcaption aria-hidden="true">image-20240308153805104</figcaption></figure><h3 id="朴素并查集">朴素并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集是可以用来维护很多额外信息的，如集合大小cnt，到祖宗节点距离 d等等</p></blockquote><h3 id="维护-cnt-的并查集">维护 cnt 的并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// cnt[]只对祖宗节点有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    cnt[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护到祖宗节点距离-d-的并查集">维护到祖宗节点距离 d的并查集</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403181631186.jpeg"alt="JIE.jpg" /><figcaption aria-hidden="true">JIE.jpg</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p[]存储每个点的父节点</span></span><br><span class="line"><span class="comment">// d[x]存储 x 到 p[x] 的距离</span></span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径优化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];<span class="comment">// d[x]存储 x 到 p[x] 的距离，</span></span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 x 是否为祖宗节点</span></span><br><span class="line"><span class="keyword">if</span> (p[x] == x)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-4">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7986586/">AcWing836. 合并集合 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7986712/">AcWing837. 连通块中点的数量 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7987057/">AcWing240. 食物链 - AcWing</a></li></ul><h1 id="堆">堆</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036286.png"alt="image-20230916123313335" /><figcaption aria-hidden="true">image-20230916123313335</figcaption></figure><p><strong>堆的特性：</strong></p><ul><li>结构性：==采用<strong><font color='blue'>数组存储</font></strong>的<strong><font color='red'>完全二叉树</font></strong>==<ul><li>从<font color='red'><code>h[1]</code>开始存储数据</font>，<code>h[0]</code>用来存放==<strong>哨兵</strong>==</li><li><code>i</code> 的左儿子 <code>2 * i</code>，右儿子<code>2 * i + 1</code></li></ul></li><li>有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)<ul><li>“<strong>最大堆(MaxHeap)</strong>”，也称“<strong>大顶堆</strong>”：任一结点的<code>data</code>大于其所有子树结点的<code>data</code></li><li>“<strong>最小堆(MinHeap)</strong>”，也称“<strong>小顶堆</strong>”：任一结点的<code>data</code>小于其所有子树结点的<code>data</code></li></ul></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036053.png"alt="image-20230916123453824" /><figcaption aria-hidden="true">image-20230916123453824</figcaption></figure><p><strong>堆的实现：</strong></p><ul><li><p>使用数组来模拟堆，堆中的数据从 <code>h[1]</code> 开始存储</p><blockquote><p>因为如果从0开始存储，根节点0按照公式计算得到的左右节点都是0，显然不成了，需要特判，麻烦</p></blockquote></li><li><p>所有关于堆的操作均建立在堆的 <code>down()</code> 和<code>up()</code> 函数基础上</p></li></ul><h2 id="模板1">模板1</h2><p>​ 如果只希望实现与C++ STL堆中相同的功能1、2、3，则堆的下滤和上滤操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>down() 注意：</p><ol type="1"><li>down 操作需要保证左右儿子是堆</li><li>t 是根节点 <code>h[u]</code>, 左儿子 <code>h[2 * u]</code>, 右儿子<code>h[2 * u + 1]</code>中最小值的下标</li><li><code>2 * u &lt;= cnt</code>说明存在左儿子，<code>2 * u + 1 &lt;= cnt</code> 说明存在右儿子</li></ol><p>up() 注意：</p><ol type="1"><li><code>u / 2 != 0</code> 说明存在父节点</li></ol></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[++cnt]=x;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>] = h[cnt--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="模板2">模板2</h2><p>​ 如果希望实现在 C++ STL堆中功能的基础上，添加在任意位置修改/删除的功能，需要存储映射：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036897.png" alt="image-20240308101556244" style="zoom:15%;" /></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091036983.jpeg" alt="b9b669b4a3a28e34e104b0c5bda7d7c" style="zoom:13%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的下标p:pointer</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的h:heap</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="comment">// m是当前堆中插入操作的次数</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换 h[] 中的两个点，及其映射关系 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>p:pointer</li><li>h:heap</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt++, m++;</span><br><span class="line">h[cnt] = x, hp[cnt] = m, ph[m] = cnt;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt--);</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除第 k 个插入的数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line"><span class="built_in">heap_swap</span>(k, cnt--);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改第 k 个插入的数,将其变为 x</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br></pre></td></tr></table></figure><blockquote><p>修改后的值与原来值相比，有3种情况</p><ul><li>相等：不需要调整堆</li><li>小于：up(k)</li><li>大于：down(k)</li></ul><p>把上面 3 种情况综合考虑，不管是相等/大于/小于，为了简单起见:</p><ul><li>如果修改h[1]：down(1)</li><li>在最后插入数据：up(++size)</li><li>如果修改其他： up(k); down(k)</li></ul><p>【实际运行时要么都不执行，要么只 up(k) ，要么只 down(k) 】</p></blockquote><ol start="6" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="例题-5">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7979479/">AcWing838. 堆排序 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7983190/">AcWing839. 模拟堆 - AcWing</a></li></ul><h1 id="哈希表">哈希表</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081905012.png" alt="image-20240308190529753" style="zoom: 25%;" /></p><ul><li>离散化是一种<strong>极其特殊</strong>的哈希方式（数据有序排列）</li><li>在算法题中，通常在哈希表 查找/添加 元素，而不会 删除 元素</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081918152.png"alt="image-20240308191829923" /><figcaption aria-hidden="true">image-20240308191829923</figcaption></figure><h2 id="一般哈希">一般哈希</h2><h3 id="拉链法">拉链法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x,ne[idx] = h[k],h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这里的 N 通常取质数eg：100003</li></ul></blockquote><h3 id="开放寻址法">开放寻址法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span> (t == N)</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希">字符串哈希</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403082108366.png" alt="image-20240308210833057" style="zoom: 50%;" /></p><ul><li><strong>核心思想</strong>：将字符串（注意不能把某个字符映射成0）看成 P 进制数， P 的经验值是 131 或13331，取这两个值的冲突概率低</li><li><strong>小技巧</strong>：取模的数Q用 <spanclass="math inline">\(2^{64}\)</span>​，这样直接用<code>unsigned long long</code>存储，溢出的结果就是取模的结果</li><li><strong>注意</strong>：字符串哈希非常有用的利器，是KMP的劲敌，字符串哈希除了循环节不能处理，其他均可代替KMP</li><li><code>str[]</code> 从下标 1 开始存储</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">// h[k]存储字符串前k个字母 str[1 ~ k] 的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 h[ ], p[ ]</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结</p><ol type="1"><li>把字符串看成是一个 P 进制数，每个字符的 ASCII 码对应数的一位</li><li>ASCII 范围 0 - 127，最少 128 进制，经验上取 131 或 13331冲突率低</li><li>字符串很长，对应的数太大，通过模 <spanclass="math inline">\(2^{64}\)</span> 把它映射到 <spanclass="math inline">\([0, 2^{64} - 1]\)</span></li><li>用 <code>unsigned long long</code> 存储，溢出相当于对 <spanclass="math inline">\(2^{64}\)</span> 取模，省略了手动运算</li><li>该方法的好处是，可以利用前缀哈希直接求出子串哈希（减去高位）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(DEF) = <span class="built_in">hash</span>(ABCDEF) - <span class="built_in">hash</span>(ABC) x P^<span class="number">3</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span>       <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">    A       B       C       D       E       F  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">5</span> + <span class="number">2</span>xP^<span class="number">4</span> + <span class="number">3</span>xP^<span class="number">3</span> + <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">                            D       E       F</span><br><span class="line">                          <span class="number">4</span>xP^<span class="number">2</span> + <span class="number">5</span>xP^<span class="number">1</span> + <span class="number">6</span>xP^<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    A       B       C  </span><br><span class="line">  <span class="number">1</span>xP^<span class="number">2</span> + <span class="number">2</span>xP^<span class="number">1</span> + <span class="number">3</span>xP^<span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意点</p><ol type="1"><li><strong>不要把某一位映射成 P 进制 0</strong>，例如，A 如果是 0，则AA 也是 0，就会出现冲突</li><li><code>\0</code> 的 ASCII 是 0，本题不出现该字符，不用担心上一点</li><li>使用这种方法就假定了人品足够好，不出现冲突</li></ol><h2 id="例题-6">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7988981/">AcWing840. 模拟散列表 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7992616/">AcWing841. 字符串哈希 - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】</title>
      <link href="/2024/03/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/"/>
      <url>/2024/03/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><h2 id="概念了解">概念【了解】</h2><ol type="1"><li><p><strong>动态规划：</strong>将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解</p><ul><li>动态规划会将每个求解过的子问题的解记录下来，这样下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算</li><li>采用<strong>递归</strong>（又叫<strong>记忆化搜索</strong>）实现</li></ul></li><li><p><strong>重叠子问题：</strong>如果<strong>一个问题可以被分解成若干个子问题</strong>，且这些子问题会重复出现，就称这个问题拥有重叠子问题。一个问题必须拥有重叠子问题，才能用动态规划去解决。</p></li><li><p><strong>最优子结构：</strong>如果<strong>一个问题的最优解可以由其子问题的最优解有效地构造出来</strong>，那么称为这个问题拥有的最优子结构。最优子结构保证了动态规划中的原问题的最优解可以由子问题的最优解推导而来</p></li><li><p><strong>动态规划</strong> vs<strong>分治：</strong>都是分解为子问题然后合并子问题得到解，但是：</p><ul><li>动态规划分解出的子问题是重叠的</li><li>分治分解出的子问题是不重叠的</li></ul></li><li><p><strong>动态规划 vs 贪心：</strong>都有最优子结构，但是：</p><ul><li>贪心直接选择一个子问题去求解，会抛弃一些子问题，这种选择的正确性需要用归纳法证明</li><li>而动态规划会考虑所有的子问题，所以这种选择一定是正确的</li></ul></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201846385.png"alt="Snipaste_2019-09-13_17-06-58.png" /><figcaptionaria-hidden="true">Snipaste_2019-09-13_17-06-58.png</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403231407219.jpeg"alt="闫式dp.jpg" /><figcaption aria-hidden="true">闫式dp.jpg</figcaption></figure><ol type="1"><li>集合划分原则</li></ol><ul><li><p>不重不漏【不漏一定要满足，不重不一定都要满足(一般求个数时要满足)】</p></li><li><p>如何将现有的集合划分为更小的子集，使得<strong>所有子集</strong>都可以计算出来</p></li></ul><ol start="2" type="1"><li>下标从 0 开始递归还是下标从 1开始递归？</li></ol><ul><li>如果涉及到 <code>f[i-1]</code>，建议下标从 1开始递归，<code>f[0]</code>存储初始值</li><li>否则下标从 0 开始递归</li></ul><ol start="3" type="1"><li>考虑状态函数初始化</li></ol><ul><li>你看看在for遍历的时候需要用到的但是你事先没有的（往往就是下标0）就要预处理</li><li>如果要找min的话别忘了INF，要找有负数的max的话别忘了-INF</li></ul><h2 id="背包问题">背包问题</h2><ul><li>0/1 背包：每种物品只有 1 个</li><li>完全背包：每种物品有无限个</li><li>多重背包：每种物品有 <span class="math inline">\(S_i\)</span>个</li><li>分组背包：有 N 组物品，每一组中有 若干个 物品</li></ul><p>标记</p><ul><li>N：物品种数</li><li>V：背包容量</li><li>S：物品数量</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081245014.png"alt="image-20240308124413525" /><figcaption aria-hidden="true">image-20240308124413525</figcaption></figure><span id="more"></span><h3 id="背包">0/1 背包</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8133547/">AcWing2. 01背包问题 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&amp;envId=top-100-liked">279.完全平方数 - 力扣（LeetCode）</a></p></li></ul><h3 id="完全背包问题">完全背包问题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8134352/">AcWing3. 完全背包问题 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8229758/">AcWing4700. 何以包邮？ - AcWing</a></p></li></ul><h3 id="多重背包">多重背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8140913/">AcWing4. 多重背包问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8141818/">AcWing5. 多重背包问题 II - AcWing</a></li></ul><h3 id="分组背包">分组背包</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8144220/">AcWing9. 分组背包问题 - AcWing</a></li></ul><h3 id="找零钱">找零钱</h3><ul><li><a href="https://leetcode.cn/problems/coin-change/description/">322.零钱兑换 - 力扣（LeetCode）</a></li></ul><h2 id="线性dp">线性DP</h2><p>线性DP指的是<strong>状态转移方程</strong>存在某种线性关系</p><h3 id="数字三角形">数字三角形</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8147866/">AcWing898. 数字三角形 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/pascals-triangle/description/">118.杨辉三角 - 力扣（LeetCode）</a></p></li></ul><h3 id="编辑距离">编辑距离</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8161653/">AcWing902. 最短编辑距离 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8178931/">AcWing899. 编辑距离 - AcWing</a></li></ul><h3 id="最长上升子序列">最长上升子序列</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8155307/">AcWing895. 最长上升子序列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8159736/">AcWing896. 最长上升子序列 II - AcWing</a></p></li></ul><h3 id="最长公共子序列lcs">最长公共子序列（LCS）</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8155566/">AcWing897. 最长公共子序列 - AcWing</a></li></ul><blockquote><p><strong>最长公共字串</strong>问题——参考KMP</p></blockquote><h3 id="乘积最大子数组">乘积最大子数组</h3><ul><li><ahref="https://leetcode.cn/problems/maximum-product-subarray/description/">152.乘积最大子数组 - 力扣（LeetCode）</a></li></ul><h3 id="最大子列和">最大子列和</h3><h4 id="类型一">类型一</h4><p>​ 给定 <span class="math inline">\(N\)</span> 个整数的序列${A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ 0,_{k=i}^j{A_k} } $ 的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = 0;</code></p></blockquote><h4 id="类型二">类型二</h4><p>​ 给定 <span class="math inline">\(N\)</span> 个整数的序列${A_1,A_2,,A_N } $，求函数 $f( i,j ) ={ _{k=i}^j{A_k} } $ 的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> thissum = <span class="number">0</span>, maxsum = -MAX_INT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        thissum += A[i];      <span class="comment">/* 向右累加 */</span></span><br><span class="line">        <span class="keyword">if</span> (thissum &gt; maxsum) <span class="comment">/* 发现更大和则更新当前结果 */</span></span><br><span class="line">            maxsum = thissum;</span><br><span class="line">        <span class="comment">// maxsum = max(maxsum, thissum);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thissum &lt; <span class="number">0</span>)      <span class="comment">/* 如果当前子列和为负 */</span></span><br><span class="line">            thissum = <span class="number">0</span>;      <span class="comment">/* 则不可能使后面的部分和增大，抛弃之 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>maxsum的初值 <code>int maxsum = -MAX_INT;</code></p></blockquote><p>:package:一定是先更新<code>maxsum = max(maxsum, thissum);</code>，再判断是否重新<code>thissum = 0;</code></p><h3 id="其他">其他</h3><h2 id="区间dp">区间DP</h2><h3 id="模板">模板</h3><ul><li><p>区间 DP的状态<code>f[i][j]</code>是一个<strong>区间</strong></p></li><li><p>区间 DP要注意<strong>循环的先后顺序</strong>，否则可能会出现当前要计算的状态值并未在先前循环计算过，通常按照以下顺序进行循环</p><ol type="1"><li><strong>从小到大</strong>枚举<strong>区间长度</strong><ol type="1"><li>一般 len = 1 时用来初始化</li><li>枚举从 len = 2 开始</li></ol></li><li>枚举<strong>区间左端点</strong></li><li>枚举决策</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++) &#123;         <span class="comment">// 区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">// 枚举起点</span></span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">// 区间终点</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = 初始值</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">// 枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8157696/">AcWing282. 石子合并 - AcWing</a></li></ul><h2 id="计数dp">计数DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8179224/">AcWing900. 整数划分 - AcWing</a></li></ul><h2 id="数位统计dp">数位统计DP</h2><h2 id="状态压缩dp">状态压缩DP</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8182668/">AcWing291. 蒙德里安的梦想 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8228208/">AcWing91. 最短Hamilton路径 - AcWing</a></p></li></ul><h2 id="树形dp">树形DP</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8190672/">AcWing285. 没有上司的舞会 - AcWing</a></li></ul><h2 id="记忆化搜索">记忆化搜索</h2><ul><li><ahref="https://www.acwing.com/activity/content/problem/content/1013/">AcWing901. 滑雪 - AcWing</a></li></ul><h1 id="单维dp">单维DP</h1><h2 id="爬楼梯"><ahref="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h2><p>​ 假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬<code>1</code> 或 <code>2</code>个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h3 id="递归">递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>递归会超时</p></blockquote><h3 id="迭代">迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 方式1 */</span></span><br><span class="line">        <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/* 方式2 */</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; a(n + 1);</span></span><br><span class="line"></span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>以空间换时间</p><p>方式2 容器 更耗时</p></blockquote><h2 id="打家劫舍"><ahref="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2><p>​你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>​ 给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p><ahref="https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap">图解动态规划——打家劫舍</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/* n&gt;=2 */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], nums[i] + dp[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词拆分"><ahref="https://leetcode.cn/problems/word-break/">单词拆分</a></h2><p>​ 给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code>作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>则返回<code>true</code>。<strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>dp[i]：前 i 个字符s[0…i-1]能否被字典中的单词拼接</li><li><span class="math inline">\(dp[i]=dp[j] \&amp;\&amp;check(s[j…i-1])\)</span>​</li></ul><p><ahref="https://www.bilibili.com/video/BV1mt4y1s7H1/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】139. 单词拆分 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt; &amp;wordDict)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; <span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>(), s.<span class="built_in">substr</span>(j, i - j)) != wordDict.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="多维dp">多维DP</h1><h2 id="不同路径"><ahref="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><p>​ 一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 “Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish” ）。问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041400223.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><ul><li><strong>方式1：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>方式2：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>方式3：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最小路径和"><ahref="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h2><p>​ 给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code>，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时空复杂度分析</title>
      <link href="/2024/03/17/%5Bobject%20Object%5D/others/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2024/03/17/%5Bobject%20Object%5D/others/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="时间复杂度分析">时间复杂度分析</h1><ul><li><p><strong>C++ 1s 的运行数量大概在 <spanclass="math inline">\(1*10^7\)</span> ~ <spanclass="math inline">\(10*10^7 =10^8\)</span></strong>，所以运算量要控制在 <spanclass="math inline">\(10^8\)</span> 以内</p></li><li><p>一般ACM或者笔试题的<strong>时间限制</strong>是<strong>1秒</strong>或<strong>2秒</strong>，在这种情况下，C++代码中的操作次数控制在<span class="math inline">\(10^7\)</span>​~ <spanclass="math inline">\(10^8\)</span>​ 为最佳</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403302109655.png"alt="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress" /><figcaptionaria-hidden="true">aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83MTg2OTc1LWQwNWViNjdlNTU4ZmU0MjUucG5n_clear_compress</figcaption></figure><ul><li>【由<strong>数据范围</strong>反推<strong>算法复杂度</strong>以及<strong>算法内容</strong>】下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</li></ul><ol type="1"><li><span class="math inline">\(n \leqslant 30\)</span> =&gt;指数级别：dfs+剪枝、状态压缩 dp</li><li><span class="math inline">\(n \leqslant 10^2\)</span> =&gt; <spanclass="math inline">\(O(n^3)\)</span>：floyd、dp、高斯消元</li><li><span class="math inline">\(n \leqslant 10^3\)</span> =&gt; <spanclass="math inline">\(O(n^2)\)</span>、<spanclass="math inline">\(O(n^2logn)\)</span>：dp、二分、朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li><span class="math inline">\(n \leqslant 10^4\)</span> =&gt; <spanclass="math inline">\(O(n\sqrt{n})\)</span>：块状链表、分块、莫队</li><li><span class="math inline">\(n \leqslant 10^5\)</span> =&gt; <spanclass="math inline">\(O(nlogn)\)</span>：各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li><span class="math inline">\(n \leqslant 10^6\)</span>​<ol type="1"><li><span class="math inline">\(O(n)\)</span>​​：单调队列、hash、双指针扫描、BFS、并查集、kmp、AC自动机</li><li>常数比较小的 <span class="math inline">\(O(nlogn)\)</span>​算法：sort、树状数组、heap、dijkstra、spfa</li></ol></li><li><span class="math inline">\(n \leqslant 10^7\)</span>​ =&gt;O(n)：双指针扫描、kmp、AC自动机、线性筛素数</li><li><span class="math inline">\(n \leqslant 10^9\)</span>​ =&gt; <spanclass="math inline">\(O(\sqrt{n})\)</span>​：判断质数</li><li><span class="math inline">\(n \leqslant 10^{18}\)</span>​ =&gt; <spanclass="math inline">\(O(logn)\)</span>​：最大公约数、快速幂、数位DP</li><li><span class="math inline">\(n \leqslant 10^{1000}\)</span> =&gt;<span class="math inline">\(O((logn)^2)\)</span>：高精度加减乘除</li><li><span class="math inline">\(n \leqslant 10^{100000}\)</span> =&gt;<span class="math inline">\(O(logk *loglogk)\)</span>，k表示位数：高精度加减、FFT/NTT</li></ol><span id="more"></span><h1 id="空间复杂度">空间复杂度</h1><h2 id="单位换算">单位换算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> KB= <span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> MB=<span class="number">1024</span>*<span class="number">1024</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> Byte</span><br></pre></td></tr></table></figure><h2 id="数据类型空间大小">数据类型空间大小</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="number">4</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>, <span class="type">long</span> <span class="type">long</span>   <span class="number">6B</span>yte</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="number">1</span> Byte</span><br><span class="line"></span><br><span class="line">*指针 <span class="number">32</span>位系统 <span class="number">4B</span><span class="number">64</span>位系统 <span class="number">8B</span></span><br></pre></td></tr></table></figure><h2 id="空间分析">空间分析</h2><ul><li>一般 ACM或者笔试题的<strong>空间限制</strong>是<strong>64MB</strong>，最多只能使用<span class="math inline">\(1.6*10^7\)</span>个<code>int</code>类型变量</li></ul><p><span class="math display">\[64MB=2^{26}Byte=2^{24} int =1.6*10^7 int\]</span></p><ul><li>分析时要注意，计算全局<strong>变量</strong>的空间复杂度要看<strong>实际运行时会用到的空间</strong>，而不是总空间，因为全局变量在未被使用时分配的是<strong>虚拟内存</strong></li><li>当代码里有<strong>递归</strong>函数或需要<strong>大量调用函数</strong>时，需要调用系统栈，因此分析空间复杂度还要加上<strong>栈空间</strong><ul><li>快速排序：需要递归 <span class="math inline">\(log\ n\)</span>​层，因此空间复杂度是 <span class="math inline">\(O(log n)\)</span></li><li>归并排序：而归并排序在递归时每一层还需要开一个长度为 <spanclass="math inline">\(n\)</span> 的数组，因此空间复杂度是 <spanclass="math inline">\(O(nlog\ n)\)</span></li></ul></li></ul><h2 id="实例">实例</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261751495.png"alt="image-20240326175147312" /><figcaption aria-hidden="true">image-20240326175147312</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>咖啡</title>
      <link href="/2024/03/17/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/"/>
      <url>/2024/03/17/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/%E5%92%96%E5%95%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="有关咖啡">有关咖啡</h1><h2id="咖啡因每日的安全使用量是多少">咖啡因每日的安全使用量是多少？</h2><p>一杯咖啡 (大约150毫升) 中的咖啡因含量一般为:研磨咖啡约100毫克，速溶咖啡大约50-60毫克。每天适量摄取等同于4杯咖啡的咖啡因400-500毫克不会对人体健康有害。少量或适量的咖啡因（每天200-400毫克）摄入可提高人的敏捷度、注意力、记忆力，并有助于保持好心情。</p><span id="more"></span><h2id="雀巢咖啡伴侣是否含反式脂肪酸">雀巢咖啡伴侣是否含反式脂肪酸？</h2><p>在雀巢咖啡伴侣的包装上有明确的标识：反式脂肪酸为0克，所以您可以放心使用。</p><h2id="为什么咖啡伴侣的瓶子是棕色的">为什么咖啡伴侣的瓶子是棕色的？</h2><p>适量的咖啡因摄取对普通大多数的人都是安全的。可能会有一些人群对咖啡因较一般人敏感，与那些对咖啡因不太敏感的人相比，这类人群可能会对少量的咖啡感到不适。通常情况下，孕妇和老年人可能会相对更加敏感一些。</p><h2id="为什么咖啡伴侣的瓶子是棕色的-1">为什么咖啡伴侣的瓶子是棕色的？</h2><p>用棕色瓶子主要是为了避光，咖啡伴侣里某些营养成分是对光敏感的。我们为了在保质期内保证食品的安全和风味，采用了能避光的棕色玻璃瓶。</p><h2 id="喝咖啡对身体有害吗">喝咖啡对身体有害吗？</h2><p>咖啡是一种天然而且健康的饮料。咖啡中除含有咖啡因之外，它还含有对人体健康有利的多种生物活性物质和营养素，如抗氧化物质、矿物质、烟酸和内脂。咖啡能提高警觉性，让我们更有效地利用前额部的大脑皮层，提高注意力和记忆力。关于咖啡因，人们从古代的时候起就开始饮用咖啡类的饮品了。咖啡因是咖啡中的天然含有的成份。目前，人类在大约60种植物中发现了咖啡因，其中最为人知的便是茶和咖啡。而一些常见的食品，如巧克力、可乐中都含有少量咖啡因。</p><h2id="经常喝咖啡是否会导致人体内的钙流失">经常喝咖啡是否会导致人体内的钙流失?</h2><p>咖啡因对钙吸收的不良影响非常小，喝1-2勺牛奶就足以弥补了。所有证据显示，中量饮用咖啡不会改变对钙的消化吸收，不会增加尿钙排泄，也不会从大便中丢失。如果每日摄入咖啡超过1升，尿钙排泄和钙丢失就会增加，但将牛奶加到咖啡里面就可以解决这个问题。适量咖啡因摄入不会对骨代谢产生直接影响。（摘自《咖啡无罪的101个理由》）</p><h2 id="喝咖啡可以减肥吗">喝咖啡可以减肥吗？</h2><p>研究表明，适量喝咖啡有助于控制体重，咖啡中含有膳食纤维，有利于帮助肠道蠕动，促进代谢。如果您想要达到减肥的效果，我们建议您咨询专业的营养师。</p><h2 id="雀巢咖啡是如何诞生的">雀巢咖啡是如何诞生的？</h2><p>二十世纪三十年代，雀巢公司受巴西政府的委托，为其过剩的咖啡寻找保存方法。雀巢公司勇敢地接受了这一技术上的挑战，并于1938年成功开发出速溶咖啡生产工艺。采用该工艺，咖啡粉可以长久地保存而不失其香醇风味。从此，人们可以随时方便地享用美味咖啡。雀巢速溶咖啡便由此诞生了，雀巢咖啡(Nescafe)品牌名称就是由公司名称Nestlé及英文中代表咖啡的CAFE组成。</p><h2 id="咖啡中的12是什么意思">1+2咖啡中的1+2是什么意思？</h2><p>1+2咖啡中的1+2是指：1=咖啡，2=植脂末+糖</p><h2 id="每天在什么时间喝咖啡比较好">每天在什么时间喝咖啡比较好？</h2><p>建议白天饮用咖啡。如果想保持规律的生理周期，晚上不要饮用咖啡。</p><h2id="雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏">雀巢丝滑拿铁和丝滑摩卡即饮咖啡产品是否可以加热或冷藏？</h2><p>即饮咖啡产品冷热饮均可，如加热饮用，加热温度不宜超过55度，勿将瓶装产品放置于火上或微波炉中直接加热，以免发生危险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学知识】</title>
      <link href="/2024/03/15/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/"/>
      <url>/2024/03/15/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="数学知识">数学知识</h1><p>:smile:<strong>数论</strong> 经常会出现 <strong>数的大小越界</strong>情况：</p><ul><li>尤其是在做<strong>乘法</strong>、其次是<strong>加法</strong>的时候非常容易溢出，此时可以使用<code>long long</code> 局部转换</li><li>比较稳妥的、一劳永逸的办法是<strong>变量类型</strong>不使用int，<strong>全部使用</strong> <code>long long</code></li><li>数论部分的题目通常需要对结果取模，以下统一使用<code>mod</code>代表取模的数，具体何时取余需要根据<code>mod</code>范围进行确定</li></ul><h2 id="质数">质数</h2><ul><li><strong>质数</strong>：在大于 1 的整数中，如果只包含 1和本身这两个约数，就被成为质数，或者叫素数。</li><li><strong>算数基本定理</strong>：任一大于1的整数 <spanclass="math inline">\(n\)</span>​ 能够唯一地表示成</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_s}^{\alpha _s},  \alpha_i&gt;0,  i=1,2,\cdots ,s\left( * \right)\]</span></p><p>​ 分解式(*)叫做 的 n 的标准分解式</p><p>注：有时为了应用方便，在分解式中插入若干素数的零次幂，而把 n表成下面形式： <span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><span id="more"></span><h3 id="判定质数试除法">判定质数——试除法</h3><ul><li>一个数的因数都是成对出现的（例如 12 的因数有 3 和 4，2 和6）所以我们可以只枚举较小的那一个。假设较小的为 <spanclass="math inline">\(d\)</span>，较大的为 <spanclass="math inline">\(n/d\)</span>，则：</li></ul><p><span class="math display">\[d\leqslant \frac{n}{d}\Longrightarrow d\leqslant \sqrt{n}\]</span></p><ul><li>时间复杂度：<span class="math inline">\(O(\sqrt{n})\)</span>​</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8063046/">AcWing866. 试除法判定质数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="comment">// 注意是小于等于</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数试除法">分解质因数——试除法</h3><ul><li><strong>性质</strong>：整数 n 中最多只含有一个<strong>大于</strong>sqrt(n) 的<font color ='red'><strong>质因子</strong></font><ul><li>证明：通过反证法：如果有两个大于 sqrt(n)的因子，那么相乘会大于n，矛盾。证毕</li><li>eg：6 的质因子 3 &gt; sqrt(6)</li></ul></li><li><strong>证明</strong>：循环里面的 <spanclass="math inline">\(i\)</span> 一定是一个质数:</li></ul><blockquote><p>假如 i是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是n 的质因子且比 i 要小，而比 i小的数在之前的循环过程中一定是被条件除完了的，所以 i不可能是合数，只可能是质数</p></blockquote><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8065120/">AcWing867. 分解质因数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 输出最后一个大于sqrt(n)的质数，注意这里的n可能已经被上面的代码更新过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eg：<span class="math inline">\(n = 96 = 2^5 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span> 且 <spanclass="math inline">\(3&gt;\sqrt{6}\)</span> ）</li><li>eg：<span class="math inline">\(n = 6 = 2 *3\)</span>，当分解完质因数 2 后，n 已经为 3，此时 i = 3，不满足 i &lt;=n / i，会进入最后判断输出 3（<spanclass="math inline">\(3&gt;\sqrt{3}\)</span>）</li><li>eg：n=17，循环不会输出，直接跳到最后判断输出 17（<spanclass="math inline">\(17&gt;\sqrt{17}\)</span>）</li><li>eg：<spanclass="math inline">\(n=16=2^4\)</span>，循环输出后，直接跳到最后判断，不会输出（<spanclass="math inline">\(1=\sqrt{1}\)</span>）</li></ul><h3 id="求-1-n-中的所有素数">求 1 ~ n 中的所有素数</h3><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8068049/">AcWing868. 筛质数 - AcWing</a>】</p><h4 id="朴素筛法不用">朴素筛法（不用）</h4><ul><li><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span>​ <spanclass="math display">\[\frac{n}{2}+\frac{n}{3}+\cdots +\frac{n}{n}=n\left(\frac{1}{2}+\frac{1}{3}+\cdots +\frac{1}{n} \right) \approx n\log n\]</span></p></li><li><p>原理：任意<strong>整数</strong> x <spanclass="math inline">\((x&gt;1)\)</span>​ 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)<span class="comment">// 循环n/i次</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="eratosthenes筛法不用">Eratosthenes筛法（不用）</h4><ul><li><p>时间复杂度：<spanclass="math inline">\(O(nloglogn)\)</span></p></li><li><p>原理：任意<font color='red'><strong>素数</strong></font> x <spanclass="math inline">\((x&gt;1)\)</span> 的倍数 2x，3x，…等都不是质数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="literal">true</span>;<span class="comment">// 可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法">线性筛法</h4><ul><li><p>朴素筛法和Eratosthenes筛法存在<strong>重复筛掉</strong>的情况（例如 12 既会被 2 筛掉，又会被 3筛掉：在标记 2 的倍数时，12 = 2 ∗ 6；在标记 3 的倍数时，12 = 3 ∗ 4）如何避免某个数被重复筛掉的情况呢？很简单，我们只需让 45只被它的最小质数（3）筛掉即可</p></li><li><p>原理：合数 x只会被其<font color='red'><strong>最小质因子</strong></font>筛掉一次</p></li><li><p>时间复杂度：<span class="math inline">\(O(n)\)</span>​</p></li></ul><p>第二层循环<code>st[primes[j] * i] = true;</code>只会对所有<strong>合数</strong>执行一次，所以时间复杂度为<span class="math inline">\(O(n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为什么不需要写 j &lt; cnt？ */</span></span><br><span class="line">        <span class="comment">// 1.   primes 数组中存有 &lt;= i 的所有质数</span></span><br><span class="line">        <span class="comment">// 2.   当 i 是合数时, 肯定会在中间就 break 掉</span></span><br><span class="line">        <span class="comment">// 3.   当 i 是质数时, 那么 primes[cnt - 1] = i，因此 j == cnt - 1 时，break，依然不越界</span></span><br><span class="line">        <span class="comment">/* 为什么循环条件是primes[j] &lt;= n / i */</span></span><br><span class="line">        <span class="comment">// 1. 下面筛掉的数是 primes[j] * i</span></span><br><span class="line">        <span class="comment">// 2. 我们要求的是1~n之间的所有素数</span></span><br><span class="line">        <span class="comment">// 3. 当 primes[j] &gt; n / i，下面筛掉的数大于n，不符合我们的要求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">            <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">            <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">            <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">            <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">            <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">            <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>证明：</p><ul><li>合数 x 的最小质因子只有一个</li></ul><blockquote><p>显然成立</p></blockquote><ul><li>合数 x<font color='red'><strong>只会</strong></font>被其<font color='red'><strong>最小质因子</strong></font>筛掉<font color='blue'><strong>一次</strong></font></li></ul><blockquote><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用合数 primes[j] * i的最小质因子 primes[j] 筛掉合数 primes[j] * i */</span></span><br><span class="line">    <span class="comment">// ∵primes[j]从小到大枚举的所有质数，有以下2种情况：</span></span><br><span class="line">    <span class="comment">//  1. 当 i % primes[j] == 0 时，primes[j] 一定是 i 的最小质因子，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">//  2. 当 i % primes[j] != 0 时，说明 i 的最小质因子比 primes[j] 还要大，因此 primes[j] 一定是 primes[j] * i 的最小质因子</span></span><br><span class="line">    <span class="comment">// ∴不管是上面哪种情况，primes[j] * i都会被其最小质因子primes[j]筛掉</span></span><br><span class="line">    st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 为什么要在 i % primes[j] == 0 的时候break掉? */</span></span><br><span class="line">    <span class="comment">// 当 i 是 prime[j] 的倍数时，有i = k * prime[j] ，如果继续运算 j+1，</span></span><br><span class="line">    <span class="comment">// prime[j+1] * i = prime[j+1] * prime[j] * k  # 这里prime[j]是最小的质因子(因为由上面的情况1知道，primes[j] 是 i 的最小质因子，因此 primes[j]&lt;=k，而 primes[j] &lt; primes[j+1]，故在这里 primes[j] 是最小质因子)，但是我们实际上用的是非最小质因子primes[j+1]筛掉的，而我们已经在上一次迭代中用primes[j]筛掉这个数了，重复筛掉</span></span><br><span class="line">    <span class="comment">// 当 i 循环到 = k * prime[j+1] 时会和 i * prime[j+1] 重复 # 所以要跳出循环。</span></span><br><span class="line">    <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>所有的合数一定会被筛掉</li></ul><blockquote><p>证明：对于合数 <span class="math inline">\(x\)</span>，假设 <spanclass="math inline">\(prime[k]\)</span> 是 <spanclass="math inline">\(x\)</span> 的最小质因子，当 <spanclass="math inline">\(i\)</span> 枚举到 <spanclass="math inline">\(x/primes[k]\)</span> 的时候，x一定会被 <spanclass="math inline">\(prime[k]\)</span> 筛掉（<spanclass="math inline">\(st[primes[k]*(x/primes[k])]=true\)</span>)</p></blockquote><p>因此，所有合数一定<strong>只</strong>会被<strong>最小质因子</strong><strong>筛掉一次</strong>，所以是线性的</p></li></ul><h2 id="约数">约数</h2><h3 id="求所有约数试除法">求所有约数——试除法</h3><ul><li><strong>原理</strong>：<ul><li>若 <span class="math inline">\(d|n\)</span>​，则 <spanclass="math inline">\(\frac{n}{d}|n\)</span>​. 所以一个数 n的约数肯定是成对存在的，对称轴是<spanclass="math inline">\(\sqrt{n}\)</span></li><li>因此只需要用 n 除以 1 到 <spanclass="math inline">\(\sqrt{n}\)</span>​之间的数，如果余数是0，则把<code>除数</code>、<code>n / 除数</code>加到答案中</li></ul></li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8068610/">AcWing869. 试除法求约数 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != n / i)</span><br><span class="line">                res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><ul><li><strong>约束个数</strong>定理：任一大于 <spanclass="math inline">\(1\)</span> 的整数 <spanclass="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数的个数为 $( _1+1 )( _1+1 ) ( _k+1 ) $</p><ul><li><strong>证明</strong>：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150912687.png"alt="image-20240315091200551" /><figcaption aria-hidden="true">image-20240315091200551</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8070605/">AcWing870. 约数个数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的 n 在 int 范围内，因此约数一定也在 int 范围内</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s++;</span><br><span class="line">            res *= s + <span class="number">1</span>;<span class="comment">// 运算的逻辑就是先算完等号右侧的数值，然后再 *=</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和">约数之和</h3><ul><li><strong>约束之和</strong>定理：任一大于 1 的整数 <spanclass="math inline">\(n\)</span>​ 分解质因式：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _2}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span></p><p>​ 则 <span class="math inline">\(n\)</span> 的正约数之和为 $(p_{1}<sup>{0}+p_{1}</sup>{1}++p_{1}<sup>{<em>1} ) (p</em>{2}</sup>{0}+p_{2}<sup>{1}++p_{2}</sup>{<em>2} ) (p</em>{k}<sup>{0}+p_{k}</sup>{1}++p_{k}^{_k} ) $</p><ul><li><strong>证明</strong>：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150917791.png"alt="image-20240315091535903" /><figcaption aria-hidden="true">image-20240315091535903</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071116/">AcWing871. 约数之和 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li><li>一个数的<strong>约数之和</strong>一定会<strong>大于这个数本身</strong>（因为这个数本身也是自己的约数）</li></ul><h4 id="原版">原版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s = s * i + <span class="number">1</span>;</span><br><span class="line">            res *= s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res *= n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化">优化</h4><p>采用分治计算 <span class="math inline">\(1 + p + p^2 + ... +p^k\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % mod;</span><br><span class="line">        a = (LL)a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优化：采用分治计算 1 + p + p^2 + ... + p^k */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">qmi</span>(p, (k + <span class="number">1</span>) / <span class="number">2</span>)) * <span class="built_in">sum</span>(p, (k - <span class="number">1</span>) / <span class="number">2</span>)) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> ((LL)(<span class="number">1</span> + <span class="built_in">qmi</span>(p, k / <span class="number">2</span>)) * <span class="built_in">sum</span>(p, k / <span class="number">2</span> - <span class="number">1</span>) + <span class="built_in">qmi</span>(p, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算约数之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisiors_sum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i, s ++;</span><br><span class="line">            res = res * <span class="built_in">sum</span>(i, s) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res * n % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><ul><li><strong>欧几里得算法</strong>：</li></ul><p><span class="math display">\[\begin{cases}    gcd\left( a,b \right) =gcd\left( b,a\%b \right)\\    gcd\left( a,0 \right) =a\\\end{cases}\]</span></p><ul><li><span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的最大公约数 <spanclass="math inline">\(gcd(a,b)\)</span> 被记作 <spanclass="math inline">\((a,b)\)</span>​</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8071167/">AcWing872. 最大公约数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><h3 id="求欧拉函数-varphi-left-n-right">求欧拉函数 <spanclass="math inline">\(\varphi \left( n \right)\)</span></h3><ul><li><strong>定理</strong>：设正整数 <spanclass="math inline">\(n\)</span> 的标准分解式为：</li></ul><p><span class="math display">\[n={p_1}^{\alpha _1}{p_1}^{\alpha _1}\cdots {p_k}^{\alpha _k},  \alpha_i\geqslant 0,  i=1,2,\cdots ,k\]</span> ​ 则欧拉函数 <span class="math display">\[\varphi \left( n \right) =n\left( 1-\frac{1}{p_1} \right) \left(1-\frac{1}{p_2} \right) \cdots \left( 1-\frac{1}{p_k} \right)\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8072352/">AcWing873. 欧拉函数 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(\sqrt{n})\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求-1-n-中每个数的欧拉函数线性筛法">求 1 ~ n中每个数的欧拉函数——线性筛法</h3><ul><li>给定一个正整数 <span class="math inline">\(n\)</span> ，求 <spanclass="math inline">\(1\)</span> ∼ <spanclass="math inline">\(n\)</span>中<strong>每个数的</strong>欧拉函数</li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8073032/">AcWing874. 筛法求欧拉函数 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> eulers[N];       <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉(状态state)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eulers[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求素数 i 的欧拉函数 phi(i) = i - 1</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            eulers[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 求合数 t = primes[j] * i 的欧拉函数</span></span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 情况1：i % primes[j] == 0，此时 primes[j] 既是 i 的最小质因数，也是 t 的最小质因数，phi(t) = phi(primes[j]*i) = primes[j] * phi(i)</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                eulers[t] = primes[j] * eulers[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2：i % primes[j] != 0，此时 primes[j] 不是 i 的质因数（primes[j] &lt; i的最小质因数），但却是 t 的最小质因数，此时 (primes[j], 1) == 1，因此phi(t) = phi(primes[j] * i) = phi(primes[j]) * phi(i) = (primes[j] - 1) * phi(i)</span></span><br><span class="line">            eulers[t] = (primes[j] - <span class="number">1</span>) * eulers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><p>快速求出 <span class="math inline">\(a^b\,\,mod\,\,p\)</span>​</p><ul><li><strong>原理：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151618057.png"alt="04a91bf62e0bd92e3db3b3a73c76793" /><figcaptionaria-hidden="true">04a91bf62e0bd92e3db3b3a73c76793</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151619524.png"alt="bb9db9bc6547be4cfcf9dba7ac9190a" /><figcaptionaria-hidden="true">bb9db9bc6547be4cfcf9dba7ac9190a</figcaption></figure><blockquote><p>《算法进阶指南》P4</p></blockquote><ul><li><strong>时间复杂度：</strong><spanclass="math inline">\(O(logb)\)</span></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8074336/">AcWing875. 快速幂 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 特判：p == 1</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left. \begin{array}{r}    a^{2^0}=a^1\\    a^{2^1}=a^2\\    a^{2^2}=a^4\\    \cdots\\    a^{2^{k-1}}\\\end{array} \right\} \Rightarrow a^{2^i}=\left( a^{2^{i-1}} \right) ^2\]</span></p><h2 id="拓展欧几里得算法">拓展欧几里得算法</h2><ul><li><strong>Bezout(贝祖等式)</strong></li></ul><p>设 <strong><span class="math inline">\(a, b\)</span></strong>是任意两个正整数，则存在整数 <strong><span class="math inline">\(x,y\)</span></strong> 使得 <span class="math display">\[ax+by=\left( a,b \right)\]</span></p><ul><li>如何求解上述等式的解 <strong><span class="math inline">\(x,y\)</span></strong> ？</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403151722173.png"alt="image-20240315172217936" /><figcaption aria-hidden="true">image-20240315172217936</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8074640/">AcWing877. 扩展欧几里得算法 - AcWing</a>】</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(log(a+b))\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求逆">求逆</h2><ul><li><strong>定义</strong>：当 <span class="math inline">\(ax≡1 \ mod \p\)</span>, <span class="math inline">\(a^{-1}\)</span> <spanclass="math inline">\(mod\)</span> <spanclass="math inline">\(p\)</span> 称为 <spanclass="math inline">\(a∈{1,2,…,p-1}\)</span> 的乘法逆</li><li><strong>定理</strong>：当且仅当 <spanclass="math inline">\(gcd(a,p)=1, \ a^{-1} \ mod \ p\)</span>​ 存在</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8078478/">AcWing876. 求逆元 - AcWing</a>】</li></ul><h3 id="费马小定理求逆元">费马小定理——求逆元</h3><ul><li><p><strong>前提要求</strong>：<font color='red'> <spanclass="math inline">\(p\)</span> 为素数 </font></p></li><li><p><strong>有解判断</strong>：</p></li></ul><p><span class="math display">\[gcd\left( a,p \right) =1\xLeftrightarrow{p\text{为素数}}a\not \equiv0\,\, mod\,\,p\]</span></p><ul><li><strong>费马小定理</strong>：若 <spanclass="math inline">\(p\)</span> 为素数，则</li></ul><p><span class="math display">\[a^{p-1}\equiv 1 \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><ul><li>因此，<span class="math inline">\(a\)</span> 的逆为</li></ul><p><span class="math display">\[a^{-1}=a^{p-2}\, \, \left( mod\,\,p \right) \,\,\,\,\,\,\,\,  s.t. a\not\equiv 0\,\, mod\,\,p\]</span></p><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(logp)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在逆元</span></span><br><span class="line"><span class="keyword">if</span> (a % p == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)<span class="built_in">qmi</span>(a, p - <span class="number">2</span>, p) % p + p) % p);</span><br></pre></td></tr></table></figure><h3 id="拓展欧几里得求逆元">拓展欧几里得——求逆元</h3><ul><li><p>不要求 <span class="math inline">\(p\)</span> 为素数， <spanclass="math inline">\(p\)</span> 为任意数即可</p></li><li><p>使用拓展欧几里得算法求一个元素的逆</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断逆元是否存在</span></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line"><span class="keyword">if</span> (g != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x + p) % p); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x+p可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">+p %p 是为了将 x 转换到 0 ~ p-1</span></span><br><span class="line"><span class="comment">/ % 的优先级要高于 + -，所以这里必须加上括号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="求解同余式">求解同余式</h2><ul><li><strong>定理：</strong>一次同余式</li></ul><p><span class="math display">\[ax\equiv b\left( mod\,\,m \right) \text{，}a\not \equiv 0\left( mod\,\,m\right)\]</span></p><ol type="1"><li>有解<span class="math inline">\(\Longleftrightarrow \left( a,m\right) |b\)</span>​</li><li>当同余式有解时<ol type="1"><li>其解数为 <span class="math inline">\(d=(a,m).\)</span>​​</li><li>求解 <span class="math inline">\(x\)</span>，满足 <spanclass="math inline">\(ax≡b(mod \ m)\)</span> &lt;==&gt; 求解 <spanclass="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>满足 <span class="math inline">\(ax+my=b\)</span><ol type="1"><li>使用 拓展欧几里得算法 ，求出 <spanclass="math inline">\(x_0\)</span>、<spanclass="math inline">\(y_0\)</span>，使得 <spanclass="math inline">\(ax_0+my_0=(a,m)\)</span></li><li>左右两侧同时乘以 <span class="math inline">\(\frac{b}{\left( a,m\right)}\)</span>，得到 $ a+m=b$</li><li>因此解 <span class="math inline">\(x=x_0*\frac{b}{\left( a,m\right)}\)</span></li></ol></li></ol></li></ol><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8082881/">AcWing878. 线性同余方程 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   输入：a,b</span></span><br><span class="line"><span class="comment">   输出：(a,b),x,y 使得 ax + by = (a,b)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// x、y 为引用返回</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (b % g)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((<span class="type">long</span> <span class="type">long</span>)x * b / g + m)% m);</span><br><span class="line"><span class="comment">// x * b可能爆int,所以用 long long</span></span><br><span class="line"><span class="comment">// * / % 的优先级相同，按照顺序从左到右依次运行</span></span><br><span class="line"><span class="comment">// + m % m 是为了将 x 转换到 0 ~ p-1</span></span><br></pre></td></tr></table></figure><h2 id="求解一次同余组">求解一次同余组</h2><h3 id="中国剩余定理">中国剩余定理</h3><ul><li>要求： <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161457480.png"alt="image-20240316145735216" /><figcaption aria-hidden="true">image-20240316145735216</figcaption></figure><h3 id="拓展中国剩余定理">拓展中国剩余定理</h3><ul><li>不要求 <span class="math inline">\(m_1\text{、}m_2\text{、}\cdots\text{、}m_k\)</span> <strong>两两互质</strong></li><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8086576/">AcWing204. 表达整数的奇怪方式 - AcWing</a>】</strong></li></ul><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403161857618.png" /></p><h2 id="高斯消元">高斯消元</h2><h3 id="解线性方程组">解线性方程组</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192214816.png"alt="image-20240319221424411" /><figcaption aria-hidden="true">image-20240319221424411</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403192222282.png"alt="image-20240319222223978" /><figcaption aria-hidden="true">image-20240319222223978</figcaption></figure><p>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8128731/">AcWing883. 高斯消元解线性方程组 - AcWing</a>】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断是否有解</span></span><br><span class="line"><span class="comment">- 返回0，表示无解</span></span><br><span class="line"><span class="comment">- 返回1：表示有无穷多组解</span></span><br><span class="line"><span class="comment">- 返回2：表示有解a[0][n]~a[n-1][n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r; <span class="comment">// c 代表 列 col ， r 代表 行 row</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先找到当前这一列绝对值最大的一个数字所在的行号 t</span></span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行，换到最上面（不是第一行，是第 r 行）去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前这一行的第一个数，变成 1，方程两边同时除以第一个数，必须倒着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--)</span><br><span class="line">            a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把【当前列】下面的所有数，全部消成 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--) <span class="comment">// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];</span></span><br><span class="line">                a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r++; <span class="comment">// 这一行的工作做完，换下一行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r &lt; n 表明剩下方程的个数是小于 n 的，不是唯一解，判断是无解还是无穷多解</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;                                <span class="comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps) <span class="comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一解，从下往上回代，得到方程的解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n]; <span class="comment">// 因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要找绝对值最大的那一行？</p><ol type="1"><li>一是因为可以寻找一个非零行</li><li>二是作浮点数除法时，显然<strong>除以一个大数会让精度更好</strong>，误差更小</li></ol></blockquote><h3 id="解异或方程组">解异或方程组</h3><ul><li><strong>核心思想</strong>：<strong>异或</strong>&lt;==&gt;<strong>不进位的加法</strong></li><li>等式与等式间的异或要一起进行才能保证等式左右两边依然是相等关系：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a^b^c = x</span><br><span class="line">   d^f = y</span><br><span class="line">则</span><br><span class="line"> a^b^d^c^f = x^y</span><br></pre></td></tr></table></figure><ul><li><strong>算法步骤</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 左下角消0</span><br><span class="line">  1.1 枚举列</span><br><span class="line">  1.2 找第一个非零行</span><br><span class="line">  1.3 交换</span><br><span class="line">  1.4 把同列下面行消零(异或)</span><br><span class="line">2 判断3种情况</span><br><span class="line">  2.1 唯一解</span><br><span class="line">  2.2 秩&lt;n</span><br><span class="line">      2.2.1 有矛盾 无解</span><br><span class="line">      2.2.2 无矛盾 无穷多解</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/8161242/">AcWing884. 高斯消元解异或线性方程组 - AcWing</a>】</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">            &#123;</span><br><span class="line">                t = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!a[t][c])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= n; j++)</span><br><span class="line">                    a[i][j] ^= a[r][j];</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][n])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 无解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无穷解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] ^= a[i][j] * a[j][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出解</span></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数">组合数</h2><p><span class="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}=C_{a}^{a-b}\\    \\    \,\,C_{a}^{0}=1\\\end{cases}\,\,         0\leqslant a\leqslant b\]</span></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404061551561.png"alt="image-20240406155131232" /><figcaption aria-hidden="true">image-20240406155131232</figcaption></figure><h3 id="模板一">模板一</h3><ul><li><strong>适用条件</strong>：<ul><li>询问次数 n 非常多</li><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^5\\1&lt;=b&lt;=a&lt;=2000\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong>：</li></ul><p><span class="math display">\[C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}\]</span></p><ul><li><strong>时间复杂度</strong>：<font color='red'><spanclass="math inline">\(O(n^2)\)</span>​</font></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8108970/">AcWing885. 求组合数 I - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)<span class="comment">// 注意：这里是 j &lt;= i</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板二">模板二</h3><ul><li><strong>适用条件</strong><ul><li>组合数取余后的结果</li></ul></li></ul><p><span class="math display">\[1&lt;= n &lt;= 10^4\\1&lt;=b&lt;=a&lt;=10^5\\p=1e9 + 7\]</span></p><ul><li><strong>原理</strong></li></ul><p><span class="math display">\[\frac{a}{b}mod\,\,p=a*b^{-1}\,\,mod\,\,p\ne\frac{a\,\,mod\,\,p}{b\,\,mod\,\,p}\]</span></p><p><span class="math display">\[\left( a*b \right) ^{-1}\,\,mod\,\,p=a^{-1}*b^{-1}\,\,mod\,\,p\]</span></p><p><span class="math display">\[C_{a}^{b}=\frac{a!}{b!\left( a-b \right) !}=fact\left( a \right) \,\,*infact\left( b \right) \,\,* infact\left( a-b \right)\,\,   \text{其中}\begin{cases}    fact\left( a \right) =a! \% mod\\    infact\left( a \right) =\left( a! \right) ^{-1}\,\,\% mod\\\end{cases}\\\\\]</span> :smile:注意：<span class="math inline">\(mod=1e^9+7\)</span>为质数，所以计算逆元 <span class="math inline">\(i^{-1}\)</span>可以采用<strong>费马小定理</strong> <span class="math display">\[\text{递推公式：}\begin{cases}    fact\left( a \right) =fact\left( a-1 \right) \,\,* a\,\,\% mod\\    infact\left( a \right) =infact\left( a-1 \right) \,\,* a^{-1}\,\,\%mod\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8110941/">AcWing886. 求组合数 II - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0! = 1, 1^&#123;-1&#125; = 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2个 int 相乘会爆 int ，使用类型转化为 long long</span></span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">// 三个 int 相乘会爆 long long，所以每2个数相乘就对 mod 取模</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ((LL)fact[a] * infact[b]) % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板三">模板三</h3><ul><li><strong>适用条件</strong></li></ul><p><span class="math display">\[1&lt;= n &lt;= 20\\1&lt;=b&lt;=a&lt;=10^{18}\\1&lt;=p&lt;=10^5，且\ p\ 为质数\]</span></p><ul><li><strong>卢卡斯定理 <span class="math inline">\(Lucas \Theory\)</span></strong></li></ul><p><span class="math display">\[C_{a}^{b}\equiv C_{a\,\,mod\,\,p}^{b\,\,mod\,\,p}\,\,*C_{a/p}^{b/p}\,\,mod\,\,p   \ \ \ \ \ \ p\ 为素数\]</span></p><p>​ 当 <span class="math inline">\(a&lt;p\)</span> 且 <spanclass="math inline">\(b&lt;p\)</span> 时，适用组合数定义求 <spanclass="math display">\[\begin{cases}    C_{a}^{b}=\frac{\overset{b\text{项}}{\overbrace{a\left( a-1 \right)\left( a-2 \right) \cdots \left( a-b+1 \right)}}}{\underset{b\text{项}}{\underbrace{b!}}}=\frac{a!}{b!\left( a-b\right) !}\\    \,\,C_{a}^{0}=1\\\end{cases}\]</span></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121840/">AcWing887. 求组合数 III - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这里的 a 和 b 需要保证小于 p , 因此(b!,p)=1, b!的逆元一定存在</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * j % p;</span><br><span class="line">        y = (LL)y * i % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)x * <span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lucas</span>(a, b, p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板四">模板四</h3><ul><li><strong>适用条件</strong><ul><li>只计算一个组合数</li><li>p 为质数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Cab mod p</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i ++, j --)</span><br><span class="line">&#123;</span><br><span class="line">    res = (LL)res * j % p;</span><br><span class="line">    res = (LL)res * qmi(i, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板五">模板五</h3><ul><li><strong>使用条件</strong></li></ul><p>当我们需要求出<strong>组合数的真实值</strong>，而非对某个数的余数时，分解质因数的方式比较好用：</p><ul><li><strong>原理</strong></li></ul><ol type="1"><li>筛法求出范围内的所有质数</li><li>通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n!中p的次数是</li></ol><p><span class="math display">\[n / p + n / p^2 + n / p^3 + ...\]</span></p><ol start="3" type="1"><li>用高精度乘法将所有质因子相乘</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403191527951.png"alt="image-20240319152754655" /><figcaption aria-hidden="true">image-20240319152754655</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8121842/">AcWing888. 求组合数 IV - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];         <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求n！分解质因数后， p 的次数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高精度乘低精度模板 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a); <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j++)</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8311244/">AcWing211. 计算系数（每日一题） - AcWing</a></li></ul><h2 id="卡特兰数">卡特兰数</h2><h3 id="原理">原理</h3><p>​ 给定 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(0\)</span> 和 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(1\)</span>，它们按照某种顺序排成长度为 <spanclass="math inline">\(2n\)</span> 的序列，满足任意前缀中 <spanclass="math inline">\(0\)</span> 的个数都不少于 <spanclass="math inline">\(1\)</span> 的个数的序列的数量为： <spanclass="math display">\[Cat_n=\frac{C_{2n}^{n}}{n+1}\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403282301866.png"alt="image-20240328230128530" /></p><h3 id="例题-1">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8121833/">AcWing889. 满足条件的01序列 - AcWing</a></li></ul><h2 id="容斥原理">容斥原理</h2><h3 id="原理-1">原理</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201238750.png"alt="image-20240319184649042" /><figcaption aria-hidden="true">image-20240319184649042</figcaption></figure><h3 id="例题-2">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8129504/">AcWing890. 能被整除的数 - AcWing</a></li></ul><h2 id="博弈论之sg函数">博弈论之SG函数</h2><h3 id="nim游戏">NIM游戏</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403281718365.png"alt="image-20240328171850955" /><figcaption aria-hidden="true">image-20240328171850955</figcaption></figure><h4 id="定理">定理</h4><p>​ 假设 <span class="math inline">\(n\)</span>​ 堆石子，数目分别是 <spanclass="math inline">\(A_1,A_1,\cdots,A_n\)</span>​</p><ul><li>如果 <span class="math inline">\(A_1\oplus A_2\oplus \cdots \oplusA_n\ne 0\)</span>​​，则先手必胜</li><li>否则先手必败</li></ul><h4 id="证明">证明</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403281928376.png"alt="image-20240328192818930" /><figcaption aria-hidden="true">image-20240328192818930</figcaption></figure><p>:tomato:基于上述三个证明：</p><ol type="1"><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n\ne0\)</span>，那么先手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，最后一定是后手面临最终没有石子可拿的状态，先手必胜。</li><li>如果先手面对的局面是 <span class="math inline">\(a_1\oplus a_2\oplus\cdots \oplus a_n=0\)</span>，那么无论先手怎么拿，都会将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplus a_n\ne0\)</span>，那么后手总可以通过拿走某一堆若干个石子，将局面变成 <spanclass="math inline">\(a_1\oplus a_2\oplus \cdots \oplusa_n=0\)</span>。如此重复，后一定是先手面临最终没有石子可拿的状态，先手必败。</li></ol><h3 id="公平组合游戏icg">公平组合游戏ICG</h3><p>若一个游戏满足：</p><ol type="1"><li>由两名玩家交替行动；</li><li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个<strong>公平组合游戏</strong>。</p><p>​NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p><h3 id="有向图游戏">有向图游戏</h3><p>​给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为<strong>有向图游戏</strong>。​<strong>任何一个公平组合游戏都可以转化为有向图游戏</strong>。具体方法是，<font color ='red'>把每个<strong>局面</strong>看成图中的一个<strong>节点</strong>，并且从<strong>每个局面</strong>向沿着合法行动能够到达的<strong>下一个局面</strong>连<strong>有向边</strong>。</font></p><h3 id="mex运算">Mex运算</h3><p>​ 设 <span class="math inline">\(S\)</span> 表示一个非负整数集合。定义<span class="math inline">\(mex(S)\)</span>为求出<strong>不属于</strong>集合 <span class="math inline">\(S\)</span>的最小非负整数的运算，即： <span class="math display">\[mex(S) = min\{x\},\ x\ 属于自然数，且\ x\ 不属于\ S\]</span></p><h3 id="sg函数">SG函数</h3><p>​ 在有向图游戏中，对于每个节点 <spanclass="math inline">\(x\)</span>，设从 <spanclass="math inline">\(x\)</span> 出发共有 <spanclass="math inline">\(k\)</span> 条有向边，分别到达节点 <spanclass="math inline">\(y_1, y_2, …, y_k\)</span> ，定义 SG(x) 为 x的后继节点 <span class="math inline">\(y_1, y_2, …, y_k\)</span> 的SG函数值 构成的集合再执行 mex(S) 运算的结果，即： <spanclass="math display">\[SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})\]</span> 特别地，整个有向图游戏 G 的 SG 函数值被定义为有向图游戏起点 s的 SG 函数值，即： <span class="math display">\[SG(G) = SG(s)\]</span> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403201408408.png"alt="image-20240320140827062" /></p><h3 id="有向图游戏的和">有向图游戏的和</h3><p>​ 设 G1，G2,····,Gm 是 m 个有向图游戏。定义有向图游戏G，他的行动规则是任选某个有向图游戏 Gi，并在 Gi 上行动一步。G被称为<strong>有向图游戏 G1，G2，·····，Gm的和</strong></p><p>​有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数的<strong>异或和</strong>，即：<span class="math display">\[SG\left( G \right) =SG\left( G_1 \right) \oplus SG\left( G_2 \right)\oplus \cdots \oplus SG\left( G_m \right)\]</span></p><h3 id="定理-1">定理</h3><ul><li>有向图游戏的某个局面<strong>必胜</strong>，当且仅当该局面对应节点的<strong>SG函数值大于0</strong></li><li>有向图游戏的某个局面<strong>必败</strong>，当且仅当该局面对应节点的<strong>SG函数值等于0</strong></li></ul><p>我们不再详细证明该定理。读者可以这样理解：</p><ul><li>在一个<strong>没有出边</strong>的节点上，棋子<strong>不能</strong>移动，它的SG 值为 0，对应必败局面。</li><li>若一个节点的某个后继节点 SG 值为 0，在 mex 运算后，该节点的 SG值大于0。这等价于，若一个局面的后继局面中存在必败局面，则当前局面为必胜局面。</li><li>若一个节点的后继节点 SG 值均不为 0，在mex运算后，该节点的 SG 值为0。这等价于，若一个局面的后继局面全部为必胜局面，则当前局面为必败局面。</li></ul><p>对于若干个有向图游戏的和，其证明方法与 NIM 博弈类似。</p><h3 id="例题-3">例题</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8129672/">AcWing891. Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8221695/">AcWing892. 台阶-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8131666/">AcWing893. 集合-Nim游戏 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8223036/">AcWing894. 拆分-Nim游戏 - AcWing</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Tips】</title>
      <link href="/2024/03/14/%5Bobject%20Object%5D/C++/%E3%80%90Tips%E3%80%91/"/>
      <url>/2024/03/14/%5Bobject%20Object%5D/C++/%E3%80%90Tips%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="tips">Tips</h1><h2 id="i"><code>~i</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i != <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">~i;</span><br></pre></td></tr></table></figure><h2 id="大数组要定义在全局变量">大数组要定义在全局变量</h2><ul><li><p>在函数（包含main）内部声明的变量属于局部变量</p></li><li><p>局部变量存放在<strong>栈空间</strong>，栈空间默认为4MB，最多只能存储 <code>1e6</code> 大小的 <code>int</code> 数组</p></li><li><p>全局变量存放在<strong>堆空间</strong>，堆空间很大，如果内存为4GB，堆空间也可以达到 4GB</p></li></ul><p>​ 因此C++ 中若要设置长度大于 <code>1e6</code>的数组，不能在函数内部声明，因为这样属于局部变量，存放在栈空间上，容易造成内存溢出</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291023786.png" alt="image-20240329102329729" style="zoom: 50%;" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291024238.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="输出回车">输出回车</h2><ul><li><p><code>puts()</code>的作用是：输出一个字符串，然后加上回车</p></li><li><p>输出回车有一个简写方式：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">// 字符串为空，相当于只输出一个回车</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先队列priority_queue</title>
      <link href="/2024/03/08/%5Bobject%20Object%5D/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/"/>
      <url>/2024/03/08/%5Bobject%20Object%5D/STL/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/</url>
      
        <content type="html"><![CDATA[<h1 id="优先队列priority_queue">优先队列priority_queue</h1><p>:smile: priority_queue实际上就是<strong>堆</strong></p><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>堆大小</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>插入</font></strong>堆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分别返回<strong><font color='red'>堆顶元素</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p><font color='blue'><strong>删除</strong></font>堆顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 queue 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><h2 id="举例">举例</h2><ol type="1"><li>基本类型例子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; a; </span><br><span class="line">    <span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">    priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(i);</span><br><span class="line">        c.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!c.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!b.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 0</span><br><span class="line">0 1 2 3 4</span><br><span class="line">cbd abcd abc</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>pari的比较，先比较第一个元素，第一个相等比较第二个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">push</span>(d);</span><br><span class="line">    a.<span class="built_in">push</span>(c);</span><br><span class="line">    a.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>对于自定义类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp1</span> <span class="comment">//运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="type">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> tmp1&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tmp2</span> <span class="comment">//重写仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tmp1 a, tmp1 b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.<span class="built_in">push</span>(b);</span><br><span class="line">    d.<span class="built_in">push</span>(c);</span><br><span class="line">    d.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        d.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.<span class="built_in">push</span>(c);</span><br><span class="line">    f.<span class="built_in">push</span>(b);</span><br><span class="line">    f.<span class="built_in">push</span>(a);</span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        f.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++标准库函数】</title>
      <link href="/2024/03/04/%5Bobject%20Object%5D/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/"/>
      <url>/2024/03/04/%5Bobject%20Object%5D/C++/%E3%80%90C++%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="c标准库函数">C++标准库函数</h1><p>[TOC]</p><h2 id="lower_bound-upper_bound">lower_bound &amp;&amp; upper_bound</h2><h3 id="头文件">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用">作用</h3><ul><li><p>在一个<strong>排好序的数组</strong>中进行<strong>二分查找</strong></p></li><li><p><strong>基于二分查找！数组或容器必须有序！</strong></p></li></ul><h3 id="用法">用法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142542.png"alt="image-20240331214206385" /><figcaption aria-hidden="true">image-20240331214206385</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312142606.png"alt="image-20240331214221383" /><figcaption aria-hidden="true">image-20240331214221383</figcaption></figure><h3 id="举例">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;; <span class="comment">// 示例数组，假设已经从小到大排序</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 最后一个小于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 最后一个小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 没有小于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 最后一个小于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p2 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p2 &gt;= a.<span class="built_in">begin</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 最后一个小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2. 没有小于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 第一个大于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p3 = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p3 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 第一个大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3. 没有大于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 第一个大于等于x的元素</span></span><br><span class="line">    <span class="keyword">auto</span> p4 = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">if</span> (p4 != a.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 第一个大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素是: &quot;</span> &lt;&lt; *p4 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;4. 没有大于等于 &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; 的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">6</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">6</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">7</span> 的元素是: <span class="number">5</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">7</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">7</span> 的元素是: <span class="number">7</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">2.</span> 没有小于等于 <span class="number">0</span> 的元素</span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">0</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">10</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">10</span> 的元素</span><br><span class="line"><span class="number">4.</span> 没有大于等于 <span class="number">10</span> 的元素</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 没有小于 <span class="number">1</span> 的元素</span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 第一个大于 <span class="number">1</span> 的元素是: <span class="number">3</span></span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">1</span> 的元素是: <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 输入 */</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">/* 输出 */</span></span><br><span class="line"><span class="number">1.</span> 最后一个小于 <span class="number">9</span> 的元素是: <span class="number">7</span></span><br><span class="line"><span class="number">2.</span> 最后一个小于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br><span class="line"><span class="number">3.</span> 没有大于 <span class="number">9</span> 的元素</span><br><span class="line"><span class="number">4.</span> 第一个大于等于 <span class="number">9</span> 的元素是: <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="nth_element">nth_element</h2><h3 id="头文件-1">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="原型">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序规则采用默认的升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//排序规则为自定义的 comp 排序规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator nth,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>first</code> 、 <code>last</code>为<strong>迭代器/指针</strong>，用于指定该函数的作用范围<code>[first, last)</code></li><li><code>nth</code>：也为<strong>迭代器/指针</strong>，其功能是令函数查找“<strong>第nth 小</strong>”的元素，并将其移动到 <code>nth</code> 指向的位置</li><li><code>comp</code>：用于<strong>自定义排序规则</strong></li></ul><blockquote><p><code>comp</code> 是可选参数，默认是求第 <spanclass="math inline">\(k\)</span> 小</p></blockquote><p><strong>返回值：</strong></p><ul><li>无</li></ul><h3 id="作用-1">作用</h3><ul><li>将数组中<strong>第 <span class="math inline">\(k\)</span>小</strong>的数 放在 <code>nth</code> 指向的位置</li><li>函数执行后， <code>nth</code>指向的元素将处于正确位置，其他位置元素顺序相较于初始顺序会被<strong>打乱</strong>，但前面的都比它小，后面的都比它大</li><li>时间复杂度：<span class="math inline">\(O(n)\)</span></li></ul><h3 id="举例-1">举例</h3><h4 id="求第k小">求第k小</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 小 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 小为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 小为 <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> </span><br></pre></td></tr></table></figure><h4 id="求第k大">求第k大</h4><ul><li><strong>数组</strong> <code>a[]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>, k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k - <span class="number">1</span>, a + n, [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong> <code>vector</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>(), k = <span class="number">3</span>; <span class="comment">// n为数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求第 k 大 */</span></span><br><span class="line">    <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + k - <span class="number">1</span>, a.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">                &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第 k 大为 &quot;</span> &lt;&lt; a[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第 k 大为 <span class="number">7</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure><h2 id="max_elementmin_element">max_element、min_element</h2><h3 id="头文件-2">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-2">作用</h3><p><strong>1. 求数组的最大值或最小值</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a, a + <span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a, a + <span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//获取最大值</span></span><br><span class="line"><span class="type">int</span> min = *<span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());<span class="comment">//获取最小值</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>2. 求数组最大值最小值对应的下标</strong></p><ul><li>普通数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a, a + <span class="number">8</span>) - a; </span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a, a + <span class="number">8</span>) - a;</span><br></pre></td></tr></table></figure><ul><li>vector容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">33</span>,<span class="number">11</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> max_index = <span class="built_in">max_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); <span class="comment">//获取最大值对应的下标</span></span><br><span class="line"><span class="type">int</span> min_index = <span class="built_in">min_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();<span class="comment">//获取最小值对应的下标</span></span><br></pre></td></tr></table></figure><h2 id="fill">fill</h2><h3 id="头文件-3">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-3">作用</h3><p><ahref="https://blog.csdn.net/liu16659/article/details/87152348?ops_request_misc=%7B%22request%5Fid%22%3A%22167715751316800188555444%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167715751316800188555444&amp;biz_id=0&amp;spm=1018.2226.3001.4187">(96条消息)C++ 中 fill() 的使用_LawsonAbs的博客-CSDN博客_c++ fill</a></p><h2 id="memset">memset</h2><h3 id="头文件-4">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型-1">原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, Byte c, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>s：为指针或是数组</li><li>c：是赋给 s 的值</li><li>count：是 s 的长度</li></ul><p>返回值</p><ul><li>指向存储区 s 的指针。</li></ul><h3 id="作用-4">作用</h3><p>​ memset是按照 c 的值（看作字节），按字节将 s赋值，因此我们最常见的就是</p><ul><li>将每一字节赋值全 0 ，整体就是 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><ul><li>将每一字节赋值全 1 ，整体就是 -1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">-1</span>, <span class="keyword">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p>注意：-1 = 0XFF</p></blockquote><ul><li>将每一个字节赋值 0x3f，整体就是 INF【<strong>正无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(s))</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/qq_42386788/article/details/116427457">关于memset函数和赋值0x3f</a></p></blockquote><ul><li>将每一个字节赋值 0xbf，整体就是 INF【<strong>正无穷</strong>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(s, <span class="number">0xbf</span>, <span class="built_in">sizeof</span>(s))</span><br></pre></td></tr></table></figure><h3 id="说明">说明</h3><p>memset可以方便的==<strong>清空</strong>或初始化一个<strong>数组</strong>。==</p><h3 id="举例-2">举例</h3><ol type="1"><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><blockquote><p><ahref="https://blog.csdn.net/weixin_44162361/article/details/115790452?ops_request_misc=%7B%22request%5Fid%22%3A%22169735623116800180650624%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169735623116800180650624&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115790452-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=memset&amp;spm=1018.2226.3001.4187">memset的用法详解_薛定谔的猫ovo的博客-CSDN博客</a></p></blockquote><h2 id="memcmp">memcmp</h2><h3 id="头文件-5">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="基本原型">基本原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf1, <span class="type">const</span> <span class="type">void</span> *buf2, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong></p><ul><li><p>当 buf1&lt;buf2 时，返回值&lt;0</p></li><li><p>当 buf1=buf2 时，返回值=0</p></li><li><p>当 buf1&gt;buf2 时，返回值&gt;0</p></li></ul><h3 id="作用-5">作用</h3><p>memcmp 是比较内存区域 buf1 和 buf2 的前 count个字节。该函数是按字节比较的</p><h3 id="举例-3">举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">r = <span class="built_in">memcmp</span>(&amp;s1,&amp;s2,<span class="built_in">strlen</span>(s1));</span><br><span class="line"><span class="keyword">if</span>(!r)<span class="comment">//！r 非零返回的是 1  这个是非运算，计算机是二进制的，不是零就是一了 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 and s2 are identical\n&quot;</span>);<span class="comment">/*s1等于s2*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is less than s2\n&quot;</span>);<span class="comment">/*s1小于s2*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1 is greater than s2\n&quot;</span>);<span class="comment">/*s1大于s2*/</span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,!r); //输出是一， </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,r);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明-1">说明</h3><ol type="1"><li>该函数是按字节比较的：当s1,s2为字符串时</li></ol><ul><li><p><code>memcmp(s1,s2,1)</code>就是比较s1和s2的第一个字节的ascII码值；</p></li><li><p><code>memcmp(s1,s2,n)</code>就是比较s1和s2的前n个字节的ascII码值；</p><p>例如:</p></li></ul><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> *s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *s2=<span class="string">&quot;acd&quot;</span>;</span><br><span class="line">&gt;<span class="type">int</span> r=<span class="built_in">memcmp</span>(s1,s2,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>​比较s1和s2的前3个字节，第一个字节相等，第二个字节比较中大小已经确定，不必继续比较第三字节了所以<spanclass="math display">\[r=-1\]</span>.</p></blockquote><ol start="2" type="1"><li><p>对于<code>memcmp()</code>，如果两个字符串相同而且<code>count</code>大于字符串长度的话，<code>memcmp</code>不会在<code>\0</code>处停下来，会继续比较<code>\0</code>后面的内存单元，直到<code>_res</code>不为零或者达到<code>count</code>次数。</p><p>例如：</p></li></ol><blockquote><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> a1[]=<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">  <span class="type">char</span> a2[]=<span class="string">&quot;ABCD&quot;</span>;</span><br></pre></td></tr></table></figure></p><p>对于<code>memcmp(a1,a2,10)</code>，<code>memcmp</code>在两个字符串的<code>\0</code>之后继续比较。所以，如果想使用memcmp比较字符串，要保证count不能超过最短字符串的长度，否则结果有可能是错误的。</p></blockquote><h2 id="memcpy">memcpy</h2><h3 id="头文件-6">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="声明">声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>str1</strong> --指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li><li><strong>str2</strong> -- 指向要复制的数据源，类型强制转换为 void*指针。</li><li><strong>n</strong> -- 要被复制的字节数。</li></ul><p><strong>返回值：</strong></p><ul><li>该函数返回一个指向目标存储区 str1 的指针。</li></ul><h3 id="作用-6">作用</h3><p>​ 从存储区 <strong>str2</strong> 复制 <strong>n</strong>个字节到存储区 <strong>str1</strong></p><h3 id="实例">实例</h3><ul><li>将字符串复制到数组 dest 中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="keyword">sizeof</span> src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest = http://www.runoob.com</span><br></pre></td></tr></table></figure><ul><li>将 s 中第 11 个字符开始的 6个连续字符复制到 d 中：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(d, s + <span class="number">11</span>, <span class="number">6</span>); <span class="comment">// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob)</span></span><br><span class="line">    <span class="comment">// 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));</span></span><br><span class="line">    d[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob</span><br></pre></td></tr></table></figure><ul><li>覆盖原有部分数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;***&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 前: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 后: %s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 memcpy 前: abcdefg</span><br><span class="line">使用 memcpy 后: ***defg</span><br></pre></td></tr></table></figure><h2 id="strcmp">strcmp</h2><h3 id="头文件-7">头文件</h3><p><code>#include &lt;cstring&gt;</code></p><h3 id="作用-7">作用</h3><p>​ 比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较</p><h3 id="原型-2">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>第一个字符串大于第二个字符串，则返回大于 0 的数字</li><li>第一个字符串<font color='red'><strong>等于</strong></font>第二个字符串，则返回<font color='red'><strong>0</strong></font></li><li>第一个字符串小于第二个字符串，则返回小于 0 的数字</li></ul><h3 id="举例-4">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* p1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p2 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p4 = <span class="string">&quot;bcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1,p2 ));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p1,p3 ));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(p3,p4 ));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="new">new</h2><h3 id="作用-8">作用</h3><p><code>new()</code>使计算机开辟一块内存空间，并返回<strong>内存空间的首地址</strong></p><h3 id="格式">格式</h3><ol type="1"><li><p>使用new函数创建变量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType;</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建变量并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> <span class="built_in">ElementType</span>(val);</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size];</span><br></pre></td></tr></table></figure></p></li><li><p>使用new函数创建数组并赋值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElementType *p = <span class="keyword">new</span> ElementType[size]&#123;&#125;;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="说明-2">说明</h3><ol type="1"><li>new开辟的空间在堆上，而一般声明的变量存放在栈上</li><li><strong><font color='red'>通常用new函数代替malloc函数</font></strong></li><li>new不需要头文件</li><li>使用 new 函数之后要<strong><font color='red'>使用 delete函数释放内存空间</font></strong></li></ol><h3 id="举例-5">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">example1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 可以在new后面直接赋值 */</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 也可以单独赋值 */</span></span><br><span class="line">    <span class="comment">// int *p = new int;</span></span><br><span class="line">    <span class="comment">// *p = 3;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">example2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 用new创建数组 */</span></span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">/* 也可以依次赋值 */</span></span><br><span class="line">    <span class="comment">// int *q = new int[3];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        q[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *st = <span class="keyword">new</span> <span class="built_in">student</span>(&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">student *<span class="title">example4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里是用一个结构体指针接住结构体数组的首地址</span></span><br><span class="line">    <span class="comment">// 对于结构体指针，个人认为目前这种赋值方法比较方便</span></span><br><span class="line">    student *stlist = <span class="keyword">new</span> student[<span class="number">3</span>]&#123;&#123;<span class="string">&quot;abc&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;bac&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="string">&quot;ccd&quot;</span>, <span class="number">93</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> e1 = <span class="built_in">example1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e1: &quot;</span> &lt;&lt; e1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *e2 = <span class="built_in">example2</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; e2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st1 = <span class="built_in">example3</span>();</span><br><span class="line">    cout &lt;&lt; st1-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st1-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    student *st2 = <span class="built_in">example4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        cout &lt;&lt; st2[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st2[i].score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e1: 3</span><br><span class="line">0 1 2</span><br><span class="line">abc 90</span><br><span class="line">abc 90</span><br><span class="line">bac 78</span><br><span class="line">ccd 93</span><br></pre></td></tr></table></figure><h2 id="swap">swap</h2><h3 id="作用-9">作用</h3><p><strong><code>swap(a,b);</code></strong>交换两个变量<strong><code>a,b</code></strong>的值</p><blockquote><p><strong><code>a,b</code></strong>可以是<strong><font color='red'>任何数据类型</font></strong></p></blockquote><h3 id="原型-3">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ElementType &amp;a, ElementType &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="举例-6">举例</h3><h4 id="例一">例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="例二">例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;ABCD&quot;</span>;     string b = <span class="string">&quot;function&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function ABCD</span><br></pre></td></tr></table></figure><h2 id="absfabs">abs/fabs</h2><h3 id="头文件-8">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-4">原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span></span><br></pre></td></tr></table></figure><h3 id="作用-10">作用</h3><ul><li><code>abs</code> 是对<strong>整数</strong>取绝对值</li><li><code>fabs</code> 是对<strong>浮点数</strong>取绝对值</li></ul><h2 id="sqrt">sqrt</h2><h3 id="头文件-9">头文件</h3><p><code>#include &lt;cmath&gt;</code></p><h3 id="原型-5">原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="作用-11">作用</h3><p><code>sqrt()</code> 用来求给定值的平方根</p><h3 id="常见错误">常见错误</h3><ol type="1"><li><strong>输出 36的开根号</strong></li></ol><ul><li><strong>错误写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152182.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><blockquote><p>忽略了sqrt()函数的返回值是 double型。导致出错</p></blockquote></blockquote><ul><li><strong>正确写法：</strong></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152197.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>常见的使用sqrt()函数的规范写法</strong> 例如:我们要判断一个数是不是质数，只需要判断 2 ~ n开根号之间有没有可以整除的数就可以了</p><ul><li><strong>错误写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法，其实并不推荐这样写。虽然我也经常这样写。但是在一次做题的过程中，就因为这样写程序出现了bug。我就改用下面的这种稳妥的写法了</p><ul><li><strong>正确写法</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.0*n的目的是——隐式转换成浮点数，开根号后再强制转换成整型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span> * n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse">reverse</h2><h3 id="头文件-10">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-12">作用</h3><p>反转在<strong><font color='red'> [ first,last )</font></strong>范围内的顺序（包括first指向的元素，不包括last指向的元素）</p><h3 id="原型-6">原型</h3><p><strong><code>void reverse (BidirectionalIterator first,BidirectionalIterator last);</code></strong></p><ul><li>参数first：待排区域的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排区域的<strong><font color='blue'>末尾地址</font></strong></li></ul><h3 id="举例-7">举例</h3><ul><li>反转<strong>向量</strong><font color='blue'><strong>vector</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//v的值为1,2,3,4,5</span></span><br></pre></td></tr></table></figure><ul><li>反转数组<strong><code>ElementType A[]</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[]=&#123;<span class="number">12</span>,<span class="number">-5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">19</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(A, A+<span class="number">6</span>);<span class="comment">//数组A为19,1,7,0,-5,12</span></span><br></pre></td></tr></table></figure><ul><li>反转<strong>字符串<font color='blue'>string</font></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;www.mathor.top&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());<span class="comment">//str结果为pot.rohtam.wwww</span></span><br></pre></td></tr></table></figure><h3 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="sort">sort</h2><h3 id="头文件-11">头文件</h3><p><strong><code>#include &lt;algorithm&gt;</code></strong></p><h3 id="作用-13">作用</h3><p>对==<strong><font color='red'>数组排序</font></strong>==</p><blockquote><ul><li>数组可以是<strong><code>ElementType A[]</code></strong>，也可以是<strong><code>vector &lt;ElementType&gt; A</code></strong><ul><li><strong><code>ElementType A[]</code></strong>：<strong><code>A</code></strong>表示<strong><font color='blue'>数组首地址</font></strong>，<strong><code>A+n</code></strong>表示<strong><font color='blue'>数组尾部</font></strong></li><li><strong><code>vector &lt;ElementType&gt; A</code></strong>：<strong><code>A.begin()</code></strong>和<strong><code>A.end()</code></strong>表示<strong><font color='blue'>头尾</font></strong></li></ul></li></ul></blockquote><h3 id="原型-7">原型</h3><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>默认</th><th><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last);</code></strong></th></tr></thead><tbody><tr class="odd"><td><strong>自定义</strong></td><td><strong><code>void sort(RandomAccessIterator first,RandomAccessIterator last,Compare comp);</code></strong></td></tr></tbody></table><ul><li>参数first：待排数组的<strong><font color='blue'>起始地址</font></strong></li><li>参数last：待排数组的<strong><font color='blue'>末尾地址</font></strong></li><li>参数comp：自定义排序方法<ul><li>如果第三个参数不写，则<strong>默认的排序方法</strong>是<strong><font color='red'>从小到大</font></strong>排序。</li></ul></li></ul><h3 id="举例-8">举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">// cmp函数返回的值是bool类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 从大到⼩排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">// 因为这里没有传入参数cmp，所以按照默认,v从小到大排列</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">10</span>, cmp); <span class="comment">// arr从大到小排列，因为cmp函数排序规则设置了从大到小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见cmp函数">常见cmp函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a,stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score!=b.score)</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.number&lt;b.number;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">return</span> a.score!=b.score ? a.score&gt;b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> node a,<span class="keyword">struct</span> node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height!=b.height ? a.height&gt;b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注： <strong><code>sort</code></strong> 函数的<strong><code>cmp</code></strong> 必须按照规定来写，即必须只是<strong><code>&gt;</code></strong> 或者<strong><code>&lt;</code></strong> ，比如：<strong><code>return a &gt; b;</code></strong> 或者<strong><code>return a &lt; b;</code></strong> 而不能是<strong><code>&lt;=</code></strong> 或者<strong><code>&gt;=</code></strong></p></blockquote><h2 id="find">find</h2><h3 id="头文件-12">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-14">作用</h3><p>​可以在<strong>任何容器</strong>中<strong>查找指定元素</strong>，返回一个迭代器指向<strong>第一个匹配</strong>的元素</p><ul><li><p>string、map、set有内置的成员方法find()，所以对于string、map、set的查找通常使用内置的find()方法</p></li><li><p>但是vector、queue没有内置的成员方法find()，他们通常使用<algorithm>头文件下通用的find()函数</p></li></ul><h3 id="参数">参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>first</strong> 和 <strong>last</strong>为输入迭代器，<strong>[first,last)</strong>用于指定该函数的查找范围</li><li><strong>val</strong>为要查找的目标元素</li></ul><h3 id="返回值">返回值</h3><p>​该函数返回一个<strong>迭代器</strong>，指向范围内搜索元素的<strong>第一次</strong>出现。如果没有找到目标元素，则返回<strong>last</strong></p><h3 id="例子">例子</h3><ul><li>在<code>vector</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element not found\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element found: 3</span><br></pre></td></tr></table></figure><ul><li>在<code>string</code>中查找指定字符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;This is a string&quot;</span>; <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  ^  ^  ^</span></span><br><span class="line"><span class="comment">                  1  2  3           */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始搜索字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到子串 is\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从首个位置开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从首个位置开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下标 5 开始寻找单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">find</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;从下标 5 开始搜索，在下标 %d 处找到字符 s\n&quot;</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>s.rfind()</code><strong>从左往右</strong>寻找、<code>s.lfind()</code><strong>从右往左</strong>寻找</p></blockquote><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从首个位置开始搜索，在下标 2 处找到子串 is</span><br><span class="line">从下标 5 开始搜索，在下标 5 处找到子串 is</span><br><span class="line">从首个位置开始搜索，在下标 3 处找到字符 s</span><br><span class="line">从下标 5 开始搜索，在下标 6 处找到字符 s</span><br></pre></td></tr></table></figure><ul><li>在<code>set</code>中查找指定元素：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法1：使用find方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">2</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 法2：使用count方法 */</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy">copy</h2><h2 id="unique">unique</h2><h3 id="头文件-13">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-15">作用</h3><p>​ <code>unique</code>可以对 <strong>vector</strong>容器内的元素去重</p><h3 id="原型-8">原型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator unique(vector&lt;int&gt; &amp;a);</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>vector&lt;int&gt;</code></li><li><strong>返回值</strong>：指向去重后<strong>最后一个元素</strong>的迭代器<code>vector&lt;int&gt;::iterator</code></li></ul><h3 id="底层原理">底层原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || a[i] != a[i - <span class="number">1</span>]) <span class="comment">// 如果是第一个元素或者该元素不等于前一个元素，即不重复元素，我们就把它存到数组前j个元素中</span></span><br><span class="line">            a[j++] = a[i];          <span class="comment">// 每存在一个不同元素，j++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j; <span class="comment">// 返回的是前j个不重复元素的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next_permutation">next_permutation</h2><h3 id="头文件-14">头文件</h3><p><code>#include &lt;algorithm&gt;</code></p><h3 id="作用-16">作用</h3><p>​<code>next_permutation</code>是求当前排列的下一个排列（按字典序升序的下一个序列），如1234的next_permutation 是1243，在<strong>全排列</strong>当中经常会用。</p><h3 id="参数-1">参数</h3><p>​和<code>sort</code>的参数一样，一般传两个参数，第一个是排列开始的地址，第二个是排列结束的下一个地址，如实现数组第1-3排列的下一个排列：<code>next_permutation(a,a+3)</code>。一般作用对象是数组。</p><h3 id="返回值-1">返回值</h3><p>​ 返回值是 <span class="math inline">\(Ture\)</span> 或者 <spanclass="math inline">\(False\)</span>，若当前排列有下一个排列，则返回Ture，反之返回False：如54321的返回值为False。该函数会直接修改数组为下一个排列。</p><h3 id="原理">原理</h3><ul><li>从后往前找原数组中第一个<code>a[i] &lt; a[i+1]</code>的地方，其后面全是降序，说明已经排好了，所以我们就要将a[i]的值改大一点</li><li>将a[i]和其后面所有数中大于他的最小的数交换位置，则a[i]后面的数仍是个降序</li><li>然后将其后面这些降序的元素翻转，就得到了原排列的下一个增序排列了</li></ul><blockquote><blockquote><p>例如：对于排列2431来说</p><p>①我们先找到2和4处</p><p>②然后交换2和3的位置，就得到了3421</p><p>③最后翻转421，就得到了3124，则3124就是2431的下一个排列，如下图。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403041152332.png"alt="eg" /><figcaption aria-hidden="true">eg</figcaption></figure></blockquote></blockquote><h3 id="全排列">全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><p><strong>示例 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:sunny:如果你希望生成所有的排列方式，一定要<strong>先将序列按升序排列</strong>，这里可以与sort函数结合起来使用，先用sort升序排列，再调用next_permutation函数。</p><h2 id="int_maxint_min">INT_MAX，INT_MIN</h2><h3 id="头文件-15">头文件</h3><p><strong><code>#include &lt;climits&gt;</code></strong></p><h3 id="介绍">介绍</h3><p>C中<strong>常量</strong><code>INT_MAX</code>和<code>INT_MIN</code>分别表示int类型的最大值和最小值</p><blockquote><ol type="1"><li>``` INT_MAX = 2^31-1 = 2147483647; INT_MIN = -2^31 = -2147483648;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 所有超过该限值的int类型变量，都会出现溢出，出现warning，但是并不会出现error。</span><br><span class="line"></span><br><span class="line">3. 如果想表示的整数超过了该限值，可以使用长整型long long （占8字节64位）表示。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">### 建议</span><br><span class="line"></span><br><span class="line">-   由于二进制编码按原码、补码和反码的规则进行运算，所有程序中对INT_MAX和INT_MIN的运算应当格外注意，在出现溢出的时候，不遵循数学规则：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">INT_MAX + 1 = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 = INT_MAX</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) = INT_MIN</span><br><span class="line"></span><br><span class="line">INT_MAX + 1 &lt; INT_MAX</span><br><span class="line"></span><br><span class="line">INT_MIN - 1 &gt; INT_MIN</span><br><span class="line"></span><br><span class="line">abs(INT_MIN) &lt; 0</span><br></pre></td></tr></table></figure></li></ol></blockquote><ul><li><p>建议在表示正负无穷时：</p><ul><li><p>使用 <code>2e9</code> 表示<strong>正无穷</strong></p></li><li><p><code>-2e9</code> 表示<strong>负无穷</strong></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e9</span>;</span><br></pre></td></tr></table></figure><h3 id="实例-1">实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX = %d\n&quot;</span>, INT_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN = %d\n&quot;</span>, INT_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MAX + 1 = %d\n&quot;</span>, INT_MAX + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INT_MIN - 1 = %d\n&quot;</span>, INT_MIN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;abs(INT_MIN) = %d\n&quot;</span>, <span class="built_in">abs</span>(INT_MIN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = 2147483647</span><br><span class="line">INT_MIN = -2147483648</span><br><span class="line">INT_MAX + 1 = -2147483648</span><br><span class="line">INT_MIN - 1 = 2147483647</span><br><span class="line">abs(INT_MIN) = -2147483648</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://blog.csdn.net/weixin_51635753/article/details/115434999?ops_request_misc=%7B%22request%5Fid%22%3A%22167049370716782414992762%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167049370716782414992762&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-21-115434999-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&amp;utm_term=C%2B%2B自带swap函数&amp;spm=1018.2226.3001.4187">(82条消息)C++ STL 常用函数_Mr.bei的博客-CSDN博客_c++stl常用函数</a></li><li><ahref="https://zh.cppreference.com/w/首页">cppreference.com</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《致谢》——黄国平</title>
      <link href="/2024/03/04/%5Bobject%20Object%5D/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/"/>
      <url>/2024/03/04/%5Bobject%20Object%5D/fighting/%E3%80%8A%E8%87%B4%E8%B0%A2%E3%80%8B%E2%80%94%E2%80%94%E9%BB%84%E5%9B%BD%E5%B9%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="致谢">致谢</h1><p>​<strong>我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天家人才团聚过。</strong></p><p>​出生在一个小山坳里，母亲在我十二岁时离家。父亲在家的日子不多，即便在我病得不能自己去医院的时候，也仅是留下勉强够治病的钱后又走了。我十七岁时，他因交通事故离世后，我哭得稀里糊涂，因为再得重病时没有谁来管我了。同年，和我住在一起的婆婆病故，真的无能为力。她照顾我十七年，下葬时却仅是一副薄薄的棺材。另一个家庭成员是老狗小花，为父亲和婆婆守过坟，后因我进城上高中而命不知何时何处所终。如兄长般的计算机启蒙老师■■没能看到我的大学录取通知书，对我照顾有加的师母也在不惑之前匆匆离开人世。<strong>每次回去看他们，这一座座坟茔都提示着生命的每一分钟都弥足珍贵。</strong></p><p>​<strong>人情冷暖，生离死别，固然让人痛苦与无奈，而贫穷则可能让人失去希望。</strong>家徒四壁，在煤油灯下写作业或者读书都是晚上最开心的事。如果下雨，保留节目就是用竹笋壳塞瓦缝防漏雨。高中之前的主要经济来源是夜里抓黄鳝、周末钓鱼、养小猪崽和出租水牛。那些年里，方圆十公里的水田和小河都被我用脚测量过无数次。被狗和蛇追，半夜落水，因蓄电瓶进水而摸黑逃回家中：学费没交，黄鳍却被父亲偷卖了，然后买了肉和酒，都是难以避免的事。</p><span id="more"></span><p>​<strong>人后的苦尚旦还能克服，人前的尊严却无比脆弱。</strong>上课的时候，因拖欠学费而经常被老师叫出教室约谈。雨天湿漉着上课，屁股后面说不定还是泥。夏天光着脚走在滚烫的路上。冬天穿着破旧衣服打着寒颤穿过那条长长的过道领作业本。这些都可能成为压垮骆驼的最后一根稻草。如果不是考试后常能从主席台领奖金，顺便能贴一墙奖状满足最后的虚荣心，我可能早已放弃。</p><p>​<strong>身处命运的旋涡，耗尽心力去争取那些可能本就是稀松平常的东西，每次转折都显得那么的身不由己。幸运的是，命运到底还有一丝怜惜。</strong>进入高中后,学校免了全部学杂费，■■■一家帮助解决了生活费。进入大学后，计算机终于成了我一生的事业与希望，胃溃疡和胃出血也终与我作别。</p><p>​我很庆幸保研时选择了自动化所，感谢研究生部的老师们将我从别的部门调剂到模式识别实验室，感谢导师宗成庆老师选择了我，宗老师将我引入了科学研究的大门，博士这五年无疑是我过去最幸福的时光。惭愧的是，离宗老师的期望显然还有很远的距离，我也知道本可以做得更好。这一段经历已经成为我这一生值得回味的美好瞬间之一。我很喜欢人机交互式机器翻译这个题目，但也仅开了个头。在未来，希望能有机会弥补这段遗憾。</p><p>​从家出发坐大巴需要两个半小时才能到县城，一直盼着走出大山。从炬光乡小学、大寅镇中学、仪陇县中学、绵阳市南山中学，到重庆的西南大学，再到中科院自动化所，我也记不清有多少次因为现实的压力而觉得自己快扛不下去了。<strong>这一路，信念很简单。把书念下去，然后走出去，不枉活一世。世事难科，未来注定还会面对更为复杂的局面。但因为有了这些点点滴滴，我已经有勇气和耐心面对任何困难和挑战。理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。</strong></p><p>​ 最近这些年，特别感谢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■重塑了我的人生。</p><p>​感谢■■■老师和■■■老师为我的研究提出诸多建设性的意见和建议。与他们的交流过程中，我也被他们坦诚为人、踏实做事的处事风格所感染。感谢所有和我一起在课题组工作的老师们和学习的同学们：■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■、■■■。我们在研究上共同努力，互相学习，如亲兄弟姐妹一般谈笑风生。不论大家将来在何处，我想我们都不会忘记这些年一起度过的时光。感谢课题组■■■女士，感谢模式识别综合办实验室的■■■、■■■和■■■等老师，感谢研究生部的■■■、■■■、■■■和■■■等老师，他们为我的学习和工作给予了极大的帮助。这会成为我日后工作的动力，希望最后能成为课题组值得骄傲的学生。</p><p>​感谢父母给了我生命，感谢婆婆和叔辈对我的抚养，感谢■■■■■■■■■■■■■■■■■■对我的牵挂，感谢■■■和■■■对我的支持，感谢一路上让我生活变得美好或者不那么美好的人和事。</p><p>​ 最后，对参加论文评审、答辩的各位老师表示衷心的感谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> fighting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基本算法】</title>
      <link href="/2024/03/03/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%91/"/>
      <url>/2024/03/03/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序">快速排序</h1><h2 id="模板">模板</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403260909414.png"alt="image-20240306185054453" /><figcaption aria-hidden="true">image-20240306185054453</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// q[l...j] 均 &lt;=x , q[j...r] 均 &gt;=x</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不要轻易改动，非常容易出错</p></blockquote><span id="more"></span><blockquote><ul><li><p><strong>分界点的位置不一定是<code>x</code></strong>，因为<code>x</code>参与交换之后仍然会被留在左右区间中的一个里</p></li><li><p>这里考虑一个边界问题，为什么移动i和j指针的条件是q[i] &lt; x和q[j]&gt; x，而不是q[i] &lt;= x和q[j] &gt;= x ？</p><p>——因为如果选取的x是数组里最大的数，那么一直都满足q[i] &lt;=x，所以i会一直++发生越界都不会停下来。同理，如果选取的x是数组里最小的数，那么一直都满足q[j]&gt;= x，所以j会一直--发生越界都不会停下来</p></li><li><p>指针i和j初始化为数组两侧外一个元素，即i = l - 1，j = r +1，然后在数组中使用do-while循环每次先进行一次指针的移动，再去看循环条件。这里考虑一个边界问题，为什么不能让i= l和j = r然后使用while循环代替do-while循环 ？</p></li></ul><p>——因为如果数组中存在重复的数字，那么某一轮可能存在i和j都指向重复的数字，并且划分数字x也是这个数字，那么while(q[i] &lt; x)和while (q[j] &gt; x)判断不成立不会进入，又因为q[i] = q[j]=x，交换它们之后这个局面仍然不会改变，从而陷入死循环。所以要使用do-while循环，确保每次两个指针都至少会移动一步，以保证上一次交换的结果能被走掉</p><p><ahref="https://blog.csdn.net/SHU15121856/article/details/109839618">【算法学习笔记】8：快速排序中的边界问题_快速排序分界点-CSDN博客</a></p></blockquote><h2 id="例题">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7946447/">AcWing785. 快速排序 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7963364/">AcWing786. 第k个数 - AcWing</a></p></li></ul><h1 id="归并排序">归并排序</h1><h2 id="模板-1">模板</h2><ul><li>[ L , R ] =&gt; [ L , mid ] , [ mid + 1 , R ]</li><li>递归排序 [ L , mid ] 和 [ mid + 1 , R]</li><li>归并，将左右 2 个有序序列合并成 1 个有序序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> q[N], temp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归排序 [ L , mid ] 和 [ mid + 1 , R]</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并，将左右 2 个有序序列合并成 1 个有序序列</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j])<span class="comment">// 此处也可以是 &lt; ,但在某些情况下只能是 &lt;=</span></span><br><span class="line">            tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7946634/">AcWing787. 归并排序 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7962764/">AcWing788. 逆序对的数量 - AcWing</a></p></li></ul><h1 id="二分">二分</h1><ul><li>只要一个序列满足在某一<font color='red'>分割点</font><strong>左侧满足性质A</strong>，<strong>右侧满足性质B</strong>，就可以使用二分求出这个边界</li></ul><h2 id="整数二分">整数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403260942345.jpeg"alt="57ac86165a5b843d61595f2983a9be5" /><figcaptionaria-hidden="true">57ac86165a5b843d61595f2983a9be5</figcaption></figure><p>:smile:具体使用时：</p><ul><li>首先确定性质A、性质B、我们要求的是 <strong>满足性质A的边界</strong>or <strong>满足性质B的边界</strong></li><li>然后编写check函数，<code>mid = l + r &gt;&gt; 1</code><ul><li>求满足性质A的边界：<ul><li>check(mid满足性质A) <code>l=mid</code></li><li>check(mid不满足性质A) <code>r=mid-1</code></li><li>改为<code>mid = l + r + 1 &gt;&gt; 1</code></li></ul></li><li>求满足性质B的边界：<ul><li>check(mid满足性质B) <code>r=mid</code></li><li>check(mid不满足性质B) <code>l=mid+1</code></li></ul></li></ul></li></ul><p>:tada:注意</p><ul><li>二分的循环的条件是<code>i &lt; j</code>，当<code>l = r</code>时，循环结束，返回<code>l</code></li><li>所有用到二分思想的算法，循环条件都是<strong>小于</strong>，而不是<strong>小于等于</strong></li></ul><p>🌮技巧</p><ul><li>上述模板<strong>题目</strong>需要保证<strong>边界一定存在</strong>，否则就会出错，具体而言：<ul><li>如果我们求的是满足<strong>左侧性质A</strong>的边界，但是区间<code>[l,r]</code>均不满足性质A，那么就会返回区间的<strong>最左侧端点<code>l</code></strong></li><li>如果我们求的是满足<strong>右侧性质B</strong>的边界，但是区间<code>[l,r]</code>均不满足性质B，那么就会返回区间的<strong>最右侧端点<code>r</code></strong></li></ul></li><li>因此，如果题目<strong>不能确保边界一定存在</strong>，我们有 2种处理办法</li></ul><ol type="1"><li><p><strong>二分结束后进行判断</strong>【推荐】</p><ol type="1"><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质A</strong>的边界，但是返回的边界不满足<strong>性质A</strong>（<code>check(l)</code>返回<code>false</code>），说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质A</strong>的边界</li><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质B</strong>的边界，但是返回的边界不满足<strong>性质B</strong>（<code>check(l)</code>返回<code>false</code>），说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质B</strong>的边界</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="built_in">bsearch</span>(l, r);</span><br><span class="line"><span class="keyword">if</span>(l &lt;= r &amp;&amp; <span class="built_in">check</span>(k))</span><br><span class="line"><span class="comment">/* k为边界 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 不存在边界 */</span></span><br></pre></td></tr></table></figure></li><li><p>在<strong>二分开始前设置哨兵</strong>【不推荐】</p><ol type="1"><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>左侧性质A</strong>的边界，则设置哨兵a[l-1]，随便赋值使<code>a[l-1]</code>满足性质A，然后将搜索区间改为<code>[l-1,r]</code>，这样当<code>返回边界=l-1</code>时，说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质A</strong>的边界</li><li>如果我们要在区间<code>[l,r]</code>找到满足<strong>右侧性质B</strong>的边界，则设置哨兵a[l-1]，随便赋值使<code>a[r+1]</code>满足性质B，然后将搜索区间改为<code>[l,r+1]</code>，这样当<code>返回边界=r+1</code>时，说明区间<code>[l,r]</code><strong>不存在</strong>满足<strong>性质B</strong>的边界</li></ol></li></ol><h2 id="浮点数二分">浮点数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>; <span class="comment">// eps 表示精度，取决于题目对精度的要求，通常比题目精度高2位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-2">例题</h2><h3 id="整数二分-1">整数二分</h3><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7945110/">AcWing789. 数的范围 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8318785/">AcWing3745. 牛的学术圈 I（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8332805/">AcWing1227. 分巧克力（蓝桥杯辅导课） - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/binary-search/description/">704.二分查找 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-a-2d-matrix/description/">74.搜索二维矩阵 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240.搜索二维矩阵 II - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34.在排序数组中查找元素的第一个和最后一个位置 -力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33.搜索旋转排序数组 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">153.寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p></li></ul><h3 id="浮点数二分-1">浮点数二分</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7945336/">AcWing790. 数的三次方根 - AcWing</a></li></ul><h1 id="高精度">高精度</h1><ul><li>当数据过大时，此时longlong存储不下，因此需要使用vector或者数组存储，然后计算</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261025399.jpeg" alt="8147590f449a6d0077d9bd05a829853" style="zoom: 33%;" /></p><blockquote><ul><li>对于两个高精度数相乘/相除很少见，在此不予阐述</li><li>高精度数采用<strong>数组</strong>、从<font color='purple'><strong>个位向高位</strong></font>依次存储</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261025407.jpeg" alt="7f7747b40d2f813ace3c448acb250a5" style="zoom: 25%;" /></p><ul><li><p>一般vector或者数组中每个数据都是一个int，<strong>如果每个位置只是存储0~9一位数字的话，比较浪费空间，并且计算也会变慢</strong>。因此可以让每个位置存储连续的多位数字，这被称作<font color='red'><strong>压位</strong></font></p></li><li><p>压位和不压位的高精度计算存在三点不同点（以下提到的压位都是压4位）：</p><ol type="1"><li>存储：不压位的话，vector或者数组中每个数据是0 ~9；压位以后，每个数据是0 ~ 9999</li><li>计算过程：不压位的话，除数和模数都是10；压位以后，除数和模数都是10000</li><li>输出：不压位的话，直接输出；压位的话，需要格式化输出，<strong>最高位直接输出</strong>，<strong>其他位都需要输出4位数字，不足的前面补零</strong></li></ol></li><li><p>高精度<strong>加减</strong>法<strong>最多可以压 9位</strong>，高精度<strong>乘除</strong>法<strong>最多可以压 4位</strong>，这里为了演示，均以压4位为例，也就是说：vector或者数组中每个位置存储四个连续的数字</p></li></ul></blockquote><h2 id="高精度加法">高精度加法</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7947226/">AcWing791. 高精度加法 - AcWing</a>】</li></ul><h3 id="不压位">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % M);</span><br><span class="line">        t /= M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        B.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><ul><li>【<strong>模板题：<ahref="https://www.acwing.com/activity/content/code/content/7947515/">AcWing792. 高精度减法 - AcWing</a>】</strong></li></ul><h3 id="不压位-1">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>(); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(A, B);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位-1">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 比较a, b大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())</span><br><span class="line">            t -= B[i];</span><br><span class="line"></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + M) % M);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        B.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(b.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(A, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘低精度">高精度乘低精度</h2><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7947712/">AcWing793. 高精度乘法 - AcWing</a>】</li></ul><h3 id="不压位-2">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位-2">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % M);</span><br><span class="line">        t /= M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除以低精度">高精度除以低精度</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7947725/">AcWing794. 高精度除法 - AcWing</a></li></ul><h3 id="不压位-3">不压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位-3">压位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>, M = <span class="number">1e4</span>; <span class="comment">// 压4位, 改这里注意同时需要该输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * M + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = <span class="built_in">max</span>(<span class="number">0</span>, i - N + <span class="number">1</span>), len = i - st + <span class="number">1</span>;</span><br><span class="line">        A.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(a.<span class="built_in">substr</span>(st, len)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C.<span class="built_in">back</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, C[i]);</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前缀和差分">前缀和&amp;&amp;差分</h1><ul><li><p><strong>前缀和</strong> 与 <strong>差分</strong>是一对<font color='red'><strong>逆运算</strong></font></p><ul><li>前缀和最用：求某一区域/区间 的和</li><li>差分作用：将某一区域/区间内的数全部<strong>加上/减去指定数值</strong></li></ul></li><li><p>差分序列通常<strong>不需要构建</strong>：</p><ul><li>将<strong>前缀和序列</strong>、<strong>差分序列</strong>均初始化为0（满足前缀和定义）</li><li>然后将原始数据<strong>依次插入</strong>前缀和序列，即可自动更新差分序列</li></ul></li><li><p><font color='red'><strong>原始数据 a[ ]，前缀和 S[ ]，差分序列 B[] 都是从下标 1 开始存储的</strong></font></p></li><li><p><strong>原数据 <code>a[]</code></strong>与<strong>前缀和<code>S[]</code></strong>，<strong>原数据<code>a[]</code></strong>与<strong>差分序列<code>B[]</code></strong>没有实时联动关系，<strong>对某一数组操作以后需要通过手动操作同步</strong></p></li></ul><h2 id="前缀和">前缀和</h2><h3 id="一维前缀和">一维前缀和</h3><ul><li><strong>定义：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">0</span>] = <span class="number">0</span>, S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i](<span class="number">1</span> &lt;= i &lt;= n)</span><br></pre></td></tr></table></figure><ul><li><strong>性质：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[i] = S[i - <span class="number">1</span>] + a[i]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[l] + ... + a[r] = S[r] - S[l - 1]</span><br></pre></td></tr></table></figure><blockquote><p>切记：前缀和 S 从下标 1 开始，S[0] = 0 用来解决边界问题</p></blockquote><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7948798/">AcWing795. 前缀和 - AcWing</a>】</li></ul><p><strong>注意</strong>：给定一个长度为 <spanclass="math inline">\(n\)</span> 的数列{<spanclass="math inline">\(a_1,a_2,…,a_n\)</span>}，每次选择一个区间<code>[l, r]</code>，计算下标在这个区间内的数之和，则这个操作对应的<font color ='red'><strong>前缀和序列 <spanclass="math inline">\(S\)</span> 的下标范围是<code>[0, n]</code></strong></font></p><h3 id="二维前缀和">二维前缀和</h3><ul><li><strong>定义：</strong></li></ul><p><span class="math display">\[S\left[ x \right] \left[ y \right] =\sum_{i=1}^x{\sum_{j=1}^y{a\left[ i\right] \left[ j \right]}}\]</span></p><ul><li><strong>性质：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]</span><br></pre></td></tr></table></figure><p>​ 以 <span class="math inline">\((x1, y1)\)</span> 为左上角， <spanclass="math inline">\((x2, y2)\)</span> 为右下角的子矩阵的和为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S[x2, y2] - S[x2, y1 - <span class="number">1</span>] - S[x1 - <span class="number">1</span>, y2] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032157.png" alt="image-20240305172624211" style="zoom: 15%;" /></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7949245/">AcWing796. 子矩阵的和 - AcWing</a>】</li></ul><h3 id="例题-3">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8303325/">AcWing562. 壁画（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8308107/">AcWing99. 激光炸弹（算法提高课） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8306422/">AcWing1230. K倍区间（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="差分">差分</h2><h3 id="一维差分">一维差分</h3><ul><li><strong>定义：</strong>【不用记，用不到】</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i] = a[i] - a[i - <span class="number">1</span>](<span class="number">1</span> &lt;= i &lt;= n)</span><br></pre></td></tr></table></figure><blockquote><p>切记：原始序列 a 从下标 1 开始，a[0] = 0 用来解决边界问题</p></blockquote><ul><li><strong>性质：</strong><code>a[]</code>是<code>B[]</code>的前缀和，<code>B[]</code>是<code>a[]</code>的差分，所以：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i] = B[<span class="number">1</span>] + B[<span class="number">2</span>] + ... B[i]</span><br><span class="line">a[i] = a[i - <span class="number">1</span>] + B[i]</span><br></pre></td></tr></table></figure><p>:smile:以上​实际上是前缀和的定于与性质</p><ul><li><strong>操作：</strong>给区间 <span class="math inline">\([l,r]\)</span> 中的每个数加上 <span class="math inline">\(c\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[l] += c;</span><br><span class="line">    B[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7949620/">AcWing797. 差分 - AcWing</a>】</li></ul><p><strong>注意</strong>：给定一个长度为 <spanclass="math inline">\(n\)</span> 的数列{<spanclass="math inline">\(a_1,a_2,…,a_n\)</span>}，每次可以选择一个区间<code>[l, r]</code>，使下标在这个区间内的数都加 <spanclass="math inline">\(1\)</span> 或者都减 <spanclass="math inline">\(1\)</span>，则这个操作对应的<font color ='red'><strong>差分序列<span class="math inline">\(B\)</span>的下标范围是 <code>[1, n + 1]</code></strong></font></p><h3 id="二维差分">二维差分</h3><ul><li><strong>定义：</strong>【不用记，用不到】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B[i][j] = a[i][j] - a[i - <span class="number">1</span>][j] - a[i][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>性质：</strong><code>a[][]</code>是<code>B[][]</code>的前缀和，<code>B[][]</code>是<code>a[][]</code>的差分，因此：</li></ul><p><span class="math display">\[a\left[ i \right] \left[ j \right] =\sum_{i=1}^n{\sum_{j=1}^m{B\left[ i\right] \left[ j \right]}}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j] = a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>] + B[i][j];</span><br></pre></td></tr></table></figure><p>:smile:以上实际上是前缀和的定于与性质</p><ul><li><strong>操作：</strong>给以(x1, y1)为左上角，(x2,y2)为右下角的子矩阵中的所有元素加上c：</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032057.png" alt="20201217174836198.png" style="zoom:30%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B[x1][y1] += c;</span><br><span class="line">    B[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261032099.png"alt="20201217170336254.png" /><figcaption aria-hidden="true">20201217170336254.png</figcaption></figure><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7954891/">AcWing798. 差分矩阵 - AcWing</a>】</li></ul><h3 id="例题-4">例题</h3><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8275142/">AcWing100. 增减序列 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8271772/">AcWing4262. 空调（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8281066/">AcWing5396. 棋盘（蓝桥杯辅导课） - AcWing</a></li></ul><h1 id="双指针">双指针</h1><h2 id="模板-2">模板</h2><ul><li><p>双指针的主要<strong>作用</strong>是 ——<strong>优化时间复杂度</strong>，通常可以将时间复杂度从 <spanclass="math inline">\(O(n^2)\)</span> 优化到 <spanclass="math inline">\(O(n)\)</span></p></li><li><p>可以从朴素思想开始，思考两个指针是否具有某种性质，eg：<strong>分类：</strong></p></li></ul><ol type="1"><li>对于<strong>一个序列</strong></li></ol><ul><li>2 个指针一前一后【快慢指针】，用两个指针维护一段区间，2个指针<strong>均只能向前移动</strong>，而不能向后移动</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312109496.png"alt="image-20240331210906340" /><figcaption aria-hidden="true">image-20240331210906340</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 快指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动慢指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= i &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 慢指针 j 移动后的操作【必须在 j++ 前面】 */</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描，<spanclass="math inline">\(j\)</span> 指针<strong>从后往前</strong>扫描</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312117865.png"alt="image-20240331211703704" /><figcaption aria-hidden="true">image-20240331211703704</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 指针 j 移动后的操作 */</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>对于<strong>两个序列</strong>，2 个指针分别指向 2个序列，维护某种次序</li></ol><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描 <span class="math inline">\(A\)</span>序列，<span class="math inline">\(j\)</span>指针<strong>从后往前</strong>扫描 <span class="math inline">\(B\)</span>序列</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312055114.png"alt="image-20240331205557944" /><figcaption aria-hidden="true">image-20240331205557944</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 指针 i 移动后的操作 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否可以移动指针 j</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">/* 指针 j 移动后的操作*/</span></span><br><span class="line">        j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><span class="math inline">\(i\)</span>指针<strong>从前往后</strong>扫描 <span class="math inline">\(A\)</span>序列，<span class="math inline">\(j\)</span>指针<strong>从后往前</strong>扫描 <span class="math inline">\(B\)</span>​序列</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403312057578.png"alt="image-20240331205747366" /><figcaption aria-hidden="true">image-20240331205747366</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i 指针移动后的操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否要移动 j 指针</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(i, j))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* j 指针移动后的操作 */</span></span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 具体问题的逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>举例：分行输出字符串</strong></li></ul><p>​给你一个字符串，请将其中的每个单词依次输出（假设字符串开头没有空格，且单词之间有且仅有一个空格）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">            cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-5">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7957914/">AcWing799. 最长连续不重复子序列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7958047/">AcWing800. 数组元素的目标和 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/7958255/">AcWing2816. 判断子序列 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8318785/">AcWing3745. 牛的学术圈 I（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8323692/">AcWing1238. 日志统计（蓝桥杯辅导课） - AcWing</a></p></li><li><p><a href="https://leetcode.cn/problems/3sum/description/">15.三数之和 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/container-with-most-water/description/">11.盛最多水的容器 - 力扣（LeetCode）</a></p></li></ul><h1 id="位运算">位运算</h1><h2 id="模板-3">模板</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261639341.jpg"alt="aa5212f8f0993c186015d618c0e496e" /><figcaptionaria-hidden="true">aa5212f8f0993c186015d618c0e496e</figcaption></figure><ul><li>求 <span class="math inline">\(x\)</span> 二进制的第 <spanclass="math inline">\(k\)</span> 位数字：<ol type="1"><li>先把第 <span class="math inline">\(k\)</span> 位移到最后一位 <spanclass="math inline">\(x&gt;&gt;k\)</span></li><li>看个位是几 <span class="math inline">\(x \&amp; 1\)</span></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt;&gt; k &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>返回 <span class="math inline">\(x\)</span> 的最后一位1：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lowbit</span>(x) = x &amp; -x</span><br></pre></td></tr></table></figure><p><span class="math display">\[x=\left( 1010 \right) _2\Rightarrow lobit\left( x \right) =\left( 10\right) _2\\x=\left( 101000 \right) _2\Rightarrow lobit\left( x \right) =\left( 1000\right) _2\]</span></p><blockquote><p>最常见的应用：统计某个二进制数中 1 的个数</p></blockquote><ul><li>将 x 乘以 <span class="math inline">\(2^k\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;&lt; k</span><br><span class="line"><span class="comment">// eg: 2^k 可以表示为 2 &lt;&lt; k</span></span><br></pre></td></tr></table></figure><h2 id="例题-6">例题</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/7958394/">AcWing801. 二进制中1的个数 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8279228/">AcWing90. 64位整数乘法 - AcWing</a></p></li><li><p><ahref="https://leetcode.cn/problems/single-number/description/">136.只出现一次的数字 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/subsets/description/">78.子集 - 力扣（LeetCode）</a></p></li></ul><h1 id="离散化">离散化</h1><h2 id="模板-4">模板</h2><ul><li><p>本质：建立了<strong>一段数列</strong>到<strong>自然数</strong>之间的映射关系（value-&gt;index)，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作（比如二分，前缀和等…）</p></li><li><p>离散化首先需要排序去重：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 排序：sort(alls.begin(),alls.end())</span><br><span class="line"><span class="number">2.</span> 去重：alls.earse(unique(alls.begin(),alls.end()),alls.end());    </span><br></pre></td></tr></table></figure><ul><li>适用条件：<font color='red'><strong>值域 ＞</strong></li><li>** 个数**</font></li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261049242.png" alt="image-20240306123731542" style="zoom: 25%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls;                                         <span class="comment">// 存储所有【待离散化的值】</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());                           <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-7">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7958787/">AcWing802. 区间和 - AcWing</a></li></ul><h1 id="区间合并">区间合并</h1><h2 id="模板-5">模板</h2><ul><li>将所有存在交集的区间合并</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261048486.png" alt="image-20240306142625082" style="zoom: 25%;" /></p><ul><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/7960049/">AcWing803. 区间合并 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模板一：需要返回【合并后的区间】 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span> <span class="comment">// segments线段</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模板二：只需要返回合并后的区间的数量、长度等等 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">PII segs[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间合并</span></span><br><span class="line">    <span class="built_in">sort</span>(segs, segs + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右端点初始化为【负无穷】</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; segs[i].first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始的[-无穷，-无穷]区间要跳过，不能装入</span></span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">                <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">            st = segs[i].first, ed = segs[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ed = <span class="built_in">max</span>(ed, segs[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最后一个区间</span></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>)</span><br><span class="line">        <span class="comment">/* 题目的具体逻辑 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-8">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8282539/">AcWing1343. 挤牛奶（每日一题） - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8287992/">AcWing422. 校门外的树 - AcWing</a></li></ul><h1 id="贡献法">贡献法</h1><p>​<strong>贡献法</strong>：从<strong>枚举</strong>的思路改为每个元素能<strong>为总和贡献</strong>多少，跟贪心一样是一种思想，没有固定的模板和套路，只能因题而异。</p><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8277974/">AcWing4261. 孤独的照片（每日一题） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8280953/">AcWing2868. 子串分值（蓝桥杯辅导课） - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/problem/content/9742/">AcWing5154. 牛的基因学 - AcWing</a></p></li></ul><h1 id="递归与递推">递归与递推</h1><ul><li>递归的关键在于寻找<strong>顺序</strong>，能够<strong>不重不漏地搜素出所有方案</strong></li><li>所有的<strong>递归</strong>都可以表示成一棵<strong>递归搜索树</strong></li></ul><p>以斐波那契序列为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法 1:</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">0</span>, f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br></pre></td></tr></table></figure><blockquote><p>参考</p><ul><li><ahref="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法- AcWing</a></li><li><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/6489818/">论递归算法的数学原理- AcWing</a></li></ul></blockquote><h2 id="简单运用">简单运用</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404091421258.png"alt="image-20240409142141963" /><figcaption aria-hidden="true">image-20240409142141963</figcaption></figure><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8338997/">AcWing92. 递归实现指数型枚举 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8345534/">AcWing93. 递归实现组合型枚举 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8342624/">AcWing94. 递归实现排列型枚举 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8345157/">AcWing95. 费解的开关 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8333433/">AcWing1360. 有序分数（每日一题） - AcWing</a></p></li></ul><h2 id="分治">分治</h2><p>​分治法把一个问题划分为若干个规模更小的同类子问题，对这些子问题递归求解然后在回溯时通过它们推导出原问题的解。</p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8351803/">AcWing97. 约数之和 - AcWing</a></li></ul><h1 id="推公式">推公式</h1><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8320617/">AcWing4956. 冶炼金属（蓝桥杯辅导课） - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/01/%5Bobject%20Object%5D/project/"/>
      <url>/2024/03/01/%5Bobject%20Object%5D/project/</url>
      
        <content type="html"><![CDATA[<h1 id="result">Result</h1><h2 id="baseline">baseline：</h2><ul><li><a href="https://arxiv.org/abs/1602.05629">FedAvg</a> (Hugh BrendanMcMahan et al., AISTATS 2017)</li><li><a href="https://arxiv.org/abs/2007.07481">FedNova</a> (Jianyu Wanget al., NeurIPS 2020) <ahref="https://github.com/JYWa/FedNova">:octocat:</a></li><li><a href="https://arxiv.org/abs/1812.06127">FedProx</a> (Tian Li etal., MLSys 2020) <ahref="https://github.com/litian96/FedProx">:octocat:</a></li><li><a href="https://arxiv.org/abs/1910.06378">SCAFFOLD</a> (SaiPraneeth Karimireddy et al.,ICML 2020) <ahref="https://github.com/ki-ljl/Scaffold-Federated-Learning">:octocat:</a></li></ul><h2 id="数据集">数据集</h2><ul><li>MNIST</li><li>Fashion-MNIST</li></ul><h2 id="模型">模型</h2><ul><li>LeNet</li><li>AlexCifarNet</li><li>ResNet18/34/50/101/152</li><li>CNN</li></ul><span id="more"></span><h2 id="可视化">可视化</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091907015.png"alt="image-20240309190716897" /><figcaption aria-hidden="true">image-20240309190716897</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091908515.png"alt="image-20240309190826462" /><figcaption aria-hidden="true">image-20240309190826462</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091909686.png"alt="image-20240309190936633" /><figcaption aria-hidden="true">image-20240309190936633</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403091910062.png"alt="image-20240309191039009" /><figcaption aria-hidden="true">image-20240309191039009</figcaption></figure><p>for(int i = 0; i &lt;= n; i++)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【搜索】</title>
      <link href="/2024/02/29/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91/"/>
      <url>/2024/02/29/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="内外部搜索">内/外部搜索</h1><p>搜索有 <span class="math inline">\(2\)</span> 大类</p><ol type="1"><li><strong>内部搜索</strong>：把棋盘中的<strong>每个格子</strong>当作一个<strong>点</strong>，从<strong>棋盘内</strong>中的<strong>一个点</strong>搜索到<strong>另一个点</strong>——不需要恢复现场</li><li><strong>外部搜索</strong>：把<strong>整个棋盘</strong>当作一个<strong>点</strong>，从<strong>一个棋盘状态</strong>搜索到<strong>另一个棋盘状态</strong><ol type="1"><li>在<strong>棋盘现场/点</strong>上直接操作，需要<strong>恢复现场</strong></li><li>拷贝<strong>棋盘现场/点</strong>，然后在<strong>棋盘现场/点的副本</strong> 上操作，不需要恢复现场</li></ol></li><li>是否需要回溯的关键在于——<code>st[][]</code>表示的这个<strong>状态/点</strong>能否被<font color = 'red'><strong>其他DFS分支</strong></font>搜索到，或者说<code>st[][]</code>表示的这个<strong>状态/点</strong>是否只能被访问1 次</li></ol><blockquote><p>只有可行性路径搜索(最优性也是需要的因为他还要搜其他路)和连通性的dfs不需要恢复现场,其他的dfs题都写吧~</p></blockquote><ol type="1"><li>例题：<ul><li><a href="#BFS_最小步数模型">BFS_最小步数模型</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7993461/">AcWing842. 排列数字 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/7994793/">AcWing843. n-皇后问题 - AcWing</a></li></ul></li></ol><ul><li></li></ul><blockquote><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/9210858/">dfs什么时候需要恢复现场- AcWing</a></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404041541544.png"alt="image-20240404154110448" /><figcaption aria-hidden="true">image-20240404154110448</figcaption></figure><h1 id="连通性模型flood_fill">连通性模型/Flood_FIll</h1><ol type="1"><li><p>搜索之<strong>连通性模型</strong>，即 <spanclass="math inline">\(Flood_Fill\)</span> 洪水覆盖算法，有 <spanclass="math inline">\(DFS\)</span>、<spanclass="math inline">\(BFS\)</span> 两种实现方式</p><ul><li><p><span class="math inline">\(DFS\)</span> 代码简短，但是 <spanclass="math inline">\(DFS\)</span>只能求出<strong>是否连通</strong>，无法求出<strong>最短距离</strong>，且<span class="math inline">\(DFS\)</span>存在<strong>爆栈</strong>的风险；</p></li><li><p><span class="math inline">\(BFS\)</span> 代码略长，但是<spanclass="math inline">\(BFS\)</span>既能求出<strong>是否连通</strong>，又能求出<strong>最短距离</strong>，且不存在爆栈风险</p></li></ul></li><li><p><strong>适用题目</strong>：求<strong>连通块</strong></p></li><li><p><strong>技巧</strong>：进行<strong>不同方向的搜索</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4 联通</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 联通</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y +<span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == t.x &amp;&amp; j == t.y)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/* ...... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟中国象棋中的“马”</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="dfs">DFS</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8291582/">AcWing1112. 迷宫 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8292209/">AcWing1113. 红与黑 - AcWing</a></li></ul><h2 id="bfs">BFS</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8236928/">AcWing1097. 池塘计数 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8263353/">AcWing1106. 山峰和山谷 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8262814/">AcWing1098. 城堡问题 - AcWing</a></li></ul><h1 id="bfs-1">BFS</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403300912028.png" alt="image-20240330091250874" style="zoom: 25%;" /></p><ul><li><span class="math inline">\(BFS\)</span>通常用于<strong>求最小</strong></li><li><span class="math inline">\(BFS\)</span> 基于<strong>迭代</strong>，<span class="math inline">\(DFS\)</span>基于<strong>递归</strong>，递归相较于迭代需要更多的时间和空间，因此<font color = 'red'><strong>能用<span class="math inline">\(BFS\)</span> 我们通常不用 <spanclass="math inline">\(DFS\)</span></strong></font></li><li><spanclass="math inline">\(BFS\)</span>过程中，如果要<strong>加判断</strong>进行<strong>剪枝</strong>，只能在<font color = 'blue'><strong>入队前</strong></font>（2处代码）/<font color = 'blue'><strong>出队后</strong></font>（1处代码）判断</li><li><code>st[][]</code>必须在<strong>入队后</strong>标记为<strong>已访问</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">PII q[M]; <span class="comment">// 注意：队列大小要开 N * N</span></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  入队前加判断 */</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++tt] = &#123;sx, sy&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始值为 -1，表示未访问</span></span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q[hh++];</span><br><span class="line">        <span class="comment">/*  出队后加判断 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; n &amp;&amp; !st[a][b] &amp;&amp; ...)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*  入队前加判断 */</span></span><br><span class="line">                q[++tt] = &#123;a, b&#125;;</span><br><span class="line">                st[a][b] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路模型">最短路模型</h2><ul><li><strong>要求</strong>：<strong>边权</strong>都<font color ='red'><strong>相等</strong></font>且<font color ='red'><strong>大于<span class="math inline">\(0\)</span></strong> </font></li><li><strong>注意：</strong><ul><li><strong>最短距离</strong>：使用<code>dist[][]</code>存储距离<strong>源点</strong>的最短距离，同时充当<code>st[]</code>的作用</li><li><strong>记路径找前驱</strong>：使用<code>pre[][]</code>记录搜索路径，同时充当<code>st[]</code>的作用</li></ul></li></ul><h3 id="单源bfs">单源BFS</h3><p><strong>适用题目</strong>：求棋盘内的点 到<strong>一个起点</strong>的<strong>最短路径</strong></p><ul><li><ahref="https://www.acwing.com/activity/content/code/content/7996829/">AcWing844. 走迷宫 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8269590/">AcWing1076. 迷宫问题 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8269663/">AcWing188. 武士风度的牛 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8270123/">AcWing1100. 抓住那头牛 - AcWing</a></li></ul><h3 id="多源bfs">多源BFS</h3><ul><li><p><strong>适用题目</strong>：求棋盘内的点 到<strong>多个起点</strong>路径中的<strong>最短路径</strong></p></li><li><p><strong>关键</strong>：<strong>初始时</strong>将<font color = 'red'><strong>所有源点</strong></font>先<strong>入队</strong>，然后进行正常的BFS 即可</p></li><li><p><ahref="https://www.acwing.com/file_system/file/content/whole/index/content/11676142/">AcWing173. 矩阵距离 - AcWing</a></p></li></ul><h2 id="最小步数模型"><a id="BFS_最小步数模型">最小步数模型</a></h2><ul><li><p><strong>适用题目</strong>：一个<strong>局面</strong> 变成<strong>另一个局面</strong> 所需的最少<strong>操作步数</strong></p></li><li><p><strong>关键</strong>：【<strong>外部搜索</strong>】把<strong>局面</strong>看作<strong>点</strong>，把<strong>操作</strong>看作<strong>边</strong></p></li><li><p><strong>难点</strong>：如何将<strong>局面</strong>抽象为<strong>点</strong>（将<strong>局面</strong>通过<strong>变量</strong>唯一确定下来）</p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8218005/">AcWing845. 八数码 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8284313/">AcWing1107. 魔板 - AcWing</a></p></li></ul><h2 id="双端队列广搜">双端队列广搜</h2><h2 id="双向bfs">双向BFS</h2><h2 id="a">A*</h2><p>搜索</p><ul><li>内部搜索——不需要回溯</li><li>外部搜索——需要回溯</li></ul><h1 id="dfs-1">DFS</h1><p>全局变量统计合法方案数</p><h2 id="搜索顺序">搜索顺序</h2><ul><li><p><ahref="https://www.acwing.com/activity/content/code/content/8295785/">AcWing1116. 马走日 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8299052/">AcWing1117. 单词接龙 - AcWing</a></p></li><li><p><ahref="https://www.acwing.com/activity/content/code/content/8303209/">AcWing1118. 分成互质组 - AcWing</a></p></li></ul><h2 id="剪枝与优化">剪枝与优化</h2><h2 id="迭代加深">迭代加深</h2><h2 id="双向dfs">双向DFS</h2><h2 id="ida">IDA*</h2><ul><li><p><ahref="https://leetcode.cn/problems/word-search/description/">79.单词搜索 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/rotting-oranges/">994.腐烂的橘子 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/generate-parentheses/description/">22.括号生成 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/combination-sum/">39.组合总和 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17.电话号码的字母组合 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&amp;envId=top-100-liked">78.子集 - 力扣（LeetCode）</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Tag】</title>
      <link href="/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90tag%E3%80%91/"/>
      <url>/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90tag%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="tag">Tag</h1><h2 id="二分差分">二分+差分</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8212454/">AcWing503. 借教室（每日一题） - AcWing</a></li></ul><h2 id="二分合并区间">二分+合并区间</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8305828/">AcWing5407. 管道（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="二分前缀和">二分+前缀和</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8335344/">AcWing102. 最佳牛围栏（算法提高课） - AcWing</a></li></ul><h2 id="差分贪心">差分+贪心</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8281317/">AcWing4655. 重新排序（蓝桥杯辅导课） - AcWing</a></li></ul><h2 id="双指针前缀和">双指针+前缀和</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8304518/">AcWing4405. 统计子矩阵（蓝桥杯辅导课） - AcWing</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图论】</title>
      <link href="/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91/"/>
      <url>/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树与图的存储">树与图的存储</h1><ul><li>树是一种特殊的图，与图的存储方式相同<ul><li>树：<span class="math inline">\(n\)</span> 个顶点，最多有 <spanclass="math inline">\(m=n-1\)</span> 条边</li><li>图：<span class="math inline">\(n\)</span> 个顶点，无向图最多有<span class="math inline">\(m=n(n-1)/2\)</span> 条边，有向图最多有 <spanclass="math inline">\(m=n(n-1)\)</span> 条边<ul><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span>是一个量级的——<strong>稀疏图</strong></li><li>如果 <span class="math inline">\(m\)</span> 和 <spanclass="math inline">\(n^2\)</span>​是一个量级的——<strong>稠密图</strong></li></ul></li></ul></li></ul><blockquote><p>eg：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稠密图</span></span><br><span class="line"><span class="number">1</span> ≤ n ≤ <span class="number">500</span>,</span><br><span class="line"><span class="number">1</span> ≤ m ≤ <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="comment">// 稀疏图</span></span><br><span class="line"><span class="number">1</span> ≤ n,m ≤ <span class="number">10</span>^<span class="number">5</span>,</span><br></pre></td></tr></table></figure></p></blockquote><span id="more"></span><ul><li>对于无向图中的边ab，存储两条有向边 <code>a-&gt;b</code>,<code>b-&gt;a</code> 即可。因此我们可以只考虑有向图的存储</li></ul><h2 id="邻接矩阵">邻接矩阵</h2><ul><li><p><code>g[a][b]</code> 存储边 <code>a-&gt;b</code></p></li><li><p><strong>空间复杂度</strong>：<spanclass="math inline">\(O(n^2)\)</span>，适合存储<strong>稠密图</strong></p></li></ul><h3 id="无权图">无权图</h3><ul><li><strong>自己到自己的边长</strong>以及<strong>不存在的边长</strong>均为 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b</span></span><br><span class="line">g[a][b] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span>(g[a][b])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有权图">有权图</h3><ul><li><strong>自己到自己的边长</strong>以及<strong>不存在的边长</strong>均为 <code>INF</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化邻接矩阵</span></span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边 a-&gt;b，权重为c</span></span><br><span class="line">g[a][b] = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断节点 a , b 之间是否有边</span></span><br><span class="line"><span class="keyword">if</span> (g[a][b] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有边的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有边的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表">邻接表</h2><ul><li><p>除非题目交代为稠密图，我们更常用<strong>邻接表</strong></p></li><li><p><strong>空间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span>，适合存储<strong>稀疏图</strong></p></li></ul><h3 id="无权图-1">无权图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有权图-1">有权图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点 k，开一个单链表，存储 k 所有可以走到的点。</span></span><br><span class="line"><span class="comment">// h[k] 存储这个单链表的头结点, w[] 存储边的权重</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b,权重为c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><ul><li>自环、重边</li></ul><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101605409.jpeg" style="zoom:20%;" /></p><h1 id="树与图的遍历">树与图的遍历</h1><ul><li><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>连通图遍历时只需要遍历任何一个点即可，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(1);</span><br><span class="line">bfs(1);</span><br></pre></td></tr></table></figure></li><li><p>非连通图遍历时要依次遍历所有点，确保能够遍历所有连通分量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">bfs</span>(i);</span><br></pre></td></tr></table></figure></li><li><p><code>st[]</code>数组的作用：标记顶点是否<strong>已经被BFS/DFS扫描过</strong></p></li></ul><h2 id="深度优先遍历">深度优先遍历</h2><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>树</strong>的 dfs 可以<strong>不用</strong><code>st[]</code></li><li><strong>图</strong>的 dfs <strong>必须使用</strong><code>st[]</code></li></ul><h2 id="宽度优先遍历">宽度优先遍历</h2><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// 表示 u 号点已经被遍历过</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (!st[j])</span><br><span class="line">            &#123;</span><br><span class="line">                st[j] = <span class="literal">true</span>; <span class="comment">// 表示点 j 已经被遍历过</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<font color ='red'><strong>入队</strong></font>的时候对<code>st[]</code>标记</li><li><strong>树</strong>的 bfs 可以<strong>不用</strong><code>st[]</code></li><li><strong>图</strong>的 bfs <strong>必须使用</strong><code>st[]</code></li></ul><blockquote><p><strong>注意：</strong>这里的 st 可以有以下2种作用</p><ol type="1"><li>【必备】记录节点 i 是否已被访问</li><li>【可选】记录子问题的解（类似 DP问题中的<code>dp[]</code>），此时通常在<code>dfs()</code> /<code>bfs()</code>最前面加一句<code>memset(st,-1,sizeof st);</code></li></ol></blockquote><h2 id="例题">例题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8006099/">AcWing846. 树的重心 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8007322/">AcWing847. 图中点的层次 - AcWing</a></li></ul><h1 id="拓扑排序">拓扑排序</h1><ul><li>理论表明：<font color='red'><strong>有向无环图</strong></font>一定有拓扑排序（拓扑图又叫<font color='red'><strong>有向无环图</strong></font>）</li><li>时间复杂度：<span class="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8010400/">AcWing848. 有向图的拓扑序列 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临界矩阵存储</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// d[i] 存储点 i 的入度</span></span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始时：所有入度为零的点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 t 的所有出边，并更新入度d[], 队列q[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图的同时初始化 d[]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y);</span><br><span class="line">    d[y]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在拓扑排序，输出-1；否则输出其中的一个拓扑排序</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">toposort</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路">最短路</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101426248.png"alt="image-20240310110004460" /><figcaption aria-hidden="true">image-20240310110004460</figcaption></figure><h2 id="朴素dijkstra算法">朴素Dijkstra算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131123733.png"alt="image-20240313112344516" /><figcaption aria-hidden="true">image-20240313112344516</figcaption></figure><ul><li>时间复杂度：<span class="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>朴素Dijkstra算法适合于<strong>稠密图</strong>：采用<strong>邻接矩阵</strong>存储</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8010586/">AcWing849. Dijkstra求最短路 I - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每循环一次,就会找到一条最短路径,循环n-1次,最后一个的dist一定也是最短的，当然你写n也是完全没问题的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明最短路不存在（即非连通图）</span></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆优化版dijkstra">堆优化版dijkstra</h2><ul><li>时间复杂度：<span class="math inline">\(O(mlogn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span>​ 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8046169/">AcWing850. Dijkstra求最短路 II - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                            <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bellman-ford算法">Bellman-Ford算法</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131128358.png" alt="image-20240313112833199" style="zoom:33%;" /></p><ul><li>如果图中存在负权回路，最短路<strong>不一定</strong>存在<ul><li>如果负环不在从 1 号点到 n 号点的路径上的话，就没有影响</li><li>如果题目限制了<strong>最短路边的个数</strong>（即不能无限转），则一定存在最短路径</li></ul></li><li>Bellman-Ford算法迭代 k 次，dist[]表示从1号点，经过<font color='red'><strong>不超过k条边</strong></font>，走到每个点的最短距离</li><li>Bellman-Ford算法可以判断图中是否存在负权回路<ul><li>迭代 n 次，第 n次仍有最短距离更新的话，说明存在一条边数为n的最短路径</li><li>n 个点最多有 n-1 条边，所以一定存在一个负权回路</li></ul></li><li>时间复杂度：<span class="math inline">\(O(nm)\)</span>​</li></ul><blockquote><p><strong><font color='red'>由于 Bellman-Ford算法只需要在每次循环中，对所有边进行遍历，因此我们可以采用结构体数组存储边的集合即可，不需要存储图</font></strong></p></blockquote><h3 id="有边数限制的bellman-ford算法">有边数限制的Bellman-Ford算法</h3><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8048290/">AcWing853. 有边数限制的最短路 - AcWing</a>】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, k;   <span class="comment">// n表示点数，m表示边数，k表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N];   <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="type">int</span> backup[N]; <span class="comment">// back[x]存储上次循环中，1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边，a表示出点，b表示入点，c表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 k 次，最短路最多经历 k 条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>last[]</code>是备份数组，用于存储上次迭代的结果，用上次迭代的结果更新当前的距离，防止发生串联</p></li><li><p>为什么需要使用 <code>last[]</code> ?</p></li></ul><blockquote><p>​ 为了避免如下的串联情况，在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452123.png" alt="2.PNG" style="zoom:45%;" /></p><p>​ 正确做法是用上轮节点2更新的距离--无穷大，来更新节点3，再取最小值，所以节点3离起点的距离是3。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131452285.png" alt="3.PNG" style="zoom:45%;" /></p></blockquote><ul><li><p>为什么是<code>dist[n] &gt; 0x3f3f3f3f/2</code>，而不是<code>dist[n] &gt; 0x3f3f3f3f</code></p><blockquote><p>​ 5 号节点距离起点的距离是无穷大，利用 5 号节点更新 n号节点距离起点的距离，将得到<spanclass="math inline">\(10^9-2\)</span>，虽然小于<spanclass="math inline">\(10^9\)</span>，但并不存在最短路(在边数限制在k条的条件下)</p></blockquote></li></ul><h3id="没有边数限制的bellman-ford算法">没有边数限制的Bellman-Ford算法</h3><ul><li>实际上是“有边数限制的Bellman-Ford算法”的特殊情况，这是的边数限制是 n，但是不需要使用 backup 数组，因为最短路上最多也就是 n个顶点，即使串联也没关系</li><li>可以用于判读是否存在负权路</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;    <span class="comment">// n表示点数，m表示边数，k表示最短路最多经过 k 条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边，a表示出点，b表示入点，c表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第 n 次迭代仍然会松弛三角不等式，就说明存在一条长度是 n+1 的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], dist[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spfa-算法">spfa 算法</h2><p>​ spfa算法是<strong>队列优化</strong>的<strong>Bellman-Ford</strong>算法</p><h3 id="求最短路">求最短路</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131416112.png"alt="image-20240313141627490" /><figcaption aria-hidden="true">image-20240313141627490</figcaption></figure><ul><li>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</li><li>Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是<font color='red'><strong>SPFA算法不可以存在负权回路</strong></font>，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</li><li>时间复杂度：<ul><li>平均情况下 <span class="math inline">\(O(m)\)</span></li><li>最坏情况下 <span class="math inline">\(O(nm)\)</span>​</li></ul></li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8050444/">AcWing851. spfa求最短路 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];                      <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">// 从队列中取出来之后该节点st被标记为false，之后该节点如果发生更新可再次入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>⭐️为什么 Bellman_ford 算法里最后 <code>return -1</code>的判断条件写的是 <code>dist[n] &gt; 0x3f3f3f3f/2</code>，而 spfa算法写的是<code>dist[n]==0x3f3f3f3f</code>？</li></ul><blockquote><p>​原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p></blockquote><ul><li>st数组的作用是什么？</li></ul><blockquote><p>​判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。</p></blockquote><ul><li>SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</li></ul><blockquote><ol type="1"><li>Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。</li><li>Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</li></ol></blockquote><ul><li>由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为<spanclass="math inline">\(O(nm)\)</span>，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)</li></ul><h3 id="判断负环">判断负环</h3><ul><li><p><strong>求负环一般使用SPFA算法</strong>，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环</p></li><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8051410/">AcWing852. spfa判断负环 - AcWing</a>】</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;                            <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];              <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的边数</span></span><br><span class="line"><span class="type">bool</span> st[N];                       <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组（因为如果存在负环，那么dist不管初始化为多少，都会被更新）</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么把所有点入队?</li></ul><blockquote><p>​我们可以假设一个虚拟源点0点，从虚拟源点连一条权值是0的边到所有点，这样这个新图其实是和原图等价的（原图上有负环等价于新图上有负环），那我们做spfa的时候首先把0入队，第一次迭代的时候会把0出队，然后把和0点相连的点全部入队，那么就相当于把1~n的所有点入队，所以我们直接把所有点入队，效果是一样的，相当于自己手动迭代了一次spfa.</p></blockquote><ul><li>dist[]为什么初始化为什么值都无所谓？</li></ul><blockquote><p>​假设有负环，那么负环上的点到虚拟源点0的距离一定是-INF对不对，因为我可以在负环上跑无限次，每次都能把我到0点的距离减小。然后因为边上的权值都是有限值，所以每次在负环上跑一圈就相当于dt[]减去一个有限值，最终dt[]==-INF，所以意味着会减无限次（简单明了的说就是我们在负环上跑无限次，就可以把我到0点的距离减成-INF）。重点来了，dt[]初值肯定是一个有限值，一个有限值每次减一个有限值（负环上跑一次），然后减无限次，最终dt[]减成-INF。即dt[]初值是多少都无所谓，因为会减无限次有限值，你再大的数减无限次有限值肯定减成-INF。我们只要用抽屉原理保证迭代超过n次的时候，说明路径上有起码n+1个点，说明有重复点，即有负环就行。所以我们甚至可以把判断条件改为cnt[j]&gt; 99999都行，只要大于n。</p></blockquote><h2 id="floyd算法">Floyd算法</h2><ul><li>Floyd算法的原理是<strong>动态规划</strong>，在代码实现的时候省去了一维状态。<ul><li><p><code>f[i, j, k]</code>：从<code>i</code>走到<code>j</code>的路径上除了<code>i</code>、<code>j</code>以外不包含点<code>k</code>的所有路径的最短距离</p></li><li><p>```c f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k- 1] <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -   因此在计算第`k`层的`f[i, j]`的时候必须先将第`k - 1`层的所有状态计算出来，所以需要把`k`放在最外层</span><br><span class="line"></span><br><span class="line">-   `d[i][j]`</span><br><span class="line"></span><br><span class="line">    -   含义：**&lt;font color=&#x27;red&#x27;&gt;从【顶点i 】到 【顶点j】 的最短路径长度&lt;/font&gt;**`</span><br><span class="line">    -   初值：</span><br><span class="line">        -   `d[i][i] = 0`【Caution!】</span><br><span class="line">        -   若 a -&gt; b 存在一条边，权重为 c，则 `d[a][b] = c`</span><br><span class="line">        -   其余的 `d[i][i] = INF`</span><br><span class="line"></span><br><span class="line">-   **时间复杂度**：$O(n+m)$ ，$n$ 表示点数，$m$​ 表示边数</span><br><span class="line"></span><br><span class="line">-   先循环 `k` ，再循环 `i` 、 `j`（ `i` 、 `j` 顺序可以颠倒），每层循环遍历所有的顶点，下面的模板顶点编号从 1 开始。如果顶点编号从 0 开始，每层循环从 `0 -&gt; n - 1` 即可</span><br><span class="line"></span><br><span class="line">-   【**模板题：**[AcWing 854. Floyd求最短路 - AcWing](https://www.acwing.com/activity/content/code/content/8055095/)】</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">// 初始化</span><br><span class="line">memset(d, 0x3f, sizeof d);</span><br><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    d[i][i] = 0;</span><br><span class="line"></span><br><span class="line">// 算法结束后，d[a][b]表示 a 到 b 的最短距离</span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for (int k = 1; k &lt;= n; k++)</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)</span><br><span class="line">            for (int j = 1; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><h1 id="最小生成树">最小生成树</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131944187.png"alt="image-20240313194446005" /><figcaption aria-hidden="true">image-20240313194446005</figcaption></figure><ul><li>最小生成树是针对无向图的</li><li><strong>连通图</strong>一定存在最小生成树</li><li><strong><span class="math inline">\(n\)</span></strong>个顶点的无向连通图，最小生成树的边数为 <strong><spanclass="math inline">\(n - 1\)</span></strong></li></ul><h2 id="prim算法">Prim算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131953561.png"alt="image-20240313195326359" /><figcaption aria-hidden="true">image-20240313195326359</figcaption></figure><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n^2+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8055703/">AcWing858. Prim算法求最小生成树 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;       <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];  <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF, 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[t] == INF)</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal算法">Kruskal算法</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403132026795.png" alt="image-20240313202628601" style="zoom: 33%;" /></p><ul><li><p>Kruskal算法使用到了<strong>并查集</strong></p></li><li><p><strong><font color='red'>由于 Kruskal算法只需要在每次循环中，对所有边进行遍历，因此我们可以采用结构体数组存储边的集合即可，不需要存储图</font></strong></p></li><li><p><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mlogm)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</p></li><li><p>【<ahref="https://www.acwing.com/activity/content/code/content/8056398/">AcWing859. Kruskal算法求最小生成树 - AcWing</a>】</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m; <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; W.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集核心操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(edges, edges + m, [](Edge x, Edge y)</span><br><span class="line">         &#123; <span class="keyword">return</span> x.c &lt; y.c; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res表示最小生成树的权重之和，cnt表示最小生成树集合中边的数量</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, c = edges[i].c;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += c;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的数量小于n-1，说明图是非连通图，不存在最小生成树</span></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分图">二分图</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403131944501.png"alt="image-20240313194459355" /><figcaption aria-hidden="true">image-20240313194459355</figcaption></figure><ul><li>二分图当且仅当<font color='red'><strong>图中不含奇数环</strong></font></li><li>二分图不一定是连通图</li></ul><h2 id="判断是否为二分图染色法">判断是否为二分图——染色法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> i 未染色</span><br><span class="line">        dfs(i, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(n+m)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8056401/">AcWing860. 染色法判定二分图 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;                   <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];               <span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数：u表示当前节点，c表示当前点的颜色 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">// u 点染成颜色 c</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 相邻的点没有颜色,则递归处理这个相邻点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="comment">// （3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）</span></span><br><span class="line">                                <span class="comment">// （3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="comment">// 如果已经染色，判断颜色是否为 c</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 作用：染色法判断是否为二分图 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二分图不一定是连通图，所以要依次对每个点遍历判断，而不能直接 dfs(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>)) <span class="comment">// 第一次染色的一定是某个连通分量中的第一个点，所以染成颜色 1/2 都可以，然后调用dfs即可将其所在连通分量的所以点染色</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="求二分图的最大匹配匈牙利算法">求二分图的最大匹配——匈牙利算法</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403141306955.gif"alt="匈牙利算法" /><figcaption aria-hidden="true">匈牙利算法</figcaption></figure><ul><li>第一个集合表示男生，第二个集合表示女生</li><li>匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</li><li><strong>时间复杂度</strong>：<spanclass="math inline">\(O(mn)\)</span> ，<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数</li><li>【<strong>模板题：</strong><ahref="https://www.acwing.com/activity/content/code/content/8060126/">AcWing861. 二分图的最大匹配 - AcWing</a>】</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;                 <span class="comment">// n1表示第一个集合中男生人数，n2表示第二个集合中女生人数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];               <span class="comment">// match[i]表示第二个集合中点i当前匹配的第一个集合中的点</span></span><br><span class="line"><span class="type">bool</span> st[N];                 <span class="comment">// 表示第二个集合中的每个点是否已经被考虑过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果妹子还没有匹配任何男生 或者 匹配的那个男生可以更换妹子</span></span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="comment">// 第一个集合中的点i能找到对应的匹配</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i))</span><br><span class="line">        res++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【贪心】</title>
      <link href="/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/"/>
      <url>/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="区间问题">区间问题</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8193086/">AcWing905. 区间选点 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8201655/">AcWing908. 最大不相交区间数量 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8200554/">AcWing906. 区间分组 - AcWing</a></li><li><ahref="https://www.acwing.com/activity/content/code/content/8203105/">AcWing907. 区间覆盖 - AcWing</a></li></ul><h2 id="huffman算法">Huffman算法</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206166/">AcWing148. 合并果子 - AcWing</a></li></ul><h2 id="排序不等式">排序不等式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206351/">AcWing913. 排队打水 - AcWing</a></li></ul><h2 id="绝对值不等式">绝对值不等式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8206765/">AcWing104. 货仓选址 - AcWing</a></li></ul><h2 id="推公式">推公式</h2><ul><li><ahref="https://www.acwing.com/activity/content/code/content/8208811/">AcWing125. 耍杂技的牛 - AcWing</a></li></ul><h2 id="其他">其他</h2><ul><li><p><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机 - 力扣（LeetCode）</a></p></li><li><p><a href="https://leetcode.cn/problems/jump-game/description/">55.跳跃游戏 - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/jump-game-ii/description/">45.跳跃游戏 II - 力扣（LeetCode）</a></p></li><li><p><ahref="https://leetcode.cn/problems/word-break/description/">139.单词拆分 - 力扣（LeetCode）</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准记号与常用函数</title>
      <link href="/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E6%A0%87%E5%87%86%E8%AE%B0%E5%8F%B7%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2024/02/28/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E6%A0%87%E5%87%86%E8%AE%B0%E5%8F%B7%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="标准记号与常用函数">标准记号与常用函数</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071215513.png"alt="image-20240407121507444" /><figcaption aria-hidden="true">image-20240407121507444</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071215300.png"alt="image-20240407121531163" /><figcaption aria-hidden="true">image-20240407121531163</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071215981.png"alt="image-20240407121551813" /><figcaption aria-hidden="true">image-20240407121551813</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071216738.png"alt="image-20240407121617613" /><figcaption aria-hidden="true">image-20240407121617613</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071216418.png"alt="image-20240407121635279" /><figcaption aria-hidden="true">image-20240407121635279</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071217988.png"alt="image-20240407121705853" /><figcaption aria-hidden="true">image-20240407121705853</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071217817.png"alt="image-20240407121730692" /><figcaption aria-hidden="true">image-20240407121730692</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071217159.png"alt="image-20240407121748074" /><figcaption aria-hidden="true">image-20240407121748074</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404071218169.png"alt="image-20240407121822048" /><figcaption aria-hidden="true">image-20240407121822048</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2024/02/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
      <url>/2024/02/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="轮转数组"><ahref="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h2><p>​ 给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="除自身以外数组的乘积"><ahref="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h2><p>​ 给你一个整数数组 <code>nums</code>，返回 <em>数组<code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code>中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><ul><li><p>题目数据 <strong>保证</strong> 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32位</strong> 整数范围内。</p></li><li><p>请 <strong>不要使用除法，</strong> 且在 <code>O(*n*)</code>时间复杂度内完成此题。</p></li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析</span></span><br><span class="line"><span class="comment">1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]</span></span><br><span class="line"><span class="comment">2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1. 从左往右遍历，记录左边所有数字的乘积 v[i]=v[0]×v[1]×...×v[i-1]  */</span></span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            v[i] = v[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 从右往左遍历，记录右边所有数字的乘积 right , v[i]*=right */</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right = right * nums[i + <span class="number">1</span>];</span><br><span class="line">            v[i] *= right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵</title>
      <link href="/2024/02/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/"/>
      <url>/2024/02/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="矩阵置零"><ahref="https://leetcode.cn/problems/set-matrix-zeroes/">矩阵置零</a></h2><p>​ 给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为<strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong>。请使用 <strong><ahref="http://baike.baidu.com/item/原地算法">原地</a></strong> 算法</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403270920185.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403270920199.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>​我们可以用<strong>两个标记数组</strong>分别记录<strong>每一行和每一列是否有零出现</strong>。具体地：</p><ol type="1"><li>我们首先遍历该数组一次，如果某个元素为 0，那么就将该元素所在的行和列所对应标记数组的位置置为<code>true</code></li><li>最后我们再次遍历该数组，用标记数组更新原数组即可</li></ol><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n)</span>, <span class="title">col</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                    row[i] = col[j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j])</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩阵旋转">矩阵旋转</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code>表示一个图像。请你将图像顺时针旋转 90 度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402241658478.png"alt="image-20240224165826279" /><figcaption aria-hidden="true">image-20240224165826279</figcaption></figure><p><strong>分析：</strong></p><p>原地旋转90度：</p><ol type="1"><li><p>沿主对角线所有元素交换</p></li><li><p>沿着垂直中轴线方向所有元素交换</p></li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/* 1.沿主对角线所有元素交换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2.沿着垂直中轴线方向所有元素交换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[i][n - <span class="number">1</span> - j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="螺旋矩阵">螺旋矩阵</h2><h3 id="螺旋矩阵-pat"><ahref="https://pintia.cn/problem-sets/994805260223102976/exam/problems/994805275146436608?type=7&amp;page=0">螺旋矩阵-PAT</a></h3><p>​ 本题要求将给定的 <em>N</em>个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 <em>m</em> 行<em>n</em> 列，满足条件：<em>m</em>×<em>n</em> 等于<em>N</em>；<em>m</em>≥<em>n</em>；且 <em>m</em>−<em>n</em>取所有可能值中的最小值。</p><p><strong>输入格式：</strong></p><p>输入在第 1 行中给出一个正整数 <em>N</em>，第 2 行给出 <em>N</em>个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。</p><p><strong>输出格式：</strong></p><p>输出螺旋矩阵。每行 <em>n</em> 个数字，共 <em>m</em> 行。相邻数字以 1个空格分隔，行末不得有多余空格。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">37 76 20 98 76 42 53 95 60 81 58 93</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">98 95 93</span><br><span class="line">42 37 81</span><br><span class="line">53 20 76</span><br><span class="line">58 60 76</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>填充时按层数填充，一个包裹矩阵的口字型为一层，计算螺旋矩阵的层数<code>level</code></li><li>如果 m 的值为偶数，层数为<code>m / 2</code>，如果 m为奇数，层数为<code>m / 2 + 1</code>，所以<code>level = m / 2 + m % 2</code></li><li>因为是从左上角第 1 个格子开始，按顺时针螺旋方向填充，所以外层 for循环控制层数 i 从 0 到 level，内层 for循环按左上到右上、右上到右下、右下到左下、左下到左上的顺序一层层填充，注意内层for循环中还要控制<code>t &lt;= N – 1</code>，因为如果螺旋矩阵中所有的元素已经都填充完毕，就不能再重复填充～</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402261637178.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">         &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算m、n</span></span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">for</span> (n = (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="built_in">double</span>(N)); n &gt;= <span class="number">1</span>; n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N % n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m = N / n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵赋值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">b</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> level = m / <span class="number">2</span> + m % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; N; j++)</span><br><span class="line">            b[i][j] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; N; j++)</span><br><span class="line">            b[j][n - <span class="number">1</span> - i] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - i - <span class="number">1</span>; j &gt;= i &amp;&amp; t &lt; N; j--)</span><br><span class="line">            b[m - <span class="number">1</span> - i][j] = a[t++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; N; j--)</span><br><span class="line">            b[j][i] = a[t++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j != n - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-i"><ahref="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵 I</a></h3><p>​ 给你一个 <code>m</code> 行 <code>n</code> 列的矩阵<code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252318668.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252318904.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(m * n)</span></span>;</span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">max</span>(m, n) / <span class="number">2</span> + <span class="built_in">max</span>(m, n) % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                res[t++] = matrix[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                res[t++] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                res[t++] = matrix[m - <span class="number">1</span> - i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                res[t++] = matrix[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-ii"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">螺旋矩阵II</a></h3><p>​ 给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的<code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402252321434.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>分析：按照⼀个个矩阵的边框输入：<strong>x为矩阵的下界，n为矩阵的上界</strong>，每次输出这个围成的矩阵的<strong>第一行</strong>——<strong>最后一列</strong>——<strong>最后⼀行</strong>——<strong>第一列</strong>，然后将<strong>x⾃增1，m⾃减1</strong>～注意：为了避免重复输出，<strong>当x和n相等的时候，就输入一次第一行就可以，不用重复输入最后一行</strong>～</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402261132564.png" alt="image-20240226113203373" style="zoom:33%;" /></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> level = n / <span class="number">2</span> + n % <span class="number">2</span>, t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt;= n * n; j++)</span><br><span class="line">                res[i][j] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">2</span> - i &amp;&amp; t &lt;= n * n; j++)</span><br><span class="line">                res[j][n - <span class="number">1</span> - i] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt;= n * n; j--)</span><br><span class="line">                res[n - <span class="number">1</span> - i][j] = t++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt;= n * n; j--)</span><br><span class="line">                res[j][i] = t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-iv"><ahref="https://leetcode.cn/problems/spiral-matrix-iv/">螺旋矩阵IV</a></h3><p>给你两个整数：<code>m</code> 和 <code>n</code>，表示矩阵的维数。另给你一个整数链表的头节点 <code>head</code>。请你生成一个大小为 <code>m x n</code>的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵<strong>左上角</strong> 开始、<strong>顺时针</strong> 按<strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用<code>-1</code> 填充。返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262137159.jpeg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]</span><br><span class="line">输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何排布的。</span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262137279.jpeg" alt="img" style="zoom:33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 1, n = 4, head = [0,1,2]</span><br><span class="line">输出：[[0,1,2,-1]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。 </span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode* head) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n * m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; k &lt; n * m) &#123;</span><br><span class="line">            nums[k++] = head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">max</span>(m, n) / <span class="number">2</span> + <span class="built_in">max</span>(m, n) % <span class="number">2</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                matrix[i][j] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt; m * n; j++)</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span> - i; j &gt;= i &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                matrix[m - <span class="number">1</span> - i][j] = nums[t++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt; m * n; j--)</span><br><span class="line">                matrix[j][i] = nums[t++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【线性表】</title>
      <link href="/2024/02/22/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/"/>
      <url>/2024/02/22/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一预备知识">一:预备知识</h1><h2 id="头插法">头插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>头指针</strong>为L，指针<code>t</code>指向待插入的新结点</p><h3 id="若单链表含有头结点">若单链表含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = t;</span><br></pre></td></tr></table></figure><h3 id="若单链表不含有头结点">若单链表不含有头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;next = head;</span><br><span class="line">head = t;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="尾插法">尾插法</h2><p>​将<strong>结点</strong>插入<strong>链表表头</strong>采用<strong>头插法</strong>，设单链表<strong>尾指针</strong>为tail，指针<code>t</code>指向待插入的新结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail-&gt;next = t;</span><br><span class="line">tail = t;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>头插法</font></strong>会改变<strong><font color='red'>原先顺序</font></strong>，<strong><font color='blue'>尾插法</font></strong>不会改变<strong><font color='blue'>原先顺序</font></strong></p></blockquote><h2 id="头节点">头节点</h2><p><strong>头节点(head node)</strong> == <strong>哑节点（dummynode）</strong></p><h3 id="头结点的作用">头结点的作用</h3><ol type="1"><li><strong>使插入操作和删除操作统一</strong>，在<strong><font color='blue'>第一个结点之前插入结点</font></strong>或<strong><font color='blue'>删除第一个结点</font></strong>时不必另作判断</li><li>不论链表是否为空，<strong>头指针不变，始终指向头结点</strong></li></ol><h3 id="没有头节点的链表">没有头节点的链表</h3><p>对于不带头结点的链表，要考虑</p><ol type="1"><li><strong><font color='red'>尾插法</font></strong>插入结点时，<strong><font color='blue'>链表是否为空</font></strong>【头插法插入结点时，不必考虑】</li><li>是否在<strong><font color='blue'>第一个结点前插入新结点</font></strong></li><li>是否<strong><font color='blue'>删除</font></strong>结点后<strong><font color='blue'>链表为空</font></strong></li></ol><h2 id="sunny应用sunny">:sunny:应用:sunny:</h2><p>​ 对于没有头节点的链表：</p><ul><li>如果不存在上面我们需要考虑的情况：正常写即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">func</span><span class="params">(ListNode *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果可能存在 3.2节的情况，对于无头节点的链表：我们就先构造一个头节点<code>h</code>，在函数最后返回的时候<code>return h-&gt;next</code>，其余部分按照含有头结点的链表写即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">func</span><span class="params">(ListNode *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​以下内容如果没有写2种方案，均按照没有头结点的情况实现，当有头结点时，直接<code>return h</code>即可</p><h1 id="二链表">二:链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;*List;</span><br></pre></td></tr></table></figure><h2 id="链表复制">链表复制</h2><h3 id="带头结点">带头结点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">copyList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = L-&gt;next, *q = h;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        q-&gt;next = t;</span><br><span class="line">        q = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sunny:2者在第4、12行有所不同</p><h3 id="不带头结点">不带头结点</h3><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">copyList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = L, *q = h;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        q-&gt;next = t;</span><br><span class="line">        q = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sunny:2者在第4、12行有所不同</p><h2 id="链表逆转">链表逆转</h2><h3 id="带头结点-1">带头结点</h3><h4 id="改变链表结构">改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 版本一 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode* &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本二 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不改变链表结构">不改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *reverse_L = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        t-&gt;next = reverse_L-&gt;next;</span><br><span class="line">        reverse_L-&gt;next = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse_L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不带头结点-1">不带头结点</h3><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><h4 id="改变链表结构-1">改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 版本一 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseList</span><span class="params">(ListNode* &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 版本二 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p-&gt;next;</span><br><span class="line">        p-&gt;next = L;</span><br><span class="line">        L = p;</span><br><span class="line">        p = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不改变链表结构-1">不改变链表结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *reverse_L = <span class="literal">NULL</span>, *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val, p-&gt;next);</span><br><span class="line">        t-&gt;next = reverse_L;</span><br><span class="line">        reverse_L = t;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverse_L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例一">例一</h3><p><strong>1025 反转链表</strong></p><p>给定一个常数 <em>K</em> 以及一个单链表 <em>L</em>，请编写程序将<em>L</em> 中每 <em>K</em> 个结点反转。例如：给定 <em>L</em> 为1→2→3→4→5→6，<em>K</em> 为 3，则输出应该为 3→2→1→6→5→4；如果 <em>K</em>为 4，则输出应该为 4→3→2→1→5→6，即最后不到 <em>K</em> 个元素不反转。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em>(≤<em>N</em>)，即要求反转的子链结点的个数。结点的地址是 5位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code>是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>];             <span class="comment">//地址为5位数,模拟内存存储；     </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t; </span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  注意：不一定所有的输入的结点都是有用的，把链表储存在L数组中</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">    n=L.<span class="built_in">size</span>();             <span class="comment">//符合要求的节点个数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line">res.<span class="built_in">resize</span>(n);                  <span class="comment">//必须设定大小，否则res【i】出错</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-n%k;i++)        <span class="comment">//sum-sum%k是除去了最后不能反转的</span></span><br><span class="line">res[i]=L[k<span class="number">-1</span>-i%k+i/k*k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-n%k;i&lt;n;i++)</span><br><span class="line">        res[i]=L[i];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    输出     </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)   <span class="comment">//最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line">    </span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;    </span><br><span class="line"><span class="comment">//     法二</span></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;n-n%k;i+=k)</span></span><br><span class="line"><span class="comment">//         reverse(L.begin()+i,L.begin()+i+k);    //需要头文件algorithm</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// //    输出     </span></span><br><span class="line"><span class="comment">// for(int i=1;i&lt;n;i++)            //最后一位不输出，因为最后一位的下一位地址必须为-1</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d %05d\n&quot;,L[i-1],A[L[i-1]].data,L[i]);</span></span><br><span class="line"><span class="comment">// printf(&quot;%05d %d -1&quot;,L.back(),A[L.back()].data);    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二">例二</h3><p><strong>1075 链表元素分类</strong></p><p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而[0, K] 区间内的元素都排在大于 K的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为-4→-6→-2→7→0→5→10→18→11。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K(≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p><p>接下来有 N 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址；<code>Data</code>是该结点保存的数据，为 [−105,105] 区间内的整数；<code>Next</code>是下一结点的地址。题目保证给出的链表不为空。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00100 9 10</span><br><span class="line">23333 10 27777</span><br><span class="line">00000 0 99999</span><br><span class="line">00100 18 12309</span><br><span class="line">68237 -6 23333</span><br><span class="line">33218 -4 00000</span><br><span class="line">48652 -2 -1</span><br><span class="line">99999 5 68237</span><br><span class="line">27777 11 48652</span><br><span class="line">12309 7 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">33218 -4 68237</span><br><span class="line">68237 -6 48652</span><br><span class="line">48652 -2 12309</span><br><span class="line">12309 7 00000</span><br><span class="line">00000 0 99999</span><br><span class="line">99999 5 23333</span><br><span class="line">23333 10 00100</span><br><span class="line">00100 18 27777</span><br><span class="line">27777 11 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100005</span>]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理多余节点   </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;L,res;</span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&lt;<span class="number">0</span>)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;=<span class="number">0</span>&amp;&amp;A[L[i]].data&lt;=k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[L[i]].data&gt;k)</span><br><span class="line">res.<span class="built_in">push_back</span>(L[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例三">例三</h3><p><strong>区块反转</strong></p><p>给定一个单链表 <em>L</em>，我们将每 <em>K</em>个结点看成一个<strong>区块</strong>（链表最后若不足 <em>K</em>个结点，也看成一个区块），请编写程序将 <em>L</em>中所有区块的链接反转。例如：给定 <em>L</em> 为1→2→3→4→5→6→7→8，<em>K</em> 为 3，则输出应该为 7→8→4→5→6→1→2→3。</p><ul><li><strong>输入格式：</strong></li></ul><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1个结点的地址、结点总个数正整数 <em>N</em> (≤105)、以及正整数 <em>K</em>(≤<em>N</em>)，即区块的大小。结点的地址是 5 位非负整数，NULL 地址用 −1表示。</p><p>接下来有 <em>N</em> 行，每行格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中 <code>Address</code> 是结点地址，<code>Data</code>是该结点保存的整数数据，<code>Next</code> 是下一结点的地址。</p><ul><li><strong>输出格式：</strong></li></ul><p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p><ul><li><strong>输入样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00100 8 3</span><br><span class="line">71120 7 88666</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 71120</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">88666 8 -1</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><ul><li><strong>输出样例：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">71120 7 88666</span><br><span class="line">88666 8 00000</span><br><span class="line">00000 4 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 00100</span><br><span class="line">00100 1 12309</span><br><span class="line">12309 2 33218</span><br><span class="line">33218 3 -1</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data,next;</span><br><span class="line">&#125;A[<span class="number">100001</span>];</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;L,res,block[<span class="number">100001</span>];<span class="comment">//当n=100000，k=1时区块最多 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> first,n,k,t;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;A[t].data&gt;&gt;A[t].next;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;t;</span></span><br><span class="line"><span class="comment">// cin&gt;&gt;A[t].data&gt;&gt;A[t].next;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vector&lt;int&gt;L,res,block[100001];//放在局部变量会导致溢出，只能放在全局变量</span></span><br><span class="line"><span class="comment">//  故申请大内存时最好放在全局变量里面</span></span><br><span class="line"><span class="keyword">while</span>(first!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(first);</span><br><span class="line">first=A[first].next;</span><br><span class="line">&#125;</span><br><span class="line">n=L.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">block[t].<span class="built_in">push_back</span>(L[i]);</span><br><span class="line"><span class="keyword">if</span>(cnt%k==<span class="number">0</span>&amp;&amp;t!=n<span class="number">-1</span>)        <span class="comment">//Attention！if(cnt%k==0) 也对</span></span><br><span class="line">t++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : block[i]) </span><br><span class="line">            res.<span class="built_in">push_back</span>(it);        </span><br><span class="line"><span class="comment">//等价   for(int j=0;j&lt;block[i].size();j++)</span></span><br><span class="line"><span class="comment">// res.push_back(block[i][j]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,res[i<span class="number">-1</span>],A[res[i<span class="number">-1</span>]].data,res[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1&quot;</span>,res.<span class="built_in">back</span>(),A[res.<span class="built_in">back</span>()].data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表合并">链表合并</h2><h3id="两个升序链表合并为一个升序链表">两个升序链表合并为一个升序链表</h3><ul><li>用两个指针p1、p2分别遍历L1和L2，用一个尾指针永远指向新链表的最后一个节点</li><li>比较两个指针指向的节点的大小，将数据域较小的节点用==<strong><font color='red'>尾插法</font></strong>==接在新链表后面</li><li>尾指针后移，p1或者p2后移</li><li>当有一个为空时另一个还会有剩余节点没有加入新链表，将剩下的直接接在新链表后面</li></ul><h4 id="不改变链表结构-2">不改变链表结构</h4><h5 id="带头节点">带头节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode *h = new ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != nullptr &amp;&amp; p2 != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、28行</p><h5 id="不带头节点">不带头节点</h5><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、28行</p><h4 id="改变链表结构-2">改变链表结构</h4><h5 id="带头节点-1">带头节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、26行</p><h5 id="不带头节点-1">不带头节点</h5><p>==<strong><font color='red'>尾插法</font></strong>==，需要考虑 一\3.2节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p = h, *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第4、26行</p><h3id="两个升序链表合并为一个降序链表">两个升序链表合并为一个降序链表</h3><ul><li>用两个指针p1，p2分别遍历L1和L2，用指针s每次指向待插入的节点</li><li>将新链表的头结点的指针域置空</li><li>开始遍历并用==<strong><font color='red'>头插法</font></strong>==开始插入节点</li><li>退出循环后对未遍历完的节点用头插法将剩余节点插入新链表</li></ul><h4 id="不改变链表结构-3">不改变链表结构</h4><h5 id="带头节点-2">带头节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ListNode *<span class="title function_">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode *h = new ListNode;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != nullptr &amp;&amp; p2 != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            t-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = new ListNode(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            t-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = new ListNode(p1-&gt;val, p1-&gt;next);</span><br><span class="line">        t-&gt;next = h;</span><br><span class="line">        h = t;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h5 id="不带头节点-2">不带头节点</h5><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = L1, *p2 = L2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">            t-&gt;next = h;</span><br><span class="line">            h = t;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p2-&gt;val, p2-&gt;next);</span><br><span class="line">            t-&gt;next = h;</span><br><span class="line">            h = t;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p1-&gt;val, p1-&gt;next);</span><br><span class="line">        t-&gt;next = h;</span><br><span class="line">        h = t;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h4 id="改变链表结构-3">改变链表结构</h4><h5 id="带头节点-3">带头节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = p1;</span><br><span class="line">            p1 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = p2;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = h-&gt;next;</span><br><span class="line">        h-&gt;next = p1;</span><br><span class="line">        p1 = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h5 id="不带头节点-3">不带头节点</h5><p><strong>头插法</strong>，不需要考虑 一\3.2 节的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *L1, ListNode *L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *h = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p1 = L1-&gt;next, *p2 = L2-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = h;</span><br><span class="line">            h = p1;</span><br><span class="line">            p1 = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = h;</span><br><span class="line">            h = p2;</span><br><span class="line">            p2 = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">        p1 = p2;</span><br><span class="line">    <span class="keyword">while</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *t = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = h;</span><br><span class="line">        h = p1;</span><br><span class="line">        p1 = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:flags:注意第3、4行</p><h3 id="例一-1">例一</h3><p><strong>List Concatenation</strong></p><p>Concatenation of lists is an operation where the elements of one listare added at the end of another list. For example, if we have a linkedlist <code>L1</code>→1→2→3 and another one <code>L2</code>→4→5→6. Thefunction <code>ListConcat</code> is to return the head pointer of thelist L→4→5→6→1→2→3.</p><p><strong>The list structure is defined as the following:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br></pre></td></tr></table></figure><p><strong>Please fill in the blanks.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">ListConcat</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Tmp = L2;</span><br><span class="line">    <span class="keyword">if</span> ( !L2 ) <span class="keyword">return</span> L1;</span><br><span class="line">    <span class="keyword">while</span> ( Tmp-&gt;Next )</span><br><span class="line">________________;【<span class="number">4</span>分】</span><br><span class="line">______________;【<span class="number">4</span>分】</span><br><span class="line">    <span class="keyword">return</span> __________;【<span class="number">4</span>分】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><p>【1】<code>Tmp=Tmp-&gt;Next</code></p><p>【2】<code>Tmp-&gt;Next=L1</code>//注：<code>Tmp-&gt;Next=L1-&gt;Next</code>错误</p><p>【3】<code>L2</code></p><blockquote><p>该链表是一个不带头结点的单链表，从两个角度判断</p><ol type="1"><li>第4行代码 <code>if ( !L2 ) return L1;</code>//链表L2为空，则返回，说明不带头结点<ul><li>带头结点应写为<code>if ( !L2-&gt;next ) return L1;</code></li></ul></li><li>题干 L1→1→2→3 , L2→4→5→6 和 L→4→5→6→1→2→3.</li></ol></blockquote><h2 id="链表分解">链表分解</h2><h3 id="例一-2">例一</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为<strong><font color='red'>奇数</font></strong>的元素；B链表中含有原链表A中序号为<strong><font color='red'>偶数</font></strong>的元素。<strong><font color='blue'>保持原来的相对顺序。</font></strong></p><blockquote><blockquote><p>因为要保持原来相对位置不变，所以要采用Lb和Lb采用<strong><font color='red'>尾插法</font></strong>,尾指针分别为<strong><code>rear1和rear2</code></strong></p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二-1">例二</h3><p>​编写一个算法，将一个<strong>头节点指针为A</strong>的单链表A分解为两个单链表A和B。其头结点指针分别为A和B。使得A链表中含有原链表A中序号为<strong><font color='red'>偶数</font></strong>的元素；B链表中含有原链表A中序号为<strong><font color='red'>奇数</font></strong>的元素。<strong><font color='blue'>保持原来的相对顺序。</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_Division</span><span class="params">(List &amp;La, List &amp;Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    List rear1 = La;</span><br><span class="line">    List rear2 = Lb;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rear1-&gt;next = p;</span><br><span class="line">            rear1 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rear2-&gt;next = p;</span><br><span class="line">            rear2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两两交换链表节点"><ahref="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表节点</a></h2><p>​给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402262245395.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281656470.gif"alt="Rec_2024-02-26_0001(2)" /><figcaption aria-hidden="true">Rec_2024-02-26_0001(2)</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281739850.jpg"alt="7236b067d914444ca3a0afe66b74809" /><figcaptionaria-hidden="true">7236b067d914444ca3a0afe66b74809</figcaption></figure><p><strong>代码：</strong></p><p>法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *t = dummyHead, *p = head, *q = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            t-&gt;next = q;</span><br><span class="line">            t = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* t = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (t-&gt;next != <span class="literal">nullptr</span> &amp;&amp; t-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *p = t-&gt;next, *q = t-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            t-&gt;next = q;</span><br><span class="line">            t = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="排序链表"><ahref="https://leetcode.cn/problems/sort-list/">排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong>排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281833020.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402281833014.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            num.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            p-&gt;val = num[k++];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="随机链表的复制"><a id="shenkaobei"><ahref="https://leetcode.cn/problems/copy-list-with-random-pointer/">随机链表的复制</a></a></h2><p>给你一个长度为 <code>n</code>的链表，每个节点包含一个额外增加的随机指针 <code>random</code>，该指针可以指向链表中的任何节点或空节点。构造这个链表的 <strong><ahref="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin">深拷贝</a></strong>。深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong>节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code> 指针和 <code>random</code>指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>。</p><p>​ 例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中<code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点<code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code>。</p><p>​ 返回复制链表的头节点。</p><p>用一个由 <code>n</code>个节点组成的链表来表示输入/输出中的链表。每个节点用一个<code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从<code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为<code>null</code> 。</li></ul><p>​ 你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code>作为传入参数。</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942322.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942294.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403030942306.png"alt="img" /></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>需要<strong>2次遍历链表</strong>：</p><ul><li>首先<strong>对所有节点进行拷贝</strong>：遍历原始链表，每遍历到一个节点，就重新创建一个拷贝节点，然后用Hash表存储原节点与新节点的映射关系</li><li>然后<strong>拷贝点与点之间的关系</strong>：遍历原始链表，每遍历到一个节点，我们都从Hash表中查询到对应的拷贝节点，然后把拷贝节点根据原始节点的关系进行连接就可以了</li></ul><blockquote><p><ahref="https://www.bilibili.com/video/BV1Bv4y1A7Aq/?buvid=XY3CA67352B7F82D3CAB27E191FA025EB4053&amp;from_spmid=main.my-history.0.0&amp;is_story_h5=false&amp;mid=ivlqRrACJE6aj0QtF6a%2FzA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=a1cae467-a3b0-4af5-a2fb-841d5a3ffb7a&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1709393487&amp;unique_k=SMN7Y8h&amp;up_id=320530935&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】138. 复制带随机指针的链表 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p></blockquote><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; h;</span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">            h[p] = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">                h[p]-&gt;next = h[p-&gt;next];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random)</span><br><span class="line">                h[p]-&gt;random = h[p-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同类型：<ahref="D:\downloads\hexo\blog\source_posts\数据结构【图】.md#kelong">图的深拷贝</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摩尔投票</title>
      <link href="/2024/01/29/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/"/>
      <url>/2024/01/29/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="摩尔投票">摩尔投票</h1><h2 id="介绍">介绍</h2><p>​<strong>摩尔投票</strong>是一种用来解决<strong>绝对众数</strong>问题的算法。</p><blockquote><p><strong>绝对众数</strong>：在一个集合中，如果一个元素的出现次数比其他所有元素的出现次数<strong>之和</strong>还多，那么就称它为这个集合的<strong>绝对众数</strong>。等价地说，绝对众数的出现次数大于总元素数的<strong>一半</strong>。</p></blockquote><p>​摩尔投票的过程非常简单，让我们把找到绝对众数的过程想象成一次选举。我们维护一个<span class="math display">\[m\]</span> ，表示当前的候选人，然后维护一个<span class="math display">\[cnt\]</span>。对于每一张新的选票，如果它投给了当前的候选人，就把 <spanclass="math display">\[cnt\]</span> 加1，否则就把 <spanclass="math display">\[cnt\]</span>减1（也许你可以想象成，B的一个狂热支持者去把A的一个支持者揍了一顿，然后两个人都没法投票，<strong>两两同归于尽</strong>）。特别地，计票时如果<span class="math display">\[cnt==0\]</span>，我们可以认为目前谁都没有优势，所以新的选票投给谁，谁就成为新的候选人。</p><p>​ 例如，5张选票分别投给1，3，3，2，3，则：</p><table><thead><tr class="header"><th>轮数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr class="odd"><td>m</td><td>1</td><td>1</td><td>3</td><td>3</td><td>3</td></tr><tr class="even"><td>cnt</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>这个过程可以转换成C++代码（设总人数为 <spanclass="math display">\[n\]</span> ）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        m = A[i];</span><br><span class="line">    <span class="keyword">if</span> (m == A[i])</span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后需要验证答案是否符合要求</span></span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>如果我们要求的是众数，这样的做法并不能给出正确答案</li><li>但如果要求的是绝对众数（<strong>且绝对众数确实存在</strong>），那么<span class="math display">\[m\]</span> 一定是正确的</li><li>如果绝对众数不存在，摩尔投票会给出一个错误的解，所以一定要记得验证答案</li><li>时间复杂度： <span class="math display">\[O(n)\]</span> 空间复杂度：<span class="math display">\[O(1)\]</span></li></ul><blockquote><p>证明：</p><ol type="1"><li>投不同票的人同归于尽，最终剩下的（cnt&gt;0）一定是绝对众数</li><li>如果候选人不是 maj ，则 maj 会和其他非候选人一起反对会反对候选人,所以候选人一定会下台( maj==0 时发生换届选举)</li><li>如果候选人是maj , 则maj 会支持自己，其他候选人会反对，同样因为maj票数超过一半，所以maj 一定会成功当选</li></ol></blockquote><h2 id="拓展摩尔投票">拓展摩尔投票</h2><p>​ 上面的算法是只选出一个人的情形。但其实，如果要选出 <spanclass="math display">\[N\]</span>个候选人，并且要求每个人的得票都超过总票数的 <spanclass="math display">\[\frac{1}{N+1}\]</span>，也可以用上面的算法，只需稍微修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m[N], cnt[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">find</span>(m, m + N, e) - m;</span><br><span class="line">    <span class="keyword">if</span> (i != N) <span class="comment">// 如果当前票投给了候选人之一</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt[i]++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">find</span>(cnt, cnt + N, <span class="number">0</span>) - cnt;</span><br><span class="line">    <span class="keyword">if</span> (j != N) <span class="comment">// 如果当前存在一个位置&quot;虚位以待&quot;</span></span><br><span class="line">    &#123;</span><br><span class="line">        m[j] = e;</span><br><span class="line">        cnt[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : cnt)</span><br><span class="line">        c--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后需要验证答案是否符合要求</span></span><br></pre></td></tr></table></figure><p>​ 原理是一样的。最后我们可以把票分为 2 个部分：投给了最多 <spanclass="math display">\[N\]</span>个候选人的一部分，和被抵消的一部分。后者可以划分为若干个 <spanclass="math display">\[N+1\]</span>元组，每个元组内的票都来自不同的候选人。因此，只有那些属于第一部分的人的票数可能超过总数的<span class="math display">\[\frac{1}{N+1}\]</span></p><h2 id="区间绝对众数">区间绝对众数</h2><p>​区间绝对众数问题也可以利用摩尔投票解决，这需要所谓的<strong>线段树上摩尔投票</strong>。</p><p>​摩尔投票符合结合律吗？实际上并不符合。但是没有关系，因为我们其实只关心<span class="math display">\[m\]</span> 而不关心 <spanclass="math display">\[cnt\]</span>，而<strong>当绝对众数存在时，可以任意交换摩尔投票的计票顺序，而不改变选出的候选人</strong>。这是显然的，因为我们上面对摩尔投票的原理的分析完全不依赖于顺序。</p><p>​所以，我们可以在线段树上进行摩尔投票。在合并左右两个区间时，相当于是先对左右两边分别进行摩尔投票，再对两边抵消后的结果进行摩尔投票。具体地，我们维护下面这样的节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m, cnt;</span><br><span class="line">    Node <span class="keyword">operator</span>+(<span class="type">const</span> Node &amp;o) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == o.m)</span><br><span class="line">            <span class="keyword">return</span> &#123;m, cnt + o.cnt&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt &gt; o.cnt)</span><br><span class="line">            <span class="keyword">return</span> &#123;m, cnt - o.cnt&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;o.m, o.cnt - cnt&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​ 然后用写一个支持区间求和的（递归/非递归式）线段树即可。</p><p>​不过，我们已经知道用摩尔投票求绝对众数需要验证，现在我们需要对若干个区间的询问快速进行验证，这样怎样实现呢？其实，对每个权值预处理一个下标数组，然后二分查找即可。</p><p>​ 例如，对于数组 <span class="math inline">\(⟨2,3,2,2,3,2,1⟩\)</span>，我们要验证 2 是不是区间 <span class="math inline">\([2,6]\)</span>里的绝对众数，于是我们考察 2 的下标数组 <spanclass="math inline">\(⟨1,3,4,6⟩\)</span> ，发现满足 <spanclass="math inline">\(2≤x≤6\)</span> 的 <spanclass="math display">\[x\]</span> 一共有 3个（这个用二分查找即可实现），出现次数超过区间长度的一半，所以就是绝对众数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector&lt;int&gt; pos[MAXV];</span></span><br><span class="line"><span class="comment">// pos[m]表示权值m的下标数组，需要预处理</span></span><br><span class="line"><span class="comment">// 如果权值值域过大，需要改用map或哈希表</span></span><br><span class="line"><span class="keyword">auto</span> itr = <span class="built_in">upper_bound</span>(pos[m].<span class="built_in">begin</span>(), pos[m].<span class="built_in">end</span>(), right);</span><br><span class="line"><span class="keyword">auto</span> itl = <span class="built_in">lower_bound</span>(pos[m].<span class="built_in">begin</span>(), pos[m].<span class="built_in">end</span>(), left);</span><br><span class="line"><span class="keyword">if</span> (itr - itl &gt; (right - left + <span class="number">1</span>) / <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h1 id="例题">例题</h1><h2 id="多数元素"><ahref="https://leetcode.cn/problems/majority-element/">多数元素</a></h2><p>​ 给定一个大小为 <code>n</code> 的数组 <code>nums</code>，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong><code>⌊ n/2 ⌋</code>的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><p><strong>法一：摩尔投票</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">                candidate = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == candidate)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法二：排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxcnt = <span class="number">-1</span>, maxval, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(nums.<span class="built_in">size</span>() - <span class="number">1</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (maxcnt &lt; cnt) &#123;</span><br><span class="line">                    maxcnt = cnt;</span><br><span class="line">                    maxval = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出</title>
      <link href="/2024/01/27/%5Bobject%20Object%5D/others/IO%E8%BE%93%E5%85%A5/"/>
      <url>/2024/01/27/%5Bobject%20Object%5D/others/IO%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="输入">输入</h1><h2 id="空白字符">空白字符</h2><p>​ <strong>空格，回车，制表符</strong> 称为空白字符</p><h2 id="scanf函数">scanf函数</h2><ul><li><code>%s</code>为输入字符串，在输入时<font color='red'><strong>以非空白字符开始</strong></font>，以<font color='red'><strong>第一个非空白字符结束</strong></font>。字符串会自动以<strong><code>\0</code></strong> 为最后一个字符，输入格式为：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="comment">// 注意s为数组变量不带取值符</span></span><br></pre></td></tr></table></figure><ul><li>%c为输入单个字符，包括空白字符，格式为：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c); <span class="comment">// 需要取值符</span></span><br></pre></td></tr></table></figure><h2 id="输入读取">输入读取</h2><p>:smile:由于 %c 会将空格，回车，制表符这 3 种空白字符吸入，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c#&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1输入：空格</span></span><br><span class="line"><span class="comment">//输出： #</span></span><br><span class="line"><span class="comment">//2输入：回车</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//输出:#</span></span><br><span class="line"><span class="comment">//3输入：tab制表符</span></span><br><span class="line"><span class="comment">//输出：    #</span></span><br></pre></td></tr></table></figure><p>而 %s则不会吸入这些空白字符，而会跳过他们自动吸入有效字符串，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s#&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1输入： abcde</span></span><br><span class="line"><span class="comment">//输出：abcde#</span></span><br><span class="line"><span class="comment">//2输入：    abcde    </span></span><br><span class="line"><span class="comment">//输出：abcde#</span></span><br></pre></td></tr></table></figure><p>因此，当我们需要使用 scanf 读取单个字符时，不建议使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而建议使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">2</span>]; <span class="comment">// 多一个 字符串结束符&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line"><span class="keyword">if</span> (*c == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在后续操作中只需要使用 *即可访问字符元素，同时又可以避免读入空白字符</p><blockquote><p>在算法竞赛中经常会出现某些坑爹的输入样例——每一行多给你个空格/回车</p></blockquote><p>:fish:切记，如果你想输入 n 个字符，字符数组的长度一定要定义为n+1，因为输入会自带 1 个字符串结束符<code>\0</code></p><h2 id="缓冲区">缓冲区</h2><p>大家知道，一般我们正常的输入都是先进入到缓冲区中，那么什么时候会将缓冲区的数据打到屏幕上呢？</p><ul><li><p>遇到了换行符</p></li><li><p>缓冲区满</p></li><li><p>程序正常推出</p></li></ul><p>这三种情况便会刷新数据，而平时我们所打的回车便会在缓冲区打入一个换行符，从而引起刷新。</p><h2 id="cincout-vs-scanfprintf">cin/cout vs scanf/printf</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081335856.png"alt="image-20240308133556727" /><figcaption aria-hidden="true">image-20240308133556727</figcaption></figure><ul><li>算法竞赛，cin/cout 要比 scanf/printf 慢2~10倍</li><li>cin/cout 提速：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">// 取消 C函数 与 C++函数 的缓冲区同步</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 提速后，cin/cout 和 scanf/printf一样快（甚至在某些情况下比scanf/printf还要快），但是开启上述优化后，由于取消了同步，不能再使用scanf/printf ，只能使用 cin/cout，scanf和cin混用，或cout和printf混用时，就会可能发生<code>错误</code></p><h2 id="printf">printf</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081351507.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="scanf">scanf</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081352693.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="经验">经验</h2><ul><li>数据规模超过100万（<spanclass="math inline">\(10^6\)</span>），建议采用scanf、printf</li><li>数据规模在100万（<spanclass="math inline">\(10^6\)</span>）以下，scanf、printf/cin、cout都可以</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>classification_report</title>
      <link href="/2024/01/27/%5Bobject%20Object%5D/sklearn/classification_report/"/>
      <url>/2024/01/27/%5Bobject%20Object%5D/sklearn/classification_report/</url>
      
        <content type="html"><![CDATA[<h1 id="classification_report">classification_report</h1><h2 id="简介">简介</h2><p>​说来惭愧，好久不写博客，让我动笔的竟然是sklearn一个小小的api功能，以前评价模型用的都是总体的准确率，第一次用sklearn提供的分类报告功能竟然搞不懂是怎么计算的，怎么还分类别。就像下面这样：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403011632622.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>嗯，这都啥呀？老实说第一次看我只看懂了准确率即accuracy是怎么计算的。。。</p><span id="more"></span><h2 id="计算">计算</h2><p>首先y_true是真实结果，y_pred是预测出的标签，它们分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y_true</span><br><span class="line">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,</span><br><span class="line">       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y_pred</span><br><span class="line">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1,</span><br><span class="line">       0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">       0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,</span><br><span class="line">       0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 闲着没事干的可以自己数数，这边统计出来的结果是： -<strong>实际情况中，前68个样本为0类别，后32个样本为1类别</strong> -<strong>预测中，前68个样本中有11个被预测为了1类别，后32个样本中有8个被预测为了0类别</strong></p><hr /><p><strong>那么我们先说分类报告中最右边的support为什么是68和32。</strong>support意思为支持，也就是说真实结果中有多少是该类别。那么有68个为0类别，32个为1类别。<strong>在左边的召回率里，分母为support个数。</strong></p><hr /><p><strong>那么0类别里召回率即recall的计算为：</strong>(68-11)/68=0.8382，保留两位小数为0.84。 同理1类别中： (32-8)/32=0.75。<strong>意思为 实际为x的类别中，有多少预测为x。</strong></p><hr /><p><strong>而精准率即precision的区别在于分母不同：</strong>此时的分母为预测样本分类。 0类别： 57/65=0.8769，保留两位小数为0.88。1类别： 24/35=0.6857，保留两位小数为0.69。 <strong>意思为预测为x的样本中，有多少被正确预测为x。</strong></p><hr /><p>解决了这两个，剩下的就很好懂了。 <strong>F1分数=2 * precision *recall /(precision+recall)。</strong><strong>accuracy=(100-11-8)/100。</strong></p><ul><li>注：准确率(accuracy)即全部样本里被分类正确的比例。</li></ul><p><strong>macro avg = 上面类别各分数的直接平均</strong></p><ul><li>注：如精准率的macro avg=(0.88+0.69)/2约等于0.78。</li></ul><p><strong>weightedavg=上面类别各分数的加权（权值为support）平均</strong></p><ul><li>注：如精准率的weighted avg=（0.88x68+0.69*32）/100约等于0.82。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希腊字母表</title>
      <link href="/2024/01/27/%5Bobject%20Object%5D/others/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/"/>
      <url>/2024/01/27/%5Bobject%20Object%5D/others/%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="希腊字母表">希腊字母表</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202401271612976.png"alt="GreekAlphabet" /><figcaption aria-hidden="true">GreekAlphabet</figcaption></figure><p>:gift_heart:读音：<ahref="https://www.bilibili.com/video/BV11b411t7Fn/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">50秒完全学会希腊字母读法~高中理科生的福音_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2024/01/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/01/25/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="例题">例题</h1><h2 id="最长回文子串"><ahref="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></h2><p>​ 给你一个字符串 <code>s</code>，找到 <code>s</code>中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>​<strong>中心扩展算法</strong>：遍历字符串，对于每个元素都<font color='red'><strong>从中间向两边寻找是否有回文子串</strong></font>，返回这个子串，将它的长度与result比较，如果比result长就更新result～<strong>要分为奇数还是偶数</strong>考虑，奇数就左右都是i，偶数就是左边是<code>i</code>，右边是<code>i+1</code>，然后扩展～</p><span id="more"></span><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">/* 情况1：子串长度为奇数 */</span></span><br><span class="line">            <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">length</span>() &amp;&amp; s[l] == s[r])</span><br><span class="line">                l--, r++;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">length</span>() &lt; r - l - <span class="number">1</span>)</span><br><span class="line">                ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 情况2：子串长度为偶数 */</span></span><br><span class="line">            l = i, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">length</span>() &amp;&amp; s[l] == s[r])</span><br><span class="line">                l--, r++;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">length</span>() &lt; r - l - <span class="number">1</span>)</span><br><span class="line">                ans = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><ahref="https://www.bilibili.com/video/BV1UZ4y1U7tt/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】5. 最长回文子串 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础命令</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/Linux/Linux%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/Linux/Linux%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基础命令">Linux基础命令</h1><h2 id="windows与linux的区分">windows与linux的区分</h2><ol type="1"><li>linux下<strong>文件名区分大小写</strong>，而windows下<strong>文件名不区分大小写</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">ABC</span><br><span class="line">aBc</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>linux下<strong>路径分隔符</strong>为<code>/</code>，而windows下<strong>路径分隔符</strong>为<code>\</code></li></ol><h2 id="linux的目录结构">Linux的目录结构</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309122142813.png"alt="20221027214128_clear_compress" /><figcaptionaria-hidden="true">20221027214128_clear_compress</figcaption></figure><span id="more"></span><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>/home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><blockquote><p>/： 根目录，操作系统的启示路径跟路径</p><p>/bin： 可执行二进制文件的目录</p><p>/etc： 系统配置文件存放的目录</p><p>/home：普通用户的家目录</p><p>/root： 管理员家目录</p><p>/dev： device设备 设备文件存放目录</p><p>/boot： 引导 主引导目录 独立的分区 启动菜单 内核</p><p>/media：光驱的挂载目录</p><p>/mnt： 临时设备挂载目录</p><p>/proc： 里面的数据都在内存中，进程的所有目录</p><p>/tmp： 临时文件存放目录</p><p>/usr： 软件的安装目录</p><p>/var： 常变文件存放目录，如日志文件，邮件文件</p></blockquote><h2 id="lsb_release命令">lsb_release命令</h2><p>功能：查看linux的发行版本信息</p><p>语法：<code>lsb_release -a</code></p><h2 id="ls命令">ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小</li><li>-a，显示隐藏文件</li></ul><blockquote><p><strong>隐藏文件/文件夹</strong></p><ul><li><p>在Linux中以<code>.</code>开头的，均是隐藏的文件/文件夹</p></li><li><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p></li></ul></blockquote><h2 id="pwd命令">pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令">cd命令</h2><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="home目录">HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径绝对路径">相对路径、绝对路径</h2><ul><li><p>相对路径，==非==<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，==以==<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符">特殊路径符</h2><ul><li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="mkdir命令">mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li>参数：被创建文件夹的路径</li><li>选项：-p，可选，表示创建前置路径</li></ul><h2 id="touch命令">touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><ul><li>参数：被创建的文件路径</li></ul><h2 id="cat命令">cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径</li></ul><h2 id="more命令">more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li></ul></li></ul><h2 id="cp命令">cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test/，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test到当前文件夹内为test2存在</li></ul><h2 id="mv命令">mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li>参数1：被移动的</li><li>参数2：要移动去的地方，参数2如果不存在，则会进行改名</li></ul><h2 id="rm命令">rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数...参数</code></p><ul><li>参数：支持多个，每一个表示被删除的，空格进行分隔</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><h2 id="which命令">which命令</h2><p>功能：查看命令的程序本体文件路径</p><p>语法：<code>which 参数</code></p><ul><li>参数：被查看的命令</li></ul><h2 id="find命令">find命令</h2><p>功能：搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符*，比如：<code>*</code>test表示搜索任意以test结尾的文件</li></ul><h2 id="grep命令">grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令">wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符">管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边的结果，作为符号右边的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cata.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><h2 id="echo命令">echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容</li></ul><h2 id="反引号">`反引号</h2><p>功能：<strong>被两个反引号包围的内容，会作为命令执行</strong></p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="tail命令">tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f -n] 参数</code></p><ul><li>参数：被查看的文件路径</li><li>选项：-f，持续跟踪文件修改</li><li>选项：-n，表示查看尾部多少行，不填默认10行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 100 filename</span><br></pre></td></tr></table></figure><h2 id="head命令">head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="重定向符">重定向符</h2><p>功能：将符号左边的结果，输出到右边指定的文件中去</p><ul><li><code>&gt;</code>，表示覆盖输出</li><li><code>&gt;&gt;</code>，表示追加输出</li></ul><h2 id="nano编辑器">nano编辑器</h2><p><ahref="https://blog.csdn.net/fuzhang_android/article/details/87873661?spm=1001.2014.3001.5506">nano简单使用介绍_nano的用法_fuzhang_android的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/WalterBrien/article/details/125836576?spm=1001.2014.3001.5506">nano编辑器的使用_SudekiMing的博客-CSDN博客</a></p><h2 id="vi编辑器">vi编辑器</h2><h3 id="命令模式快捷键">命令模式快捷键</h3><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215841.png"alt="image-20221027215841573" /><figcaption aria-hidden="true">image-20221027215841573</figcaption></figure><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215846.png"alt="image-20221027215846581" /><figcaption aria-hidden="true">image-20221027215846581</figcaption></figure><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215849.png"alt="image-20221027215849668" /><figcaption aria-hidden="true">image-20221027215849668</figcaption></figure><h3 id="底线命令快捷键">底线命令快捷键</h3><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027215858.png"alt="image-20221027215858967" /><figcaption aria-hidden="true">image-20221027215858967</figcaption></figure><h2 id="命令的选项">命令的选项</h2><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p><p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I-k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X-1等选项，可以发现选项是极其多的。</p><p>课程中，并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</p><p>课程中，会对常见的选项进行讲解，足够满足绝大多数的学习、工作场景。</p><h3 id="查看命令的帮助">查看命令的帮助</h3><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220005.png"alt="image-20221027220005610" /><figcaption aria-hidden="true">image-20221027220005610</figcaption></figure><h3 id="查看命令的详细手册">查看命令的详细手册</h3><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p><figure><imgsrc="https://image-set.oss-cn-zhangjiakou.aliyuncs.com/img-out/2022/10/27/20221027220010.png"alt="image-20221027220009949" /><figcaption aria-hidden="true">image-20221027220009949</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用操作</title>
      <link href="/2024/01/06/%5Bobject%20Object%5D/Linux/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/01/06/%5Bobject%20Object%5D/Linux/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="linux常用操作">Linux常用操作</h1><h2 id="软件安装">软件安装</h2><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><span id="more"></span><h2 id="systemctl">systemctl</h2><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h2 id="软链接">软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><h2 id="日期">日期</h2><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y 年%y 年份后两位数字 (00..99)</li><li>%m 月份 (01..12)</li><li>%d 日 (01..31)</li><li>%H 小时 (00..23)</li><li>%M 分钟 (00..59)</li><li>%S 秒 (00..60)</li><li>%s 自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354525.png"alt="image-20221027220514640" /><figcaption aria-hidden="true">image-20221027220514640</figcaption></figure></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354546.png"alt="image-20221027220525625" /><figcaption aria-hidden="true">image-20221027220525625</figcaption></figure></li><li><p>-d选项日期计算</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354538.png"alt="image-20221027220429831" /><figcaption aria-hidden="true">image-20221027220429831</figcaption></figure><ul><li><p>支持的时间标记为：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354567.png"alt="image-20221027220449312" /><figcaption aria-hidden="true">image-20221027220449312</figcaption></figure></li></ul></li></ul><h2 id="时区">时区</h2><p>修改时区为中国时区</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354572.png"alt="image-20221027220554654" /><figcaption aria-hidden="true">image-20221027220554654</figcaption></figure><h2 id="ntp">ntp</h2><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h2 id="ip地址">ip地址</h2><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h2 id="主机名">主机名</h2><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h2 id="配置vmware固定ip">配置VMware固定IP</h2><ol type="1"><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;# 改为static，固定IP</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=&quot;192.168.88.131&quot;# IP地址，自己设置，要匹配网络范围</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;# 子网掩码，固定写法255.255.255.0</span><br><span class="line">GATEWAY=&quot;192.168.88.2&quot;# 网关，要和VMware中配置的一致</span><br><span class="line">DNS1=&quot;192.168.88.2&quot;# DNS1服务器，和网关一致即可</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="ps命令">ps命令</h2><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><p><strong>举例</strong>：在Linux上，我想查看：用户为ycxie，执行命令为python3的所有进程信息，应使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;ycxie.*python3&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="kill命令">kill命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354615.png"alt="image-20221027221303037" /><figcaption aria-hidden="true">image-20221027221303037</figcaption></figure><h2 id="nmap命令">nmap命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354218.png"alt="image-20221027221241123" /><figcaption aria-hidden="true">image-20221027221241123</figcaption></figure><h2 id="netstat命令">netstat命令</h2><p>功能：查看端口占用</p><p>用法：<code>netstat -anp | grep xxx</code></p><h2 id="ping命令">ping命令</h2><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354289.png"alt="image-20221027221129782" /><figcaption aria-hidden="true">image-20221027221129782</figcaption></figure><h2 id="wget命令">wget命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354323.png"alt="image-20221027221148964" /><figcaption aria-hidden="true">image-20221027221148964</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354349.png"alt="image-20230830233213202" /><figcaption aria-hidden="true">image-20230830233213202</figcaption></figure><h2 id="curl命令">curl命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354388.png"alt="image-20221027221201079" /><figcaption aria-hidden="true">image-20221027221201079</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354464.png"alt="image-20221027221210518" /><figcaption aria-hidden="true">image-20221027221210518</figcaption></figure><h2 id="top命令">top命令</h2><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354904.png"alt="image-20221027221340729" /><figcaption aria-hidden="true">image-20221027221340729</figcaption></figure><p>交互式模式中，可用快捷键：</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354037.png"alt="image-20221027221354137" /><figcaption aria-hidden="true">image-20221027221354137</figcaption></figure><h2 id="df命令">df命令</h2><p>查看磁盘占用</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354055.png"alt="image-20221027221413787" /><figcaption aria-hidden="true">image-20221027221413787</figcaption></figure><h2 id="iostat命令">iostat命令</h2><p>查看CPU、磁盘的相关信息</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354200.png"alt="image-20221027221439990" /><figcaption aria-hidden="true">image-20221027221439990</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354117.png"alt="image-20221027221514237" /><figcaption aria-hidden="true">image-20221027221514237</figcaption></figure><h2 id="sar命令">sar命令</h2><p>查看网络统计</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354176.png"alt="image-20221027221545822" /><figcaption aria-hidden="true">image-20221027221545822</figcaption></figure><h2 id="环境变量">环境变量</h2><ul><li>临时设置：export 变量名=变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h3 id="path变量">PATH变量</h3><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h2 id="符号">$符号</h2><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo $&#123;PATH&#125;ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p><h2 id="压缩解压">压缩解压</h2><h3 id="压缩">压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写</li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354586.png"alt="image-20221027221906247" /><figcaption aria-hidden="true">image-20221027221906247</figcaption></figure><h3 id="解压">解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354703.png"alt="image-20221027221939899" /><figcaption aria-hidden="true">image-20221027221939899</figcaption></figure><h2 id="bgp-dump">BGP-dump</h2><ul><li><p>打开任意终端，输入bgpdump，可查看参数。</p></li><li><p>MRT格式的RIB可从route view project官网下载：<ahref="http://archive.routeviews.org/">route view projectarchive</a>。</p></li><li><p>常用指令：bgpdump -m xxx.bz2 &gt; output.txt</p></li></ul><h2 id="su命令">su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354737.png"alt="image-20221027222021619" /><figcaption aria-hidden="true">image-20221027222021619</figcaption></figure><h2 id="sudo命令">sudo命令</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354874.png"alt="image-20221027222035337" /><figcaption aria-hidden="true">image-20221027222035337</figcaption></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itheima ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="chmod命令">chmod命令</h2><p>修改文件、文件夹权限</p><p>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354864.png"alt="image-20221027222157276" /><figcaption aria-hidden="true">image-20221027222157276</figcaption></figure></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li></ul><h2 id="chown命令">chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354954.png"alt="image-20221027222326192" /><figcaption aria-hidden="true">image-20221027222326192</figcaption></figure><h2 id="用户组管理">用户组管理</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354190.png"alt="image-20221027222354498" /><figcaption aria-hidden="true">image-20221027222354498</figcaption></figure><h2 id="用户管理">用户管理</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354334.png"alt="image-20221027222407618" /><figcaption aria-hidden="true">image-20221027222407618</figcaption></figure><h2 id="genenv命令">genenv命令</h2><ul><li><p><code>getenv group</code>，查看系统全部的用户组</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354405.png"alt="image-20221027222446514" /><figcaption aria-hidden="true">image-20221027222446514</figcaption></figure></li><li><p><code>getenv passwd</code>，查看系统全部的用户</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221354510.png"alt="image-20221027222512274" /><figcaption aria-hidden="true">image-20221027222512274</figcaption></figure></li></ul><h2 id="env命令">env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p><h2 id="python3命令">python3命令</h2><h2 id="nano命令">nano命令</h2><p><ahref="https://blog.csdn.net/WalterBrien/article/details/125836576?ops_request_misc=%7B%22request%5Fid%22%3A%22169508811116777224443235%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169508811116777224443235&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125836576-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=nano&amp;spm=1018.2226.3001.4187">nano编辑器的使用_SudekiMing的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/carefree2005/article/details/129042788?ops_request_misc=%7B%22request%5Fid%22%3A%22169508802416800182147582%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169508802416800182147582&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-129042788-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=nano命令&amp;spm=1018.2226.3001.4187">Linux命令之nano命令_恒悦sunsite的博客-CSDN博客</a></p><h2 id="nohup命令">nohup命令</h2><p><code>nohup python3 -u test.py &gt; nohup.out 2&gt;&amp;1 &amp;</code></p><p><ahref="https://blog.csdn.net/jiangyu1013/article/details/81476184?ops_request_misc=%7B%22request%5Fid%22%3A%22169018276616800184180892%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169018276616800184180892&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-81476184-null-null.142%5Ev90%5Econtrol_2,239%5Ev3%5Einsert_chatgpt&amp;utm_term=nohup命令&amp;spm=1018.2226.3001.4187">(139条消息)linux 中的 nohup 命令（设置后台进程）： nohup: ignoring input andappending output to ‘nohup.out’_nohup: ignoring input and appendingoutput to 'noh_微风--轻许--的博客-CSDN博客</a></p><h2 id="ping命令-1">ping命令</h2><h2 id="traceroute命令">traceroute命令</h2><ul><li>traceroute的用法为:<code>Traceroute [options] [data size]</code></li><li><code>[options]</code>的内容有:</li></ul><p><code>[-n]</code>：显示的地址是用数字表示而不是符号<code>[-v]</code>：长输出 <code>[-p]</code>：UDP端口设置（缺省为33434）<code>[-q]</code>：设置TTL测试数目（缺省为3）<code>[-t]</code>：设置测包的服务类型<code>[data size]</code>：每次测试包的数据字节长度（缺省为38）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typedef</title>
      <link href="/2023/12/19/%5Bobject%20Object%5D/C++/typedef/"/>
      <url>/2023/12/19/%5Bobject%20Object%5D/C++/typedef/</url>
      
        <content type="html"><![CDATA[<h1 id="typedef">typedef</h1><h2 id="介绍">介绍</h2><pre><code>使用关键字`typedef`可以为数据类型起一个新的别名</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br><span class="line">newName a,b;</span><br></pre></td></tr></table></figure><ul><li><code>oldName</code> 是类型原来的名字，</li><li><code>newName</code> 是类型新的名字</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  oldName  newName;</span><br></pre></td></tr></table></figure><p>==<code>typedef</code>去掉，<code>oldname</code>保留，<code>newname</code>换成a,b==</p></blockquote><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldName a,b;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol type="1"><li>typedef是赋予<strong>现有类型</strong>一个<strong>新的名字</strong>，而==<strong>不是创建新的类型</strong>==。</li><li>为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。</li><li>==<font color='red'><strong>最后的分号<code>;</code>不要忘记</strong></font>==</li></ol></blockquote><h2 id="定义">定义</h2><ol type="1"><li>typedef给如<code>int</code>，<code>double</code>，<code>char</code>，<code>long</code>，<code>float</code>等类型定义别名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER;</span><br><span class="line">INTEGER a, b;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br></pre></td></tr></table></figure><hr /><ol start="2" type="1"><li><strong>typedef 给数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> array[<span class="number">20</span>];</span><br><span class="line">array a1, a2, s1, s2;</span><br></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[<span class="number">20</span>], a2[<span class="number">20</span>], s1[<span class="number">20</span>], s2[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><blockquote><p>注：数组也是有类型的。例如char a1[20];定义了一个数组 a1，它的类型就是==<strong>char [20]</strong>==。</p></blockquote><hr /><ol start="3" type="1"><li><strong>typedef 给结构体类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure><p><code>stu</code> 是 <code>struct node</code> 的别名，可以用<code>stu</code> 定义结构体变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu x;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> x;</span><br></pre></td></tr></table></figure><hr /><ol start="4" type="1"><li><strong>typedef 给结构数组类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li><strong>typedef 给指针类型定义别名</strong></li></ol><ul><li>例一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_ARR)</span>[4]</span>;</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR是类型<code>int [4] *</code>的别名，它是一个==<strong>二维数组指针</strong>==类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><hr /><ul><li>例二</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * PTR_TO_ARR [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><blockquote><p>表示 PTR_TO_ARR是类型<code>int * [4]</code>的别名，它是一个==<strong>元素指向整形数据的指针数组</strong>==类型。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTR_TO_ARR p;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p [<span class="number">4</span>];</span><br></pre></td></tr></table></figure><ol start="6" type="1"><li><strong>typedef为函数指针类型定义别名</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">PTR_TO_FUNC pfunc;</span><br></pre></td></tr></table></figure><h2 id="示例">示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*PTR_TO_ARR)</span>[30]</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PTR_TO_FUNC)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">3</span>][<span class="number">30</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;百度搜索引擎&quot;</span>,</span><br><span class="line">    <span class="string">&quot;C-Language&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PTR_TO_ARR parr = str;</span><br><span class="line">    PTR_TO_FUNC pfunc = max;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max: %d\n&quot;</span>, (*pfunc)(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str[%d]: %s\n&quot;</span>, i, *(parr+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max: <span class="number">20</span></span><br><span class="line">str[<span class="number">0</span>]: http:<span class="comment">//www.baidu.com</span></span><br><span class="line">str[<span class="number">1</span>]: 百度搜索引擎</span><br><span class="line">str[<span class="number">2</span>]: C-Language</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研帽子</title>
      <link href="/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E7%A7%91%E7%A0%94%E5%B8%BD%E5%AD%90/"/>
      <url>/2023/12/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E7%A7%91%E7%A0%94%E5%B8%BD%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403280931551.png"alt="科研等级" /><figcaption aria-hidden="true">科研等级</figcaption></figure><p><strong>四青人才</strong></p><ol type="1"><li>优青：国家自然科学基金委设立的<strong>优秀青年科学基金项目</strong></li><li>青长：长江学者奖励计划中的<strong>青年长江学者</strong></li><li>青拔：万人计划中的<strong>青年选拔人才</strong></li><li>青千：千人计划中的<strong>青年千人计划</strong></li></ol><p><strong>杰青</strong></p><p>​杰青，全称是“<strong>国家杰出青年科学基金</strong>”，是国家自然科学基金委为了促进青年科学和技术人才的成长，鼓励海外学者回国工作，加速培养造就一批进入世界科技前沿的优秀学术带头人而特别设立的科学基金。</p><p><strong>长江</strong></p><p>​长江学者是指获得“<strong>长江学者奖励计划</strong>”的科研工作者。“长江学者奖励计划”是中华人民共和国教育部与香港李嘉诚基金会为提高中国高等学校学术地位，振兴中国高等教育，于1998年共同筹资设立的专项高层次人才计划，该计划包括实行<strong>特聘教授岗位制度</strong>和<strong>长江学者成就奖</strong>两项内容。</p><p>​“长江学者奖励计划”是国家重大人才工程的重要组成部分。长江学者奖励计划分为<strong>特聘教授</strong>和<strong>讲座教授</strong>项目，每年支持聘任150名特聘教授，50名讲座教授；特聘教授聘期5年，讲座教授聘期为3年。</p><p><strong>千人</strong></p><p>​“<strong>千人计划</strong>”，全称是“<strong>海外高层次人才引进计划</strong>”。从2008年开始，中央决定围绕国家发展战略目标，用5-10年的时间，在国家重点创新项目、重点学科和重点实验室和各种企业等，引进并重点支持一批海外高层次人才回国创新创业。“千人计划”分为创新型人才和创业型人才，前者是高等院校、研究机构引进的人才，后者是企业引进的人才。</p><p>​除此之外，中央还施行了“<strong>青年千人计划</strong>“，即“<strong>海外高层次人才引进计划青年项目</strong>”。与“千人计划”不同的是，“青千”主要是引进在国外获得博士学位或者进行过博后研究，愿意回国发展的青年人才。“千人计划”一般俗称“大千人”，而“青年千人”俗称“小千人”。</p><p>​“千人计划”主要面向国外的高层次人才，吸引他们回国创业。截至目前，“千人计划”已经分批引进6000余名高层次人才，成为创新型国家建设的一批重要生力军。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2023/11/26/%5Bobject%20Object%5D/others/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/11/26/%5Bobject%20Object%5D/others/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><span id="more"></span><h1 id="markdown语法">Markdown语法</h1><p><strong>==参考视频：<ahref="https://www.bilibili.com/video/BV1hG411p7fX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">Markdown语法讲解</a>==</strong></p><h2 id="简要介绍"><a id="tag">😂 简要介绍</a></h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以<code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于<strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 <spanclass="math inline">\(\LaTeX\)</span>, 并不是最淳朴的那种"所见即所得".它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服,语法简单, 尤其在处理纯文本上有很大的优势.</p><p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用,不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用<strong>Markdown</strong> 语法. 如 <strong>Github</strong>(等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀(等一系列笔记平台).</p><h2 id="实际应用">📐 实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p><p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰,层次分明.</p><p>像我大一的时候就用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告,代码的 <code>README.md</code> ... 包括本教程文档.</p><h2 id="工具">🍴 工具</h2><p>Markdown 只是一种语法. 那么用来写 Markdown 的文本编辑器呢? 我推荐的是<strong>Typora</strong> 或者 <strong>VS Code</strong></p><h3 id="typora">Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将<code>.md</code> 导出成多种文件, 如 <code>.pdf</code>,<code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p><p>但是现在 Typora 已经发布正式版并且变为收费软件. 中文官网在此 <ahref="https://typoraio.cn/">Typora 官方中文站</a>.</p><p>我当然是推荐大家都用正版啦. 不过价格是永久版￥89,好在可以用在3台设备上. 如果和你的两位同学/舍友均摊一下, 每人就只要￥30,和一张游戏月卡差不多.</p><p>至于盗版以及破解方法<ahref="https://www.only4.work/blog/?id=379">在此随便找一种改注册表时间方法的</a><del>不介绍(还挺多的其实)</del>.</p><p><del>还有一种免费白嫖的方法就是安装测试版/Beta版.官网有历史版本的下载链接 <ahref="https://typoraio.cn/windows/dev_release.html">Typora历史版本下载页</a></del></p><p>白嫖Beta版已经寄了, 要么支持正版要么去学习一下破解方法吧(还是忍不住啦, 看上面的链接👆)</p><h3 id="vs-code">VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VSCode 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All inOne</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p><h3 id="其他">其他</h3><p>大部分IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法,在此不多赘述.</p><p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora所包含的扩展语法.</p><h2 id="基础教程">🍭 基础教程</h2><p>当有多种标记方法时我会倾向其中一种.</p><p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的VS Code <strong>本地生效</strong>,在大多数平台上<strong>并不认可</strong>.</p><h3 id="写-markdown-的第零步">写 Markdown 的第零步</h3><p>我们写文本的时候大多写的是中文,可是输入法在输中文时使用的标点为全角标点, 如<code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的,也是无法转义的.</p><p>我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如<code>,.?!()[]:;""</code>. 且每个半角标点在文本使用时加上后置空格,符合英文标点的书写规范, 也更加美观.</p><p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> +<code>.(这是个句号)</code>, 切换标点的全角与半角.这样即可中文输入+半角标点.</p><h3 id="标题-数个-空格-前置">标题 [数个 "#" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>标题会在目录与大纲分级显示, 可以跳转.</p><p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为<code>#标题</code>, 应为 <code># 标题</code>.</p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.</p><h3 id="强调-用-或-__-包围">强调 [用 "**" 或 "__" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**欢迎报考南京大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考南京大学!__</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>.</p><p>E.G.</p><p><strong>欢迎报考南京大学!</strong></p><h3 id="斜体-用-或-_-包围">斜体 [用 "*" 或 "_" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*欢迎大佬来浇浇我各种知识* (我喜欢用这种)</span><br><span class="line">_欢迎大佬来浇浇我各种知识_</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>.</p><p>E.G.</p><p><em>欢迎大佬来浇浇我各种知识</em></p><p>(P.S. <strong><em>斜体并强调</em></strong> [用 "***" 或 "___"包围])</p><h3 id="删除线-用-包围">删除线 [用 "~~" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我宣布个事儿, 我是Sabiyary!~~</span><br></pre></td></tr></table></figure><p>E.G.</p><p><del>我宣布个事儿, 我是Sabiyary!</del></p><h3 id="高亮-用-包围">*高亮 [用 "==" 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==我喜欢黄色, 也喜欢绿色==</span><br></pre></td></tr></table></figure><p>E.G.</p><p>==我喜欢黄色, 也喜欢绿色==</p><h3 id="代码-用-包围">代码 [用 "`" 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo rm -rf /*`</span><br></pre></td></tr></table></figure><p>E.G.</p><p><code>sudo rm -rf /*</code> (没事别乱敲这个! )</p><p><del>"请输入管理员密码: (闪烁的光标)"</del></p><h3 id="代码块-按三个-并敲回车">代码块 [按三个 "`" 并敲回车]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment">// 这里就可以开始输入你要的代码了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    print（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    retrun O;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">``` // (这三个&quot;</span>`<span class="string">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></span><br></pre></td></tr></table></figure><p>(我之前都是用这个来展示各种语法的, 应该不用举例了吧)</p><p>要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项.</p><p>代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后,<code>```</code> 会变为 <code>````</code> + <code>对应语言</code>.</p><h3 id="引用-空格-前置">引用 ["&gt;" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 24岁, 是学生.</span><br><span class="line">&gt; &gt; 学生特有的无处不在(恼)</span><br></pre></td></tr></table></figure><p>引用是可以嵌套的!</p><p>E.G.</p><blockquote><p>24岁, 是学生.</p><blockquote><p>学生特有的无处不在(恼)</p></blockquote></blockquote><h3 id="无序列表---或-空格-前置">无序列表 ["-" 或 "+" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一颗是枣树 (我喜欢用这种)</span><br><span class="line">+ 另一颗还是枣树</span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure><p>三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号,敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><ul><li>一颗是枣树</li><li>另一颗还是枣树</li></ul><h3 id="有序列表-数字-.-空格-前置">有序列表 [数字 + "." + 空格前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我来这里就为了三件事:</span><br><span class="line">1. 公平</span><br><span class="line">2. 公平</span><br><span class="line">3. 还是tm的公平!</span><br></pre></td></tr></table></figure><p>敲回车会自动补全, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><p>我来这里就为了三件事:</p><ol type="1"><li><p>公平</p></li><li><p>公平</p></li><li><p>还是tm的公平!</p></li></ol><h3 id="上标-用-包围">*上标 [用 "^" 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure><p>E.G.</p><p>C语言中 <code>int</code> 的上限是 2<sup>31</sup> - 1 = 2147483647</p><h3 id="下标-用-包围">*下标 [用 "~" 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure><p>E.G.</p><p>H<sub>2</sub>O 是剧毒的!</p><h3 id="注释-后置">*注释 ["[^]" 后置]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure><p>需要在文末写上注释对应的内容</p><p>E.G.</p><blockquote><p>今日我们相聚于此, 是为了学习 Markdown 的使用,它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励!<a href="#fn1"class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></blockquote><h3 id="链接-常用-分别包围文本与链接">链接 [常用 "[ ]" + "( )"分别包围文本与链接]</h3><p><strong>(注意: 文内跳转为扩展用法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)</span><br><span class="line">[基础教程: 12. 下标](#12. 下标 [用 &quot;~&quot; 包围])</span><br></pre></td></tr></table></figure><p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并<code>单击鼠标左键</code> 即可跳转.</p><p>E.G.</p><p><a href="https://github.com/Sakiyary">来看看我贫瘠的仓库罢</a></p><p>[基础教程: 12. 下标](#12. 下标 [用 "~" 包围])</p><h3 id="任务列表---空格-前置">任务列表 ["- [ ]" + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TodoList:</span><br><span class="line">- [ ] 刷B站</span><br><span class="line">- [ ] 写代码</span><br><span class="line">- [x] 起床</span><br></pre></td></tr></table></figure><p>用 <code>x</code> 代替 <code>[ ]</code> 中的空格来勾选任务列表. 在Typora 中可以直接用鼠标左键单击勾选框.</p><p>E.G. TodoList:</p><ul class="task-list"><li><label><input type="checkbox" />刷B站</label></li><li><label><input type="checkbox" />写代码</label></li><li><label><input type="checkbox" checked="" />起床</label></li></ul><h3 id="表格-用-绘制表格边框">表格 [用 "|" 绘制表格边框]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 学号 | 姓名  | 年龄 |</span><br><span class="line">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class="line">|114514|田所|24|</span><br><span class="line">|1919810|浩三|25|</span><br></pre></td></tr></table></figure><p>第一行为表头, 并由第二行分割线决定对齐方式与长度,第三行及之后即表格数据</p><p>E.G.</p><table><thead><tr class="header"><th style="text-align: left;">学号</th><th style="text-align: center;">姓名</th><th style="text-align: right;">年龄</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">114514</td><td style="text-align: center;">田所</td><td style="text-align: right;">24</td></tr><tr class="even"><td style="text-align: left;">1919810</td><td style="text-align: center;">浩三</td><td style="text-align: right;">25</td></tr></tbody></table><h3 id="图片-直接拖进来或者复制粘贴">图片 [直接拖进来或者复制粘贴]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片](图片的位置)</span><br></pre></td></tr></table></figure><p>我还是会选择拖进来或者复制粘贴啦~ 在 Typora的设置里也可以改图片的储存方式.</p><h3 id="分割线-按三个-或---或-_-并敲回车">分割线 [按三个 "*" 或 "-" 或"_" 并敲回车]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">--- (我喜欢用这种)</span><br><span class="line">___</span><br><span class="line">// (其实按三个及以上都可以)</span><br></pre></td></tr></table></figure><p>由于 <code>*</code> 与 <code>_</code> 均会自动补全, 所以我觉得<code>-</code> 最为方便.</p><p>E.G.</p><hr /><hr /><hr /><h3 id="emoji表情-前置">Emoji表情 [":" 前置]</h3><p><strong>(注意: 英文输入为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sweat_smile: </span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br></pre></td></tr></table></figure><p>这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji的英文名.</p><p>E.G.</p><p>:sweat_smile: :drooling_face: :clown_face:</p><p>对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来,这是直接<strong>硬编码</strong>的 (<del>刻进DNA里</del>)</p><p>E.G.</p><p>😅🤤🤡</p><p>用好这个功能可以让你的文本非常的可爱! <del>太抽象了</del></p><p>这里分享一个可以复制<ahref="https://emojipedia.org/apple/">全Emoji的网站</a>, 非常好用!我之前的C语言大作业也是从这里下载的资源!</p><h2 id="进阶教程">🔥 进阶教程</h2><h3 id="目录-自动生成">目录 [自动生成]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure><p>若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code的<code>命令面板</code> (即 <ahref="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">VSCode Command Palette</a>) 输入 <code>Create Table of Contents</code>自动生成目录, 且可在扩展设置中细调目录参数.</p><h3 id="内联-html-代码-用-包围">内联 HTML 代码 [用 "&lt;&gt; &lt;/&gt;"包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">  &lt;font style=&quot;color:red&quot;&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>只要你会写, 你完全可以把 Markdown 当作 <strong>HTML</strong>来写.</p><p>同时, <code>.md</code> 文件可以直接导出成一个网页.</p><p>下划线可以选中想要下划的文字按下 <code>Ctrl</code> +<code>U</code>.</p><p>E.G.</p><div style="text-align:center"><p><font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font></p></div><center>简单的文字居中也可以这样</center><p><u>我差点忘了还有下划线这东西...</u></p><h3 id="内联-latex-公式-用-包围">内联 <spanclass="math inline">\(\LaTeX\)</span> 公式 [用 "$" 包围]</h3><p><strong>(注意: 部分编译器会不识别部分符号)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class="line"></span><br><span class="line">$a^n+b^n=c^n$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">%\usepackage&#123;unicode-math&#125;</span><br><span class="line">\displaystyle \ointctrclockwise\mathcal&#123;D&#125;[x(t)]</span><br><span class="line">\sqrt&#123;\frac&#123;\displaystyle3\uppi^2-\sum_&#123;q=0&#125;^&#123;\infty&#125;(z+\hat L)^&#123;q&#125;</span><br><span class="line">\exp(\symrm&#123;i&#125;q^2 \hbar x)&#125;&#123;\displaystyle (\symsfup&#123;Tr&#125;\symbfcal&#123;A&#125;)</span><br><span class="line">\left(\symbf\Lambda_&#123;j_1j_2&#125;^&#123;i_1i_2&#125;\Gamma_&#123;i_1i_2&#125;^&#123;j_1j_2&#125;</span><br><span class="line">\hookrightarrow\vec D\cdot \symbf P \right)&#125;&#125;</span><br><span class="line">=\underbrace&#123;\widetilde&#123;\left\langle \frac&#123;\notin \emptyset&#125;</span><br><span class="line">&#123;\varpi\alpha_&#123;k\uparrow&#125;&#125;\middle\vert</span><br><span class="line">\frac&#123;\partial_\mu T_&#123;\mu\nu&#125;&#125;&#123;2&#125;\right\rangle&#125;&#125;_&#123;\mathrm&#123;K&#125;_3</span><br><span class="line">\mathrm&#123;Fe&#125;(\mathrm&#123;CN&#125;)_6&#125; ,\forall z \in \mathbb&#123;R&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>用 <code>$</code> 包围为单条公式, 按下两个 <code>$</code>并敲回车即生成公式块.</p><p>E.G.</p><p><span class="math inline">\(\LaTeX\)</span> 是最好用的论文排版语言!不信你看!</p><p><span class="math inline">\(a^n+b^n=c^n\)</span></p><p><span class="math display">\[%\usepackage{unicode-math}\displaystyle \ointctrclockwise\mathcal{D}[x(t)]\sqrt{\frac{\displaystyle3\uppi^2-\sum_{q=0}^{\infty}(z+\hat L)^{q}\exp(\symrm{i}q^2 \hbar x)}{\displaystyle (\symsfup{Tr}\symbfcal{A})\left(\symbf\Lambda_{j_1j_2}^{i_1i_2}\Gamma_{i_1i_2}^{j_1j_2}\hookrightarrow\vec D\cdot \symbf P \right)}}=\underbrace{\widetilde{\left\langle \frac{\notin \emptyset}{\varpi\alpha_{k\uparrow}}\middle\vert\frac{\partial_\mu T_{\mu\nu}}{2}\right\rangle}}_{\mathrm{K}_3\mathrm{Fe}(\mathrm{CN})_6} ,\forall z \in \mathbb{R}\]</span></p><h3 id="网络图床">*网络图床</h3><p>(这是学长给我的网络图床教程, 我并未实践过...)</p><p>分享一个 Typora 搭配腾讯云COS/阿里云OSS图床的<ahref="https://blog.csdn.net/guo_ridgepole/article/details/108257277">例子</a>.新用户免费试用6个月, 另外还可选择七牛云或者路过图床.</p><h3 id="typora-的常用快捷键">*Typora 的常用快捷键</h3><table><colgroup><col style="width: 26%" /><col style="width: 21%" /><col style="width: 26%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th style="text-align: center;">按键</th><th style="text-align: center;">效果</th><th style="text-align: center;">按键</th><th style="text-align: center;">效果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>D</code></td><td style="text-align: center;">选中当前词</td><td style="text-align: center;"><code>Ctrl</code> + <code>L</code></td><td style="text-align: center;">选中当前句/行</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>E</code></td><td style="text-align: center;">选中当前区块</td><td style="text-align: center;"><code>Ctrl</code> + <code>F</code></td><td style="text-align: center;">搜索当前选中</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>B</code></td><td style="text-align: center;">加粗当前选中</td><td style="text-align: center;"><code>Ctrl</code> + <code>H</code></td><td style="text-align: center;">替换当前选中</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>I</code></td><td style="text-align: center;">倾斜当前选中</td><td style="text-align: center;"><code>Ctrl</code> + <code>U</code></td><td style="text-align: center;">下划当前选中</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>K</code></td><td style="text-align: center;">将当前选中生成链接</td><td style="text-align: center;"><code>Ctrl</code> + <code>J</code></td><td style="text-align: center;">滚动屏幕将选中滚至顶部</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>W</code></td><td style="text-align: center;">关闭当前窗口</td><td style="text-align: center;"><code>Ctrl</code> + <code>N</code></td><td style="text-align: center;">打开新窗口</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>O</code></td><td style="text-align: center;">打开文件</td><td style="text-align: center;"><code>Ctrl</code> + <code>P</code></td><td style="text-align: center;">搜索文件并打开</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> +<code>回车</code></td><td style="text-align: center;">表格下方插入行</td><td style="text-align: center;"><code>Ctrl</code> + <code>,</code></td><td style="text-align: center;">打开偏好设置</td></tr><tr class="odd"><td style="text-align: center;"><code>Ctrl</code> + <code>.</code></td><td style="text-align: center;">切换全角/半角标点</td><td style="text-align: center;"><code>Ctrl</code> + <code>/</code></td><td style="text-align: center;">切换正常/源代码视图</td></tr><tr class="even"><td style="text-align: center;"><code>Ctrl</code> + <code>Shift</code> +<code>-</code></td><td style="text-align: center;">缩小视图缩放</td><td style="text-align: center;"><code>Ctrl</code> + <code>Shift</code> +<code>+</code></td><td style="text-align: center;">放大视图缩放</td></tr></tbody></table><p>还有一些不常用的/三键的快捷键不在此列出.</p><h3 id="typora-的主题样式与检查元素">*Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的Markdown, 故Typora的主题样式本质就是 CSS 文件.</p><p>可以下载各种好看的主题给 Typora换上, 同时也可以自己调整对应的 CSS文件, 或者自己手搓.</p><p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开<code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML来编辑.</p><h3 id="页面跳转">页面跳转</h3><h4 id="同一文档内跳转">同一文档内跳转</h4><ul><li><p>跳转到的位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;tag&quot;&gt;......&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>原位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...](#tag)</span><br></pre></td></tr></table></figure></li><li><p>举例：跳转到本文档的第一小节</p><p><a href="#tag">同一文档内跳转</a></p></li></ul><h4 id="不同文档跳转">不同文档跳转</h4><ul><li><p>跳转到的位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;tag&quot;&gt;......&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>原位置使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...](路径#tag)</span><br></pre></td></tr></table></figure></li><li><p>举例：跳转到<code>D:\downloads\hexo\blog\source\_posts\数据结构\【图】.md</code>的例题部分</p><p><ahref="D:\downloads\hexo\blog\source_posts\数据结构【图】.md#liti">不同文档跳转</a></p></li></ul><h3 id="html语法">html语法</h3><ul><li><p>要想在typora直接使html语法生效，就应该直接将html代码粘贴到文档里，而不应该以html代码块的形式插入</p></li><li><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072245307.png"alt="image-20240307224553215" /><figcaption aria-hidden="true">image-20240307224553215</figcaption></figure></li><li><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072247006.png"alt="image-20240307224713725" /><figcaption aria-hidden="true">image-20240307224713725</figcaption></figure></li></ul><h3 id="插入本地视频">插入本地视频</h3><p>html语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;&quot;</span> <span class="attr">preload</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">id</span>=<span class="string">&quot;mp4&quot;</span> <span class="attr">src</span>=<span class="string">&quot;C:\Users\Lenovo\Videos\青年\1.mp4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的mp4视频文件可以是本地文件路径如："C:\1.mp4"，也可以是网页mp4文件路径"https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072217736.mp4"</p></blockquote><h3 id="插入b站视频">插入B站视频</h3><p>html语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">allowfullscreen</span>=<span class="string">&quot;allowfullscreen&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sandbox</span>=<span class="string">&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的src应该从 B站视频下方选择<code>分享 -&gt; 嵌入代码</code>，然后从中取出src部分即可完成。其余部分保持不变</p></blockquote><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072249425.png" alt="image-20240307224904283" style="zoom: 25%;" /></p><h3 id="图片增加标题">图片增加标题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;!--块级封装--&gt;</span><br><span class="line">    &lt;center&gt;&lt;!--将图片和文字居中--&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;图片路径放这里&quot;</span></span><br><span class="line">         style=<span class="string">&quot;zoom:这里写图片的缩放百分比&quot;</span>/&gt;</span><br><span class="line">    &lt;br&gt;&lt;!--换行--&gt;</span><br><span class="line">    这里是图片的标题&lt;!--标题--&gt;</span><br><span class="line">    &lt;/center&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><div><pre><code>       &lt;!--块级封装--&gt;&lt;center&gt;    &lt;!--将图片和文字居中--&gt;&lt;img src=&quot;https://tianchou.oss-cn-beijing.aliyuncs.com/img/202404080922927.webp&quot;&lt;br&gt;        &lt;!--换行--&gt;图1 横向联邦学习示例，横向联邦使训练样本量增大    &lt;!--标题--&gt;&lt;/center&gt;</code></pre></div><h2 id="总结">💯 总结</h2><p>至此, <strong>Markdown + Typora / VSCode</strong>的手册教程也告一段落.</p><p>不知你看完这么长的教程/手册, 是否能体会到 Markdown的精妙简洁之处呢?</p><p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown之后对于理解 HTML 也有帮助, 对于用 <spanclass="math inline">\(\LaTeX\)</span> 来写论文也有帮助.标记语言正是为了摆脱 Word 那种虽然"所见即所得", 但又过于花哨浮华,很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的"所写即所得"时,你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>沃兹·基·硕德 改编自「公鸡」普契涅拉.<a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex公式</title>
      <link href="/2023/11/26/%5Bobject%20Object%5D/others/LaTeX%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/11/26/%5Bobject%20Object%5D/others/LaTeX%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="希腊字母">希腊字母</h2><p><span class="math display">\[\delta,\lambda\\\Delta,\Lambda\\\Alpha\Beta\\\phi,\varphi\\\epsilon,\varepsilon\\π\]</span></p><h2 id="上下标">上下标</h2><p><span class="math display">\[a^2,a_1\\x^{y+z},p_{ij},p_ij\\x_i,x_{\text i}\\\text{A B},\rm{A B}\\\text A B,\rm A B\\{\rm A} B\\\text{e},\text{i}\]</span></p><span id="more"></span><h2 id="分式与根式">分式与根式</h2><p><span class="math display">\[\frac{1}{2},\frac 1 2,\\\frac 1 {x+y}\\\frac {\dfrac 1 x + 1}{y + 1}\]</span></p><p><span class="math display">\[\sqrt 2,\sqrt{x+y},\sqrt[3]x\]</span></p><h2 id="普通运算符">普通运算符</h2><p><span class="math display">\[+-\\\times,\cdot,\div\\\pm,\mp\\&gt;&lt;,\ge,\le,\gg,\ll,\ne,\approx,\equiv\\\cap,\cup,\in,\notin,\subseteq,\subsetneqq,\varnothing\\\forall,\exists,\nexists\\\because,\therefore\\\mathbb R,\R,\Q,\N,\Z_+\\\mathcal F,\mathscr F\]</span></p><p><span class="math display">\[\cdots,\vdots,\ddots\]</span></p><p><span class="math display">\[\infty,\partial,∂,\nabla,\propto,\degree\]</span></p><p><span class="math display">\[\sin x,\sec x,\cosh x\\\log_2 x, \ln x,\lg x\\\lim\limits_{x \to 0} \frac { x}{\sin x}\\\max x\]</span></p><p><span class="math display">\[\text{MSE}(x)\]</span></p><h2 id="大型运算符">大型运算符</h2><p><span class="math display">\[\sum,\prod\\\sum_i,\sum_{i=0}^N\\\frac{\sum\limits_{i=1}^n x_i}{\prod\limits_{i=1}^n x_i}\]</span></p><p><span class="math display">\[\int,\iint,\iiint,\oint,\oiint\\\int_{-\infty}^0 f(x)\,\text d x\]</span></p><p><span class="math display">\[a\, a\\a\ a\\a\quad a\\a\qquad a\]</span></p><h2 id="标注符号">标注符号</h2><p><span class="math display">\[\vec x,\overrightarrow {AB}\\\bar x,\overline{AB}\]</span></p><h2 id="箭头">箭头</h2><p><span class="math display">\[\leftarrow,\Rightarrow,\Leftrightarrow,\longleftarrow\]</span></p><h2 id="括号与定界符">括号与定界符</h2><p><span class="math display">\[([])\{ \}\\\lceil,\rceil,\lfloor,\rfloor,||\\\left(0,\frac 1 a\right]\\\left.\frac {∂f}{∂x}\right|_{x=0}\]</span></p><h2 id="多行公式">多行公式</h2><p>$$ <span class="math display">\[\begin{align}a&amp;=b+c+d\\&amp;=e+f\end{align}\]</span> $$</p><h2 id="大括号">大括号</h2><p>$$ f(x)=</p><span class="math display">\[\begin{cases}\sin x, &amp; -π\le x \le π\\0,&amp; \text{其他}\end{cases}\]</span><p>$$</p><h2 id="矩阵">矩阵</h2>$$<span class="math display">\[\begin{matrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{matrix}\]</span><p>$$</p>$$<span class="math display">\[\begin{bmatrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{bmatrix}\]</span><span class="math display">\[\begin{pmatrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{pmatrix}\]</span><span class="math display">\[\begin{vmatrix}a &amp; b &amp; \cdots &amp; c \\\vdots&amp; \vdots &amp; \ddots &amp; \vdots \\e &amp; f&amp; \cdots &amp; g\end{vmatrix}\]</span><p>$$</p><p><span class="math display">\[\bf A,\bf B^{\rm T}\]</span></p><h2 id="实战演练">实战演练</h2><p><span class="math display">\[f(x) = \frac 1 {\sqrt{2\pi} \sigma} {\rm e} ^ {-\frac{(x-\mu)^2}{2\sigma ^ 2}}\\f(x) = \frac 1 {\sqrt{2\pi} \sigma} \exp \left[ {-\frac{(x-\mu)^2}{2\sigma ^ 2}}\right]\]</span></p><p><span class="math display">\[\lim\limits_{N\to \infty} P \left\{ \left| \frac {I\left( \alpha_i\right)}{N} - H(s) \right| &lt; \varepsilon  \right\} = 1\]</span></p><p>$$ x(n) = {2} _{-π} ^ π X( {} ^</p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sscanf&#92;sprintf</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/C++/sscanf%E5%92%8Cssprintf/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/C++/sscanf%E5%92%8Cssprintf/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>​ <code>sscanf</code>和<code>sprintf</code>在处理<ahref="https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020">字符串</a>问题上很有用！（<code>sscanf</code>和<code>sprintf</code>可以从字面意思上分别理解为string+scanf和string+printf）</p><h2 id="头文件">头文件</h2><ol type="1"><li><code>C++</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><code>C</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="正文">正文</h2><p>简单举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sscanf与sprintf </span></span><br><span class="line"><span class="comment">sscanf(str,&quot;%d&quot;,&amp;n) 其实就是把字符串str的内容以&quot;%d&quot;的格式写入到int::n中（从左到右）</span></span><br><span class="line"><span class="comment">同理 sprintf(str,&quot;%d&quot;,n)就是把int::n以&quot;%d&quot;的格式写入到字符串str （从右到左） </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;666&quot;</span>;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">10</span>]; </span><br><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line"><span class="built_in">sprintf</span>(str1,<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str1); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述输出结果为</p><blockquote><p>666 666</p></blockquote><p>处理上述例子，还可以使用较为复杂的格式，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line"><span class="type">double</span> date;</span><br><span class="line"><span class="type">char</span> str1[<span class="number">100</span>],str2[<span class="number">100</span>]=<span class="string">&quot;2020:7.2:go!&quot;</span>,str3[<span class="number">100</span>]=<span class="string">&quot;woo~&quot;</span>; </span><br><span class="line"><span class="built_in">sscanf</span>(str2,<span class="string">&quot;%d:%lf:%s&quot;</span>,&amp;year,&amp;date,str1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;========sscanf========\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;year=%d,date=%.1f,str1=%s\n&quot;</span>,year,date,str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;========sprintf========\n&quot;</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(str1,<span class="string">&quot;%d:%.1f:%s&quot;</span>,year,date,str3); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下图所示： <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311111729191.png"alt="在这里插入图片描述" /></p><h2 id="应用">应用</h2><blockquote><p><code>sscanf</code>和<code>sprintf</code>应用如下：（以下例题为蓝桥杯模拟题）一般都是使用sprinf将整型数据写入到字符串数组，再将字符串数组转为<code>string</code>，从而使用<code>string</code>的方法函数</p></blockquote><h3 id="例一">例一：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在1至2019中，有多少个数的数位中包含数字9？</span></span><br><span class="line"><span class="comment">注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算时只是算一个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2019</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;<span class="comment">//char数组转string</span></span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">find</span>(<span class="string">&#x27;9&#x27;</span>) != string::npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例二">例二：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*</span><br><span class="line">一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。</span><br><span class="line">给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？</span><br><span class="line">*/</span><br><span class="line">char str[1000001];</span><br><span class="line">bool check(string num)&#123;</span><br><span class="line">int len=num.size();</span><br><span class="line">for(int i=0;i&lt;len-1;i++)&#123;</span><br><span class="line">if(num[i]&gt;num[i+1])return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125; </span><br><span class="line">//整型数转字符串 </span><br><span class="line">string toStr(int i)&#123;</span><br><span class="line">sprintf(str,&quot;%d&quot;,i);</span><br><span class="line">string num(str);</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,count=0;</span><br><span class="line">string num;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">num=toStr(i);</span><br><span class="line">if(check(num))count++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码表</title>
      <link href="/2023/11/11/%5Bobject%20Object%5D/C++/ASCII%E7%A0%81%E8%A1%A8/"/>
      <url>/2023/11/11/%5Bobject%20Object%5D/C++/ASCII%E7%A0%81%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ascii码表"><strong>ASCII码表</strong></h2><table><colgroup><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 13%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th><th style="text-align: center;"><strong>ASCII值</strong></th><th style="text-align: center;"><strong>控制字符</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">NUL</td><td style="text-align: center;">32</td><td style="text-align: center;">(space)</td><td style="text-align: center;">64</td><td style="text-align: center;">@</td><td style="text-align: center;">96</td><td style="text-align: center;">、</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">SOH</td><td style="text-align: center;">33</td><td style="text-align: center;">！</td><td style="text-align: center;">65</td><td style="text-align: center;">A</td><td style="text-align: center;">97</td><td style="text-align: center;">a</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">STX</td><td style="text-align: center;">34</td><td style="text-align: center;">”</td><td style="text-align: center;">66</td><td style="text-align: center;">B</td><td style="text-align: center;">98</td><td style="text-align: center;">b</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">ETX</td><td style="text-align: center;">35</td><td style="text-align: center;">#</td><td style="text-align: center;">67</td><td style="text-align: center;">C</td><td style="text-align: center;">99</td><td style="text-align: center;">c</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">EOT</td><td style="text-align: center;">36</td><td style="text-align: center;">$</td><td style="text-align: center;">68</td><td style="text-align: center;">D</td><td style="text-align: center;">100</td><td style="text-align: center;">d</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">ENQ</td><td style="text-align: center;">37</td><td style="text-align: center;">%</td><td style="text-align: center;">69</td><td style="text-align: center;">E</td><td style="text-align: center;">101</td><td style="text-align: center;">e</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">ACK</td><td style="text-align: center;">38</td><td style="text-align: center;">&amp;</td><td style="text-align: center;">70</td><td style="text-align: center;">F</td><td style="text-align: center;">102</td><td style="text-align: center;">f</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">BEL</td><td style="text-align: center;">39</td><td style="text-align: center;">'</td><td style="text-align: center;">71</td><td style="text-align: center;">G</td><td style="text-align: center;">103</td><td style="text-align: center;">g</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">BS</td><td style="text-align: center;">40</td><td style="text-align: center;">(</td><td style="text-align: center;">72</td><td style="text-align: center;">H</td><td style="text-align: center;">104</td><td style="text-align: center;">h</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">HT</td><td style="text-align: center;">41</td><td style="text-align: center;">)</td><td style="text-align: center;">73</td><td style="text-align: center;">I</td><td style="text-align: center;">105</td><td style="text-align: center;">i</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">LF</td><td style="text-align: center;">42</td><td style="text-align: center;">*</td><td style="text-align: center;">74</td><td style="text-align: center;">J</td><td style="text-align: center;">106</td><td style="text-align: center;">j</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">VT</td><td style="text-align: center;">43</td><td style="text-align: center;">+</td><td style="text-align: center;">75</td><td style="text-align: center;">K</td><td style="text-align: center;">107</td><td style="text-align: center;">k</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;">FF</td><td style="text-align: center;">44</td><td style="text-align: center;">,</td><td style="text-align: center;">76</td><td style="text-align: center;">L</td><td style="text-align: center;">108</td><td style="text-align: center;">l</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;">CR</td><td style="text-align: center;">45</td><td style="text-align: center;">-</td><td style="text-align: center;">77</td><td style="text-align: center;">M</td><td style="text-align: center;">109</td><td style="text-align: center;">m</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;">SO</td><td style="text-align: center;">46</td><td style="text-align: center;">.</td><td style="text-align: center;">78</td><td style="text-align: center;">N</td><td style="text-align: center;">110</td><td style="text-align: center;">n</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;">SI</td><td style="text-align: center;">47</td><td style="text-align: center;">/</td><td style="text-align: center;">79</td><td style="text-align: center;">O</td><td style="text-align: center;">111</td><td style="text-align: center;">o</td></tr><tr class="odd"><td style="text-align: center;">16</td><td style="text-align: center;">DLE</td><td style="text-align: center;">48</td><td style="text-align: center;">0</td><td style="text-align: center;">80</td><td style="text-align: center;">P</td><td style="text-align: center;">112</td><td style="text-align: center;">p</td></tr><tr class="even"><td style="text-align: center;">17</td><td style="text-align: center;">DCI</td><td style="text-align: center;">49</td><td style="text-align: center;">1</td><td style="text-align: center;">81</td><td style="text-align: center;">Q</td><td style="text-align: center;">113</td><td style="text-align: center;">q</td></tr><tr class="odd"><td style="text-align: center;">18</td><td style="text-align: center;">DC2</td><td style="text-align: center;">50</td><td style="text-align: center;">2</td><td style="text-align: center;">82</td><td style="text-align: center;">R</td><td style="text-align: center;">114</td><td style="text-align: center;">r</td></tr><tr class="even"><td style="text-align: center;">19</td><td style="text-align: center;">DC3</td><td style="text-align: center;">51</td><td style="text-align: center;">3</td><td style="text-align: center;">83</td><td style="text-align: center;">X</td><td style="text-align: center;">115</td><td style="text-align: center;">s</td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;">DC4</td><td style="text-align: center;">52</td><td style="text-align: center;">4</td><td style="text-align: center;">84</td><td style="text-align: center;">T</td><td style="text-align: center;">116</td><td style="text-align: center;">t</td></tr><tr class="even"><td style="text-align: center;">21</td><td style="text-align: center;">NAK</td><td style="text-align: center;">53</td><td style="text-align: center;">5</td><td style="text-align: center;">85</td><td style="text-align: center;">U</td><td style="text-align: center;">117</td><td style="text-align: center;">u</td></tr><tr class="odd"><td style="text-align: center;">22</td><td style="text-align: center;">SYN</td><td style="text-align: center;">54</td><td style="text-align: center;">6</td><td style="text-align: center;">86</td><td style="text-align: center;">V</td><td style="text-align: center;">118</td><td style="text-align: center;">v</td></tr><tr class="even"><td style="text-align: center;">23</td><td style="text-align: center;">TB</td><td style="text-align: center;">55</td><td style="text-align: center;">7</td><td style="text-align: center;">87</td><td style="text-align: center;">W</td><td style="text-align: center;">119</td><td style="text-align: center;">w</td></tr><tr class="odd"><td style="text-align: center;">24</td><td style="text-align: center;">CAN</td><td style="text-align: center;">56</td><td style="text-align: center;">8</td><td style="text-align: center;">88</td><td style="text-align: center;">X</td><td style="text-align: center;">120</td><td style="text-align: center;">x</td></tr><tr class="even"><td style="text-align: center;">25</td><td style="text-align: center;">EM</td><td style="text-align: center;">57</td><td style="text-align: center;">9</td><td style="text-align: center;">89</td><td style="text-align: center;">Y</td><td style="text-align: center;">121</td><td style="text-align: center;">y</td></tr><tr class="odd"><td style="text-align: center;">26</td><td style="text-align: center;">SUB</td><td style="text-align: center;">58</td><td style="text-align: center;">:</td><td style="text-align: center;">90</td><td style="text-align: center;">Z</td><td style="text-align: center;">122</td><td style="text-align: center;">z</td></tr><tr class="even"><td style="text-align: center;">27</td><td style="text-align: center;">ESC</td><td style="text-align: center;">59</td><td style="text-align: center;">;</td><td style="text-align: center;">91</td><td style="text-align: center;">[</td><td style="text-align: center;">123</td><td style="text-align: center;">{</td></tr><tr class="odd"><td style="text-align: center;">28</td><td style="text-align: center;">FS</td><td style="text-align: center;">60</td><td style="text-align: center;">&lt;</td><td style="text-align: center;">92</td><td style="text-align: center;">\</td><td style="text-align: center;">124</td><td style="text-align: center;">|</td></tr><tr class="even"><td style="text-align: center;">29</td><td style="text-align: center;">GS</td><td style="text-align: center;">61</td><td style="text-align: center;">=</td><td style="text-align: center;">93</td><td style="text-align: center;">]</td><td style="text-align: center;">125</td><td style="text-align: center;">}</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;">RS</td><td style="text-align: center;">62</td><td style="text-align: center;">&gt;</td><td style="text-align: center;">94</td><td style="text-align: center;">^</td><td style="text-align: center;">126</td><td style="text-align: center;">~</td></tr><tr class="even"><td style="text-align: center;">31</td><td style="text-align: center;">US</td><td style="text-align: center;">63</td><td style="text-align: center;">?</td><td style="text-align: center;">95</td><td style="text-align: center;">—</td><td style="text-align: center;">127</td><td style="text-align: center;">DEL</td></tr></tbody></table><span id="more"></span><p><strong>注意</strong></p><blockquote><ol type="1"><li><strong>ASCII中的<code>0</code>~<code>31</code>为控制字符；<code>32</code>~<code>126</code>为打印字符；<code>127</code>为Delete(删除)命令</strong>，下表为控制字符释义</li></ol><table><colgroup><col style="width: 15%" /><col style="width: 18%" /><col style="width: 15%" /><col style="width: 15%" /><col style="width: 18%" /><col style="width: 18%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">00</td><td style="text-align: center;">空</td><td style="text-align: center;">16</td><td style="text-align: center;">10</td><td style="text-align: center;">数据链路转意</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">01</td><td style="text-align: center;">头标开始</td><td style="text-align: center;">17</td><td style="text-align: center;">11</td><td style="text-align: center;">设备控制 1</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">02</td><td style="text-align: center;">正文开始</td><td style="text-align: center;">18</td><td style="text-align: center;">12</td><td style="text-align: center;">设备控制 2</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">03</td><td style="text-align: center;">正文结束</td><td style="text-align: center;">19</td><td style="text-align: center;">13</td><td style="text-align: center;">设备控制 3</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">04</td><td style="text-align: center;">传输结束</td><td style="text-align: center;">20</td><td style="text-align: center;">14</td><td style="text-align: center;">设备控制 4</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">05</td><td style="text-align: center;">查询</td><td style="text-align: center;">21</td><td style="text-align: center;">15</td><td style="text-align: center;">反确认</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">06</td><td style="text-align: center;">确认</td><td style="text-align: center;">22</td><td style="text-align: center;">16</td><td style="text-align: center;">同步空闲</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">07</td><td style="text-align: center;">震铃</td><td style="text-align: center;">23</td><td style="text-align: center;">17</td><td style="text-align: center;">传输块结束</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">08</td><td style="text-align: center;">backspace</td><td style="text-align: center;">24</td><td style="text-align: center;">18</td><td style="text-align: center;">取消</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">09</td><td style="text-align: center;">水平制表符</td><td style="text-align: center;">25</td><td style="text-align: center;">19</td><td style="text-align: center;">媒体结束</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">0A</td><td style="text-align: center;">换行/新行</td><td style="text-align: center;">26</td><td style="text-align: center;">1A</td><td style="text-align: center;">替换</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">0B</td><td style="text-align: center;">竖直制表符</td><td style="text-align: center;">27</td><td style="text-align: center;">1B</td><td style="text-align: center;">转意</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;">0C</td><td style="text-align: center;">换页/新页</td><td style="text-align: center;">28</td><td style="text-align: center;">1C</td><td style="text-align: center;">文件分隔符</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;">0D</td><td style="text-align: center;">回车</td><td style="text-align: center;">29</td><td style="text-align: center;">1D</td><td style="text-align: center;">组分隔符</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;">0E</td><td style="text-align: center;">移出</td><td style="text-align: center;">30</td><td style="text-align: center;">1E</td><td style="text-align: center;">记录分隔符</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;">0F</td><td style="text-align: center;">移入</td><td style="text-align: center;">31</td><td style="text-align: center;">1F</td><td style="text-align: center;">单元分隔符</td></tr></tbody></table></blockquote><h2 id="ascii扩展字符">ASCII扩展字符</h2><p>​<strong>ASCII扩展字符——（为了适应更多字符）<code>128</code>~<code>255</code>/<code>-128</code>~<code>-1</code>，其中，<code>-128</code>对应<code>128</code>，依次递增对应</strong></p><table><colgroup><col style="width: 16%" /><col style="width: 20%" /><col style="width: 13%" /><col style="width: 16%" /><col style="width: 20%" /><col style="width: 13%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th><th style="text-align: center;"><strong>十进制</strong></th><th style="text-align: center;"><strong>十六进制</strong></th><th style="text-align: center;"><strong>字符</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">128</td><td style="text-align: center;">80</td><td style="text-align: center;">Ç</td><td style="text-align: center;">192</td><td style="text-align: center;">C0</td><td style="text-align: center;">└</td></tr><tr class="even"><td style="text-align: center;">129</td><td style="text-align: center;">81</td><td style="text-align: center;">ü</td><td style="text-align: center;">193</td><td style="text-align: center;">C1</td><td style="text-align: center;">┴</td></tr><tr class="odd"><td style="text-align: center;">130</td><td style="text-align: center;">82</td><td style="text-align: center;">é</td><td style="text-align: center;">194</td><td style="text-align: center;">C2</td><td style="text-align: center;">┬</td></tr><tr class="even"><td style="text-align: center;">131</td><td style="text-align: center;">83</td><td style="text-align: center;">â</td><td style="text-align: center;">195</td><td style="text-align: center;">C3</td><td style="text-align: center;">├</td></tr><tr class="odd"><td style="text-align: center;">132</td><td style="text-align: center;">84</td><td style="text-align: center;">ä</td><td style="text-align: center;">196</td><td style="text-align: center;">C4</td><td style="text-align: center;">─</td></tr><tr class="even"><td style="text-align: center;">133</td><td style="text-align: center;">85</td><td style="text-align: center;">à</td><td style="text-align: center;">197</td><td style="text-align: center;">C5</td><td style="text-align: center;">┼</td></tr><tr class="odd"><td style="text-align: center;">134</td><td style="text-align: center;">86</td><td style="text-align: center;">å</td><td style="text-align: center;">198</td><td style="text-align: center;">C6</td><td style="text-align: center;">╞</td></tr><tr class="even"><td style="text-align: center;">135</td><td style="text-align: center;">87</td><td style="text-align: center;">ç</td><td style="text-align: center;">199</td><td style="text-align: center;">C7</td><td style="text-align: center;">╟</td></tr><tr class="odd"><td style="text-align: center;">136</td><td style="text-align: center;">88</td><td style="text-align: center;">ê</td><td style="text-align: center;">200</td><td style="text-align: center;">C8</td><td style="text-align: center;">╚</td></tr><tr class="even"><td style="text-align: center;">137</td><td style="text-align: center;">89</td><td style="text-align: center;">ë</td><td style="text-align: center;">201</td><td style="text-align: center;">C9</td><td style="text-align: center;">╔</td></tr><tr class="odd"><td style="text-align: center;">138</td><td style="text-align: center;">8A</td><td style="text-align: center;">è</td><td style="text-align: center;">202</td><td style="text-align: center;">CA</td><td style="text-align: center;">╩</td></tr><tr class="even"><td style="text-align: center;">139</td><td style="text-align: center;">8B</td><td style="text-align: center;">ï</td><td style="text-align: center;">203</td><td style="text-align: center;">CB</td><td style="text-align: center;">╦</td></tr><tr class="odd"><td style="text-align: center;">140</td><td style="text-align: center;">8C</td><td style="text-align: center;">î</td><td style="text-align: center;">204</td><td style="text-align: center;">CC</td><td style="text-align: center;">╠</td></tr><tr class="even"><td style="text-align: center;">141</td><td style="text-align: center;">8D</td><td style="text-align: center;">ì</td><td style="text-align: center;">205</td><td style="text-align: center;">CD</td><td style="text-align: center;">═</td></tr><tr class="odd"><td style="text-align: center;">142</td><td style="text-align: center;">8E</td><td style="text-align: center;">Ä</td><td style="text-align: center;">206</td><td style="text-align: center;">CE</td><td style="text-align: center;">╬</td></tr><tr class="even"><td style="text-align: center;">143</td><td style="text-align: center;">8F</td><td style="text-align: center;">Å</td><td style="text-align: center;">207</td><td style="text-align: center;">CF</td><td style="text-align: center;">╧</td></tr><tr class="odd"><td style="text-align: center;">144</td><td style="text-align: center;">90</td><td style="text-align: center;">É</td><td style="text-align: center;">208</td><td style="text-align: center;">D0</td><td style="text-align: center;">╨</td></tr><tr class="even"><td style="text-align: center;">145</td><td style="text-align: center;">91</td><td style="text-align: center;">æ</td><td style="text-align: center;">209</td><td style="text-align: center;">D1</td><td style="text-align: center;">╤</td></tr><tr class="odd"><td style="text-align: center;">146</td><td style="text-align: center;">92</td><td style="text-align: center;">Æ</td><td style="text-align: center;">210</td><td style="text-align: center;">D2</td><td style="text-align: center;">╥</td></tr><tr class="even"><td style="text-align: center;">147</td><td style="text-align: center;">93</td><td style="text-align: center;">ô</td><td style="text-align: center;">211</td><td style="text-align: center;">D3</td><td style="text-align: center;">╙</td></tr><tr class="odd"><td style="text-align: center;">148</td><td style="text-align: center;">94</td><td style="text-align: center;">ö</td><td style="text-align: center;">212</td><td style="text-align: center;">D4</td><td style="text-align: center;">Ô</td></tr><tr class="even"><td style="text-align: center;">149</td><td style="text-align: center;">95</td><td style="text-align: center;">ò</td><td style="text-align: center;">213</td><td style="text-align: center;">D5</td><td style="text-align: center;">╒</td></tr><tr class="odd"><td style="text-align: center;">150</td><td style="text-align: center;">96</td><td style="text-align: center;">û</td><td style="text-align: center;">214</td><td style="text-align: center;">D6</td><td style="text-align: center;">╓</td></tr><tr class="even"><td style="text-align: center;">151</td><td style="text-align: center;">97</td><td style="text-align: center;">ù</td><td style="text-align: center;">215</td><td style="text-align: center;">D7</td><td style="text-align: center;">╫</td></tr><tr class="odd"><td style="text-align: center;">152</td><td style="text-align: center;">98</td><td style="text-align: center;">ÿ</td><td style="text-align: center;">216</td><td style="text-align: center;">D8</td><td style="text-align: center;">╪</td></tr><tr class="even"><td style="text-align: center;">153</td><td style="text-align: center;">99</td><td style="text-align: center;">Ö</td><td style="text-align: center;">217</td><td style="text-align: center;">D9</td><td style="text-align: center;">┘</td></tr><tr class="odd"><td style="text-align: center;">154</td><td style="text-align: center;">9A</td><td style="text-align: center;">Ü</td><td style="text-align: center;">218</td><td style="text-align: center;">DA</td><td style="text-align: center;">┌</td></tr><tr class="even"><td style="text-align: center;">155</td><td style="text-align: center;">9B</td><td style="text-align: center;">¢</td><td style="text-align: center;">219</td><td style="text-align: center;">DB</td><td style="text-align: center;">█</td></tr><tr class="odd"><td style="text-align: center;">156</td><td style="text-align: center;">9C</td><td style="text-align: center;">£</td><td style="text-align: center;">220</td><td style="text-align: center;">DC</td><td style="text-align: center;">▄</td></tr><tr class="even"><td style="text-align: center;">157</td><td style="text-align: center;">9D</td><td style="text-align: center;">¥</td><td style="text-align: center;">221</td><td style="text-align: center;">DD</td><td style="text-align: center;">▌</td></tr><tr class="odd"><td style="text-align: center;">158</td><td style="text-align: center;">9E</td><td style="text-align: center;">?</td><td style="text-align: center;">222</td><td style="text-align: center;">DE</td><td style="text-align: center;">?</td></tr><tr class="even"><td style="text-align: center;">159</td><td style="text-align: center;">9F</td><td style="text-align: center;">ƒ</td><td style="text-align: center;">223</td><td style="text-align: center;">DF</td><td style="text-align: center;">?</td></tr><tr class="odd"><td style="text-align: center;">160</td><td style="text-align: center;">A0</td><td style="text-align: center;">á</td><td style="text-align: center;">224</td><td style="text-align: center;">E0</td><td style="text-align: center;">α</td></tr><tr class="even"><td style="text-align: center;">161</td><td style="text-align: center;">A1</td><td style="text-align: center;">í</td><td style="text-align: center;">225</td><td style="text-align: center;">E1</td><td style="text-align: center;">ß</td></tr><tr class="odd"><td style="text-align: center;">162</td><td style="text-align: center;">A2</td><td style="text-align: center;">ó</td><td style="text-align: center;">226</td><td style="text-align: center;">E2</td><td style="text-align: center;">Γ</td></tr><tr class="even"><td style="text-align: center;">163</td><td style="text-align: center;">A3</td><td style="text-align: center;">ú</td><td style="text-align: center;">227</td><td style="text-align: center;">E3</td><td style="text-align: center;">π</td></tr><tr class="odd"><td style="text-align: center;">164</td><td style="text-align: center;">A4</td><td style="text-align: center;">ñ</td><td style="text-align: center;">228</td><td style="text-align: center;">E4</td><td style="text-align: center;">Σ</td></tr><tr class="even"><td style="text-align: center;">165</td><td style="text-align: center;">A5</td><td style="text-align: center;">Ñ</td><td style="text-align: center;">229</td><td style="text-align: center;">E5</td><td style="text-align: center;">σ</td></tr><tr class="odd"><td style="text-align: center;">166</td><td style="text-align: center;">A6</td><td style="text-align: center;">ª</td><td style="text-align: center;">230</td><td style="text-align: center;">E6</td><td style="text-align: center;">µ</td></tr><tr class="even"><td style="text-align: center;">167</td><td style="text-align: center;">A7</td><td style="text-align: center;">º</td><td style="text-align: center;">231</td><td style="text-align: center;">E7</td><td style="text-align: center;">τ</td></tr><tr class="odd"><td style="text-align: center;">168</td><td style="text-align: center;">A8</td><td style="text-align: center;">¿</td><td style="text-align: center;">232</td><td style="text-align: center;">E8</td><td style="text-align: center;">Φ</td></tr><tr class="even"><td style="text-align: center;">169</td><td style="text-align: center;">A9</td><td style="text-align: center;">?</td><td style="text-align: center;">233</td><td style="text-align: center;">E9</td><td style="text-align: center;">Θ</td></tr><tr class="odd"><td style="text-align: center;">170</td><td style="text-align: center;">AA</td><td style="text-align: center;">¬</td><td style="text-align: center;">234</td><td style="text-align: center;">EA</td><td style="text-align: center;">Ω</td></tr><tr class="even"><td style="text-align: center;">171</td><td style="text-align: center;">AB</td><td style="text-align: center;">½</td><td style="text-align: center;">235</td><td style="text-align: center;">EB</td><td style="text-align: center;">δ</td></tr><tr class="odd"><td style="text-align: center;">172</td><td style="text-align: center;">AC</td><td style="text-align: center;">¼</td><td style="text-align: center;">236</td><td style="text-align: center;">EC</td><td style="text-align: center;">∞</td></tr><tr class="even"><td style="text-align: center;">173</td><td style="text-align: center;">AD</td><td style="text-align: center;">¡</td><td style="text-align: center;">237</td><td style="text-align: center;">ED</td><td style="text-align: center;">φ</td></tr><tr class="odd"><td style="text-align: center;">174</td><td style="text-align: center;">AE</td><td style="text-align: center;">«</td><td style="text-align: center;">238</td><td style="text-align: center;">EE</td><td style="text-align: center;">ε</td></tr><tr class="even"><td style="text-align: center;">175</td><td style="text-align: center;">AF</td><td style="text-align: center;">»</td><td style="text-align: center;">239</td><td style="text-align: center;">EF</td><td style="text-align: center;">∩</td></tr><tr class="odd"><td style="text-align: center;">176</td><td style="text-align: center;">B0</td><td style="text-align: center;">?</td><td style="text-align: center;">240</td><td style="text-align: center;">F0</td><td style="text-align: center;">≡</td></tr><tr class="even"><td style="text-align: center;">177</td><td style="text-align: center;">B1</td><td style="text-align: center;">?</td><td style="text-align: center;">241</td><td style="text-align: center;">F1</td><td style="text-align: center;">±</td></tr><tr class="odd"><td style="text-align: center;">178</td><td style="text-align: center;">B2</td><td style="text-align: center;">▓</td><td style="text-align: center;">242</td><td style="text-align: center;">F2</td><td style="text-align: center;">≥</td></tr><tr class="even"><td style="text-align: center;">179</td><td style="text-align: center;">B3</td><td style="text-align: center;">│</td><td style="text-align: center;">243</td><td style="text-align: center;">F3</td><td style="text-align: center;">≤</td></tr><tr class="odd"><td style="text-align: center;">180</td><td style="text-align: center;">B4</td><td style="text-align: center;">┤</td><td style="text-align: center;">244</td><td style="text-align: center;">F4</td><td style="text-align: center;">?</td></tr><tr class="even"><td style="text-align: center;">181</td><td style="text-align: center;">B5</td><td style="text-align: center;">╡</td><td style="text-align: center;">245</td><td style="text-align: center;">F5</td><td style="text-align: center;">?</td></tr><tr class="odd"><td style="text-align: center;">182</td><td style="text-align: center;">B6</td><td style="text-align: center;">╢</td><td style="text-align: center;">246</td><td style="text-align: center;">F6</td><td style="text-align: center;">÷</td></tr><tr class="even"><td style="text-align: center;">183</td><td style="text-align: center;">B7</td><td style="text-align: center;">╖</td><td style="text-align: center;">247</td><td style="text-align: center;">F7</td><td style="text-align: center;">≈</td></tr><tr class="odd"><td style="text-align: center;">184</td><td style="text-align: center;">B8</td><td style="text-align: center;">╕</td><td style="text-align: center;">248</td><td style="text-align: center;">F8</td><td style="text-align: center;">≈</td></tr><tr class="even"><td style="text-align: center;">185</td><td style="text-align: center;">B9</td><td style="text-align: center;">╣</td><td style="text-align: center;">249</td><td style="text-align: center;">F9</td><td style="text-align: center;">?</td></tr><tr class="odd"><td style="text-align: center;">186</td><td style="text-align: center;">BA</td><td style="text-align: center;">║</td><td style="text-align: center;">250</td><td style="text-align: center;">FA</td><td style="text-align: center;">·</td></tr><tr class="even"><td style="text-align: center;">187</td><td style="text-align: center;">BB</td><td style="text-align: center;">╗</td><td style="text-align: center;">251</td><td style="text-align: center;">FB</td><td style="text-align: center;">√</td></tr><tr class="odd"><td style="text-align: center;">188</td><td style="text-align: center;">BC</td><td style="text-align: center;">╝</td><td style="text-align: center;">252</td><td style="text-align: center;">FC</td><td style="text-align: center;">?</td></tr><tr class="even"><td style="text-align: center;">189</td><td style="text-align: center;">BD</td><td style="text-align: center;">╜</td><td style="text-align: center;">253</td><td style="text-align: center;">FD</td><td style="text-align: center;">²</td></tr><tr class="odd"><td style="text-align: center;">190</td><td style="text-align: center;">BE</td><td style="text-align: center;">╛</td><td style="text-align: center;">FE</td><td style="text-align: center;">■</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">191</td><td style="text-align: center;">BF</td><td style="text-align: center;">┐</td><td style="text-align: center;">255</td><td style="text-align: center;">FF</td><td style="text-align: center;">ÿ</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>int main(int argc,char *argv [])</title>
      <link href="/2023/11/03/%5Bobject%20Object%5D/C++/argc,argv/"/>
      <url>/2023/11/03/%5Bobject%20Object%5D/C++/argc,argv/</url>
      
        <content type="html"><![CDATA[<h2 id="int-mainint-argcchar-argv">int main(int argc,char *argv [])</h2><p><code>int argc</code> 和 <code>char *argv[]</code> 是通常在 C 和 C++中用于处理命令行参数的两个参数，它们用于从命令行获取程序启动时传递给程序的参数信息。</p><ol type="1"><li><code>int argc</code>（ArgumentCount）：表示命令行参数的数量，即在程序启动时传递给程序的参数的个数。参数至少包括了程序名称本身，因此至少为1。</li><li><code>char *argv[]</code>（ArgumentVector）：是一个指向字符指针数组的指针，用于存储命令行参数的字符串。每个字符串表示一个命令行参数。<strong><code>argv[0]</code>通常存储程序的名称</strong>，而<code>argv[1]</code>、<code>argv[2]</code>等存储传递给程序的其他参数。</li></ol><span id="more"></span><h2 id="实例">实例</h2><p><strong><code>a.cpp</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// argc 表示参数的数量，包括程序名称本身</span></span><br><span class="line">    <span class="comment">// argv 是一个指向参数字符串的数组</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;argc = &quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印每个命令行参数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;argv[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户不提供参数">1. 用户不提供参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\a.exe</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311032300431.png"alt="image-20231103230027354" /><figcaption aria-hidden="true">image-20231103230027354</figcaption></figure><h3 id="用户提供参数">2. 用户提供参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\a.exe 0 1 2</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202311032301519.png"alt="image-20231103230121475" /><figcaption aria-hidden="true">image-20231103230121475</figcaption></figure><blockquote><ul><li><strong><code>argv[0]</code>由OS自动赋值，存储程序的名称</strong></li><li><strong><code>argc≥1</code></strong></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型的精度及范围</title>
      <link href="/2023/10/20/%5Bobject%20Object%5D/C++/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E5%BA%A6%E5%8F%8A%E8%8C%83%E5%9B%B4/"/>
      <url>/2023/10/20/%5Bobject%20Object%5D/C++/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B2%BE%E5%BA%A6%E5%8F%8A%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310200836229.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><span id="more"></span><h2 id="整型">整型</h2><table style="width:100%;"><colgroup><col style="width: 26%" /><col style="width: 5%" /><col style="width: 26%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">字节数</th><th style="text-align: center;">取值范围1</th><th style="text-align: center;">取值范围2</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>char</code></td><td style="text-align: center;">1</td><td style="text-align: center;"><spanclass="math display">\[-2^{7}\]</span> ~ <spanclass="math display">\[2^{7}-1\]</span></td><td style="text-align: center;">-128 ~ 127</td></tr><tr class="even"><td style="text-align: center;"><code>unsigned char</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{8}-1\]</span></td><td style="text-align: center;">0 ~ 255</td></tr><tr class="odd"><td style="text-align: center;"><code>short</code></td><td style="text-align: center;">2</td><td style="text-align: center;"><spanclass="math display">\[-2^{15}\]</span> ~ <spanclass="math display">\[2^{15}-1\]</span></td><td style="text-align: center;"><span class="math display">\[-3.2\times10^{4}\]</span> ~ <span class="math display">\[3.2\times10^{4}\]</span></td></tr><tr class="even"><td style="text-align: center;"><code>unsigned short</code></td><td style="text-align: center;">2</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{16}-1\]</span></td><td style="text-align: center;">0 ~ <spanclass="math display">\[6.5\times 10^{4}\]</span></td></tr><tr class="odd"><td style="text-align: center;"><code>int</code>/<code>long</code></td><td style="text-align: center;">4</td><td style="text-align: center;"><spanclass="math display">\[-2^{31}\]</span> ~ <spanclass="math display">\[2^{31}-1\]</span></td><td style="text-align: center;"><span class="math display">\[-2.1\times10^{9}\]</span> ~ <span class="math display">\[2.1\times10^{9}\]</span></td></tr><tr class="even"><tdstyle="text-align: center;"><code>unsigned int</code>/<code>unsigned long</code></td><td style="text-align: center;">4</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{32}-1\]</span></td><td style="text-align: center;">0 ~ <spanclass="math display">\[4.2\times 10^{9}\]</span></td></tr><tr class="odd"><td style="text-align: center;"><code>long long</code></td><td style="text-align: center;">8</td><td style="text-align: center;"><spanclass="math display">\[-2^{63}\]</span> ~ <spanclass="math display">\[2^{63}-1\]</span></td><td style="text-align: center;"><span class="math display">\[-9.2\times10^{18}\]</span> ~ <span class="math display">\[9.2\times10^{18}\]</span></td></tr><tr class="even"><td style="text-align: center;"><code>unsigned long long</code></td><td style="text-align: center;">8</td><td style="text-align: center;">0 ~ <spanclass="math display">\[2^{64}-1\]</span></td><td style="text-align: center;">0 ~ <spanclass="math display">\[1.8\times 10^{19}\]</span></td></tr></tbody></table><h2 id="浮点型">浮点型</h2><table><colgroup><col style="width: 16%" /><col style="width: 7%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th style="text-align: center;">数据类型</th><th style="text-align: center;">字节数</th><th style="text-align: center;">取值范围（绝对值）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>float</code></td><td style="text-align: center;">4</td><td style="text-align: center;"><spanclass="math display">\[1.17549\times 10^{-38}\]</span> ~ <spanclass="math display">\[3.40282\times 10^{38}\]</span></td></tr><tr class="even"><td style="text-align: center;"><code>double</code></td><td style="text-align: center;">8</td><td style="text-align: center;"><spanclass="math display">\[2.22507\times 10^{-308}\]</span> ~ <spanclass="math display">\[1.79769\times 10^{308}\]</span></td></tr><tr class="odd"><td style="text-align: center;"><code>long double</code></td><td style="text-align: center;">12</td><td style="text-align: center;"><spanclass="math display">\[2.22507\times 10^{-308}\]</span> ~ <spanclass="math display">\[1.79769\times 10^{308}\]</span></td></tr></tbody></table><blockquote><p><ahref="https://blog.csdn.net/qq_52911954/article/details/125528446">C语言——数据类型、基本数据类型的取值范围_c语言数据类型取值范围_Lydialyy的博客-CSDN博客</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INT_MAX，INT_MIN</title>
      <link href="/2023/10/15/%5Bobject%20Object%5D/C++/INT_MAX%EF%BC%8CINT_MIN/"/>
      <url>/2023/10/15/%5Bobject%20Object%5D/C++/INT_MAX%EF%BC%8CINT_MIN/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2023/10/15/%5Bobject%20Object%5D/C++/%E6%8C%87%E9%92%88/"/>
      <url>/2023/10/15/%5Bobject%20Object%5D/C++/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="指针">指针</h2><h3 id="用法一">用法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> *p; <span class="comment">// p是空指针，没有分配内存单元</span></span><br><span class="line"><span class="comment">//*p=4错误</span></span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure><h3 id="用法二">用法二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// p分配了内存单元，存有内存单元的地址</span></span><br><span class="line">*p = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERROR</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/others/ERROR/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/others/ERROR/</url>
      
        <content type="html"><![CDATA[<h1 id="算法error">算法Error</h1><ul><li><p><strong><code>AC</code></strong>——Accepted 答案正确/通过</p></li><li><p><strong><code>WA</code></strong>——Wrong Answer 答案错误</p><ul><li><strong>变量定义一定要初始化</strong>，否则变量初始值就是随机数，会出现各种奇葩的答案</li><li>算法有误，算错了</li></ul></li><li><p><strong><code>RE</code></strong>——Runtime Error运行时错误</p></li><li><p><strong><code>CE</code></strong>——Complie Error 编译错误</p><ul><li>语法有问题</li></ul></li><li><p><strong><code>TLE</code></strong>——Time Limit Exceed运行超时</p></li><li><p><strong><code>MLE</code></strong>——Memory Limit Exceed超出内存限制</p></li><li><p><strong><code>PE</code></strong>——Presentation Error格式错误</p></li><li><p><strong><code>OLE</code></strong>——Output Limit Exceed输出超出限制/输出超限</p></li><li><p><strong><code>UKE</code></strong>——Unknown Error未知错误</p></li></ul><h1 id="c-error">C++ Error</h1><h2id="using-namespace-stddefinetypedefinclude顺序"><code>using namespace std</code>、<code>#define</code>、<code>typedef</code>、<code>#include</code>顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q[N][N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h2id="error-expected-initializer-before-int"><code>error: expected initializer before 'int'</code></h2><p>通常是前面一行末尾没有加 <code>;</code></p><h2id="reference-to-xxx-is-ambiguous"><code>reference to 'XXX' is ambiguous</code></h2><h3 id="原因">原因</h3><blockquote><p><strong>自定义的变量与库中重名</strong></p></blockquote><h3 id="解决">解决</h3><p>​ <strong>修改变量名</strong>，避免使用以下变量</p><ul><li><code>left</code> ==&gt; <code>l</code></li><li><code>right</code> ==&gt; <code>r</code></li><li><code>size</code> ==&gt; <code>cnt</code></li><li><code>next</code> ==&gt; <code>ne</code></li><li><code>start</code>==&gt;<code>st</code></li><li><code>end</code>==&gt;<code>ed</code></li></ul><span id="more"></span><h2 id="invalid-types-intint-for-array-subscript">invalid types'int[int]' for array subscript</h2><p>这通常是数组的问题，我目前总结出3种可能：</p><ol type="1"><li>数组变量名不一致，或者没定义，比如你定义了一个ans数组，但是你在用的时候误写成了a数组（oj应该爆CE）</li><li>数组空间不够，比如你要访问a[6]，可是你只定义了inta[6]数组，所以下标最多到5，定义改成7就行了。（oj应该爆RE）</li><li><strong>变量名和数组名重复定义</strong>，比如定义了一个inta;然后又定义了一个int a[6];数组，（oj应该爆CE吧）</li></ol><h2 id="segmentation-fault">Segmentation Fault</h2><p>主要有 2 个原因</p><ul><li><p><strong>数组越界</strong>：比如</p><ul><li>你要访问<code>a[6]</code>，可是你只定义了<code>int a[6]</code>数组，所以下标最多到5，定义改成 7 就行了</li><li>循环的条件 <code>j++</code> 写成 <code>i++</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; i++)</span><br></pre></td></tr></table></figure></li><li><p><strong>函数无限递归/递归次数太多了</strong>，爆栈</p></li></ul><h2id="error-no-matching-function-for-call-to-maxint-stdbasic_stringsize_type">error:no matching function for call to 'max(int&amp;,std::basic_string<char>::size_type)'</h2><p><code>max()/min()</code>函数必须传入两个<strong>同类型的参数</strong></p><ul><li><code>.length()</code> 和 <code>.size()</code>的返回类型都是<code>size_t</code>，使用时要在前面加上<code>(int)</code>强制类型转换</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新版《骗分导论》</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/others/%E3%80%8A%E9%AA%97%E5%88%86%E5%AF%BC%E8%AE%BA%E3%80%8B/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/others/%E3%80%8A%E9%AA%97%E5%88%86%E5%AF%BC%E8%AE%BA%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="新版骗分导论第-7-版">新版骗分导论(第 7 版)</h1><h2 id="前言">前言</h2><ul><li><ahref="https://fidel.js.org/2020/10/07/the-new-guide-of-cheating-in-oi/">【转载】蒟蒻的宝书- 新版骗分导论 | Fidel's Lab</a></li><li></li></ul><p>​ 文中类似<code>[*]</code>、<code>[**]</code>等的符号代表我对文章所做的注释<del>（并不是打错字了，也不是屏蔽语）</del>，其对应解释在文章末尾。</p><h2 id="目录">目录</h2><blockquote><p><strong>第1章 绪论</strong></p></blockquote><blockquote><p><strong>第2章 从无解出发</strong></p><blockquote><p>2.1 无解情况</p></blockquote></blockquote><blockquote><blockquote><p>2.2 样例——白送的分数</p></blockquote></blockquote><blockquote><p><strong>第3章 “艰苦朴素永不忘”</strong></p><blockquote><p>3.1 模拟</p></blockquote></blockquote><blockquote><blockquote><p>3.2 万能钥匙——<code>DFS</code></p></blockquote></blockquote><blockquote><p><strong>第4章 骗分的关键——猜想</strong></p></blockquote><blockquote><blockquote><p>4.1 听天由命</p></blockquote></blockquote><blockquote><blockquote><p>4.2 猜测答案</p></blockquote></blockquote><blockquote><blockquote><p>4.3 寻找规律</p></blockquote></blockquote><blockquote><blockquote><p>4.4 小数据杀手——打表</p></blockquote></blockquote><blockquote><p><strong>第5章 做贪心的人</strong></p></blockquote><blockquote><blockquote><p>5.1 贪心的算法</p></blockquote></blockquote><blockquote><blockquote><p>5.2 贪心地得分</p></blockquote></blockquote><blockquote><p><strong>第6章 C++的福利</strong></p></blockquote><blockquote><blockquote><p>6.1 快速排序</p></blockquote></blockquote><blockquote><blockquote><p>6.2 “如意金箍棒”</p></blockquote></blockquote><blockquote><p><strong>第7章 “宁为玉碎，不为瓦全”</strong></p></blockquote><blockquote><p><strong>第8章 实战演练</strong></p></blockquote><blockquote><p><strong>第9章 结语</strong></p></blockquote><hr /><h2 id="第1章-绪论">第1章 绪论</h2><p>在 Oier 中，有一句话广为流传：任何蒟蒻必须经过大量的刷题练习才能成为大牛乃至于神牛。 这就是著名的 lzn定理。然而，我们这些蒟蒻们，没有经过那么多历练，却要和大牛们同场竞技，我们该怎么以弱胜强呢？答案就是：<strong>骗分</strong>。</p><p>那么，骗分是什么呢？骗分就是用简单的程序（比标准算法简单很多，保证蒟蒻能轻松搞定的程序），尽可能多得骗取分数。让我们走进这本<strong>《新版骗分导论》</strong>，来学习骗分的技巧，挑战神牛吧！</p><h2 id="第2章-从无解出发">第2章 从无解出发</h2><h3 id="无解情况">2.1 无解情况</h3><p>在很多题目中都有这句话：“若无解，请输出 <code>-1</code>.”看到这句话时，骗分的蒟蒻们就欣喜若狂，因为——数据中必定会有无解的情况！那么，只要打出下面这个程序： <code>printf("-1")</code>; 就能得到10 分，甚至 20 分，30 分！</p><p>举个例子： <a href="https://www.luogu.com.cn/problem/P1078">P1078NOIP2012 普及组 文化之旅</a></p><p>这道题看起来很复杂，但其中有振奋人心的一句话<em>“输出-1”</em>，我考试时就高兴坏了<del>（当时我才初一，水平太烂）</del> ，随手打了个<code>printf("-1");</code>,得 10 分。</p><blockquote><p>还有一道题：[P8819 <ahref="https://www.luogu.com.cn/problem/P8819">CSP-S 2022]星战</a>：全部输出 <code>no</code> 即可得到 45 分<del>（CCF拿脚造的数据吧……）</del></p><p>但是相应的，2022 年的 CSP-S 分数线暴涨，比往年多了七八十分。</p><p><del>顺便玩一下梗</del>：https://www.luogu.com.cn/discuss/525529</p></blockquote><h3 id="样例白送的分数">2.2 样例——白送的分数</h3><p>每道题目的后面，都有一组 <em>“样例输入”</em> 和 <em>“样例输出”</em>。它们的价值极大，不仅能初步帮你检验程序的对错（特别坑的样例除外），而且，如果你不会做这道题（这种情况蒟蒻们已经司空见惯了），你就可以直接输出样例！例如美国的USACO，它的题目有一个规则，就是第一组数据必须是样例。那么，只要你输出所有的样例，你就能得到100 分（满分 1000 分）！这是相当可观的分数了。</p><p>现在，你已经掌握了最基础的骗分技巧。只要你会基本的输入输出语句，你就能实现这些骗分方法。那么，如果你有一定的基础，请看下一章——我将教你怎样用简单方法骗取部分分数。</p><h2 id="第3章-艰苦朴素永不忘">第3章 “艰苦朴素永不忘”</h2><p>本章的标题来源于《学习雷锋好榜样》的一句歌词，但我不是想教导你们学习雷锋精神，而是学习骗分！</p><p>看到“朴素”两个字了吗？它们代表了一类算法[*]，主要有模拟和<code>DFS</code>。下面我就来介绍它们在骗分中的应用。</p><h3 id="模拟">3.1 模拟</h3><p>所谓模拟，就是用计算机程序来模拟实际的事件。例如 NOIP2012的“寻宝”，就是写一个程序来模拟小明上藏宝塔的动作。</p><p>较繁的模拟就不叫骗分了，我这里也不讨论这个问题。</p><p>模拟主要可以应用在骗高级数据结构题上的分，例如线段树。下面举一个例子来说明一下。</p><p><a href="https://www.luogu.com.cn/problem/P2880">P2880 USACO07JANBalanced Lineup G</a></p><p>对于这个例子，大牛们可以写个线段树，而我们蒟蒻，就模拟吧。</p><p>附模拟程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> min = INT_MAX, max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= b; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt; min)</span><br><span class="line">            min = h[i];</span><br><span class="line">        <span class="keyword">if</span> (h[i] &gt; max)</span><br><span class="line">            max = h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max - min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序简洁明了，并且能高效骗分。本程序得50分。</p><h3 id="万能钥匙dfs">3.2 万能钥匙——<code>DFS</code>[**]</h3><p><code>DFS</code>是图论中的重要算法，但我们看来，图论神马的都是浮云，关键就是如何骗分。下面引出本书的第22 条定理：<code>DFS</code>是万能的。</p><p>这对于你的骗分是至关重要的。比如说，一些动态规划题，可以<code>DFS</code>；数学题，可以 <code>DFS</code>；剪枝的题，更能<code>DFS</code>。下面以一道省选题为例，解释一下<code>DFS</code>骗分。</p><p>例题： <a href="https://www.luogu.com.cn/problem/P1048">P1048NOIP2005 普及组 采药</a></p><p>这题的方法很简单。我们瞄准 20 的数据来做，可以用<code>DFS</code>枚举方案，然后模拟计算出最优解。</p><p>附一个大致的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; ans)</span><br><span class="line">            ans = c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(d + <span class="number">1</span>, c + w[i]);</span><br><span class="line">    <span class="built_in">DFS</span>(d + <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4章-骗分的关键猜想">第4章 骗分的关键——猜想</h2><h3 id="听天由命">4.1 听天由命</h3><p>如果你觉得你的人品很好，可以试试这一招——输出随机数。</p><p>先看一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">// &lt;ctime&gt;和&lt;cstdlib&gt;必不可少</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">random</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> <span class="comment">// 随机数函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    end++;</span><br><span class="line">    <span class="type">int</span> res = start + (end - start) * <span class="built_in">rand</span>() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">unsigned</span>(<span class="built_in">time</span>(<span class="number">0</span>))); <span class="comment">// 利用时间确定随机数种子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">random</span>(<span class="number">1</span>, <span class="number">100</span>)); <span class="comment">// 重复一千次输出 1~100 之间的任意数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关随机数的具体叙述，可以自行<ahref="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=C%2B%2B%20随机数&amp;fenlei=256&amp;rsv_pq=d3f8e017002ad667&amp;rsv_t=c580sKegC7Ff19NF9vEI9tAWiO8y5beJWKKCtRAReNomFOPDStrMr4SCpl4&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=6&amp;rsv_sug1=6&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;prefixsug=%26lt%3B%2B%2B%20%E9%9A%8F%E6%9C%BA%E6%95%B0&amp;rsp=4&amp;inputT=3869&amp;rsv_sug4=3954">百度</a>（<ahref="https://www.cnblogs.com/xiaokang01/p/9786751.html">可参考</a>）</p><p>这种方法适用于输出一个整数（或判断是否）的题目中，答案的范围越小越好。让老天决定你的得分吧。</p><p>据说，在 NOIP2013 中，有人最后一题不会，愤然打了个随机数，结果得了 70分啊!!</p><h3 id="猜测答案">4.2 猜测答案</h3><p>有些时候，问题的答案可能很有特点：对于大多数情况，答案是一样的。这时，骗分就该出手了。你需要做的，就是发掘出这个答案，然后直接输出。</p><p>有时，你需要运用第 3章中学到的知识，先写出朴素算法，然后造一些数据，可能就会发现规律。</p><p>例如，本班月赛中有一道题：</p><blockquote><p>### 炸毁计划</p><p>#### 【问题描述】</p><p>皇军侵占了通往招远的黄金要道。为了保护渤海通道的安全，使得黄金能够顺利地运送到敌后战略总指挥地延安，从而购买战需武器，所以我们要通过你的程序确定这条战略走廊是否安全。已知我们有N座小岛，只有使得每一个小岛都能与其他任意一个小岛联通才能保证走廊的安全。每个小岛之间只能通过若干双向联通的桥保持联系，已知有M座桥(Ai,Bi)表示第i座桥连接了Ai与Bi这两座城市。现在，敌人的炸药只能炸毁其中一座桥，请问在仅仅炸毁这一座桥的情况下，能否保证所有岛屿安全，都能联通起来。现在给出Q个询问Ci，其中Ci表示桥梁编号，桥梁的编号按照输入顺序编号。每个询问表示在仅仅炸毁第Ci座桥的情况下能否保证所有岛屿安全。如果可以，在输出文件当中，对应输入顺序输出yes，否则输出no（输出为半角英文单词，区分大小写，默认为小写，不含任何小写符号，每行输出一个空格，忽略文末空格）。</p><p>#### 【输入格式】</p><p>第一行 三个整数N，M，Q，分别表示岛屿的个数，桥梁的个数和询问的个数。第二行到第M+1行 每行两个整数。第i+1行有两个整数Ai Bi表示这个桥梁的属性。第M+2行 有Q个整数Ci表示查询。</p><p>#### 【输出格式】</p><p>Q行，表示查询结果。</p><p>#### 【样例】</p><p>destroy.in destroy.out</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1 1</span><br><span class="line">1 2</span><br><span class="line">1 no</span><br></pre></td></tr></table></figure></p><p>#### 【样例范围】</p><p>对于80%的数据，N≤100。 对于100%的数据，N≤1000，N,Q≤M≤2000 。</p></blockquote><p>你发现问题了吗？那么多座桥，炸一座就破坏岛屿的联系，可能性微乎其微（除非特别设计数据）。那么，我们的骗分策略就出来了：对于所有询问，输出<code>yes</code>.果然，此算法效果不错，得 80 分。</p><p>现在知道猜测答案的厉害了吧？</p><h3 id="寻找规律">4.3 寻找规律</h3><p>首先声明：<strong>本节讲的规律不是正当的算法规律，而是数据的特点。</strong></p><p>某些题目会给你很多样例，你就可以观察他们的特点了。有时，数据中的某一个（或几个）数，能通过简单的关系直接算出答案。</p><p>只要你找到了规律，在很多情况下你都能得到可观的分数。</p><p>这样的题目大多出现在 NOI或更高等级的比赛中，本人蒟蒻一个，就不举例了。传说某人去省选时专门琢磨数据的规律，结果有一题得了30 分。</p><h3 id="小数据杀手打表">4.4 小数据杀手——打表</h3><p>我认识一个人，他在某老师家上<code>C语言</code>家教，老师每讲一题，他都喊一句：“打表行吗？”</p><p>他真的是打表的忠实粉丝。表虽然不能乱打，但还是很有用的。</p><p>先看一个例子：</p><p><strong><a href="https://www.luogu.com.cn/problem/P1044">NOIP2003栈</a></strong></p><p>这题看似复杂，但数据范围太小，<spanclass="math inline">\(N≤18\)</span>。所以，骗分程序就好写了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">18</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">42</span>, <span class="number">132</span>, <span class="number">429</span>, <span class="number">1430</span>, <span class="number">4862</span>, <span class="number">16796</span>, <span class="number">58786</span>, <span class="number">208012</span>, <span class="number">742900</span>, <span class="number">2674440</span>, <span class="number">9694845</span>, <span class="number">35357670</span>, <span class="number">129644790</span>, <span class="number">477638700</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[n - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>测试结果不言而喻，<strong>AC</strong>了。</p><p>学完这一章，你已基本掌握了骗分技巧。下面的内容涉及一点算法知识，难度有所增加。蒟蒻中的蒟蒻可以止步于此了。</p><h2 id="第5章-做贪心的人">第5章 做贪心的人</h2><h3 id="贪心的算法">5.1 贪心的算法</h3><p>给你一堆纸币，让你挑一张，相信你一定会挑面值最大的。其实，这就是贪心算法。</p><p>贪心算法是个复杂的问题，但你不用管那么多。我们只关心骗分。给你一个问题，让你从一些东西中选出一些，你就可以使用贪心的方法，尽量挑好的。</p><p>举个例子：这是我们的市队选拔的一道题。</p><blockquote><p>### 有趣的问题</p><p>#### 【问题描述】</p><p>2013 年的 NOIP 结束后， Smart发现自己又被题目碾压了，心里非常地不爽，于是暗下决心疯狂地刷数学题目，做到天昏地暗、废寝忘食，准备在今年的中考中大展身手。有一天，他在做题时发现了一个有趣的问题： 给定n 个二元组(ai, bi)i)，记函数： <span class="math inline">\(y=100*\sum{\left( a_i\right)}/\sum{\left( b_i \right)}\)</span>; 将函数y 的值四舍五入取整。现将n 个二元组去掉其中的k 个计算一个新的y值（也四舍五入取整），均能满足：y &lt;= z ，求出最小的z值。Smart想让你帮他一起找出最小的z值。</p><p>#### 【输入格式】</p><p>输入包含多组测试数据。每组测试数据第一行两个整数：n和k；第二行为n个数：a1 a2 …… an；第三行为n 个数： b1 b2 …… bn。 输入数据当n、k 均为0时结束。</p><p>#### 【输出格式】</p><p>对于每组测试数据输出一行，即找出的最小的冘值。注意：为避免精度四舍五入出现误差，测试点保证每个函数值与最终结果的差值至少为0.001 。</p><p>#### 【样例】</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">math.in</span><br><span class="line">3 1</span><br><span class="line">5 0 1</span><br><span class="line">5 1 6</span><br><span class="line">4 2</span><br><span class="line">1 2 7 9</span><br><span class="line">5 6 7 9</span><br><span class="line">0 0</span><br><span class="line">math. out</span><br><span class="line">83</span><br><span class="line">100</span><br></pre></td></tr></table></figure></p><p>#### 【数据范围】</p><p>对于40% 的数据： n≤20； 对于70% 的数据： n≤1000； 对于100% 的数据：n≤10000，ai,bi 都在 int 范围内。</p></blockquote><p>这题让人望而生畏，但我们有贪心的手段。每个二元组的 <spanclass="math inline">\(a\)</span> 值是乘到答案中的，所以 <spanclass="math inline">\(a\)</span> 越大越好，那么只要选择出最小的 <spanclass="math inline">\(k\)</span>个去掉即可。代码就不写了，因为这个涉及到下一章的内容：排序。</p><p>此代码得20分。</p><h3 id="贪心地得分">5.2 贪心地得分</h3><p>我们已经学了很多骗分方法，但他们中的大多效率并不高，一般能骗10∼2010∼20 分。这不能满足我们的贪心。</p><p>然而，我们可以合成骗分的程序。举个最简单的例子，有些含有无解情况的题目，</p><p>它们同样有样例。我们可以写这个程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (是样例)</span><br><span class="line">    <span class="built_in">printf</span>(样例);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;- 1&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样也许能变 1010 分为 2020 分，甚至更多。</p><p>当然，合并骗分方法时要注意，不要重复骗同一种情况，或漏考虑一些情况。</p><p>大量能骗分的问题都能用此法，大家可以试试用新方法骗2.1中的例子“文化之旅”。</p><h2 id="第6章-c-的福利">第6章 C++ 的福利</h2><p><em>（请 P 党们跳过本章，这不是你们的福利）</em></p><p>在 <code>C++</code>中，有一个好东西，名唤<strong><code>STL</code></strong> ，被万千 Oier们所崇拜，所喜爱。下面让我们走进 <code>STL</code>。</p><h3 id="快速排序">6.1 快速排序</h3><p>快速排序是一个经典算法，也是<code>C++</code>党的经典福利。他们有这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//这是必须的</span></span></span><br><span class="line"><span class="built_in">sort</span>(A, A + n);      <span class="comment">// 对一个下标从0开始存储，长度为n的数组升序排序</span></span><br></pre></td></tr></table></figure><p>就这么简单，完成了 P 党[***]一大堆代码干的事情。</p><h3 id="如意金箍棒">6.2 “如意金箍棒”</h3><p><code>C++</code>里有一种东西，叫<code>vector</code>容器。它好比如意金箍棒，可以随着元素的数量而改变大小。它其实就是数组，却比数组强得多。</p><p>下面看看它的几种操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; V;  <span class="comment">// 定义</span></span><br><span class="line">V.<span class="built_in">push_back</span>(x); <span class="comment">// 末尾增加一个元素x</span></span><br><span class="line">V.<span class="built_in">pop_back</span>();   <span class="comment">// 末尾删除一个元素</span></span><br><span class="line">V.<span class="built_in">size</span>();       <span class="comment">// 返回容器中的元素个数</span></span><br><span class="line"><span class="comment">// 它同样可以使用下标（如 V[n] ）访问。（从0开始）</span></span><br></pre></td></tr></table></figure><h2 id="第7章-宁为玉碎不为瓦全">第7章 “宁为玉碎，不为瓦全”</h2><p>至此，我已介绍完了我所知的骗分方法。如果上面的方法都不奏效，我也无能为力。但是，我还有最后一招——</p><p>有句古话说：<em>“宁为玉碎，不为瓦全”</em>。我们蒟蒻也应有这样的精神。骗不到分，就报复一下，卡评测以泄愤吧！卡评测主要有两种方法：</p><ol type="1"><li>利用死循环，故意超时；</li><li>进入终端，卡住编译器。</li></ol><p>先介绍下第一种。代码很简单，请看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>就是这短短一句话，就能卡住评测机长达 <spanclass="math inline">\(10s\)</span>，<spanclass="math inline">\(20s\)</span>，甚至更多！对于测试点多、时限长的题目，这是个不错的方法。</p><p>第二种方法也很简单，但危害性较大，建议不要在重要比赛中使用，否则可能让你追悔莫及。它就是：[****]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;con&gt;</span>          <span class="comment">//windows系统中使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;/dev/console&gt;</span> <span class="comment">//Linux系统中使用</span></span></span><br></pre></td></tr></table></figure><p>它非常强大，可以卡住评测系统，使其永远停止不了编译你的程序。唯一的解除方法是，工作人员强行关机，重启，重测。当然，我不保证他们不会气愤地把你的成绩变成00 分。请慎用此方法。</p><h2 id="第8章-实战演练">第8章 实战演练</h2><p>下面我们来做一些习题，练习骗分技巧。我们来一起分析一下NOIP2013普及组的试题吧。</p><ol type="1"><li><a href="https://www.luogu.com.cn/problem/P1980">P1980 NOIP2013普及组 计数问题</a></li><li><a href="https://www.luogu.com.cn/problem/P1981">P1981 NOIP2013普及组 表达式求值</a></li><li><a href="https://www.luogu.com.cn/problem/P1982">NOIP2013 普及组小朋友的数字</a></li><li><a href="https://www.luogu.com.cn/problem/P1983">NOIP2013 普及组车站分级</a></li></ol><p>第 11 题，太弱了，不用骗，得 100100 分。</p><p>第 22 题，数据很大，但是可以直接输入一个数，输出它 mod  10000mod10000的值。得 1010 分。</p><p>第 33 题，是一道非常基础的 <code>DP</code>，但对于不知<code>DP</code>为何物的蒟蒻来说，就使用暴力算法（即<code>DFS</code>）。得 2020 分。</p><p>第 44 题，我们可以寻找一下数据的规律，你会发现，在所有样例中， <spanclass="math inline">\(M\)</span> 值即为答案。所以直接输出 <spanclass="math inline">\(M\)</span> ，得 1010 分。</p><p>这样下来，一共得 140140 分，比一等分数线还高 2020分！你的信心一定会得到鼓舞的。这就是骗分的神奇。</p><h2 id="第9章-结语">第9章 结语</h2><p>骗分是蒟蒻的有力武器，可以在比赛中骗得大量分数。相信大家在这本书中收获了很多，希望本书能帮助你多得一些分。但是，最后我还是要说一句：</p><p>不骗分，是骗分的最高境界。不骗分，是骗分的最高境界。</p><hr /><blockquote><p>### 注释</p><p>[*] 【朴素算法】 英文术语为<em>brute-force</em>，也可直译为“暴力求解”。</p></blockquote><blockquote><p>[**] 【<code>DFS</code>】 即“深度优先搜索”算法。</p></blockquote><blockquote><p>[***] 【P 党】 原文如此，应该是指学习<code>Pascal</code>语言的学生。</p></blockquote><blockquote><p>[****] 【<code>#include&lt;con&gt;...</code>】这里应该是只用在代码中加入以上两个头文件即可。不过实际使用时很可能会编译错误。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV vs Resume</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/CV%20vs%20Resume/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/CV%20vs%20Resume/</url>
      
        <content type="html"><![CDATA[<h1 id="学术">学术</h1><h2 id="cv">CV</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403110913323.png"alt="image-20240311091351193" /><figcaption aria-hidden="true">image-20240311091351193</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403110913499.png"alt="image-20240311091339390" /><figcaption aria-hidden="true">image-20240311091339390</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403110913567.png"alt="image-20240311091331323" /><figcaption aria-hidden="true">image-20240311091331323</figcaption></figure><p><ahref="https://www.bilibili.com/video/BV1CE411P7vj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【求职求学系列#1】你知道CV和resume的不同吗？还有personalstatememt和cover letter..._哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能头文件</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="万能头文件">万能头文件</h1><h2 id="介绍">介绍</h2><p>万能头文件<strong><code>#include &lt;bits/stdc++.h&gt;</code></strong>==<strong>包含了目前c++所包含的所有头文件！！！！</strong>==</p><span id="more"></span><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看我们开挂以后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol type="1"><li>使用万能头文件<font color='red'><strong>不会影响运行速度，只是会略微增加编译时间</strong></font>。考试的时候编译时间不会被计算在运行时间里，只是在debug的时候每次编译都会慢一点，如果不care这一点的话那使用万能头文件会方便一些~</li><li>使用场景：当我们==<strong>忘记</strong>==<strong>某函数的头文件</strong>或者<strong>头文件较多</strong>时，可以用<strong><code>#include&lt;bits/stdc++.h&gt;</code></strong>代替。</li><li>缺点：<ul><li><strong>编译时间太长</strong>。</li><li><strong><code>#include &lt;bits/stdc++.h&gt;</code></strong>不是c++的标准头文件，部分编译器不支持。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏定义</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="宏定义">宏定义</h1><h2 id="宏常量"><strong>宏常量</strong></h2><p>  我们最常使用到的#define的用法就是用#define来定义一个符号常量，而要修改时,只需修改#define这条语句就行了,不必每处代码都修改例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR <span class="string">&quot;圆周率约等于&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %f&quot;</span>,STR,PI); <span class="comment">//预处理时会被替换为 printf(&quot;%s %f&quot;,&quot;圆周率约等于&quot;,3.14);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>运行结果: <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429733.png"alt="在这里插入图片描述" /></p><h2 id="宏语句"><strong>宏语句</strong></h2><p>  我们还可以用宏定义一条或多条语句 例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Print printf(<span class="string">&quot;hello world!&quot;</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Print;  <span class="comment">//预处理时会被替换为 printf(&quot;hello world!&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>操作结果: <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429680.png"alt="在这里插入图片描述" /></p><h2 id="宏函数"><strong>宏函数</strong></h2><p>  我还可以用宏来定义函数,因为宏定义也可以带参数 例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Print(str) printf(<span class="string">&quot;%s&quot;</span>,str)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Print(<span class="string">&quot;这是一个只有一条语句的宏函数!&quot;</span>);</span><br><span class="line">    <span class="comment">//预处理时会被替换为 printf(&quot;%s&quot;,&quot;这是一个只有一条语句的宏函数!&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121429685.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="其它"><strong>其它</strong></h2><p><strong>1.#undef 是用来撤销宏定义的，用法如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.141592654</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI</span></span><br><span class="line"><span class="comment">//下面开始 PI 就失效了</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>2.使用ifndef防止头文件被重复包含和编译</strong></p><p>  这是宏定义的一种，它可以根据是否已经定义了一个变量来进行分支选择，一般用于调试等等.实际上确切的说这应该是预处理功能中三种（宏定义，文件包含和条件编译）中的一种----条件编译。C语言在对程序进行编译时，会先根据预处理命令进行“预处理”。C语言编译系统包括预处理，编译和链接等部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> x <span class="comment">//先测试x是否被宏定义过</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x <span class="comment">//如果没有宏定义下面就宏定义x并编译下面的语句</span></span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//如果已经定义了则编译#endif后面的语句</span></span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>条件指示符#ifndef检查预编译常量在前面是否已经被宏定义。如果在前面没有被宏定义,则条件指示符的值为真，于是从#ifndef到#endif之间的所有语句都被包含进来进行编译处理。相反，如果#ifndef指示符的值为假，则它与#endif指示符之间的行将被忽略。条件指示符#ifndef的最主要目的是防止头文件的重复包含和编译。　　千万不要忽略了头件的中的#ifndef，这是一个很关键的东西。比如你有两个C文件，这两个C文件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。</p><p>所以还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;标识&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p><标识>在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDIO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDIO_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> xxx <span class="comment">//如果没有定义xxx</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xxx <span class="comment">//定义xxx</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//结束如果</span></span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>这个用法主要是在头文件中，主要是为了防止类重复的include，所以在类的头文件之前加上前面两个，用类名替代xxx，在最后加上最后一句</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转义字符</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="转义字符">转义字符</h1><table><colgroup><col style="width: 17%" /><col style="width: 50%" /><col style="width: 32%" /></colgroup><thead><tr class="header"><th style="text-align: center;">转义字符</th><th style="text-align: center;">字 符 值</th><th style="text-align: center;">输 出 结 果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>\'</code></td><td style="text-align: center;">一个单撇号（'）</td><td style="text-align: center;">输出单撇号字符'</td></tr><tr class="even"><td style="text-align: center;"><code>\"</code></td><td style="text-align: center;">一个双撇号（"）</td><td style="text-align: center;">输出双撇号字符"</td></tr><tr class="odd"><td style="text-align: center;"><code>\?</code></td><td style="text-align: center;">一个人问号（?）</td><td style="text-align: center;">输出问号字符?</td></tr><tr class="even"><td style="text-align: center;"><code>\\</code></td><td style="text-align: center;">一个反斜杠（）</td><td style="text-align: center;">输出反斜杠字符\</td></tr><tr class="odd"><td style="text-align: center;"><code>\a</code></td><td style="text-align: center;">警告（alert）</td><td style="text-align: center;">产生声音或视觉信号</td></tr><tr class="even"><td style="text-align: center;"><code>\b</code></td><td style="text-align: center;">退格（backspace）</td><td style="text-align: center;">将光标当前位置后退一个字符</td></tr><tr class="odd"><td style="text-align: center;"><code>\f</code></td><td style="text-align: center;">换页（from feed）</td><td style="text-align: center;">将光标当前位置移到下一页的开头</td></tr><tr class="even"><td style="text-align: center;"><code>\n</code></td><td style="text-align: center;">换行</td><td style="text-align: center;">将光标当前位置移到下一行的开头</td></tr><tr class="odd"><td style="text-align: center;"><code>\r</code></td><td style="text-align: center;">回车（carriagereturn）</td><td style="text-align: center;">将光标当前位置移到本行的开头</td></tr><tr class="even"><td style="text-align: center;"><code>\t</code></td><td style="text-align: center;">水平制表符</td><td style="text-align: center;">将光标当前位置移到下一个Tab位置</td></tr><tr class="odd"><td style="text-align: center;"><code>\v</code></td><td style="text-align: center;">垂直制表符</td><tdstyle="text-align: center;">将光标当前位置移到下一个垂直表对齐点</td></tr><tr class="even"><tdstyle="text-align: center;"><code>\o</code>、<code>\oo</code>、<code>\ooo</code></td><tdstyle="text-align: center;">与该八进制码对应的ASCII字符，其中o表示一个八进制数字</td><td style="text-align: center;">与该八进制码对应的字符</td></tr><tr class="odd"><td style="text-align: center;"><code>\xh[h...]</code></td><tdstyle="text-align: center;">与该十六进制码对应的ASCII字符，其中h代表一个十六进制数字</td><td style="text-align: center;">与该十六进制码对应的字符</td></tr></tbody></table><p><strong>详解</strong></p><blockquote><p><ahref="https://blog.csdn.net/qq_61552595/article/details/124109830?ops_request_misc=%7B%22request%5Fid%22%3A%22169709154416800192287021%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169709154416800192287021&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-124109830-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=转义字符&amp;spm=1018.2226.3001.4187">详解转义字符_小蜗牛~向前冲的博客-CSDN博客</a></p></blockquote><span id="more"></span><h1 id="输出">输出<code>%</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%%&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组初始化</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的初始化">数组的初始化</h1><h2 id="引例">引例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;全局数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n局部数组：\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121413439.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>结论</strong></p><ul><li><strong>全局数组的初始值为0</strong></li><li><strong>局部数组的初始值为随机数</strong></li></ul><span id="more"></span><h2 id="使用memset函数">1. 使用memset<a href="">函数</a></h2><p><ahref="%5B(66条消息)%20memset的用法详解_薛定谔的猫ovo的博客-CSDN博客_memset%5D(https://blog.csdn.net/weixin_44162361/article/details/115790452?spm=1001.2014.3001.5506)">memset函数用法</a></p><h3 id="头文件">头文件</h3><p><strong><code>#include &lt;cstring&gt;</code></strong></p><h3 id="原型">原型</h3><p><code>void *memset(void *s, int c, int count)</code></p><ul><li>s：为指针或是数组</li><li>c：是赋给s的值</li><li>count：是s的长度</li><li>返回类型是一个指向存储区s的指针。</li></ul><h3 id="作用">作用</h3><p>memset是一个初始化函数，作用是<strong>将某一块内存空间全部设置为指定的值</strong>。</p><h3 id="说明">说明</h3><p>memset可以方便的==<strong>清空</strong>或初始化一个<strong>数组</strong>。==</p><h3 id="举例">举例</h3><ol type="1"><li>将数组初始化为0</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将数组清空</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br></pre></td></tr></table></figure><h2 id="赋值">2. 赋值</h2><ol type="1"><li>直接给每个元素赋值 <code>int arr[5] = &#123;1,2,3,4,5&#125;;</code></li><li>给一部分赋值，后面的全部为0 <code>int arr[5] = &#123;1,2&#125;;</code></li><li>由赋值参数个数决定数组的个数 <code>int arr[] = &#123;1,2&#125;;</code></li><li>数组元素初始化为0 <code>int array[4] = &#123;0&#125;;</code></li></ol><blockquote><p>注意：声明、初始化与赋值的区别</p><ul><li>声明：<code>int a;</code></li><li>初始化：<code>int a = 2;</code>（在声明的时候顺带赋值叫做初始化）</li><li>赋值：<code>a = 2;</code></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【自定义函数】</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E3%80%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E3%80%91/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E3%80%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义函数">自定义函数</h1><h2 id="将某个数转化为-0m-1-之间">将某个数转化为 0~m-1 之间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="keyword">inline</span> <span class="title">mod</span><span class="params">(LL a, LL p)</span> </span>&#123; <span class="keyword">return</span> ((a % p) + p) % p; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">long</span> <span class="type">long</span>)x % m + m) % m</span><br></pre></td></tr></table></figure><ul><li>这里的x也可以是表达式eg：<spanclass="math inline">\(x*a\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">long</span> <span class="type">long</span>)x * a % m+ m) % m</span><br></pre></td></tr></table></figure><blockquote><p><span class="math inline">\(x * a\)</span> 可能会爆掉 int，具体参考算法—数学知识</p></blockquote><h2 id="求三个数的最大小值">求三个数的最大/小值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxOfThree</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(a, b), c); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minOfThree</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(a, b), c); &#125;</span><br></pre></td></tr></table></figure><h2 id="大数加法">大数加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">string <span class="title">addString</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, j = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num += b[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(num % <span class="number">10</span>);</span><br><span class="line">        carry = num / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="大数乘法">大数乘法</h2><p>​ 假设 <code>i</code> 和 <code>j</code>分别表示两个数的当前位，<code>result[i + j]</code>存储了来自<strong>进位的累积值</strong>，而<code>result[i + j + 1]</code>存储了<strong>两位相乘后的最终结果</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">mulString</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len2 = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len1 + len2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mul = (a[i] - <span class="string">&#x27;0&#x27;</span>) * (b[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="type">int</span> sum = mul + res[i + j + <span class="number">1</span>];</span><br><span class="line">            res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果转换为字符串</span></span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(result.<span class="built_in">empty</span>() &amp;&amp; num == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result += <span class="built_in">to_string</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">empty</span>() ? <span class="string">&quot;0&quot;</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成mnmn的随机数">生成【m，n】（m&lt;n）的随机数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span><span class="comment">//srand(time(0));</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">random</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rand</span>() % (n - m + <span class="number">1</span>) + m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//放在主函数main()内部</span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="判断是否为闰年">判断是否为闰年</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>闰年：二月29天，一年366天</li><li>非闰年：二月28天，一年365天</li></ul></blockquote><h2 id="求year的天数">求year的天数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//    return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">days</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">365</span> + <span class="built_in">leap</span>(year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求year年month月的天数">求year年month月的天数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">leap</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span> || (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">days</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (month == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">28</span> + <span class="built_in">leap</span>(year);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">4</span> || month == <span class="number">6</span> || month == <span class="number">9</span> || month == <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求关键字k的第p位">求关键字k的第p位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Radix</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121356542.png"alt="image-20221209092201927" /><figcaption aria-hidden="true">image-20221209092201927</figcaption></figure><h2 id="判断质数">判断质数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="comment">// 注意是小于等于</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="因数个数">因数个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">divisor</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i * i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            cnt += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i * i == n)</span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分解质因数个数">分解质因数个数</h2><p>求正整数<spanclass="math display">\[N(N&gt;1)\]</span>的质因数的个数。相同的质因数需要重复计算。如<spanclass="math display">\[120=2*2*2*3*5\]</span>，共有<spanclass="math display">\[5\]</span>个质因数。</p><blockquote><p>我们求质因子的时候其实没有必要去先判断一个因子是否为质数，为什么呢？</p><ul><li><p>比如说一个因子为11，是质数，那么无论前面怎么进行除法运算，一定有这个因子，所以质数因子不可能漏掉</p></li><li><p>而对于因子4，它肯定可以转换成质因子之积：2×2，那么在前面已经被除过了，所以已经没有非质数因子了</p></li></ul><p>所以我们只需要从 2 开始遍历，遍历到<spanclass="math display">\[\sqrt{n}\]</span>即可，为什么是<spanclass="math display">\[\sqrt{n}\]</span>呢？</p><ul><li>因为任何一个数n至多存在一个大于<spanclass="math display">\[\sqrt{n}\]</span>且<spanclass="math display">\[!=n\]</span>的因子，所以如果存在，加1就好了。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prime_cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在大于 sqrt(num) 的因子</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大公约数gcd">最大公约数gcd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b==<span class="number">0</span> ? a : <span class="built_in">gcd</span>(b,a%b);<span class="comment">//递归+辗转相除法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小公倍数lcm">最小公倍数lcm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b==<span class="number">0</span> ? a : <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;<span class="comment">//有时候两数乘积会超过整数的范围,由此我们可以调整一下顺序:a/gcd(a,b)*b,   先除一下，这样就可以避免在一定程度上避免溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最小公倍数=两数乘积/最大公约数，即</p><p><strong><span class="math display">\[\left[ a,b \right] \cdot \left(a,b \right) =a\cdot b\]</span></strong></p></blockquote><h2 id="四舍五入精确到小数点后i位">四舍五入精确到小数点后i位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">rounding</span><span class="params">(<span class="type">double</span> a)</span><span class="comment">//四舍五入保留i位小数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>)<span class="keyword">return</span>  (<span class="type">int</span>)(a*<span class="built_in">pow</span>(<span class="number">10</span>,i)+<span class="number">0.5</span>)/<span class="built_in">pow</span>(<span class="number">10</span>,i);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">return</span>  (<span class="type">int</span>)(a*<span class="built_in">pow</span>(<span class="number">10</span>,i)- <span class="number">0.5</span>)/<span class="built_in">pow</span>(<span class="number">10</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为指定字符">判断是否为“指定字符”</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s=<span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">find</span>(ch)!=string::npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为-闰年">判断是否为 闰年</h2><blockquote><p>闰年：被 4 整除且不能被 100 整除 或者 可以被 400 整除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeapYear</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>)||n%<span class="number">400</span>==<span class="number">0</span>); <span class="comment">//Attention:最外面必须有一个（）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用sort自定义cmp函数">使用sort自定义cmp函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a, stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.score != b.score)</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.number &lt; b.number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stu a, stu b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score != b.score ? a.score &gt; b.score : a.number &lt; b.nember;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式3 */</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](stu a, stu b)</span><br><span class="line">     &#123; <span class="keyword">return</span> a.score != b.score ? a.score &gt; b.score : a.number &lt; b.nember; &#125;);</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.height != b.height ? a.height &gt; b.height : a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](node a, node b)</span><br><span class="line">     &#123; <span class="keyword">return</span> a.height != b.height ? a.height &gt; b.height : a.name &lt; b.name; &#125;);</span><br></pre></td></tr></table></figure><hr /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string school;</span><br><span class="line">    <span class="type">int</span> tws, ns;<span class="comment">//加权总分total weighted score(tws)    考生人数number of students()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tws != b.tws)</span><br><span class="line">        <span class="keyword">return</span> a.tws &gt; b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.ns != b.ns)</span><br><span class="line">        <span class="keyword">return</span> a.ns &lt; b.ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.school &lt; b.school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure><ul><li>注：类型为void类型时，可以不带return语句，系统会自动加上一个return语句</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403132252291.png"alt="image-20240313225235092" /><figcaption aria-hidden="true">image-20240313225235092</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符数组&amp;&amp;字符串</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84&amp;&amp;%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84&amp;&amp;%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符数组字符串">字符数组&amp;&amp;字符串</h1><h2 id="字符数组">字符数组</h2><p>​我们知道定义一个数组时需要为其指定相应的变量类型。也就是说，定义了数组的类型之后这个数组中的所有变量就都是相同的类型。现在我们就来定义一个<strong>字符数组</strong>，如下：</p><p><code>char hello[5] = &#123;'H','e','l','l','o'&#125;;</code></p><p>​这样我们就定义了一个字符型的数组，对于数组型的变量这样定义是没有问题的，但有两个方面的不足：</p><ol type="1"><li><p>定义的过程比较麻烦，在数组变量初始化时需要逐个写出每一个字符，并在这每一个字符的两端加上一对单引号。</p></li><li><p>在显示字符数组时，我们通常希望能够让其一次性的显示出来，而不是通过循环数组的方式逐个显示这些字符。</p></li></ol><p>​例如上面定义的数组我们想要用printf将其显示出来我们则需要通过循环的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">5</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, hello[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="字符串">字符串</h2><p>​其实，在C语言中支持直接定义<strong>字符串</strong>的方式，定义字符数组，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, hello);</span><br></pre></td></tr></table></figure><p>​注意，我们在定义这个数组时，指定数组的大小为6，也就是说需要申请6个字节的存储空间，而在等号右侧的双引号中我们却只书写了5个字符。这并不是笔误，C语言规定当使用<strong><font color='red'>双引号定义字符串</font></strong>时以==<strong><code>'\0'</code></strong>==作为这个字符串的<strong><font color='blue'>结束标志符</font></strong>，也就是说这个字符串一共有6个字符，分别是<code>'H'</code>、<code>'e'</code>、<code>'l'</code>、<code>'l'</code>、<code>'o'</code>、<code>'\0'</code></p><blockquote><p>关于<code>'\0'</code>读者只需要知道这是一个特殊的字符即可，它表示字符串的结束，它的值为0。</p></blockquote><p>​这样我们就可以通过printf函数将这个字符串直接打印出来。需要注意的是，<strong>当使用<code>printf(“%s”,  )</code>来显示字符串时，我们要确保这个<font color='red'>字符串变量中最后一个结束字符为\0</font>，如果结束字符不是\0则printf在显示这个字符串时，就不知道显示到何处结束，</strong>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hello[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">Hello#@($<span class="number">0948</span>#.<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>​也就是说，我们虽然定义了一个字符串，但只定义了5个字符的长度，而使用双引号为其初始化时，这个字符串的<strong>实际大小应该是6</strong>，因为要<strong>追加一个<code>\0</code></strong>，但我们在定义数组大小时只指定其大小是5，所以这个数组中的中只有5个元素是<code>'H'</code>、<code>'e'</code>、<code>'l'</code>、<code>'l'</code>、<code>'o'</code>。而在'o'之后并没有<code>'\0'</code>，所以在<code>printf</code>显示这个字符串时，显示Hello之后，并不知道何时结束，所以就会继续显示，直到遇到一个<code>'\0'</code>为止，于是我们程序就出现了非预期的结果。这样的程序并不是我们提倡的，<strong>我们在定义字符串时一定要为其<font color='red'>多分配一个字符的长度</font>，以便存放<font color='blue'>字符串结束符<code>'\0'</code></font>。</strong>当然，使用双引号定义的字符串可以像使用普通数组一样使用其数组元素，例如ABC运行结果可以看到直接显示字符串和循环显示字符数组中的元素的效果是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(str); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>​在这里我们使用了另一个重要函数sizeof()，它的作用是可以计算出某一个变量或类型的大小，就是占用的内存字节数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d\n&quot;</span>, </span><br><span class="line">        <span class="built_in">sizeof</span>(ch), </span><br><span class="line">        <span class="built_in">sizeof</span>(sh), </span><br><span class="line">        <span class="built_in">sizeof</span>(i), </span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">long</span>), </span><br><span class="line">        <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>​请注意，long类型的变量在不同的操作系统下占用字节数可能不同，请参数参见《变量大小》。另外在使用sizeof来计算数组大小时，计算的是数组一共占用内存的字节数，而不是数组的元素元素的个数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br></pre></td></tr></table></figure><p>​ 上面例子的结果是16而不是4。</p><h2 id="输入对比">输入对比</h2><ol type="1"><li>字符数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">50</span>];<span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>字符串</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">50</span>];<span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121407458.png"alt="image-20221010181124750" /><figcaption aria-hidden="true">image-20221010181124750</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串string</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/STL/%E5%AD%97%E7%AC%A6%E4%B8%B2string/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/STL/%E5%AD%97%E7%AC%A6%E4%B8%B2string/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串string">字符串string</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;string&gt;</code></strong></p><blockquote><p>头文件不写也可以</p></blockquote><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br></pre></td></tr></table></figure><blockquote><p>生成<strong>空字符串</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 法1 */</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="comment">/* 法2 */</span></span><br><span class="line">string s = str;</span><br></pre></td></tr></table></figure><blockquote><p>将字符串str的内容复制给s；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, i, len)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>将字符串str中从<strong>下标i开始</strong>、<strong>长度为len</strong>的部分作为字符串初值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, i)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>将字符串str中从<strong>下标i开始</strong>到<strong>字符串结束</strong>的部分作为字符串初值</li></ul></blockquote><blockquote><ul><li>这里的cstr是<strong>字符串变量</strong>，eg：<code>string s(str,3);</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cstr, len)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>以<strong>C_string类型</strong>cstr的<strong>前len个字符</strong>作为字符串s的初值</li><li>这里的==C_string类型是<strong>字符串常量</strong>类型==，eg：<code>string s("abcde",3);</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(num ,c)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>生成<font color='red'><strong>num个 c字符</strong></font>的字符串，c为char类型</p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;               <span class="comment">//生成空字符串</span></span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;  <span class="comment">//生成&quot;1234456789&quot;的复制品</span></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;0123456&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为&quot;01234&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;       <span class="comment">//结果为&quot;11111&quot;</span></span><br><span class="line">    <span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为&quot;3456789&quot;</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str2:&quot;</span>&lt;&lt;str2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str3:&quot;</span>&lt;&lt;str3&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str4:&quot;</span>&lt;&lt;str4&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str5:&quot;</span>&lt;&lt;str5&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str6:&quot;</span>&lt;&lt;str6&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310121323094.png"alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><h2 id="方法">方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.size();</span><br></pre></td></tr></table></figure><blockquote><p>字符串 s 的<strong>长度</strong>(unsigned_int)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.length();</span><br></pre></td></tr></table></figure><blockquote><p>字符串 s 的<strong>长度</strong>(int)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><blockquote><p>将字符串 s 清空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">max_size</span>();</span><br></pre></td></tr></table></figure><blockquote><p><code>s.max_size()</code>：返回string对象最多包含的字符数，超出编译器会抛出length_error异常</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.capacity();</span><br></pre></td></tr></table></figure><blockquote><p><code>s.capacity()</code>：返回当前string类在<strong>不重新分配内存</strong>的情况下，能存多少字符（即当前内存支持多少）</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;1234567&quot;</span>)</span></span>; <span class="comment">// string s=&quot;1234567&quot;;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;length=&quot;</span> &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_size=&quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>运行结果：</strong></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size=7</span><br><span class="line">length=7</span><br><span class="line">max_size=9223372036854775807</span><br><span class="line">capacity=15</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">compare</span>()</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>C++字符串支持<strong>比较</strong>操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如<code>str&lt;"hello"</code>)。string比较的原则是<strong>从左往右</strong>，按<strong>字典序</strong>，<strong>逐个字符比较</strong>，直到不同</p></li><li><p><code>s.compare()</code>支持多参数处理，支持用索引值和长度定位子串来进行比较，他返回一个整数来表示比较结果：</p><ul><li><strong>0：相等</strong></li><li><strong>1：大于</strong></li><li><strong>-1：小于</strong></li></ul></li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (A的ASCII码是65，a的ASCII码是97)</span></span><br><span class="line">    <span class="comment">// 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0</span></span><br><span class="line">    <span class="function">string <span class="title">A</span><span class="params">(<span class="string">&quot;aBcd&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">B</span><span class="params">(<span class="string">&quot;Abcd&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">C</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">D</span><span class="params">(<span class="string">&quot;123dfg&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;aBcd&quot; 和 &quot;Abcd&quot;比较------ a &gt; A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(B)：&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(B)&lt;&lt; endl;                          <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;cd&quot; 和 &quot;Abcd&quot;比较------- c &gt; A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B):&quot;</span> &lt;&lt;A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B)&lt;&lt; endl;                <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;cd&quot; 和 &quot;cd&quot;比较 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B, 2, 3):&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由结果看出来：0表示下标，3表示长度</span></span><br><span class="line">    <span class="comment">// &quot;123&quot; 和 &quot;123&quot;比较 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C.compare(0, 3, D, 0, 3)&quot;</span> &lt;&lt;C.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, D, <span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl;    <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>(pos)</span><br></pre></td></tr></table></figure><blockquote><p>返回从<strong>s[pos] 开始一直到结束</strong>的子串</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.substr(pos, num)</span><br></pre></td></tr></table></figure><blockquote><p>返回从 <strong>s[pos] 开始</strong>、<strong>长度为 num</strong>的子串</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;0123456789abcdefghij&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count 是 npos，返回 [pos, size())</span></span><br><span class="line">    string sub1 = a.<span class="built_in">substr</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; sub1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pos 和 pos + count 都在边界内，返回 [pos, pos + count)</span></span><br><span class="line">    string sub2 = a.<span class="built_in">substr</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; sub2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pos 在边界内，pos+count 不在，返回 [pos, size())</span></span><br><span class="line">    string sub4 = a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - <span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 这等效于</span></span><br><span class="line">    <span class="comment">// string sub4 = a.substr(17, 3);</span></span><br><span class="line">    <span class="comment">// 因为 a.size() == 20，pos == a.size() - 3 == 17 而 a.size() - pos == 3</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sub4 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pos 在边界外，抛出</span></span><br><span class="line">        string sub5 = a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() + <span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">        cout &lt;&lt; sub5 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> out_of_range &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pos 超出了字符串的大小\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="举例">举例</h2><p>:sweat_drops:c语言里没有<strong><code>string</code></strong>型的，<strong><code>string</code></strong>在c++里面。但有时候在c++里要用<strong><code>scanf()</code></strong>和<strong><code>printf()</code></strong>输入输出<strong><code>string</code></strong>型字符串，此时可以使用<strong>string</strong> 的成员函数<strong><code>s.c_str()</code></strong>，该函数返回字符串的首字符的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s[<span class="number">0</span>]); <span class="comment">// 不能用&amp;s</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>取地址 or 引用</title>
      <link href="/2023/10/12/%5Bobject%20Object%5D/C++/&amp;%E7%9A%842%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2023/10/12/%5Bobject%20Object%5D/C++/&amp;%E7%9A%842%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="的两种使用方法">&amp;的两种使用方法</h1><h2 id="取地址符">取地址符</h2><p>​ 用来获取变量的地址，通常在 <code>=</code> 的右侧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// 这就是取地址符，指针p指向对象a，p里面存的a的地址</span></span><br></pre></td></tr></table></figure><h2 id="引用">引用</h2><p>​C++里面的引用时在变量名之前加一个<code>&amp;</code>符号，比如在函数传入的参数中<code>int &amp;a</code>,那么对这个引用变量<code>a</code>做的所以操作都是<strong>直接对传入的原变量进行操作</strong>，并没有像原来<code>int a</code>一样只是<strong>拷贝一个副本</strong>（传值），运行速度更快</p><span id="more"></span><h3 id="例子">例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">(<span class="type">int</span> &amp;a)</span> <span class="comment">// 传入的是n的引用，相当于直接对n进行了操作,只不过在func函数中换了个名字叫a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">(<span class="type">int</span> a)</span> <span class="comment">// 传入的是0这个值，并不会改变main函数中n的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">33</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func_1</span>(n); <span class="comment">// n由0变成了99</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func_2</span>(n); <span class="comment">// 并不会改变n的值，n还是99</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法">用法</h3><h4 id="对函数参数引用">对函数参数引用</h4><p>​相当于在函数内部可以直接<strong>对传入的原变量</strong>进行操作，通常用于需要向函数内传递<strong>大数组</strong>，引用可以省去了对原变量的拷贝，运行速度更快，减少运行时间</p><h4 id="对变量引用减小代码量">对变量引用减小代码量</h4><p>​当某一变量名特别长，且下面要多次使用时，为了减小代码量，我们通常使用引用，相当于对变量起了一个别名。如下面所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// son[p][x &gt;&gt; i &amp; 1]太长了，用 s 引用</span></span><br><span class="line">        <span class="type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!s) s = ++ idx;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈stack</title>
      <link href="/2023/10/11/%5Bobject%20Object%5D/STL/%E6%A0%88stack/"/>
      <url>/2023/10/11/%5Bobject%20Object%5D/STL/%E6%A0%88stack/</url>
      
        <content type="html"><![CDATA[<h1 id="栈stack">栈stack</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;stack&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;ElementType&gt; s;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>ElementType</code>可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。</p></blockquote><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">push</span>()</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>压入栈顶</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">top</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>栈顶元素</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p>令<strong><font color='red'>栈顶元素</font>出栈</strong>，<font color='blue'><strong>删除</strong></font>栈顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 stack 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回 stack 中的<font color='red'><strong>元素个数</strong></font></p></blockquote><span id="more"></span><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 0</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, q.<span class="built_in">front</span>(),q.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:sailboat:<code>s.pop()</code>无返回值，仅删除栈顶元素。要<strong><font color='blue'>获得</font></strong><font color='red'><strong>栈顶元素</strong></font>还需<code>s.top()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;  q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.size &quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.top &quot;</span>&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;   <span class="comment">//输出栈顶元素 </span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//删除栈顶元素</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.size &quot;</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;endl;  </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;q.top &quot;</span>&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q.size 5</span><br><span class="line">q.top 5</span><br><span class="line">q.size 4</span><br><span class="line">q.top 4</span><br></pre></td></tr></table></figure></li></ul><p>:tea:使用 <strong><code>s.top()</code></strong>和<strong><code>s.pop()</code></strong>函数前，必须用<strong><code>s.empty()</code></strong>判断队列==<strong>是否为空</strong>==，否则可能因为<strong>队空</strong>而出现错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用list或vector作为栈的容器，默认是使用deque的。</span></span><br><span class="line">stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; a;</span><br><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.<span class="built_in">top</span>()); <span class="comment">// 取栈项数据</span></span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">3</span>);              <span class="comment">// 将3这个元素入栈a</span></span><br><span class="line">b.<span class="built_in">push</span>(<span class="number">2</span>);              <span class="comment">// 将2这个元素入栈b</span></span><br><span class="line">a.<span class="built_in">pop</span>();                <span class="comment">// 将栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//  判断栈是否为空</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射map</title>
      <link href="/2023/10/10/%5Bobject%20Object%5D/STL/%E6%98%A0%E5%B0%84map/"/>
      <url>/2023/10/10/%5Bobject%20Object%5D/STL/%E6%98%A0%E5%B0%84map/</url>
      
        <content type="html"><![CDATA[<h1 id="映射map">映射map</h1><p>​map提供了“[]”运算符，使得map可以像数组一样使用，所以map也称为“关联数组”，map就是从键（key）到值（value）的映射。例如可以用一个<code>map&lt;string, int&gt; month_name</code>来表示“月份名字到月份编号”的映射，然后用<code>month_name[“July”] = 7</code>这样的方式来赋值</p><blockquote><p>map 会自动将所有的键值对，按照==<strong>键</strong>==从小到大排序</p></blockquote><h2 id="头文件">头文件</h2><p><code>#include &lt;map&gt;</code></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;ElementType, ElementType&gt; m;</span><br></pre></td></tr></table></figure><blockquote><p>这里的ElementType可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等</p><p>哈希表：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;ElementType, ElementType&gt; m;</span><br></pre></td></tr></table></figure></p></blockquote><span id="more"></span><h2 id="方法">方法</h2><p><ahref="https://blog.csdn.net/sevenjoin/article/details/81943864?ops_request_misc=%7B%22request%5Fid%22%3A%22169708750416800215061817%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169708750416800215061817&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81943864-null-null.142%5Ev96%5Epc_search_result_base3&amp;utm_term=map&amp;spm=1018.2226.3001.4187">C++map用法总结</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">begin</span>()         <span class="comment">// 返回指向map头部的迭代器</span></span><br><span class="line">m.<span class="built_in">clear</span>()         <span class="comment">// 删除所有元素</span></span><br><span class="line">m.<span class="built_in">count</span>(elem)     <span class="comment">// 返回指定元素出现的次数</span></span><br><span class="line">m.<span class="built_in">empty</span>()         <span class="comment">// 如果map为空则返回true</span></span><br><span class="line">m.<span class="built_in">end</span>()           <span class="comment">// 返回指向map末尾的迭代器</span></span><br><span class="line">m.<span class="built_in">equal_range</span>()   <span class="comment">// 返回特殊条目的迭代器对</span></span><br><span class="line">m.<span class="built_in">erase</span>()         <span class="comment">// 删除一个元素(输入的参数是pair或者迭代器)</span></span><br><span class="line">m.<span class="built_in">find</span>()          <span class="comment">// 查找一个元素</span></span><br><span class="line">m.<span class="built_in">get_allocator</span>() <span class="comment">// 返回map的配置器</span></span><br><span class="line">m.<span class="built_in">insert</span>()        <span class="comment">// 插入pair</span></span><br><span class="line">m.<span class="built_in">key_comp</span>()      <span class="comment">// 返回比较元素key的函数</span></span><br><span class="line">m.<span class="built_in">max_size</span>()      <span class="comment">// 返回可以容纳的最大元素个数</span></span><br><span class="line">m.<span class="built_in">rbegin</span>()        <span class="comment">// 返回一个指向map尾部的逆向迭代器</span></span><br><span class="line">m.<span class="built_in">rend</span>()          <span class="comment">// 返回一个指向map头部的逆向迭代器</span></span><br><span class="line">m.<span class="built_in">size</span>()          <span class="comment">// 返回map中元素的个数</span></span><br><span class="line">m.<span class="built_in">swap</span>()          <span class="comment">// 交换两个map</span></span><br><span class="line">m.<span class="built_in">lower_bound</span>()   <span class="comment">// 返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line">m.<span class="built_in">upper_bound</span>()   <span class="comment">// 返回键值&gt;给定元素的第一个位置</span></span><br><span class="line">m.<span class="built_in">value_comp</span>()    <span class="comment">// 返回比较元素value的函数</span></span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><p><strong>反片语</strong>输入一些单词，找出所有满足如下条件的单词:该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输入时应保留输入中的大小写，按字典序进行排列(所有大写字母在小写字母的前面)</p><ul><li><p>样例输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ladder came tape soon leader acme RIDE lone Dreis peat ScAlE orb eye Rides dealer NotE derail LaCeS drled noel dire Disk mace Rob dries #</span><br></pre></td></tr></table></figure></li><li><p>样例输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disk</span><br><span class="line">NotE</span><br><span class="line">derail</span><br><span class="line">drled</span><br><span class="line">eye</span><br><span class="line">ladder</span><br></pre></td></tr></table></figure></li><li><p><strong>代码：</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mapp;</span><br><span class="line">vector&lt;string&gt; words;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将单词s标准化</span></span><br><span class="line"><span class="function">string <span class="title">standard</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">length</span>(); i++)</span><br><span class="line">        t[i] = <span class="built_in">tolower</span>(t[i]);</span><br><span class="line">    <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        words.<span class="built_in">push_back</span>(s);</span><br><span class="line">        string r = <span class="built_in">standard</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (!mapp.<span class="built_in">count</span>(r))</span><br><span class="line">            mapp[r] = <span class="number">0</span>;</span><br><span class="line">        mapp[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapp[<span class="built_in">standard</span>(words[i])] == <span class="number">1</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压位bitset</title>
      <link href="/2023/10/09/%5Bobject%20Object%5D/STL/%E5%8E%8B%E4%BD%8Dbitset/"/>
      <url>/2023/10/09/%5Bobject%20Object%5D/STL/%E5%8E%8B%E4%BD%8Dbitset/</url>
      
        <content type="html"><![CDATA[<h1 id="bitset压位">bitset压位</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line"><span class="built_in">flip</span>()  等价于~</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双端队列deque</title>
      <link href="/2023/10/09/%5Bobject%20Object%5D/STL/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/"/>
      <url>/2023/10/09/%5Bobject%20Object%5D/STL/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/</url>
      
        <content type="html"><![CDATA[<h1 id="双端队列deque">双端队列deque</h1><h2 id="头文件"><strong>头文件</strong></h2><p><code>#include &lt;deque&gt;</code></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;ElementType&gt; a;</span><br></pre></td></tr></table></figure><ul><li>queue 只能在对头删除元素，在队尾添加元素</li><li>deque 在队头队尾均能删除/插入元素</li></ul><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在队首加入数据0</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">11</span>); <span class="comment">// 在队尾加入数据11</span></span><br><span class="line">a.<span class="built_in">pop_front</span>();   <span class="comment">// 在队首删除数据</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();    <span class="comment">// 在队尾删除数据</span></span><br><span class="line">a.<span class="built_in">resize</span>(num);   <span class="comment">// 重新指定队列的长度</span></span><br><span class="line">a.<span class="built_in">size</span>()         <span class="comment">// 返回容器中实际数据个数</span></span><br><span class="line">a.<span class="built_in">max_size</span>()     <span class="comment">// 返回容器中最大数据的数量</span></span><br><span class="line">a.<span class="built_in">clear</span>()<span class="comment">// 清空队列</span></span><br><span class="line">a.<span class="built_in">front</span>()<span class="comment">// 返回队头元素</span></span><br><span class="line">a.<span class="built_in">back</span>()<span class="comment">// 返回队尾元素</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//创建一个有10个元素双端队列a,初始值都为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给deque赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出deque中的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头尾加入新数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在头部加入数据0：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在尾部加入数据11：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头尾删除数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在头部删除数据: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在尾部删除数据: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回容器中实际数据个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新指定队列的长度</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回容器中最大数据的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.max_size() = &quot;</span> &lt;&lt; a.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.front() = &quot;</span> &lt;&lt; a.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.back() = &quot;</span> &lt;&lt; a.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空队列</span></span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.empty() = &quot;</span> &lt;&lt; a.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入&amp;&amp;输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">在头部加入数据0：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">在尾部加入数据11：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 </span><br><span class="line">在头部删除数据: </span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11 </span><br><span class="line">在尾部删除数据: </span><br><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">a.size() = 10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 0 </span><br><span class="line">a.empty() = 0</span><br><span class="line">a.max_size() = 4611686018427387903</span><br><span class="line">a.front() = 1</span><br><span class="line">a.back() = 0</span><br><span class="line">a.empty() = 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组vector</title>
      <link href="/2023/10/08/%5Bobject%20Object%5D/STL/%E6%95%B0%E7%BB%84vector/"/>
      <url>/2023/10/08/%5Bobject%20Object%5D/STL/%E6%95%B0%E7%BB%84vector/</url>
      
        <content type="html"><![CDATA[<h1 id="数组vector">数组vector</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;vector&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;ElementType&gt; v;</span><br></pre></td></tr></table></figure><blockquote><p>这里的ElementType可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br></pre></td></tr></table></figure><blockquote><p>定义一个向量v，<strong><font color='red'>大小为0</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><blockquote><p>先定义⼀个向量v，然后<strong><font color='red'>将长度resize为8</font></strong>，默认这8个元素都是0</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>定义具有10个int元素的向量v，<strong><font color='red'>默认这10个元素值都为0</font></strong></p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>定义具有10个int元素的向量v，且<strong><font color='red'>这10个元素值都为</font></strong>1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure><blockquote><p>先定义⼀个向量a，然后<strong><font color='red'>将向量b赋值给向量a</font></strong>（a的值完全等价于b的值）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br></pre></td></tr></table></figure><blockquote><p>将向量b中从0-2（<strong><font color='blue'>共3个</font></strong>）的元素赋值给a，a的类型为int型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b, b + <span class="number">7</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>从数组中获得初值</p></blockquote><h2 id="方法">方法</h2><p><ahref="https://blog.csdn.net/weixin_41743247/article/details/90635931?ops_request_misc=%7B%22request%5Fid%22%3A%22167064353616800184186226%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167064353616800184186226&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90635931-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&amp;utm_term=vector&amp;spm=1018.2226.3001.4187">C++_vector操作</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>vector数组大小</font></strong>，类型<strong>unsignedint</strong></p></blockquote><p>:taco: 如果v.size()==1，则v.size()-3为正数，必须int(a.size()) -3才行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(n)</span><br></pre></td></tr></table></figure><blockquote><p>将向量 v的<strong><font color='red'>元素个数调整为n个</font></strong>，<strong><font color='blue'>多则删，少则补（其值为0）</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">resize</span>(n,x)</span><br></pre></td></tr></table></figure><blockquote><p>将向量 v的<strong><font color='red'>元素个数调整为n个</font></strong>，<strong><font color='blue'>多则删，少则补（其值为x）</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>清空</font></strong>向量<strong>v</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">front</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回v的<font color='red'><strong>第一个元素</strong></font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回v的<font color='red'><strong>最后一个元素</strong></font>，不检查这个数据是否存在</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 vector 是否为空：==<strong><font color='red'>返回 true则空，返回 false 则非空</font></strong>== 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(x)</span><br></pre></td></tr></table></figure><blockquote><p>将 <strong>x</strong> 添加到<strong><font color='red'>向量 v最后</font></strong>（<code>v.size</code>会加1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>删除</font></strong>向量 v的<strong><font color='red'>最后一个元素</font></strong>（<code>v.size</code>会减1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,elem)</span><br></pre></td></tr></table></figure><blockquote><p>在pos位置插入一个elem拷贝，传回新数据位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,n,elem)</span><br></pre></td></tr></table></figure><blockquote><p>在pos位置插入n个elem数据,无返回值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos,beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>在pos位置插入在[beg,end)区间的数据。无返回值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(pos);</span><br></pre></td></tr></table></figure><blockquote><p>删除pos位置的数据，传回下一个数据的位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>删除[beg,end)区间的数据，传回下一个数据的位置</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(beg,end)</span><br></pre></td></tr></table></figure><blockquote><p>将(beg; end)区间中的数据赋值给v</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(n,elem)</span><br></pre></td></tr></table></figure><blockquote><p>将n个elem的拷贝赋值给v</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.at(idx)</span><br></pre></td></tr></table></figure><blockquote><p>传回索引idx所指的数据，如果idx越界，抛出out_of_range。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.capacity()</span><br></pre></td></tr></table></figure><blockquote><p>返回容器中数据个数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.max_size()</span><br></pre></td></tr></table></figure><blockquote><p>返回容器中最大数据的数量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1.<span class="built_in">swap</span>(v2)</span><br></pre></td></tr></table></figure><blockquote><p>将vector:v1中的元素和vector:v2中的元素<strong><font color='red'>整体交换</font></strong></p></blockquote><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除v[2]元素（即数字3）</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After erasing v[2]: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除v[2]、v[3]、v[4]元素（即数字4、5、6）</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">begin</span>() + <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After erasing range from v[2] to v[4]: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用assign函数重新赋值</span></span><br><span class="line">    v.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="number">100</span>); <span class="comment">// 创建一个大小为5的vector，所有元素值为100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After using assign to set 5 elements to 100: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用at函数访问元素</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idxElement = v.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; idxElement &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> out_of_range &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Out of range error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中数据的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of the vector: &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回容器中最大数据的数量（通常与size()相同）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max size of the vector: &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义另一个vector并与当前vector交换</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">swap</span>(v2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">After erasing v[2]: 1 2 4 5 6 7 8 9 10 </span><br><span class="line">After erasing range from v[2] to v[4]: 1 2 7 8 9 10</span><br><span class="line">After using assign to set 5 elements to 100: 100 100 100 100 100</span><br><span class="line">Element at index 2: 100</span><br><span class="line">Size of the vector: 5</span><br><span class="line">Max size of the vector: 4611686018427387903</span><br><span class="line">Before swap:</span><br><span class="line">v1: 100 100 100 100 100</span><br><span class="line">v2: 11 12 13 14 15</span><br><span class="line">After swap:</span><br><span class="line">v1: 11 12 13 14 15</span><br><span class="line">v2: 100 100 100 100 100</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义的时候不指定vector的大小</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">// 这个时候size是0 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">        a.<span class="built_in">push_back</span>(i); <span class="comment">//在vector a的末尾添加一个元素i </span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 此时会发现a的size变成了10 </span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">15</span>)</span></span>; <span class="comment">//定义的时候指定vector的大小，默认b里面元素都是0</span></span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) </span><br><span class="line">        b[i]= <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++) </span><br><span class="line">        cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>)</span></span>; <span class="comment">//定义的时候指定vector的大小并把所有的元素赋一个指定的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i++) </span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); it++) <span class="comment">//使用迭代器的方式访问vector </span></span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//vector相等判断与赋值    </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec2;</span><br><span class="line"><span class="keyword">if</span> (vec1 == vec2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec1与vec2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">vec2 = vec1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值后&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (vec1 == vec2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec1与vec2相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">赋值后</span><br><span class="line">vec1与vec2相等</span><br></pre></td></tr></table></figure></li><li><p>vector的赋值会把<strong>一个vector的所有元素</strong>赋值到<strong>另一个vector中</strong>，并<font color='red'><strong>替代所有元素</strong></font>；</p></li><li><p>而vector的相等也是需要<strong>逐个元素<font color='red'>依次比较</font></strong>并<strong><font color='blue'>全部相等</font></strong>才算相等。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!v.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  ..........</span><br><span class="line">  v.<span class="built_in">pop_back</span>();</span><br><span class="line">  ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>v.pop_back()</code>之前要<code>v.empty()</code></p></li><li><p>`<code>v.pop_back();</code>无返回值，<strong><font color='blue'>仅删除</font></strong>向量v的最后一个元素；要<strong><font color='gree'>获得</font></strong><font color='red'><strong>向量v 的最后一个元素</strong></font>需要<code>v.back()</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合set</title>
      <link href="/2023/10/07/%5Bobject%20Object%5D/STL/%E9%9B%86%E5%90%88set/"/>
      <url>/2023/10/07/%5Bobject%20Object%5D/STL/%E9%9B%86%E5%90%88set/</url>
      
        <content type="html"><![CDATA[<h1 id="集合set">集合set</h1><p><code>set</code> 是集合：满足以下2个特点</p><ul><li><code>set</code> ⾥面的各元素是各不相同的</li><li>set 会按照元素进行从小到⼤排序</li></ul><blockquote><blockquote><p><code>multiset</code>里面的各元素是<font color='red'><strong>可以有相同的</strong></font></p></blockquote></blockquote><h2 id="头文件">头文件</h2><p><code>#include &lt;set&gt;</code></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;ElementType&gt; s;</span><br><span class="line">multiset&lt;ElementType&gt; s;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">begin</span>()         <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">clear</span>()         <span class="comment">// 清除所有元素</span></span><br><span class="line">s.<span class="built_in">count</span>()         <span class="comment">// 返回某个值元素的个数</span></span><br><span class="line">s.<span class="built_in">empty</span>()         <span class="comment">// 如果集合为空，返回true(真）</span></span><br><span class="line">s.<span class="built_in">end</span>()           <span class="comment">// 返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line">s.<span class="built_in">equal_range</span>()   <span class="comment">// 返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line">s.<span class="built_in">erase</span>()         </span><br><span class="line"><span class="comment">// (1) 输入是一个数x，删除所有x   O(k + logn)</span></span><br><span class="line"><span class="comment">// (2) 输入一个迭代器，删除这个迭代器</span></span><br><span class="line">s.<span class="built_in">find</span>()          <span class="comment">// 返回一个指向被查找到元素的迭代器</span></span><br><span class="line">s.<span class="built_in">get_allocator</span>() <span class="comment">// 返回集合的分配器</span></span><br><span class="line">s.<span class="built_in">insert</span>()        <span class="comment">// 在集合中插入元素</span></span><br><span class="line">s.<span class="built_in">key_comp</span>()      <span class="comment">// 返回一个用于元素间值比较的函数</span></span><br><span class="line">s.<span class="built_in">max_size</span>()      <span class="comment">// 返回集合能容纳的元素的最大限值</span></span><br><span class="line">s.<span class="built_in">rbegin</span>()        <span class="comment">// 返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">s.<span class="built_in">rend</span>()          <span class="comment">// 返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">s.<span class="built_in">size</span>()          <span class="comment">// 集合中元素的数目</span></span><br><span class="line">s.<span class="built_in">swap</span>()          <span class="comment">// 交换两个集合变量</span></span><br><span class="line">s.<span class="built_in">lower_bound</span>(x)   <span class="comment">// 返回【&gt;=】x 的第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>(x)   <span class="comment">// 返回【&gt;】x 的第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">value_comp</span>()    <span class="comment">// 返回一个用于比较元素间的值的函数</span></span><br></pre></td></tr></table></figure><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s; <span class="comment">// 创建一个空的整数集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合的大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of set: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查集合是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is set empty? &quot;</span> &lt;&lt; (s.<span class="built_in">empty</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向最后一个元素之后的迭代器</span></span><br><span class="line">    it = s.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 注意：这里不能通过*it来访问元素，因为it现在指向的是最后一个元素之后的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;One past the last element: &quot;</span> &lt;&lt; *<span class="built_in">prev</span>(it) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    it = s.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found element 10&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element 10 not found&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查集合是否为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is set empty after clear? &quot;</span> &lt;&lt; (s.<span class="built_in">empty</span>() ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用insert插入多个元素</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// 插入重复元素，set会忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出元素个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count of element 10: &quot;</span> &lt;&lt; s.<span class="built_in">count</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 总是返回1，因为set中不会有重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向集合中最后一个元素的反向迭代器</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::reverse_iterator rit = s.<span class="built_in">rbegin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Last element (reverse): &quot;</span> &lt;&lt; *rit &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指向集合中第一个元素的反向迭代器</span></span><br><span class="line">    rit = s.<span class="built_in">rend</span>();</span><br><span class="line">    <span class="comment">// 注意：这里不能通过*rit来访问元素，因为rit现在指向的是第一个元素之前的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before the first element (reverse): &quot;</span> &lt;&lt; *<span class="built_in">prev</span>(rit) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个集合变量（这里只有一个集合，所以无法演示交换）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合的上界和下界</span></span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator&gt; bounds = s.<span class="built_in">equal_range</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lower bound of 5: &quot;</span> &lt;&lt; *bounds.first &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Upper bound of 5: &quot;</span> &lt;&lt; *bounds.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合的分配器</span></span><br><span class="line">    allocator&lt;<span class="type">int</span>&gt; alloc = s.<span class="built_in">get_allocator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取比较键的函数对象</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::key_compare keyComp = s.<span class="built_in">key_comp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取比较值的函数对象</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::value_compare valueComp = s.<span class="built_in">value_comp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取集合能容纳的最大元素数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max size of set: &quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Size of set: 4</span><br><span class="line">Is set empty? false</span><br><span class="line">First element: 5</span><br><span class="line">One past the last element: 20</span><br><span class="line">Found element 10</span><br><span class="line">Is set empty after clear? true</span><br><span class="line">Count of element 10: 1</span><br><span class="line">Last element (reverse): 5</span><br><span class="line">Before the first element (reverse): 5</span><br><span class="line">Lower bound of 5: 5</span><br><span class="line">Upper bound of 5: 1</span><br><span class="line">Max size of set: 461168601842738790</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对组pair</title>
      <link href="/2023/10/06/%5Bobject%20Object%5D/STL/%E5%93%88%E5%B8%8C%E8%A1%A8unordered/"/>
      <url>/2023/10/06/%5Bobject%20Object%5D/STL/%E5%93%88%E5%B8%8C%E8%A1%A8unordered/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表">哈希表</h1><table><thead><tr class="header"><th>哈希</th><th style="text-align: center;">原来</th></tr></thead><tbody><tr class="odd"><td>unordered_set</td><td style="text-align: center;">set</td></tr><tr class="even"><td>unordered_map</td><td style="text-align: center;">map</td></tr><tr class="odd"><td>unordered_multiset</td><td style="text-align: center;">multiset</td></tr><tr class="even"><td>unordered_multimap</td><td style="text-align: center;">multimap</td></tr></tbody></table><ul><li>哈希表不支持 lower_bound()/upper_bound()， 迭代器的++，--</li><li>其余操作与原来的一摸一样</li></ul><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列queue</title>
      <link href="/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E5%88%97queue/"/>
      <url>/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E5%88%97queue/</url>
      
        <content type="html"><![CDATA[<h1 id="队列queue">队列queue</h1><h2 id="头文件">头文件</h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><h2 id="定义">定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;ElementType&gt; q;</span><br></pre></td></tr></table></figure><blockquote><p>这里的ElementType可以是<strong>任意类型</strong>，例如int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。</p></blockquote><span id="more"></span><h2 id="方法">方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回<strong><font color='red'>队列大小</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>()</span><br></pre></td></tr></table></figure><blockquote><p>将 x <strong><font color='red'>插入队尾</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">front</span>()</span><br><span class="line">q.<span class="built_in">back</span>()</span><br></pre></td></tr></table></figure><blockquote><p>分别返回<strong><font color='red'>队首元素</font></strong>和<font color='red'><strong>队尾元素</strong></font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>()</span><br></pre></td></tr></table></figure><blockquote><p>令队首元素<strong>出队</strong>，<font color='blue'><strong>删除</strong></font>队首元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>检测 queue 是否为空：==<strong><font color='red'>返回 true 则空，返回false 则非空</font></strong>==</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><blockquote><p>返回 queue 中<font color='red'><strong>元素个数</strong></font></p></blockquote><h2 id="举例">举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 0</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// 出队首元素 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, q.<span class="built_in">front</span>(),q.<span class="built_in">back</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>q.pop()</code>无返回值，仅删除队首元素。要<strong><font color='gree'>获得</font></strong><font color='red'><strong>队首元素</strong></font><strong>还需<code>q.front()</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()==<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EMPTY! \n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NOT EMPTY! \n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        q.<span class="built_in">push</span>(i); <span class="comment">//push(i) 用来将 i 压入队列，因此依次入队 0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;EMPTY! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NOT EMPTY! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EMPTY!</span><br><span class="line">NOT EMPTY!</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li><li><p>注意： 使用 <code>q.front()</code>和<code>q.pop()</code>函数前，必须用<code>q.empty()</code>判断队列==<strong>是否为空</strong>==，否则可能因为<strong>队空</strong>而出现错误</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对组pair</title>
      <link href="/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E7%BB%84pair/"/>
      <url>/2023/10/06/%5Bobject%20Object%5D/STL/%E9%98%9F%E7%BB%84pair/</url>
      
        <content type="html"><![CDATA[<h1 id="对组pair">对组pair</h1><h2 id="应用">应用</h2><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。pair的实现是一个结构体，主要的两个成员变量是first second因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><p>其标准库类型--pair类型定义在<code>#include &lt;utility&gt;</code>头文件中，定义如下：</p><ul><li><p>类模板：template&lt;class T1,class T2&gt; struct pair</p></li><li><p>参数：T1是第一个值的数据类型，T2是第二个值的数据类型。</p></li><li><p>功能：<strong>pair将一对值(T1类型和T2类型)组合成一个值</strong></p><ul><li>这一对值可以具有不同的数据类型（T1和T2）</li><li>两个值可以分别用<font color='red'><strong>pair的两个公有成员变量first和second访问</strong></font></li></ul></li><li><p>定义(构造函数)：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;         <span class="comment">// 创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p1</span><span class="params">(v1, v2)</span></span>; <span class="comment">// 创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);       <span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line">p1 &lt; p2;                 <span class="comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span></span><br><span class="line">p1 == p;                 <span class="comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span></span><br><span class="line">p1.first;                <span class="comment">// 返回对象p1中名为first的公有数据成员</span></span><br><span class="line">p1.second;               <span class="comment">// 返回对象p1中名为second的公有数据成员</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="定义">定义</h2><ul><li><p>pair包含两个数值，与容器一样，pair也是一种模板类型。但是又与之前介绍的容器不同；</p></li><li><p>在创建pair对象时，<font color='red'><strong>必须提供两个类型名，两个对应的类型名的类型不必相同</strong></font></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br></pre></td></tr></table></figure><ul><li>当然也可以在定义时进行成员初始化：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">author</span><span class="params">(<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joy&quot;</span>)</span></span>;    <span class="comment">// 创建一个author对象，两个元素类型分别为string类型，并默认初始值为James和Joy。</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">name_age</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">name_age2</span><span class="params">(name_age)</span></span>;    <span class="comment">// 拷贝构造初始化</span></span><br></pre></td></tr></table></figure><ul><li>pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;string,string&gt; Author;</span><br><span class="line"><span class="function">Author <span class="title">proust</span><span class="params">(<span class="string">&quot;March&quot;</span>,<span class="string">&quot;Proust&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Author <span class="title">Joy</span><span class="params">(<span class="string">&quot;James&quot;</span>,<span class="string">&quot;Joy&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>变量间赋值：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">1.2</span>)</span></span>;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p2 = p1;     <span class="comment">// copy construction to initialize object</span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p3；</span><br><span class="line">p3 = p1;    <span class="comment">// operator =</span></span><br></pre></td></tr></table></figure><h2 id="操作">操作</h2><ul><li>访问两个元素操作可以通过<code>first</code>和<code>second</code>访问：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;</span><br><span class="line"></span><br><span class="line">p1.first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">p1.second = <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：1 2.5</span></span><br><span class="line"></span><br><span class="line">string firstBook;</span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">&quot;James&quot;</span> &amp;&amp; author.second == <span class="string">&quot;Joy&quot;</span>)</span><br><span class="line">    firstBook = <span class="string">&quot;Stephen Hero&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>可以利用<code>make_pair</code>创建新的 pair 对象：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;</span><br><span class="line">p1 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1.2</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 1 1.2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">string m = <span class="string">&quot;James&quot;</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, string&gt; newone;</span><br><span class="line"></span><br><span class="line">newone = <span class="built_in">make_pair</span>(a, m);</span><br><span class="line">cout &lt;&lt; newone.first &lt;&lt; newone.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 8 James</span></span><br></pre></td></tr></table></figure><ul><li><p>通过 <code>tie</code> 获取 pair 元素值：在某些清况函数会以 pair对象作为返回值时，可以直接通过<code>std::tie</code>进行接收。比如：</p><blockquote><blockquote><p>注意使用tie要引入<code>#include &lt;tuple&gt;</code></p></blockquote></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">getPreson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="comment">/* C++ 11支持下面操作 */</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> ages;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tie</span>(name, ages) = <span class="built_in">getPreson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, ages: &quot;</span> &lt;&lt; ages &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line">PII author;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">&quot;James&quot;</span> &amp;&amp; author.second == <span class="string">&quot;Joy&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (author == <span class="built_in">make_pair</span>(<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Joy&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">if</span> (author == &#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Joy&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2023/10/05/%5Bobject%20Object%5D/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2023/10/05/%5Bobject%20Object%5D/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器">迭代器</h1><p>遍历<strong><font color='blue'>容器</font></strong><code>vector</code>、<code>set</code>、<code>map</code>要使用<strong><font color='red'>迭代器/反向迭代器</font></strong>访问</p><ul><li><p><strong><code>c.begin()</code></strong>是一个指针，指向容器的<strong><font color='purple'>第一个元素</font></strong></p></li><li><p><strong><code>c.end()</code></strong>是一个指针，指向容器==<strong><font color='red'>最后一个元素的后一个位置</font></strong>==</p></li><li><p><strong><code>c.rbegin()</code></strong>是一个指针，指向容器的<font color='purple'><strong>最后一个元素</strong></font></p></li><li><p><strong><code>c.rend()</code></strong>是一个指针，指向容器的==<font color='red'><strong>第一个元素的前一个位置</strong></font>==</p></li></ul><p>所以<strong><font color='blue'>迭代器指针it</font></strong>的for循环判断条件是 <strong><code>it != c.end()</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); it++)  <span class="comment">// 使用迭代器的方式访问vector </span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = c.<span class="built_in">rbegin</span>(); it != c.<span class="built_in">rend</span>(); it--)  <span class="comment">// 使用反向迭代器的方式访问vector </span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221222424.jpeg"alt="e5b86169c82b93bbe409229eb505976" /><figcaptionaria-hidden="true">e5b86169c82b93bbe409229eb505976</figcaption></figure><p>运行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reference</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/Reference/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E7%AE%97%E6%B3%95/Reference/</url>
      
        <content type="html"><![CDATA[<p>==<a href="https://www.hello-algo.com/">Hello 算法(hello-algo.com)</a>==</p><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑话</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%BB%91%E8%AF%9D/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%BB%91%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403101310480.jpg"alt="71aadb82ca8db1e3230dd4494834751" /><figcaptionaria-hidden="true">71aadb82ca8db1e3230dd4494834751</figcaption></figure><span id="more"></span><ul><li>rk：rank，绩点排名。</li><li>bar：入营门槛。</li><li>oq：即overqualified，举例：清北选手报中九末九，可能因oq直接被筛掉。</li><li>弱(强)com：com即committee，弱com即学院官方权利弱，对应导师权力大。强com反之。</li><li>套磁：由 keep in touch引申而来，指提前与老师联系，通常以实习或捞入营为目的，部分导师会提前组织考核。</li><li>bg：即 background，指个人背景条件。</li><li>pub：即 publication，指论文发表情况。</li></ul><h2 id="保研黑话大全"><ahref="https://mp.weixin.qq.com/s/I-wBSnUTf7Oa-bjESjn3Gg">保研黑话大全</a></h2><ul><li><p><strong>title：</strong>通常指学校的层次，包括985、211、双一流等，反映学校的整体实力和声誉，有时候也会作为入营录取的隐形门槛。</p></li><li><p><strong>双非：</strong>非985、211的院校，在保研竞争中处于劣势地位。</p></li><li><p><strong>rank/rk：</strong>专业排名，指学院盖章的官方成绩排名，又分为纯绩点排名和综测排名，影响着学生保研的选择和竞争。</p></li><li><p><strong>bg：background</strong>，指你的院校专业、专业排名、英语成绩和科研竞赛等综合背景，是从留学申请的“黑话”中借用过来的一个词。</p></li><li><p><strong>bar：</strong>即入营门槛，不同层次的院校bar有所不同，在本科学校，成绩排名，英语四六级成绩，竞赛，科研论文等方面都会有要求。</p></li><li><p><strong>oq：</strong>overqualified，学生报名比自己本科院校或能力水平低的院校，一般这样做是为了保底，但有时候也会因为oq而被院校主动放弃。</p></li><li><p><strong>套磁：</strong>提前联系导师介绍自身背景情况，表明读研意愿，增加获得导师名额的机会。一般理工科同学需要套磁的比较多，经管类比较少。</p></li><li><p><strong>强com：</strong>招生办话语权大于导师，录取方式、名额增减等主要由招生办决定，而不是导师。</p></li><li><p><strong>弱com：</strong>导师话语权大于招生办，能够自主决定学生的去留、名额的增减。</p></li><li><p><strong>ap：</strong>assistantprofessor，助理教授，也可以带研究生。</p></li><li><p><strong>霸面：</strong>入营失败但通过联系导师同样获得面试机会，常见于计算机专业保研中。</p></li><li><p><strong>mock：</strong>指模拟面试，一般会在夏令营前找学长学姐帮自己模拟面试，以提前熟悉夏令营流程，训练口语表达能力。</p></li><li><p><strong>优营/offer：</strong>优秀营员，优营效力视具体学校而定。有些优营＝拟录取，直接9.28填系统就可以。有些优营仍然需要进入预推免，参加预推免考核。</p></li><li><p><strong>候补/wl/waitinglist：</strong>候补队列，许多学校防止优营鸽太狠，优营不去以后一般从wl开始往后顺延录取。</p></li><li><p><strong>鸽子：</strong>和A导师/学校约定好，后来放导师鸽子，去B导师/学校。</p></li><li><p><strong>被海：</strong>分两种情况</p><ul><li><strong>学生被海：</strong>院校超放大量offer/入营后录取人数多很多。</li><li><strong>学校被海：</strong>学生有很多offer，但依然没有拒绝院校的offer。</li></ul></li><li><p><strong>夏0营：</strong>夏令营一个offer都没有获得。</p></li><li><p><strong>捡漏：</strong>9.28之后，有些院校开系统后招不够人进行补录，保研er可能捡到高性价比的offer，甚至被梦校捞起来。</p></li><li><p><strong>学硕：</strong>3年，学士型研究生，偏向学术研究，可以直接读博/硕博连读。</p></li><li><p><strong>专硕：</strong>2-3年，专业型研究生，偏向实际应用，学费普遍比学硕贵（有的不含宿舍），需实习。</p></li><li><p><strong>直博：</strong>5/6年毕业，直博不经过硕士阶段，毕业时只拿博士学位。如果放弃，一些项目可以选择转硕，然后以硕士毕业；一些项目则只能拿本科学位。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老师交流话术</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E8%80%81%E5%B8%88%E4%BA%A4%E6%B5%81%E8%AF%9D%E6%9C%AF/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E8%80%81%E5%B8%88%E4%BA%A4%E6%B5%81%E8%AF%9D%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>还是蛮建议各位研究生在读研前，再申请一个微信号，留作读研期间以及以后工作用的。</p><p>再申请一个，你就不用去担心发朋友圈要屏蔽谁，不用怕把不该发东西发出去。</p><p><strong>1. 加了微信后。</strong></p><p>这个时候导师也确认了，介绍一下自己就行：姓名+学校+家乡+手机号码。老师好，我是小诸，本科就读于xxxx，老家是xx省xx市xx县的，我的手机号码是123456789。非常高兴成为您的学术！</p><p><strong>2. 做好老师的备注。</strong></p><p>郑重告知各位，不要给老师备注什么奇怪奇怪的名字，万一被看到，尴尬的是自己。</p><p><strong>3. 不要吐槽，不要吐槽！</strong></p><p>很多人都是吐槽老师，然后就发到<ahref="https://www.zhihu.com/search?q=课题组&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%223171015542%22%7D">课题组</a>或者老师那里了，社死三年啊！</p><p><strong>4. 明确目的</strong></p><p>和老师沟通，一般是和科研任务有关，所以明确自己的沟通目的，确保信息传达清晰。避免模糊的开场白，直接表达你要讨论的主题。没事还是少和导师聊，他们也不喜欢的。</p><p><strong>5. 简洁明了</strong></p><p>微信是<ahref="https://www.zhihu.com/search?q=即时通讯&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%223171015542%22%7D">即时通讯</a>工具，因此消息最好简洁明了。用清晰的语言表达自己的问题、需求或意见，避免过长的篇幅。</p><p><strong>6. 避免过度频繁</strong></p><p>别有问题就去找导师，导师脾气再好也会被折磨得想哭。有问题，自己先查查。给导师点时间，避免在短时间内连续发送多条消息。也让自己喘口气。如果涉及到较复杂的问题，可以提前说明，和导师商量，安排一个正式的讨论时间。</p><p><strong>7.避免在非工作时间（如晚上或周末）打扰导师，除非有紧急情况。</strong></p><p>其实发了也没事，导师会装作没看到，等他空了回就是了。紧急情况，一定要打电话！</p><p><strong>8. 回应尽可能及时</strong></p><p>除了做实验的时候，不方便回。一般情况，建议看到就回，保持流畅的沟通。但如果你需要时间来做进一步的准备或思考，也可以委婉地表达。</p><p><strong>9. 少聊私事</strong></p><p>在与导师沟通时，避免涉及过多个人隐私或敏感信息。尽量保持专业和学术性质的讨论。特别是女生，如果导师和你聊一些奇奇怪怪的，截图保存，立马检举他！</p><p><strong>10. 常用话术</strong></p><p>「好的，老师。」「收到，老师！」「嗯嗯，好。」「嗯嗯，行」以及各种大拇指、撒花表情</p><p><strong>11. 记得总结</strong></p><p>在沟通结束后，对讨论的要点进行简要回顾，以确保双方都对沟通内容有清晰的理解。</p><p><strong>12. 灵活切换</strong></p><p>如果发现微信并不适合某些复杂或重要的讨论，可以适时切换到其他更合适的沟通方式，如面谈。</p><p>其实跟导师聊微信没什么聊的，除了科研学术相关，其他的聊不到一块去。</p><p>你一个二十几的人，和一个三四十，甚至五六十岁的人，压根没有什么共同话题的。</p><p>你：玩玩玩，嗨皮嗨皮嗨皮，搞个毛学术！</p><p>导师：钱钱钱，项目项目项目，本子本子本子！老婆孩子家人……</p><p>少聊一点，没关系的。聊什么都不如来一句：老师，这个实验我做出来了，数据不错，可以写文章了！老师，文章中了！老师，我毕业走了！</p><hr /><p>在微信上和导师聊，最多就是一些任务分配，约一个时间沟通这类比较细碎的事情。</p><p>要指导，还是得面对面的。</p><p>很多研究生就不喜欢沟通，但是没办法。你不找，他也要找你。你不找，他刚好就有理由甩锅。</p><p>“你自己不主动，论文出问题，毕业不了，和我有什么关系？”</p><p>别怕，聊几回就习惯了。</p><p><strong>1.使用恰当的呼：</strong>有事找老师的第一点，就是客气礼貌，就是很正常的客套话，比如“老师好...”、“老师，打扰一下您.....”。这个是通用的，你麻烦谁都要先客气一下。别低估一些奇葩导师的自尊心！</p><p><strong>2. 简明扼要：</strong>把自己的目的说清楚。比如说：“我想讨论一下关于……的事情，不知道您啥时候方便？”不要问：老师，在吗？。直接说事情就好，老师看到就会回复。问“在吗”，非常膈应人。</p><p><strong>3. 提前预约：</strong>尽量提前预约拜访时间，让导师能有足够的准备。可以说：“您哪个时间比较方便？我想约个时间和您讨论一下。”也可以给几个时间选项，问问导师哪个时间段方便。</p><p><strong>4. 适当提前提醒：</strong>在约好当天的上午或者前一天晚上，可以再次发条消息确认。“老师，我们约好了沟通时间，是XX号楼XX室，时间是XX点。”</p><p><strong>5. 尊重导师的时间：</strong>如果导师当时很忙，可能没法立即拜访。你可以这样说：“如果现在不方便，那我们可以再定个时间。”</p><p><strong>6. 准备好问题：</strong>在拜访前，准备好你想要讨论的问题或话题，发一个PPT或者Word给他，确保能有意义的交流。</p><p><strong>7. 开场礼节：</strong>在见面时，先表示感谢，比如：“感谢您抽时间和我见面”。</p><p><strong>8. 尊重导师意见：</strong>在交流中，尊重导师的意见和建议，不要争论或反驳。反驳了，导师会不爽，他会让你也不爽。</p><p><strong>9. 主动提问：</strong>问一些开放性的问题，让导师能够深入分享他的观点和经验。</p><p><strong>10. 表达感谢：</strong>在拜访结束时，表达感谢并表示你会认真考虑导师的建议。</p><p><strong>11. 跟进邮件：</strong>拜访后，可以发一封邮件，再次感谢导师，并简要总结一下你们的讨论和得出的结论。</p><p><strong>12. 保持联系：</strong>如果有需要，以后也可以不定期地通过微信向导师请教问题或分享进展。</p><p>读研和大学不同。大学你能舒舒服服，翘翘课，美滋滋。读研你得老老实实在实验室，三年完成导师规定的工作量，否则别想毕业。两者可比性不高，因为不在一个数量级。</p><p>该做的事情，还是要做的。别拖着，越拖着越倒霉！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强弱com</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%99%A2%E6%A0%A1/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E4%BF%9D%E7%A0%94/%E9%99%A2%E6%A0%A1/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403150851284.jpeg"alt="38249f41fdcdd6b840eb92e95c719ba" /><figcaptionaria-hidden="true">38249f41fdcdd6b840eb92e95c719ba</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261622008.jpg"alt="3756f0f7c4457c4c50fe2db2c9e6e6a" /><figcaptionaria-hidden="true">3756f0f7c4457c4c50fe2db2c9e6e6a</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261622887.jpg"alt="cb7777272adc0455cb53596e7af73a9" /><figcaptionaria-hidden="true">cb7777272adc0455cb53596e7af73a9</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261622653.jpg"alt="eba94262d123ff7046dbc6479bfd4f7" /><figcaptionaria-hidden="true">eba94262d123ff7046dbc6479bfd4f7</figcaption></figure><h1 id="院校com概念">院校COM概念</h1><p><strong>强COM院校:</strong></p><table><thead><tr class="header"><th style="text-align: left;">院校</th><th style="text-align: left;">com强弱</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">清华软件</td><td style="text-align: left;">强com*</td></tr><tr class="even"><td style="text-align: left;">北大软微</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">中科院自动化所</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">上交计算机硕士</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">复旦计算机</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">南大计算机</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">南大人工智能</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">人大高瓴</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">人大信息</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">北航计算机</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">哈工大计算机</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">天大智算</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">南开软院</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">厦大计算机</td><td style="text-align: left;">强com</td></tr><tr class="odd"><td style="text-align: left;">川大计算机</td><td style="text-align: left;">强com</td></tr><tr class="even"><td style="text-align: left;">中科大计算机</td><td style="text-align: left;">强com*</td></tr><tr class="odd"><td style="text-align: left;">东南计算机</td><td style="text-align: left;">强com*</td></tr></tbody></table><p>清华*: 如果涉及上机考核，必须通过上机考试</p><p>中科大计算机*：导师可以推荐入营，但是仍需要通过学校面试拿到优营。</p><p>东南计算机*：必须先陶瓷拿到导师推荐信，才能入营参加学院考核。</p><p><strong>弱COM院校:</strong></p><table><thead><tr class="header"><th style="text-align: left;">院校</th><th style="text-align: left;">com强弱</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">清华叉院</td><td style="text-align: left;">弱com*</td></tr><tr class="even"><td style="text-align: left;">北大叉院</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">北大计算机</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">北大智能</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">中科院计算所</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">中科院软件所</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">上交计算机直博</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">浙大计算机直博</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">南开计算机</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">上科大计算机</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">北邮计算机</td><td style="text-align: left;">弱com</td></tr><tr class="even"><td style="text-align: left;">西电AI</td><td style="text-align: left;">弱com</td></tr><tr class="odd"><td style="text-align: left;">电子科大计算机</td><td style="text-align: left;">弱com*</td></tr></tbody></table><p>清华*: 如果涉及上机考核，必须通过上机考试</p><p>电子科大*：22年因导师招生超标，学院组织面试刷掉部分学生</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403261642745.png"alt="image-20240326164209640" /><figcaption aria-hidden="true">image-20240326164209640</figcaption></figure><p>可以使用<strong>贪心算法</strong>来解决</p><ol type="1"><li><p>将所有区间按<strong>左端点从小到大</strong>排序</p></li><li><p>从前往后依次处理每个区间，判断能否将该区间<strong>放到当前某个集合中</strong></p><ol type="1"><li>如果该区间能放到当前某个集合中：则把该区间放到该组中，并更新当前组的Max_r</li><li>如果该区间不能放到当前任意一个集合中：则新开一个集合，然后把该区间放到新开的集合中</li></ol></li><li><p>集合的数量就是答案。</p></li></ol><p>关键步骤是第二步，如何判断当前区间能否放到之前的集合中呢？</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403262030011.png"alt="image-20240326203038926" /><figcaption aria-hidden="true">image-20240326203038926</figcaption></figure><p>​为了快速找出当前所有集合右端点的<strong>最小值</strong>，可以使用小根堆保存每个集合的右端点，这样heap.top()就是当前集合的最小值啦~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5A级景区</title>
      <link href="/2023/10/03/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/5A%E6%99%AF%E5%8C%BA/"/>
      <url>/2023/10/03/%5Bobject%20Object%5D/%E7%94%9F%E6%B4%BB/5A%E6%99%AF%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939877.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030949257.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939648.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939378.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030939756.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940425.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940146.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940323.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030940140.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310030950797.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【排序】</title>
      <link href="/2023/09/29/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91/"/>
      <url>/2023/09/29/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="内部排序img">内部排序<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900163.png"alt="img" /></h1><span id="more"></span><h2 id="前提">前提</h2><p><code>void XSort ( ElementType A[], int N )</code></p><ul><li>为简单起见，讨论<strong><font color='red'>从小大的整数</font></strong>排序</li><li>只讨论基于比较的排序（&gt; = &lt; 有定义）</li><li>==<strong>没有一种排序是任何情况下都表现最好的</strong>==</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290857254.png"alt="image-20230929085748167" /><figcaption aria-hidden="true">image-20230929085748167</figcaption></figure><h2 id="插入排序">插入排序</h2><h3 id="直接插入排序">直接插入排序</h3><h4 id="算法思路">算法思路</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900164.png"alt="image-20221021191151215" /><figcaption aria-hidden="true">image-20221021191151215</figcaption></figure><blockquote><p>注：</p><ol type="1"><li>直接插入排序是从<strong><font color='red'>第二个元素</font></strong>开始的</li><li>直接插入排序<strong><code>L</code></strong>趟后，前<strong><code>L+1</code></strong>个元素是<strong><font color='blue'>有序的</font></strong>。</li><li>总共需要==<strong><font color='blue'>n-1</font></strong>==趟排序</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ElementType t = A[i];<span class="type">int</span> j=i<span class="number">-1</span>;<span class="comment">//t为待插入元素</span></span><br><span class="line"><span class="comment">//寻找待插入元素的位置，同时移动元素</span></span><br><span class="line"><span class="keyword">while</span>( A[j] &gt; t &amp;&amp; j &gt;= <span class="number">0</span> )<span class="comment">//必须是t&lt;a[j]，不能是a[i]&lt;a[j] </span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">A[j+<span class="number">1</span>] = t;<span class="comment">//j+1即为待插入的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li><strong><code>while( a[j] &gt; t &amp;&amp; j &gt;= 0 )</code></strong>决定了该算法是<strong><font color='red'>稳定的排序算法</font></strong></li><li>移动位置时<strong><font color='blue'>从后往前</font></strong>移动</li></ol></blockquote><h4 id="算法分析">算法分析</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900165.png" alt="image-20221021194038472" style="zoom:70%;" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900166.png"alt="image-20221021194054276" /><figcaption aria-hidden="true">image-20221021194054276</figcaption></figure><h4 id="总结">总结</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900167.png"alt="image-20221021194336606" /><figcaption aria-hidden="true">image-20221021194336606</figcaption></figure><h3 id="折半插入排序">折半插入排序</h3><h4 id="算法思想">算法思想</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900168.png"alt="image-20221021194551088" /><figcaption aria-hidden="true">image-20221021194551088</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900169.png"alt="image-20221208164824621" /><figcaption aria-hidden="true">image-20221208164824621</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(ElementType A[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == t)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; t)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModInsertSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = A[i];</span><br><span class="line">        <span class="comment">// 折半插入排序采用--折半查找</span></span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">BinarySearch</span>(A, <span class="number">0</span>, i - <span class="number">1</span>, t);</span><br><span class="line">        <span class="comment">// 从后往前移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= k; j--)</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        A[k] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：折半插入排序采用--折半查找，查找效率提高，但<strong><font color='blue'>元素移动次数不变</font></strong>（<strong><font color='blue'>元素比较次数减少</font></strong>），仅仅将<strong><font color='red'>分散移动</font></strong>改为<strong><font color='red'>集体移动</font></strong></p></blockquote><h2 id="希尔排序">希尔排序</h2><h3 id="思想缩小增量排序">思想：缩小增量排序</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900170.png"alt="image-20221208165741872" /><figcaption aria-hidden="true">image-20221208165741872</figcaption></figure><h3 id="算法">算法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900171.png"alt="image-20221208183557556" /><figcaption aria-hidden="true">image-20221208183557556</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=gap; i&lt;n; i++) <span class="comment">//插入排序,从第二个元素开始,对所有组进行</span></span><br><span class="line">        &#123;</span><br><span class="line">            ElementType t=A[i];<span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; t &lt; A[j]; j -= gap) <span class="comment">//从后往前移动</span></span><br><span class="line">                A[j+gap]=A[j];</span><br><span class="line">            A[j+gap]=t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序">冒泡排序</h2><h3 id="特点">特点</h3><ul><li>冒泡排序一趟后，<font color='red'><strong>最大元素沉底</strong></font>且<strong>位于最终位置</strong></li><li>总共需要<strong><font color='blue'>n-1</font></strong>趟</li></ul><h3 id="算法-1">算法</h3><p>冒泡法排序：（数字/字符）</p><ol type="1"><li>相邻两个元素作比较，大的元素放在后面，</li><li>对n个数进行排序<font color='blue'><strong>需n-1次排序</strong></font></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElementType A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) <span class="comment">//n-1次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j=<span class="number">0</span>; j&lt;n-i; j++)</span><br><span class="line"><span class="keyword">if</span>( A[j] &gt; A[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=A[j];A[j]=A[j+<span class="number">1</span>];A[j+<span class="number">1</span>]=t;<span class="comment">// swap(A[j],A[j+1]);</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若某一趟排序中没有元素交换,则说明所有元素已经有序，不需要再排序</span></span><br><span class="line"><span class="keyword">if</span> (flag)<span class="keyword">return</span>;<span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><h3 id="法一推荐">法一（推荐）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Median3</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (A[left] &gt; A[mid])</span><br><span class="line">        <span class="built_in">swap</span>(A[left], A[mid]);</span><br><span class="line">    <span class="keyword">if</span> (A[left] &gt; A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[left], A[right]);</span><br><span class="line">    <span class="keyword">if</span> (A[mid] &gt; A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[mid], A[right]);</span><br><span class="line">    <span class="built_in">swap</span>(A[mid], A[left]); <span class="comment">// 把中值放在数组的首位，便于取主元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Median3</span>(A, left, right);</span><br><span class="line">    <span class="type">int</span> k = left;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//必须是先right再left</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt;= A[k])</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= A[k])</span><br><span class="line">            left++;</span><br><span class="line">        <span class="built_in">swap</span>(A[left], A[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(A[k], A[right]); <span class="comment">// swap(A[k], A[left]);也可以</span></span><br><span class="line">    <span class="keyword">return</span> right;<span class="comment">// return left;也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(A, left, right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, left, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(A, <span class="number">0</span>, n<span class="number">-1</span>);<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><h3 id="法二">法二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Median3</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[left] &gt; A[mid])</span><br><span class="line">        <span class="built_in">swap</span>(A[left],A[mid]);</span><br><span class="line">    <span class="keyword">if</span>(A[left]&gt;A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[left],A[right]);</span><br><span class="line">    <span class="keyword">if</span>(A[mid]&gt;A[right])</span><br><span class="line">        <span class="built_in">swap</span>(A[mid],A[right]);    </span><br><span class="line">    <span class="built_in">swap</span>(A[mid],A[left]);<span class="comment">//把中值放在数组的首位，便于取主元</span></span><br><span class="line">    <span class="keyword">return</span> A[left];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">Median3</span>(A,left,right);</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; A[right]&gt;=t)</span><br><span class="line">            right--;</span><br><span class="line">        A[left]=A[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; A[left]&lt;=t)</span><br><span class="line">          left++;</span><br><span class="line">        A[right]=A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left]=t;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot=<span class="built_in">partition</span>(A,left,right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,left,pivot<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(A, <span class="number">0</span>, n<span class="number">-1</span>);<span class="comment">//调用</span></span><br></pre></td></tr></table></figure><h2 id="选择排序">选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="type">int</span> min=i;<span class="comment">//min是用来记录a[i]后面最小元素的下标</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line"><span class="keyword">if</span>(A[j]&lt;A[min])</span><br><span class="line">min=j;</span><br><span class="line"><span class="keyword">if</span>(min!=i)</span><br><span class="line"><span class="built_in">swap</span>(A[i],A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序">堆排序</h2><ul><li><h3id="以大根堆为例">以<font color='purple'>大根堆</font>为例</h3></li></ul><blockquote><p>堆排序<strong><code>ElementType A[]</code>从<code>A[1]</code><font color='red'>开始存储</font></strong>，<strong><font color='blue'>A[0]充当哨兵</font></strong></p><ul><li><p><strong><font color='red'>A[1]到A[n]</font></strong>存储<strong><font color='cyan'>待排元素</font></strong></p></li><li><p>此时堆满足：</p></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900172.png"alt="image-20221208224655254" /><figcaption aria-hidden="true">image-20221208224655254</figcaption></figure></blockquote><h3 id="算法概述">算法概述</h3><ol type="1"><li>构造初始堆：将给定的无序序列构造成<strong><font color='red'>大根堆</font></strong>：A[1]、A[2]……..A[n]；</li><li>将堆顶元素A[1]与末尾元素进行交换，使末尾元素最大；</li><li>然后再将A[]调整为最大堆，重复步骤2，反复调整、交换、调整，直到整个序列有序</li></ol><h3 id="筛选算法">筛选算法</h3><h4 id="上滤">上滤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s]=A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h4 id="下滤">下滤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])<span class="comment">//i&lt;n说明A[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= A[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s]=A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><hr /><hr /><hr /><blockquote><p>从<strong><font color='red'>最后一个非终端结点</font></strong>开始建堆；</p><ul><li>n个结点 ,最后一个非终端结点的下标是 <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900173.png"alt="image-20221208235618668" /></li><li>归并排序采用<strong><font color='blue'>下滤筛选</font></strong>算法</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调整为初始堆</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=n; i&gt;<span class="number">1</span>; i--)  <span class="comment">//i表示当前最大堆的末尾元素，也是当前堆的大小</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//堆顶元素A[1]与末尾元素A[i]交换，使最大元素沉底        </span></span><br><span class="line">        ElementType t=A[i];A[i]=A[<span class="number">1</span>];A[<span class="number">1</span>]=t;</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,i<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二路归并排序">二路归并排序</h2><h3 id="思路">思路</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900174.png"alt="image-20221209083227737" /><figcaption aria-hidden="true">image-20221209083227737</figcaption></figure><h3 id="算法-2">算法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900175.png"alt="image-20221209083336292" /><figcaption aria-hidden="true">image-20221209083336292</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900176.jpg"alt="微信图片_20221209083037" /><figcaption aria-hidden="true">微信图片_20221209083037</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElementType A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType B[n]; <span class="comment">// 构造辅助数组B,n为A数组大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">        B[i] = A[i]; <span class="comment">// 复制A中元素到B中</span></span><br><span class="line">    <span class="type">int</span> i = low, j = mid + <span class="number">1</span>, k = low;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j])</span><br><span class="line">            A[k++] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有剩余元素，则一一复制到数组A中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElementType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(A, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(A, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MergeSort</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="基数排序">基数排序</h2><h3 id="思想">思想</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900177.png"alt="image-20221209090502894" /><figcaption aria-hidden="true">image-20221209090502894</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900178.png"alt="image-20221209090418302" /><figcaption aria-hidden="true">image-20221209090418302</figcaption></figure><h3 id="算法-3">算法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900179.png"alt="image-20221209091734211" /><figcaption aria-hidden="true">image-20221209091734211</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Radix</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(k/<span class="built_in">pow</span>(<span class="number">10</span>,p<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(ElementType A[],<span class="type">int</span> figure,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;Q[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> pass=<span class="number">1</span>; pass&lt;=figure; pass++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1">总结</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900180.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900181.jpg"alt="13315216532604079" /><figcaption aria-hidden="true">13315216532604079</figcaption></figure><blockquote><ul><li>不稳定排序：<strong><font color='red'>选择排序，希尔排序，快速排序，堆排序</font></strong></li></ul></blockquote><h1 id="例题">例题</h1><h2 id="例一">例一</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900182.png"alt="image-20221111123448323" /><figcaption aria-hidden="true">image-20221111123448323</figcaption></figure><h3 id="问题抽象">问题抽象</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900183.png"alt="image-20221111123540642" /><figcaption aria-hidden="true">image-20221111123540642</figcaption></figure><h3 id="算法-4">算法</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900184.png"alt="image-20221111123621514" /><figcaption aria-hidden="true">image-20221111123621514</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(ElementType A[i],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=n, h=<span class="number">1</span>;<span class="comment">//h代表颜色</span></span><br><span class="line">    <span class="keyword">while</span>(h&lt;=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( i&lt;j &amp;&amp; A[i].key==h )</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>( i&lt;j &amp;&amp; A[j].key!=h )</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            &#123;ElementType t=A[i];A[i]=A[j];A[j]=t;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j=n;h++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>此题采用了———<strong><font color='red'>快速排序</font></strong>的部分思想</p></blockquote><h2 id="例二">例二</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290900185.png"alt="image-20221211154954610" /><figcaption aria-hidden="true">image-20221211154954610</figcaption></figure><h3 id="补充">补充</h3><h4 id="下滤筛选">下滤筛选</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])<span class="comment">//i &lt; n 说明A[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= A[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆调整">堆调整</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h4 id="上滤筛选">上滤筛选</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆调整-1">堆调整</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>上滤</font>：用于<font color='blue'>向堆中插入一个元素</font></strong></p></blockquote><h3 id="答案">答案</h3><ul><li>==<strong><font color='red'>上滤算法</font></strong> +<strong><font color='red'>调整算法</font></strong>==</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElementType A[],<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = A[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;A[s] = A[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[s]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span> <span class="params">(ElementType A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,n,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h1 id="重点参考">重点参考</h1></li></ul><p><ahref="https://blog.csdn.net/weixin_53011574/article/details/125964731?spm=1001.2014.3001.5506">(72条消息)数据结构学习笔记（第八章排序-内部排序）_低调$(生活)的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【对列】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%AF%B9%E5%88%97%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%AF%B9%E5%88%97%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一循环队列">一：循环队列</h1><p>循环队列的引入是为了克服==<strong><font color='red'>“假上溢”现象</font></strong>==。</p><h3 id="存储结构">1、存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* base;</span><br><span class="line"><span class="type">int</span> front;</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>front和rear</font></strong>是头尾指针（相对于数组），front指向<strong>第一个元素</strong>，rear指向<strong>最后一个元素的==<font color='blue'>下一个位置</font>==</strong></p></blockquote><span id="more"></span><h3 id="初始化">2、初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(Queue&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q.base = <span class="keyword">new</span> ElementType[MASQSIZE];<span class="comment">//开辟空间</span></span><br><span class="line"><span class="keyword">if</span> (!q.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">q.front = q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队">3、入队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; q, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((q.rear + <span class="number">1</span>) % MAXQSIZE == q.front)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队满</span></span><br><span class="line">q.base[q.rear] = e;</span><br><span class="line">q.rear = (q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队">3、出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; q, ElementType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q.front == q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">e = q.base[q.front];</span><br><span class="line">q.front = (q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列长度">4、队列长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q.rear - q.front + MAXQSIZE ) % MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队满">5、队满</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueFull</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q.rear + <span class="number">1</span> ) % MAXQSIZE == q.front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二链队列">二、链队列</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119858.png"alt="image-20230928211711116" /><figcaption aria-hidden="true">image-20230928211711116</figcaption></figure><blockquote><p><strong><font color='red'>链队</font></strong>带<strong><font color='blue'>头结点</font></strong></p></blockquote><h3 id="存储结构-1">1、存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">Node* front;<span class="comment">//队头指针</span></span><br><span class="line">Node* rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h3 id="链队的初始化">2、链队的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front = Q.rear = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队的入队">3、链队的入队</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119834.png"alt="image-20230928211729867" /><figcaption aria-hidden="true">image-20230928211729867</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue&amp; Q, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">p-&gt;data = x;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//头插法    </span></span><br><span class="line">Q.rear-&gt;next = p;</span><br><span class="line">Q.rear = p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链队的出队">4、链队的出队</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119867.png"alt="image-20230928211745037" /><figcaption aria-hidden="true">image-20230928211745037</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue&amp; Q, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//队列为空</span></span><br><span class="line">p = Q.front-&gt;next;<span class="comment">//p指向队头元素</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//e保存队头元素的值</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p)<span class="comment">//如果最后一个元素被删，则队尾指针为空</span></span><br><span class="line">Q.rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放原队头元素的空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><pre><code>  如果队列Q中==**&lt;font color=&#39;red&#39;&gt;最后一个元素被删除&lt;/font&gt;**==了，则队列中没有元素了，  </code></pre><ul><li><strong><code>Q.rear</code></strong>不指向任何元素，要修改并赋值<strong><code>NULL</code></strong></li><li><strong><code>Q.front</code></strong>由于是<strong><font color='red'>头结点</font></strong>，所以其值始终不会改变</li></ul></blockquote><h1 id="例题">例题</h1><h2 id="例一">例一</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119854.png"alt="image-20221216122834047" /><figcaption aria-hidden="true">image-20221216122834047</figcaption></figure><blockquote><p><strong><font color='red'>不设置头结点</font></strong>，就必须考虑</p><ol type="1"><li>初始时==<strong><font color='blue'>链表是否为空</font></strong>==</li><li>是否在<strong><font color='orange'>第一个结点前插入新结点</font></strong></li><li>是否<strong><font color='red'>删除</font></strong>结点后<strong><font color='blue'>链表为空</font></strong></li></ol></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282119888.jpeg"alt="13315216532604079" /><figcaption aria-hidden="true">13315216532604079</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(node* rear,ElementType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p=<span class="keyword">new</span> node;</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">    <span class="keyword">if</span>(rear==<span class="literal">NULL</span>)<span class="comment">//队列为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=p;</span><br><span class="line">        rear=p;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=rear-&gt;next;</span><br><span class="line">        rear-&gt;next=p;</span><br><span class="line">        rear=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">status <span class="title">DeQueue</span><span class="params">(ElementType &amp;x,node* rear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear==<span class="literal">NULL</span>)<span class="keyword">return</span> ERROR;       </span><br><span class="line">    node* p=rear-&gt;next;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(p==rear)<span class="comment">//删除后队列为空</span></span><br><span class="line">        rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rear-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符优先级</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310031506806.png"alt="202310031501616" /><figcaption aria-hidden="true">202310031501616</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202310031505067.png"alt="202310031501616" /><figcaption aria-hidden="true">202310031501616</figcaption></figure><p><strong>说明</strong>：</p><ol type="1"><li><strong>一优先级的运算符，运算次序由结合方向所决定</strong></li><li><strong>简单记就是：！ &gt;</strong> <strong>算术运算符</strong><strong>&gt;</strong> <strong>关系运算符</strong> <strong>&gt;&amp;&amp; &gt; || &gt;</strong> <strong>赋值运算符</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【串】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E4%B8%B2%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E4%B8%B2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="串">串</h1><h2 id="例题">例题</h2><h3 id="例一">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403291850568.jpeg"alt="307d2ae478633f0ab69b5f4ea7662e1" /><figcaptionaria-hidden="true">307d2ae478633f0ab69b5f4ea7662e1</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsReverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断输入的字符串中‘&amp;’前后两部分是否为逆串，是则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;s;<span class="type">char</span> c,t;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        s.<span class="built_in">push</span>(c);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t!=c)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>判断是否为逆序通常需要使用<strong><code>stack</code></strong></li><li>注意<strong>第9，第13行</strong>。</li></ol></blockquote><h3 id="例二">例二</h3><p><strong>1095 解码PAT准考证</strong></p><p><strong>题目</strong></p><p>PAT 准考证号由 4 部分组成：</p><ul><li>第 1 位是级别，即 <code>T</code> 代表顶级；<code>A</code>代表甲级；<code>B</code> 代表乙级；</li><li>第 2~4 位是考场编号，范围从 101 到 999；</li><li>第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；</li><li>最后 11~13 位是考生编号，范围从 000 到 999。</li></ul><p>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。</p><p><strong>输入格式：</strong></p><p>输入首先在一行中给出两个正整数 <em>N</em>（≤104）和<em>M</em>（≤100），分别为考生人数和统计要求的个数。</p><p>接下来 <em>N</em> 行，每行给出一个考生的准考证号和其分数（在区间[0,100] 内的整数），其间以空格分隔。</p><p>考生信息之后，再给出 <em>M</em>行，每行给出一个统计要求，格式为：<code>类型 指令</code>，其中</p><ul><li><code>类型</code> 为 1表示要求按分数非升序输出某个指定级别的考生的成绩，对应的<code>指令</code> 则给出代表指定级别的字母；</li><li><code>类型</code> 为 2表示要求将某指定考场的考生人数和总分统计输出，对应的 <code>指令</code>则给出指定考场的编号；</li><li><code>类型</code> 为 3表示要求将某指定日期的考生人数分考场统计输出，对应的 <code>指令</code>则给出指定日期，格式与准考证上日期相同。</li></ul><p><strong>输出格式：</strong></p><p>对每项统计要求，首先在一行中输出 <code>Case #: 要求</code>，其中<code>#</code> 是该项要求的编号，从 1 开始；<code>要求</code>即复制输入给出的要求。随后输出相应的统计结果：</p><ul><li><code>类型</code> 为 1 的指令，输出格式与输入的考生信息格式相同，即<code>准考证号 成绩</code>。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；</li><li><code>类型</code> 为 2 的指令，按 <code>人数 总分</code>的格式输出；</li><li><code>类型</code> 为 3 的指令，输出按人数非递增顺序，格式为<code>考场编号 总人数</code>。若人数并列则按考场编号递增顺序输出。</li></ul><p>如果查询结果为空，则输出 <code>NA</code>。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">8 4</span><br><span class="line">B123180908127 99</span><br><span class="line">B102180908003 86</span><br><span class="line">A112180318002 98</span><br><span class="line">T107150310127 62</span><br><span class="line">A107180908108 100</span><br><span class="line">T123180908010 78</span><br><span class="line">B112160918035 88</span><br><span class="line">A107180908021 98</span><br><span class="line">1 A</span><br><span class="line">2 107</span><br><span class="line">3 180908</span><br><span class="line">2 999</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1 A</span><br><span class="line">A107180908108 100</span><br><span class="line">A107180908021 98</span><br><span class="line">A112180318002 98</span><br><span class="line">Case 2: 2 107</span><br><span class="line">3 260</span><br><span class="line">Case 3: 3 180908</span><br><span class="line">107 2</span><br><span class="line">123 2</span><br><span class="line">102 1</span><br><span class="line">Case 4: 2 999</span><br><span class="line">NA</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    string t;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value != b.value ? a.value &gt; b.value : a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; v[i].t &gt;&gt; v[i].value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; num &gt;&gt; s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d %s\n&quot;</span>, i, num, s.<span class="built_in">c_str</span>());      <span class="comment">//Attention!    s.c_str()</span></span><br><span class="line">        vector&lt;node&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t[<span class="number">0</span>] == s[<span class="number">0</span>])      ans.<span class="built_in">push_back</span>(v[j]); <span class="comment">//S[0]即为字符‘A’....</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, ans[j].t.<span class="built_in">c_str</span>(), ans[j].value);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>)     <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>) == s) </span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    sum += v[j].value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt)   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, sum);</span><br><span class="line">            <span class="keyword">else</span>       <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (v[j].t.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">6</span>) == s)   m[v[j].t.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>)]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : m)   </span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;it.first, it.second&#125;);   <span class="comment">//Attention!!   &#123;it.first,it.second&#125;直接插入结构体</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans.<span class="built_in">size</span>(); j++)    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, ans[j].t.<span class="built_in">c_str</span>(), ans[j].value);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == <span class="number">0</span>)     <span class="built_in">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>27行：<code>string</code>类型的变量s用printf输出必须是<code>printf(“%s”,s.c_str());</code>即<strong>s.c_str()</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HuffmanTree】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90HuffmanTree%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90HuffmanTree%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树">哈夫曼树</h1><h2 id="定义">定义</h2><blockquote><p>通过==最小堆（最小堆存放树的根结点）==来实现，每次拿出两个权值==最小的二叉树==进行合并，合并后的新树插入最小堆</p></blockquote><h2 id="注意">注意</h2><ol type="1"><li>哈夫曼<strong>树</strong> 属于 ==树==，也是链式存储</li><li><strong>构建<code>HuffmanTree</code>之前必须先构建<code>MinHeap</code></strong></li></ol><span id="more"></span><h2 id="特点">特点</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012075.png"alt="image-20230916123759336" /><figcaption aria-hidden="true">image-20230916123759336</figcaption></figure><blockquote><ol type="1"><li>==<strong><font color='red'>权值的个数即为叶子节点的个数</font></strong>==</li><li>HuffmanTree编码的<strong><font color='gree'>码字</font></strong>均在<strong><font color='purple'>叶结点</font></strong>上</li></ol></blockquote><p>哈夫曼树是一种带权路径长度最短的树，在一个度为m的哈夫曼树中，其叶结点个数为n，则非叶结点的个数为<u><strong><font color='red'>（n-1)/ （m-1）</font></strong></u>。答：叶结点即度为0的结点有n个；假设度为m的结点个数为x,则x+n=mx+1;也就是x=n-1/m-1;若n-1不能被整除，即所给数据不能直接构造最优m叉树，这时需要加一些不影响建树的数据，可以添0；添加的个数为(m-1)-（(n-1)%(m-1)）。所以最终x应该为⌈n-1/m-1⌉，即向上取整；</p><blockquote><p>联想：信息论进行m元Huffman编码进行压缩，每m个压缩一次后减少了m-1个，最后一次压缩可能需要补零。q+t=k(m-1)+m</p></blockquote><h2 id="操作">操作</h2><h3 id="对象">对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* left,right;</span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree data[Maxsize];<span class="comment">//Attention!!</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MinHeap;</span><br><span class="line"></span><br><span class="line">HuffmanTree T=<span class="built_in">CreateHuffman</span>();</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树的创建初始化">哈夫曼树的创建(初始化)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Huffman T=(Huffman)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;weight=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树的建立">哈夫曼树的建立</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">BuildHuffman</span><span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;H-&gt;size;i++)<span class="comment">/*做H-&gt;Size-1次合并*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));<span class="comment">/*建立新结点*/</span></span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(H);<span class="comment">/*从最小堆中删除一个结点，作为新T的左子结点*/</span></span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(H);<span class="comment">/*再从最小堆中删除一个结点，作为新T的右子结点*/</span></span><br><span class="line">        T-&gt;weight=T-&gt;left-&gt;weight+T-&gt;right-&gt;weight;<span class="comment">/*计算新权值*/</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T);<span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="built_in">Delete</span>(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要调用的minheap函数">需要调用的MinHeap函数</h4><h6 id="最小堆creatheap">最小堆CreatHeap</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinHeap H=(MinHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HeapNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]=(Huffman)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;left=H-&gt;data[<span class="number">0</span>]-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;weight=<span class="number">-1</span>;<span class="comment">//哨兵H-&gt;data[0]的值最小</span></span><br><span class="line">H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr /><h6 id="最小堆buildheap函数">最小堆BuildHeap函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuidHeap</span> <span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    HuffmanTree t=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">    t-&gt;left=t-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t-&gt;weight;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h6 id="最小堆delete函数">最小堆Delete函数</h6><blockquote><ol type="1"><li>需要把<code>ElementType</code>改变成<code>HuffmanTree</code></li><li>将<code>H-&gt;data[child]</code>改为<code>H-&gt;data[child]-&gt;weight</code></li><li>将<code>t</code>改为<code>t-&gt;weight</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span><span class="comment">//Attention!!!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//可有可无</span></span><br><span class="line"><span class="comment">//    if(H-&gt;size==0)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line">    </span><br><span class="line">    HuffmanTree min=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点最小值，最后return</span></span><br><span class="line">   <span class="comment">/* 用最小堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    HuffmanTree t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最小的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;size&amp;&amp;H-&gt;data[child]-&gt;weight &gt; H-&gt;data[child+<span class="number">1</span>]-&gt;weight)<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;weight &lt;= H-&gt;data[child]-&gt;weight)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>将H-&gt;Elements[]按==权值==<code>H-&gt;Elements[]-&gt;weight</code>调整为最小堆</li><li>第11行~~parent*=2~~错误，必须是<code>parent=child</code>,作用是parent索引变成儿子索引，向下交换</li><li>第9行<del><code>data[H-&gt;size]</code></del>错误，必须是<code>data[H-&gt;size--]</code></li></ol></blockquote><hr /><h6 id="最小堆insert函数">最小堆Insert函数</h6><blockquote><ol type="1"><li>需要把<code>ElementType</code>改变成<code>HuffmanTree</code></li><li>将<code>H-&gt;data[i/2]</code>改为<code>H-&gt;data[i/2]-&gt;weight</code></li><li>将<code>t</code>改为<code>t-&gt;weight</code></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size&gt;=Maxsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t-&gt;weight &lt; H-&gt;data[i/<span class="number">2</span>]-&gt;weight;i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="wpl的计算">WPL的计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意：哈夫曼树没有度为1的节点 </span></span><br><span class="line"><span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)<span class="comment">//左右子树都为空</span></span><br><span class="line"><span class="keyword">return</span> depth*T-&gt;weight;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//递归去左右子树求权重，而且深度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">WPL</span>(T-&gt;left,depth+<span class="number">1</span>)+<span class="built_in">WPL</span>(T-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>初次调用WPL时：<code>int sum=WPL(T,0);</code>使depth的初始值为==0==；（因为==根节点的深度为0==）。这里的深度<code>depth</code>实际是码字长度</li><li>递归出口为根节点<code>T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL</code></li><li>递归关系为<code>WPL(T-&gt;left,depth+1)+WPL(T-&gt;right,depth+1);</code></li><li>哈夫曼树没有度为1的节点</li></ol></blockquote><hr /><h1 id="例题-05-树9-huffman-codes">例题 <strong>05-树9 HuffmanCodes</strong></h1><p>In 1953, David A. Huffman published his paper "A Method for theConstruction of Minimum-Redundancy Codes", and hence printed his name inthe history of computer science. As a professor who gives the final examproblem on Huffman codes, I am encountering a big problem: the Huffmancodes are NOT unique. For example, given a string "aaaxuaxz", we canobserve that the frequencies of the characters 'a', 'x', 'u' and 'z' are4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0,'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001,'z'=000}, both compress the string into 14 bits. Another set of code canbe given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01,'u'=011, 'z'=001} is NOT correct since "aaaxuaxz" and "aazuaxax" canboth be decoded from the code 00001011001001. The students aresubmitting all kinds of codes, and I need a computer program to help medetermine which ones are correct and which ones are not.</p><h3 id="input-specification">Input Specification:</h3><p>Each input file contains one test case. For each case, the first linegives an integer <em>N</em> (2≤<em>N</em>≤63), then followed by a linethat contains all the <em>N</em> distinct characters and theirfrequencies in the following format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[1] f[1] c[2] f[2] ... c[N] f[N]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is a character chosen from {'0' - '9', 'a' -'z', 'A' - 'Z', '_'}, and <code>f[i]</code> is the frequency of<code>c[i]</code> and is an integer no more than 1000. The next linegives a positive integer <em>M</em> (≤1000), then followed by <em>M</em>student submissions. Each student submission consists of <em>N</em>lines, each in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i] code[i]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is the <code>i</code>-th character and<code>code[i]</code> is an non-empty string of no more than 63 '0's and'1's.</p><h3 id="output-specification">Output Specification:</h3><p>For each test case, print in each line either "Yes" if the student'ssubmission is correct, or "No" if not.</p><p>Note: The optimal solution is not necessarily generated by Huffmanalgorithm. Any prefix code with code length being optimal is consideredcorrect.</p><h3 id="sample-input">Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">A 1 B 1 C 1 D 3 E 3 F 6 G 6</span><br><span class="line">4</span><br><span class="line">A 00000</span><br><span class="line">B 00001</span><br><span class="line">C 0001</span><br><span class="line">D 001</span><br><span class="line">E 01</span><br><span class="line">F 10</span><br><span class="line">G 11</span><br><span class="line">A 01010</span><br><span class="line">B 01011</span><br><span class="line">C 0100</span><br><span class="line">D 011</span><br><span class="line">E 10</span><br><span class="line">F 11</span><br><span class="line">G 00</span><br><span class="line">A 000</span><br><span class="line">B 001</span><br><span class="line">C 010</span><br><span class="line">D 011</span><br><span class="line">E 100</span><br><span class="line">F 101</span><br><span class="line">G 110</span><br><span class="line">A 00000</span><br><span class="line">B 00001</span><br><span class="line">C 0001</span><br><span class="line">D 001</span><br><span class="line">E 00</span><br><span class="line">F 10</span><br><span class="line">G 11</span><br></pre></td></tr></table></figure><h3 id="sample-output">Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>400 ms</p><p>内存限制</p><p>64 MB</p><p><ahref="%5B数据结构_中国大学MOOC(慕课)%20(icourse163.org)%5D(https://www.icourse163.org/learn/ZJU-93001?tid=1468077441#/learn/content?type=detail&amp;id=1249683129&amp;cid=1277237407)">解题思路</a></p><h2 id="分析">分析</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012036.png"alt="image-20220923151214229" /><figcaption aria-hidden="true">image-20220923151214229</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012970.png"alt="image-20220923151404979" /><figcaption aria-hidden="true">image-20220923151404979</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291012024.png"alt="image-20220923151427266" /><figcaption aria-hidden="true">image-20220923151427266</figcaption></figure><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 64</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建MinHeap和HeapNode结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* left, *right;</span><br><span class="line">&#125;*HuffmanTree;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree data[Maxsize];<span class="comment">//Attention!!</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MinHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line"><span class="type">int</span> n,m,min_length;<span class="type">char</span> c; </span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span>;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//建立最小堆 </span></span><br><span class="line">MinHeap H=<span class="built_in">CreatHeap</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    HuffmanTree t=<span class="built_in">CreateHuffman</span>(); </span><br><span class="line">        cin&gt;&gt;c&gt;&gt;t-&gt;weight;</span><br><span class="line">        cnt[c]=t-&gt;weight;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  建立哈夫曼树 </span></span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    <span class="type">int</span> n=H-&gt;size; </span><br><span class="line"><span class="comment">//  for(int i=1;i&lt;H-&gt;size;i++) 错误，H-&gt;size的值会在循环中改变 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">/*做n-1次合并*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(H);</span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(H);</span><br><span class="line">        T-&gt;weight=T-&gt;left-&gt;weight+T-&gt;right-&gt;weight;<span class="comment">/*计算新权值*/</span></span><br><span class="line">        <span class="built_in">Insert</span>(H,T);<span class="comment">/*将新T插入最小堆*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="built_in">Delete</span>(H);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  计算最短长度 </span></span><br><span class="line">min_length=<span class="built_in">WPL</span>(T,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//判断 </span></span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">judge</span>())<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MinHeap <span class="title">CreatHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinHeap H=(MinHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HeapNode));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;left=H-&gt;data[<span class="number">0</span>]-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">H-&gt;data[<span class="number">0</span>]-&gt;weight=<span class="number">-1</span>;<span class="comment">//哨兵H-&gt;data[0]的值最小</span></span><br><span class="line">H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">CreateHuffman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HuffmanTree T=(HuffmanTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line">T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;weight=<span class="number">0</span>;<span class="comment">//Attention！！</span></span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MinHeap H,HuffmanTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    可有可无 </span></span><br><span class="line"><span class="comment">//    if(H-&gt;size&gt;=Maxsize)</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t-&gt;weight &lt; H-&gt;data[i/<span class="number">2</span>]-&gt;weight;i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffmanTree <span class="title">Delete</span><span class="params">(MinHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    HuffmanTree min=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点（weight最小），最后return</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 用最小堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    HuffmanTree t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最小的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>(child!=H-&gt;size&amp;&amp;H-&gt;data[child]-&gt;weight &gt; H-&gt;data[child+<span class="number">1</span>]-&gt;weight)<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;weight&lt;=H-&gt;data[child]-&gt;weight)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WPL</span><span class="params">(HuffmanTree T,<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意：哈夫曼树没有度为1的节点 </span></span><br><span class="line"><span class="keyword">if</span>((T-&gt;left==<span class="literal">NULL</span>)&amp;&amp;(T-&gt;right==<span class="literal">NULL</span>))<span class="comment">//左右子树都为空</span></span><br><span class="line"><span class="keyword">return</span> depth*T-&gt;weight;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//递归去左右子树求权重，而且深度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">WPL</span>(T-&gt;left,depth+<span class="number">1</span>)+<span class="built_in">WPL</span>(T-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">string codes; </span><br><span class="line">HuffmanTree T=<span class="built_in">CreateHuffman</span>();      <span class="comment">//模拟建树</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c&gt;&gt;codes;</span><br><span class="line"><span class="keyword">if</span>(codes.<span class="built_in">length</span>()&gt;=n)<span class="comment">//也可以没有这个判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">HuffmanTree p = T;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;codes.<span class="built_in">length</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(codes[j]==<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!p-&gt;left)</span><br><span class="line">p-&gt;left = <span class="built_in">CreateHuffman</span>();</span><br><span class="line">p = p-&gt;left;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(codes[j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">p-&gt;right = <span class="built_in">CreateHuffman</span>();</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;weight) <span class="comment">//说明已经被访问过了 </span></span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//不能直接打印，要把后面的读完 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;left || p-&gt;right )<span class="comment">//说明该结点不是叶子节点 </span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p-&gt;weight = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">len += codes.<span class="built_in">length</span>()*cnt[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(len!=min_length)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1">注意</h3><blockquote><p>judge函数模拟建树过程中</p><ol type="1"><li>左右移动过程中不能遇到<strong>已经访问的节点</strong></li><li>最后赋值的节点必须是<strong>叶节点</strong></li><li>节点weight起到标记flag的作用</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【堆】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%A0%86%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%A0%86%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="堆">堆</h1><h2 id="定义">定义</h2><p>==采用<strong><font color='blue'>数组存储</font></strong>的<strong><font color='red'>完全二叉树</font></strong>==</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011962.png"alt="image-20230916123313335" /><figcaption aria-hidden="true">image-20230916123313335</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011898.png"alt="image-20221019101952011" /><figcaption aria-hidden="true">image-20221019101952011</figcaption></figure><ul><li>从<font color='red'><code>h[1]</code>开始存储数据</font>，<code>h[0]</code>用来存放==<strong>哨兵</strong>==</li><li><code>i</code> 的左儿子 <code>2 * i</code>，右儿子<code>2 * i + 1</code></li></ul><span id="more"></span><h2 id="分类">分类</h2><blockquote><p><code>最小堆</code>（MinHeap）：任一结点的<code>data</code>小于其所有子树结点的data</p></blockquote><blockquote><p><code>最大堆</code>（MinHeap）：任一结点的<code>data</code>大于其所有子树结点的data</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011027.png"alt="image-20230916123453824" /><figcaption aria-hidden="true">image-20230916123453824</figcaption></figure><h2 id="模板">模板</h2><ul><li><p>使用数组来模拟堆，堆中的数据从 <code>h[1]</code> 开始存储</p><blockquote><p>因为如果从0开始存储，根节点0按照公式计算得到的左右节点都是0，显然不成了，需要特判，麻烦</p></blockquote></li><li><p>所有关于堆的操作均建立在堆的 <code>down()</code> 和<code>up()</code> 函数基础上</p></li></ul><h3 id="模板1">模板1</h3><p>如果只希望实现与C++ STL堆中相同的功能1、2、3，则堆的下滤和上滤操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t])</span><br><span class="line">        t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>down() 注意：</p><ol type="1"><li>down 操作需要保证左右儿子是堆</li><li>t 是根节点 <code>h[u]</code>, 左儿子 <code>h[2 * u]</code>, 右儿子<code>h[2 * u + 1]</code>中最小值的下标</li><li><code>2 * u &lt;= cnt</code>说明存在左儿子，<code>2 * u + 1 &lt;= cnt</code> 说明存在右儿子</li></ol><p>up() 注意：</p><ol type="1"><li><code>u / 2 != 0</code> 说明存在父节点</li></ol></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[++cnt]=x;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>] = h[cnt--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h3 id="模板2">模板2</h3><p>如果希望实现在 C++ STL堆中功能的基础上，添加在任意位置修改/删除的功能，需要存储映射：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081015324.png" alt="image-20240308101556244" style="zoom:15%;" /></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403081036812.jpg" alt="b9b669b4a3a28e34e104b0c5bda7d7c" style="zoom:13%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的下标p:pointer</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的h:heap</span></span><br><span class="line"><span class="comment">// cnt是堆中元素的个数</span></span><br><span class="line"><span class="comment">// m是当前堆中插入操作的次数</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交换两个点，及其映射关系 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上滤 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>p:pointer</li><li>h:heap</li></ul></blockquote><ol type="1"><li>插入一个数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt++, m++;</span><br><span class="line">h[cnt] = x, hp[cnt] = m, ph[m] = cnt;</span><br><span class="line"><span class="built_in">up</span>(cnt);</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>求堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>删除堆中的最小值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt--);</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除第 k 个插入的数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line"><span class="built_in">heap_swap</span>(k, cnt--);</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>修改第 k 个插入的数,将其变为 x</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure><blockquote><p>修改后的值与原来值相比，有3种情况</p><ul><li>相等：不需要调整堆</li><li>小于：up(k)</li><li>大于：down(k)</li></ul><p>把上面 3 种情况综合考虑，不管是相等/大于/小于，为了简单起见:</p><ul><li>如果修改h[1]：down(1)</li><li>在最后插入数据：up(++size)</li><li>如果修改其他： up(k); down(k)</li></ul><p>【实际运行时要么都不执行，要么只 up(k) ，要么只 down(k) 】</p></blockquote><ol start="6" type="1"><li>建堆</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* O(n)建堆 */</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="comment">// 输入原始数据，叶节点都是堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆，从最后一个非叶节点 n/2 开始 down</span></span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><blockquote><ul><li>由于我们是从下往上 down() 的，因此可以保证每次 down()时左右儿子都是堆</li><li>参考：<ahref="https://www.bilibili.com/video/BV1Et411v7cN/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c3da48d994eb8c44a3a243596175737e">堆的建立</a></li></ul></blockquote><h2 id="操作以maxheap为例">操作（以MaxHeap为例）</h2><h3 id="对象集">对象集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HeapNode</span> </span><br><span class="line">&#123;</span><br><span class="line">ElementType data[Maxsize];</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;* MaxHeap;</span><br></pre></td></tr></table></figure><h3 id="下滤筛选">下滤筛选</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(MaxHeap H,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = H-&gt;data[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">2</span>*s; i&lt;=n; i*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; H-&gt;size &amp;&amp; H-&gt;data[i] &lt; H-&gt;data[i+<span class="number">1</span>])<span class="comment">//i &lt; H-&gt;size说明H-&gt;data[i+1]存在</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= H-&gt;data[i])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;H-&gt;data[s]=H-&gt;data[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>下滤</font>：用于<font color='blue'>删除堆顶元素</font>后，调整堆</strong></p></blockquote><h3 id="上滤筛选">上滤筛选</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(MaxHeap H,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType t = H-&gt;data[s];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=s/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i/=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(H-&gt;data[i] &gt;= t)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;H-&gt;data[s]=H-&gt;data[i];s=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[s]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>上滤</font>：用于<font color='blue'>向堆中插入一个元素</font></strong></p></blockquote><h3 id="最大堆的初始化创建">最大堆的初始化创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">CreatHeap</span><span class="params">(<span class="type">int</span> Max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大堆的插入">最大堆的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size&gt;=Maxsize)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=++H-&gt;size;t&gt;H-&gt;data[i/<span class="number">2</span>];i/=<span class="number">2</span>)</span><br><span class="line">        H-&gt;data[i]=H-&gt;data[i/<span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i]=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>H-&gt;data[0]</code>是哨兵，它不会小于堆中的最大元素，其作用：控制循环结束。</p></blockquote><h3 id="最大堆的删除">最大堆的删除</h3><h4 id="步骤">步骤</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291011907.png"alt="这里写图片描述" /><figcaption aria-hidden="true">这里写图片描述</figcaption></figure><blockquote><p>删除并且返回根节点（最大值）</p></blockquote><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(MaxHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(H-&gt;size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ElementType max=H-&gt;data[<span class="number">1</span>];<span class="comment">//取出根节点最大值，最后return</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span> </span><br><span class="line">    ElementType t=H-&gt;data[H-&gt;size--];</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    <span class="keyword">for</span>(parent=<span class="number">1</span>;parent*<span class="number">2</span>&lt;=H-&gt;size;parent=child)<span class="comment">//若parent*2&gt;H-&gt;size说明parent没有左儿子，也就更没有右儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>;<span class="comment">//child指向左右儿子最大的那个，先初始赋值左儿子</span></span><br><span class="line">        <span class="keyword">if</span>((child!=H-&gt;size)&amp;&amp;H-&gt;data[child] &lt; H-&gt;data[child+<span class="number">1</span>])<span class="comment">//child!=H-&gt;size说明有右儿子</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=H-&gt;data[child])<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            H-&gt;data[parent]=H-&gt;data[child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[parent]=t;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第10行~~parent*=2~~错误，必须是<code>parent=child</code>,作用是parent索引变成儿子索引，向下交换</li><li>第8行<del><code>data[H-&gt;size]</code></del>错误，必须是<code>data[H-&gt;size--]</code></li></ul></blockquote><h3 id="最大堆的建立">最大堆的建立</h3><h4 id="法一">法一：</h4><h5 id="步骤-1">步骤：</h5><h6id="调用insert函数将n个元素一个个相继插入到一个初始为空的堆heap中去">（1）调用Insert函数，将N个元素一个个相继插入到一个初始为空的堆Heap中去。</h6><h6 id="其时间复杂度为on-logn">（2）其时间复杂度为O(N logN)。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">BuildHeap</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    ElementType t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="built_in">Insert</span>(H,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二">法二：</h4><h5 id="步骤-2">步骤：</h5><h6id="将n个元素按输入顺序存入先满足完全二叉树的结构特性">（1）将N个元素按输入顺序存入，先满足完全二叉树的结构特性</h6><h6id="调整各结点位置以满足最大堆的有序特性">（2）调整各结点位置，以满足最大堆的有序特性。</h6><h5 id="代码-1">代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">BuildHeap</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H=(MaxHeap)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>((<span class="keyword">struct</span> HeapNode)));</span><br><span class="line">    H-&gt;data[<span class="number">0</span>]=MaxData;<span class="comment">//INT_MAX</span></span><br><span class="line">    H-&gt;size=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ElementType t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;H-&gt;data[i];</span><br><span class="line">        <span class="keyword">if</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%9B%BE%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E5%9B%BE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="图的术语">图的术语</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017409.png"alt="image-20221105083921772" /><figcaption aria-hidden="true">image-20221105083921772</figcaption></figure><span id="more"></span><h1 id="图的存储结构">图的存储结构</h1><h2 id="邻接矩阵adjacency-matrix">邻接矩阵（Adjacency Matrix)</h2><h3 id="存储结构">存储结构</h3><blockquote><p>1、图是由<strong>顶点</strong>和<strong>边/弧</strong>两部分组成，合在一起比较困难，可以分为两个结构来存储</p><p>2、<strong>顶点</strong>因为不区分大小，主次，所以可以用一个<font color='red'><strong>一维数组</strong>来存储顶点</font>，记录各个顶点的信息</p><p><strong>边/弧</strong>是顶点和顶点的关系，用<strong>邻接矩阵</strong>来存储，表示各个顶点之间的邻接关系。是图的<strong><font color='red'>顺序存储结构</font></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;  <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><blockquote><p>注：<strong>VertexType</strong>和<strong>ArcType</strong>等价于<strong>ElementType</strong></p><ol type="1"><li><p><strong><code>ElementType</code></strong>既可以是<code>int</code>，<code>char</code>，<code>double</code>，<code>float</code>等，即</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> ElementType;    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ElementType ;      </span><br></pre></td></tr></table></figure></p><blockquote><p>注意typedef最后面的<font color='red'><strong>分号</strong></font></p></blockquote><p><strong><code>ElementType</code></strong>也可以是自定义的<strong>struct类型</strong>，eg：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;ElementType;</span><br></pre></td></tr></table></figure></p></li><li><p><code>MVNum</code>与<code>MaxInt</code>需要通过宏定义</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br></pre></td></tr></table></figure></p></li></ol></blockquote><hr /><hr /><h3 id="采用邻接矩阵创建无向网">采用邻接矩阵创建无向网</h3><blockquote><p>【算法步骤】 1、输入总顶点数和边数 2、依次输入点的信息存入到顶点表中3、初始化邻接矩阵，使每个权值初始化为极大值 4、构造邻接矩阵</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用邻接矩阵表示法创建无向网*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateUDN</span><span class="params">(Graph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入总顶点数和总边数</span></span><br><span class="line">cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输入顶点表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">cin &gt;&gt; G.vexs[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入邻接矩阵</span></span><br><span class="line"><span class="comment">    1. 初始化邻接矩阵，边的权值均置为极大值    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*法一：</span></span><br><span class="line"><span class="comment">for (int i = 0;i &lt; G.vexnum;++i)</span></span><br><span class="line"><span class="comment">for (int j = 0;j &lt; G.vexnum;++j)</span></span><br><span class="line"><span class="comment">G.arcs[i][j] = INT_MAX;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line">    <span class="built_in">fill</span>(G.arcs[<span class="number">0</span>],G.arc[<span class="number">0</span>] + G.vexnum * G.vexnum, INT_MAX);<span class="comment">//头文件：#include &lt;algorithm&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2. 输入边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.arcnum;++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输入一条边依附的顶点和权值        </span></span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line"><span class="comment">//确定两个顶点v1和v2在G中的位置        </span></span><br><span class="line">i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line"><span class="comment">//无向网 边&lt;v1,v2&gt;和&lt;v2,v1&gt;的权值均置为w        </span></span><br><span class="line">G.arcs[i][j] = G.arcs[j][i] = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在图中查找顶点的位置LocateVex()函数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(Graph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若在图中找到这个元素，则返回它的下标i,否则返回-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line"><span class="keyword">if</span> (u == G.vexs[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意">注意</h3><p>问：图的邻接矩阵，不相连的边用0还是无穷？</p><blockquote><p>——–那要看你的边权到底是拿来干嘛用的了</p><ul><li><p>若做路径搜索/最小生成树/最短距离，边权是路程长度，那不连通的理所应当用inf。</p></li><li><p>但若仅判断有无边，无关长度/路径/代价，无连接的时候自然可以用0</p></li></ul></blockquote><h4 id="无向有向图的邻接矩阵">（无向/有向）图的邻接矩阵</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017348.png"alt="image-20221101200143602" /><figcaption aria-hidden="true">image-20221101200143602</figcaption></figure><blockquote><p><strong><font color='blue'>无边用0表示</font></strong></p></blockquote><p>例如：<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017365.png"alt="image-20221101200513851" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017328.png"alt="image-20221101200537514" /><figcaption aria-hidden="true">image-20221101200537514</figcaption></figure><h4 id="有向无向网">（有向/无向）网</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017324.png"alt="image-20221101200729973" /><figcaption aria-hidden="true">image-20221101200729973</figcaption></figure><blockquote><p><strong><font color='blue'>无边用∞表示</font></strong></p></blockquote><p>例如</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017330.png"alt="image-20221101200823831" /><figcaption aria-hidden="true">image-20221101200823831</figcaption></figure><p>有向带权图（网）的邻接矩阵</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017882.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><table><thead><tr class="header"><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr class="odd"><td>A</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr class="even"><td>B</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>C</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr class="even"><td>D</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr class="odd"><td>E</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr class="even"><td>F</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id="邻接表adjacency-list">邻接表(Adjacency List）</h2><ol type="1"><li>邻接表是图的<strong><font color='red'>链式存储结构</font></strong></li><li>只存储图中<strong>存在的边</strong>的信息，对不相邻的顶点则不保留信息</li><li>对图中<strong>每个顶点v</strong>i建立一个<strong>带头结点的单链表</strong>，称为顶点表</li><li>把<strong>与vi相邻接的顶点</strong>放在这个链表中，一个单链表对应邻接矩阵中的一行，称为<strong>边链表</strong>。</li></ol><h3 id="存储结构-1">存储结构</h3><blockquote><p><strong>分三部分： 1、图的结构定义 2、顶点的头结点结构3、弧（边）的结点结构</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（即在AdjList[]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*说明*/</span></span><br><span class="line">Graph G;<span class="comment">//定义了邻接表表示的图G</span></span><br><span class="line">G.vexnum = <span class="number">5</span>;G.arcnum = <span class="number">6</span>;<span class="comment">//图G包含了5个顶点和6条边</span></span><br><span class="line">G.vexs[<span class="number">1</span>].data = <span class="string">&#x27;v2&#x27;</span>;<span class="comment">//图G中第2个顶点是v2</span></span><br><span class="line">p = G.vexs[<span class="number">1</span>].firstarc;<span class="comment">//指针p指向顶点v2的第一个边结点</span></span><br><span class="line">p-&gt;adjvex = <span class="number">4</span>;<span class="comment">//p指针所指边结点是到下标为4的结点的边</span></span><br></pre></td></tr></table></figure><h3 id="采用邻接表创建无向图">2，采用邻接表创建无向图</h3><blockquote><p>【算法步骤】</p><p>1，输入总顶点数和总边数</p><p>2，建立顶点表</p><ul><li>依次输入点的信息存入顶点表中</li><li>使每个表头结点的指针域初始化为<code>NULL</code></li></ul><p>3、创建邻接表</p><ul><li>依次输入每条边依附的两个顶点</li><li>确定这两个顶点的序号<code>i</code>和<code>j</code></li><li>将此边结点分别插入<code>vi</code>和<code>vj</code>对应的两个边链表的头部</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用邻接表表示法创建无向图*/</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(Graph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入顶点数和弧数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; G.vexs[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">G.vexs[i].firstarc = <span class="literal">NULL</span>;<span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.arcnum;k++)<span class="comment">//输入各边，构造邻接表，头插法</span></span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">i = <span class="built_in">LocateVex</span>(G, v1);j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">        p1=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));<span class="comment">//生成一个新的边结点*p1</span></span><br><span class="line">p1-&gt;adjvex = j;<span class="comment">//邻结点序号为j</span></span><br><span class="line">p1-&gt;nextarc = G.vexs[i].firstarc;<span class="comment">//firstarc为空，所以nextarc也指向空，即最后的一个结点</span></span><br><span class="line">G.vexs[i].firstarc = p1;   <span class="comment">//将新结点*p1插入到顶点vi的边表头部</span></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">p2 = <span class="keyword">new</span> ArcNode;<span class="comment">//生成一个新的边结点*p2</span></span><br><span class="line">p2-&gt;adjvex = i;</span><br><span class="line">p2-&gt;nextarc = G.vexs[j].firstarc;<span class="comment">//插入弧结点到单链表</span></span><br><span class="line">G.vexs[j].firstarc = p2;<span class="comment">//将新结点*p2插入到顶点vi的边表头部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1">注意</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017876.png"alt="image-20221101201335057" /><figcaption aria-hidden="true">image-20221101201335057</figcaption></figure><blockquote><ol type="1"><li>顶点表顺序存储，以便可以随机访问任一顶点的边链表</li><li>邻接表表示不唯一</li></ol></blockquote><h1 id="图的遍历">图的遍历</h1><h2 id="dfs">DFS</h2><h3 id="连通图">连通图</h3><h4 id="邻接矩阵"><strong>邻接矩阵</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接矩阵的存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//当前图的顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DFS遍历连通图*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从第v个顶点依次遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//访问标志符数组置为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; G.vexnum;w++)<span class="comment">//依次检查邻接矩阵v所在行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][w] != <span class="number">0</span> &amp;&amp; !visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//w是v的邻接点，如果w未被访问，则调用DFS_AM</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表"><strong><font color='red'>邻接表</font></strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span>* nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">OtherInfo info;<span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"></span><br><span class="line">==========================================================================================================================================</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*采用邻接表表示图的DFS*/</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">DFS</span>(ALGraph G, <span class="type">int</span> v)</span><br><span class="line">&#123;<span class="comment">//图G为邻接表类型，从第v个结点出发DFS图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//置访问标志符为true</span></span><br><span class="line"><span class="keyword">for</span>(ArcNode* p = G.vexs[v].firstarc; p ;p = p-&gt;nextarc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> w = p-&gt;adjvex;<span class="comment">//w是p邻接点的下标</span></span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//如果w未访问，则递归调用DFS_AL</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非连通图">非连通图</h3><h4 id="邻接矩阵-1">邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*非连通图G的深度优先搜索遍历*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//从第v个顶点依次遍历图G</span></span><br><span class="line"><span class="built_in">visit</span>(v);<span class="comment">//访问第v个顶点</span></span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//访问标志符数组置为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>;w &lt; G.vexnum; w++)<span class="comment">//依次检查邻接矩阵v所在行</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[v][w] &amp;&amp; !visited[w])</span><br><span class="line"><span class="built_in">DFS</span>(G, w);<span class="comment">//w是v的邻接点，如果w未被访问，则调用DFS_AM</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//访问标志数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line"><span class="built_in">DFS</span>(G, i);<span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表-1">邻接表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v)</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(ArcNode* p=G.vexs[v].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[j])</span><br><span class="line">            <span class="built_in">DFS</span>(G,j);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line">visited[i] = <span class="literal">false</span>;<span class="comment">//访问标志数组初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum; i++)</span><br><span class="line"><span class="keyword">if</span> (!visited[i])</span><br><span class="line"><span class="built_in">DFS</span>(G, i);<span class="comment">//对尚未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bfs">BFS</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017851.png"alt="image-20221003205935386" /><figcaption aria-hidden="true">image-20221003205935386</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017845.png"alt="image-20221003205948486" /><figcaption aria-hidden="true">image-20221003205948486</figcaption></figure><h3id="采用邻接矩阵表示的图的bfs"><strong>采用<font color='red'>邻接矩阵</font>表示的图的BFS:</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按广度优先非递归遍历连通图G*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">q.<span class="built_in">push</span>(v);<span class="comment">//v进队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();<span class="comment">//队头元素出队并置为u</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line"><span class="keyword">if</span> (arcs[u][w] &amp;&amp; !visited[w])<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;<span class="comment">//置访问标志数组分量为true</span></span><br><span class="line">q.<span class="built_in">push</span>(w);<span class="comment">//w进队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color='red'>入栈的同时访问</font></strong>，出栈时不必访问</p></blockquote><h3id="采用邻接表表示的图的bfs"><strong>采用<font color='red'>邻接表</font>表示的图的BFS:</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按广度优先非递归遍历连通图G*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">visit</span>(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//访问第v个顶点</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;<span class="comment">//辅助队列Q初始化，置空</span></span><br><span class="line">q.<span class="built_in">push</span>(v);<span class="comment">//v进队</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())<span class="comment">//队列非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();<span class="comment">//队头元素出队并置为u</span></span><br><span class="line"><span class="keyword">for</span> (ArcNode* p=G.vexs[u].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w=p-&gt;adjvex;<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;<span class="comment">//置访问标志数组分量为true</span></span><br><span class="line">q.<span class="built_in">push</span>(w);<span class="comment">//w进队</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用">作用</h2><p>DFS/BFS的作用</p><ul><li>求图的<strong><font color='red'>连通分量</font></strong></li><li>判断图是否连通</li></ul><h2 id="例题">例题</h2><h3 id="图1-列出连通集"><strong>06-图1 列出连通集</strong></h3><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式">输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式">输出格式:</h3><p>按照"{ <em>v</em>1 <em>v</em>2 ... *v**k*}"的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arc[<span class="number">105</span>][<span class="number">105</span>];<span class="type">int</span> visit[<span class="number">10</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arc[i][j]==<span class="number">1</span>&amp;&amp;visit[j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">            visit[j]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">visit[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arc[i][j]==<span class="number">1</span>&amp;&amp;visit[j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line"> visit[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> t1,t2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">arc[t1][t2]=arc[t2][t1]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//memset(visit,0,sizeof(visit));</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">visit[i]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#123; &quot;</span>);</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树">最小生成树</h1><ul><li><p>生成树：包含==<strong><font color='red'>连通图</font></strong>==中<strong><font color='blue'>所有顶点</font></strong>的<strong><font color='gree'>极小</font><font color='orange'>连通子图</font></strong></p></li><li><p>最小生成树（Minimum SpanningTree，简称MST）：带权<strong><font color='red'>连通图</font></strong>（网）的所有生成树中，<strong>各边权值之和最小</strong>的<strong>生成树</strong>称为<strong>最小生成树</strong></p></li></ul><blockquote><ol type="1"><li><p>只有<strong><font color='red'>连通图（无向）</font></strong>才存在最小生成树/生成树</p></li><li><p><strong><font color='red'>有向图不存在生成树</font></strong>的概念</p></li><li><p>连通图的生成树具有这样的特征，即生成树中<code>边的数量 = 顶点数 - 1</code>。</p></li></ol></blockquote><h2 id="prim算法加点法">prim算法(加点法)</h2><h3 id="算法概要">算法概要</h3><pre><code>**设G = （ V , E )是连通网，T是 G 上最小生成树中边的集合。U为G上最小生成树顶点的集合**</code></pre><p>（1）初始时，<strong>U={u<sub>0</sub>}（u<sub>0</sub>∈V）,T={}</strong></p><p>（2）找到满足<strong><code>min&#123; weight(ui,vi) |ui∈U，vi∈V-U&#125;</code></strong>的边<strong><code>(ui,vi)</code></strong>，并将该边加入T，同时<strong><code>vi</code></strong>并入U；</p><p>（3）重复步骤（2），直到<strong><code>U=V</code></strong>时算法结束</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017920.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="数据结构">数据结构</h3><p><strong>（1）图采用邻接矩阵来存储（2）一维数组closedeg,记录从U到V-U具有最小代价的边。</strong></p><blockquote><p><strong><code>closeedge[i]</code></strong>表示顶点==<strong><font color='blue'>v<sub>i</sub></font></strong>==到集合U的<strong><font color='gree'>最短边</font></strong>，其中</p><ul><li><strong><code>closeedge[i].adjvex</code></strong>表示依附于这条最小代价边的<strong><font color='blue'>另一个顶点</font></strong></li><li><strong><code>closeedge[i].lowcost</code></strong>表示最小边的权值<ul><li><strong><code>closeedge[i].lowcost = 0</code></strong> :表示顶点v<sub>i</sub> 已经在顶点集U中</li><li><strong><code>closeedge[i].lowcost != 0</code></strong> :表示顶点v<sub>i</sub> 还在顶点集V-U中</li></ul></li></ul><blockquote><p><strong><code>closeedge[i];</code></strong>有三种功能</p><ol type="1"><li>标记顶点 v<sub>i</sub>是否已经再顶点集U中</li><li>记录顶点v<sub>i</sub>到集合U-V的最小边（包含另一个顶点adjvex和边的权值）</li></ol></blockquote></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018349.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;  <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VerTexType adjvex;<span class="comment">//最小边的顶点</span></span><br><span class="line">ArcType lowcost;<span class="comment">//最小边的权值</span></span><br><span class="line">&#125;closedge[MAX_VERTEX_NUM];</span><br><span class="line"><span class="comment">//adjvex:依附于这条最小代价边的另一个顶点</span></span><br><span class="line"><span class="comment">//lowcost = 0 :表示顶点已经在顶点集U中</span></span><br><span class="line"><span class="comment">//lowcost != 0 :表示顶点i还在V-U中</span></span><br></pre></td></tr></table></figure><h3 id="算法实现">算法实现</h3><h4 id="邻接矩阵-2">邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(Graph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//无向网G以邻接矩阵存储，从顶点u出发构造G的最小生成树T,输出T的各条边</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">LocateVex</span>(G, u);<span class="comment">//起点位置，k为顶点u的下标</span></span><br><span class="line"><span class="comment">//对V-U的每个顶点vi,初始化closedge[i]    </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != k)</span><br><span class="line">        &#123;</span><br><span class="line">            closedge[i].adjvex = u;</span><br><span class="line">closedge[i].lowcost = G.arcs[k][i];</span><br><span class="line">          <span class="comment">//closedge[i]=&#123;G.vexs[k],G.arcs[k][i]&#125;  //closedge[i]=&#123; u, G.arcs[k][i]&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            closedge[i].lowcost = <span class="number">0</span>;<span class="comment">//初始，U = &#123; u &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; G.vexnum;++i)<span class="comment">//选择其余n-1个顶点，生成n-1条边（n = G.vexnum ）</span></span><br><span class="line">&#123;</span><br><span class="line">k = <span class="built_in">Min</span>(closedge);<span class="comment">//求出T的下一个结点：closedge[k]存有当前最小边(非零最小)</span></span><br><span class="line"><span class="built_in">printf</span>( G.vexs[k], closedge[k].adjvex );</span><br><span class="line">        closedge[k].lowcost=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//新顶点并入U后修改其他顶点最小边        </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line"><span class="keyword">if</span> (G.arcs[k][j] &lt; closedge[j].lowcost)</span><br><span class="line">&#123;</span><br><span class="line">closedge[j].adjvex = G.vexs[k];</span><br><span class="line">closedge[j].lowcost = G.arcs[k][j];</span><br><span class="line">             <span class="comment">//closedge[j]=&#123;G.vexs[k],G.arcs[k][j]&#125;  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表-2">邻接表</h4><h2 id="kruskal算法加边法">Kruskal算法（加边法）</h2><h3 id="算法思想">算法思想</h3><pre><code>            **设G = （ V , E )是连通网，T是 G 上最小生成树中边的集合。**</code></pre><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018480.png"alt="image-20221101171353307" /><figcaption aria-hidden="true">image-20221101171353307</figcaption></figure><h3 id="算法实现-1">算法实现</h3><h2 id="注意-2">注意</h2><blockquote><p>Dijkstra算法不能处理带有<strong><font color='red'>负权值</font></strong>的边</p></blockquote><ul><li>反例<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018368.webp"alt="img" /></li></ul><p>按照Prim算法，d（4）为2，路径为1，3，4</p><p>但显然路径是1，2，3，4时，d（4）才是最小，为1</p><ul><li>原因：Dijkstra算法是按照<strong><font color='red'>路径长度递增</font></strong>的次序，逐步产生各个顶点到源点最短路径的<strong><font color='red'>贪心</font></strong>算法，而当存在带负权值的边时，当把一个节点选入集合S时，即意味着已经找到了从源点到这个点的最短路径，但若存在负权边，就与这个前提矛盾，可能会出现得出的距离加上负权后比已经得到S中的最短路径还短。（无法回溯）</li></ul><blockquote><p>Floyd算法允许有<strong><font color='red'>带负权值的边</font></strong>，但不允许图中有<strong><font color='red'>包含带负权值回路</font></strong></p></blockquote><ul><li><p>这句话的意思并不是说“<strong>只要回路中存在负权值Floyd就不可以解决</strong>”。而是<strong>“组成这个回路的所有的边的权值之和如果为负，就无法解决，否则还是可以解决的”</strong></p></li><li><p>举例说明<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018397.png"alt="img" /></p></li></ul><p>这个图中右侧的三个边组成了一个回路，其中一边为负，但是三边权值之和为：<strong>2+3+(-1)=4&gt;0</strong>，此时Folyd算法是可以解决的</p><hr /><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018382.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>而第二张图同样右侧的三个边组成了一个回路，其中一边为负，但是三边权值之和为：<strong>1+1+(-3)=-2&lt;0</strong>，此时Folyd算法无法解决，因为每多走一遍回路总的路径就会-2 如果求路径长度最小值只需要一直走下去，进入了死循环。</p><hr /><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018390.png"alt="image-20221109220903123" /><figcaption aria-hidden="true">image-20221109220903123</figcaption></figure><h2 id="例题-1">例题</h2><p><strong>利用Prim算法、Kruskal算法构造最小生成树</strong> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018791.png"alt="在这里插入图片描述" /></p><p><strong>利用Prim算法、Kruskal算法构造最小生成树</strong> <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018797.png"alt="在这里插入图片描述" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018021.jpeg"alt="13311768599213125" /><figcaption aria-hidden="true">13311768599213125</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018029.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h1 id="拓扑排序">拓扑排序</h1><h2 id="定义">定义</h2><ol type="1"><li><p><strong><font color='red'>顶点活动网(AOV网</font></strong>，ActivityOn <strong><font color='red'>Vertex</font></strong>NetWork)：将==<strong><font color='oran'>顶点表示活动，边表示活动之间的关系</font></strong>==的有向网称为<strong>顶点活动网</strong>；</p></li><li><p>拓扑序列：若有向图G/AOV网的顶点序列v1,v2,…,vn满足下列条件：若在AOV网/有向图G中<strong>存在从vi到vj的路径</strong>，则在该<strong>（线性）序列</strong>中的<strong><font color='orange'>vi必定在vj之前</font></strong>，便称这个序列为一个拓扑序列。</p></li><li><p>求一个有向图拓扑序列的过程称为拓扑排序。</p></li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018070.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="算法概要-1">算法概要</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018246.png"alt="image-20221102100608149" /><figcaption aria-hidden="true">image-20221102100608149</figcaption></figure><p>拓扑排序<strong>可以判断一个有向图<font color='red'>是否存在环路</font></strong></p><ol type="1"><li>若网中<strong>所有顶点</strong>都在其的拓扑排序序列中，则该AOV网中必不存在环。</li><li>如果有向图存在环，则不能进行拓扑排序；反之，如果对一个有向图不能进行拓扑排序，则必定存在环。<ul><li>==<strong><font color='red'>有向图存在环路&lt; = =&gt;不能进行拓扑排序&lt; = = &gt;不存在关键路径</font></strong>==</li><li>==<strong><font color='red'>有向图不存在环路（即有向无环图）&lt; = =&gt;能进行拓扑排序&lt; = = &gt;存在关键路径</font></strong>==</li></ul></li></ol><h3 id="算法实现-2">算法实现</h3><h4 id="邻接矩阵-3">邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(Graph G,<span class="type">int</span> &amp;indegree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[i][j])</span><br><span class="line">            indegree[j]++;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G, <span class="type">int</span> topo[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图G采用邻接矩阵存储</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G,indegree);<span class="comment">//求出各顶点的入度存入数组indegree中</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;<span class="comment">//栈初始化为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line"><span class="keyword">if</span> (!indegree[i]) s.<span class="built_in">push</span>(i);<span class="comment">//入度为0者进栈</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始化为0</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())<span class="comment">//栈S非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();<span class="comment">//取栈顶顶点vi出栈</span></span><br><span class="line">topo[cnt++] = i;<span class="comment">//将vi保存在拓扑序列数组topo中    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p遍历vi的所有邻接点        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="keyword">if</span>(G.arcs[i][j] &amp;&amp; --indegree[j]==<span class="number">0</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (cnt &lt; G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//该有向图有回路</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="邻接表-3">邻接表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（在AdjList[MVNum]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindInDegree</span><span class="params">(Graph G,<span class="type">int</span> &amp;indegree[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">for</span>(ArcNode *p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">            indegree[p-&gt;adjvex]++;</span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopoSort</span><span class="params">(Graph G, <span class="type">int</span> topo[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储</span></span><br><span class="line">    <span class="built_in">FindInDegree</span>(G,indegree);<span class="comment">//求出各顶点的入度存入数组indegree中</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;<span class="comment">//栈初始化为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line"><span class="keyword">if</span> (!indegree[i]) s.<span class="built_in">push</span>(i);<span class="comment">//入度为0者进栈</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//对输出顶点计数，初始化为0</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>())<span class="comment">//栈S非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();<span class="comment">//取栈顶顶点vi出栈</span></span><br><span class="line">topo[cnt++] = i;<span class="comment">//将vi保存在拓扑序列数组topo中    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p遍历vi的所有邻接点        </span></span><br><span class="line">        <span class="keyword">for</span>(ArcNode *p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">        &#123;</span><br><span class="line">            k=p-&gt;adjvex;<span class="comment">//vk为vi的邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(--indegree[k]==<span class="number">0</span>)<span class="comment">//先把indegree[k]减1，若入度减为0，则入栈</span></span><br><span class="line">                s.<span class="built_in">push</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (cnt &lt; G.vexnum)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//该有向图有回路</span></span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="关键路径">关键路径</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018217.png"alt="image-20221109094330861" /><figcaption aria-hidden="true">image-20221109094330861</figcaption></figure><h3 id="邻接表-4">邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接表的存储定义*/</span></span><br><span class="line"><span class="comment">//弧的结点结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（在AdjList[MVNum]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"><span class="comment">//G为邻接表存储的有向网，输出G的各项关键活动    </span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CriticalPath</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用拓扑排序算法，使拓扑序列保存在topo中，若调用失败，则存在有向环</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">TopoSort</span>(G, topo)) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给每个事件的最早发生时间置初值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">ve[i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*按照拓扑次序求每个事件的最早发生时间*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)<span class="comment">//从前往后</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = topo[i];<span class="comment">//取得拓扑序列中的顶点序号j</span></span><br><span class="line"><span class="keyword">for</span>(ArcNode *p = G.vexs[j].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">&#123;    <span class="comment">//依次更新j的所有邻接顶点的最早发生时间</span></span><br><span class="line"><span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//k为邻接顶点的序号</span></span><br><span class="line"><span class="keyword">if</span> (ve[k] &lt; ve[j] + p-&gt;info)   <span class="comment">//更新顶点k的最早发生时间ve[k]</span></span><br><span class="line">ve[k] = ve[j] + p-&gt;info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给每个事件的最迟发生时间置初值为ve[n-1]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++) </span><br><span class="line">vl[i] = ve[G.vexnum - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*按逆拓扑次序求每个事件的最迟发生时间*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = G.vexnum - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//从后往前</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = topo[i];<span class="comment">//取得拓扑序列中的顶点序号k</span></span><br><span class="line"><span class="keyword">for</span>(p = G.vexs[j].firstarc; p ; p=p-&gt;nextarc)<span class="comment">//活动&lt;vj,vk&gt;</span></span><br><span class="line">&#123; <span class="comment">//依次更新j的所有邻接顶点的最迟发生时间</span></span><br><span class="line"><span class="type">int</span> k = p-&gt;adjvex;<span class="comment">//k为邻接顶点的序号</span></span><br><span class="line"><span class="keyword">if</span> (vl[j] &gt; vl[k] - p-&gt;info)   <span class="comment">//更新顶点j的最迟发生时间vl[j]</span></span><br><span class="line">vl[j] = vl[k] - p-&gt;info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*判断每一活动是否为关键活动*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line">&#123; <span class="comment">//每次循环针对vi为活动开始点的所有活动</span></span><br><span class="line"><span class="keyword">for</span> (p = G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = p-&gt;adjvex;<span class="comment">//j为i的邻接顶点的序号</span></span><br><span class="line"><span class="type">int</span> e = ve[i];<span class="comment">//计算活动&lt;vi,vj&gt;的最早开始时间</span></span><br><span class="line"><span class="type">int</span> l = vl[j] - p-&gt;info;<span class="comment">//计算活动&lt;vi,vj&gt;的最迟开始时间</span></span><br><span class="line"><span class="keyword">if</span> (e == l)<span class="comment">//若为关键活动，输出&lt;vi,vj&gt;</span></span><br><span class="line">cout &lt;&lt; G.vexs[i].data &lt;&lt; G.vexs[j].data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li><p>关键活动和拓扑排序是针对<strong><font color='blue'>有向无环图</font></strong>而言的</p></li><li><p>求<strong>关键路径</strong>之前<strong>首先要进行<font color='red'>拓朴排序</font></strong>，目的是</p><ul><li>判断该有向网是否存在环路；若存在环路，不存在关键路径，否则存在关键路径</li><li>给出相应的拓扑序列（工程能完成的某一个事件顺序，从最开始源点事件到汇点事件，包含所有事件的一条路径）</li></ul></li></ol></blockquote><h1 id="最短路径">最短路径</h1><h2 id="单源最短路径">单源最短路径</h2><h3 id="dijkstra算法">Dijkstra算法</h3><h4 id="算法概述">算法概述</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282017920.png"alt="1、初始化：" /><figcaption aria-hidden="true"><strong>1、初始化：</strong></figcaption></figure><blockquote><p>用Dijkstra算法求有向网G的<strong>v<sub>0</sub>顶点</strong>到<strong><font color='red'>其余各个顶点</font></strong>的最短路径</p></blockquote><h4 id="存储结构-2">存储结构</h4><p>1, 主要存储结构：<strong>邻接矩阵</strong>G(或者邻接表)</p><p>2 , 辅助存储结构：</p><p>（1）数组<strong><code>final[n]</code></strong>:记录相应顶点是否==<strong>已被确定</strong>最短距离==（是否在<strong>集合S</strong>中）</p><ul><li>初值：1：已确定；0:未确定</li></ul><p>（2）数组<strong><code>D[n]</code></strong>:记录<strong><font color='red'>源点V<sub>0</sub></font></strong>到相应顶点V<sub>i</sub> 路径的长度</p><ul><li>初值：如果V<sub>0</sub>到V<sub>i</sub><strong>有弧</strong>，则<code>D[i]</code>为弧上权值，否则为无穷</li></ul><p>（3）数组<strong><code>P[n]</code></strong>:记录相应顶点的<strong><font color='red'>前驱顶点</font></strong></p><ul><li>初值：如果v0到vi有弧，则<strong><code>P[i]</code></strong>为<strong><font color='gree'>v<sub>0</sub></font></strong>，否则为==<font color='blue'><strong>–1</strong></font>==</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*图的邻接矩阵存储表示法*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767  <span class="comment">//表示极大值，即无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ArcType ;<span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph G;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">final</span>[MVNum];</span><br><span class="line"><span class="type">int</span> P[MVNum];</span><br><span class="line"><span class="type">double</span> D[MVNum];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="算法实现-3">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*迪杰斯特拉算法*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//初始化辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">&#123; </span><br><span class="line">D[w] = G.arcs[v][w]; <span class="comment">//将v到各个终点的最短路径长度初始化       </span></span><br><span class="line"><span class="keyword">final</span>[w] = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (D[w] &lt; MaxInt)</span><br><span class="line">P[w] = v; <span class="comment">//v与w之间有弧，将w的前驱置为v</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P[w] = <span class="number">-1</span>; <span class="comment">//如果v与w之间无弧，则将w的前驱置为-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">1</span>; <span class="comment">//将v加入final</span></span><br><span class="line">P[v]= <span class="number">-1</span>; <span class="comment">//源点v的前驱结点设为-1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*循环n-1次，将图中所有顶点加入集合S中*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//找到当前离v距离最近的顶点j（即在D[]中寻找最小值）</span></span><br><span class="line"><span class="type">int</span> min = MaxInt;<span class="comment">//min辅组找最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">final</span>[j] == <span class="number">0</span> &amp;&amp; D[j] &lt; min)<span class="comment">//w顶点在V-S中</span></span><br><span class="line">&#123;</span><br><span class="line">min = D[j];                </span><br><span class="line">v = j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">1</span>; <span class="comment">//将v加入S集</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//更新从v出发到集合V-S上所有顶点的P[]和D[]        </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; w++) </span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; D[v] + G.arcs[v][w] &lt; D[w])</span><br><span class="line">&#123;</span><br><span class="line">D[w] = D[v] + G.arcs[v][w];<span class="comment">//更新D[w]</span></span><br><span class="line">P[w] = v;<span class="comment">//更改w的前驱为v</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">=====================================================================</span><br><span class="line">    </span><br><span class="line"><span class="comment">//输出v到各个顶点的最小距离和路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(i != v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n%f:%d&quot;</span>,D[i],i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> pre=P[i]; pre!= <span class="number">-1</span>; pre=P[pre])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;-%d&quot;</span>,pre);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多源最短路径">多源最短路径</h2><h3 id="floyd算法">Floyd算法</h3><blockquote><p>求有向网G中<strong><font color='red'>任意两个顶点V<sub>i</sub>，V<sub>j</sub>之间</font></strong>/ <strong><font color='red'>所有顶点之间</font></strong>的最短路径</p></blockquote><h4 id="算法思想-1">算法思想</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018452.png"alt="image-20221012132457324" /><figcaption aria-hidden="true">image-20221012132457324</figcaption></figure><h4 id="算法实例分析">算法实例分析</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018694.png"alt="image-20221012132532780" /><figcaption aria-hidden="true">image-20221012132532780</figcaption></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018686.png" alt="image-20221012132638042" style="zoom:60%;" /></p><blockquote><ol type="1"><li>表中<strong><font color='red'>最多只有三个字母</font></strong>，<strong>最左最右是固定的，中间的那个字母是动态调整的</strong></li><li>只有<strong><font color='orange'>两个字母表示直达</font></strong>，对角线一定是两个相同的字母00</li></ol></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018576.png"alt="image-20221012132812283" /><figcaption aria-hidden="true">image-20221012132812283</figcaption></figure><h4 id="算法要点迭代">算法要点—迭代</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018828.png"alt="image-20221012132930217" /><figcaption aria-hidden="true">image-20221012132930217</figcaption></figure><h4 id="存储结构-3">存储结构</h4><p>1, 主要存储结构：邻接矩阵G</p><p>2 , 辅助存储结构：</p><p>（1）数组<strong><code>D[i][j]</code></strong>:记录==<strong>当前</strong>==<strong><font color='red'>从【顶点i】到 【顶点j】 的最短路径长度</font></strong></p><ul><li>初值：<strong><code>D[i][j]=G.arc[i][j];</code></strong></li></ul><p>（2）数组<strong><code>P[i][j]</code></strong>:记录==<strong>顶点j</strong>==的（到顶点i这条路径）<strong><font color='red'>前驱顶点</font></strong></p><ul><li>初值：如果vi到vj有弧，则<strong><code>P[i][j]=i</code></strong>，否则为<font color='gree'>-1</font></li></ul><h4 id="算法实现-4">算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShortestPath_Floyed</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//初始化各结点之间的已知路径及距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line">D[i][j] = G.arcs[i][j];</span><br><span class="line"><span class="keyword">if</span> (D[i][j] &lt; MaxInt)</span><br><span class="line">P[i][j] = i;<span class="comment">//i和j之间有弧，将j的前驱置为i</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P[i][j] = <span class="number">-1</span>;<span class="comment">//i和j之间无弧，则将j的前驱置为-1</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Dk依次迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; G.vexnum;k++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; G.vexnum;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; G.vexnum;j++)</span><br><span class="line"><span class="keyword">if</span> (D[i][k] + D[k][j] &lt; D[i][j])</span><br><span class="line">&#123; <span class="comment">// 从i经过k到j的一条路径更短</span></span><br><span class="line">D[i][j] = D[i][k] + D[k][j];<span class="comment">//更新D[i][j]</span></span><br><span class="line">P[i][j] = k;<span class="comment">//更改j的前驱为k，记录路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：==<strong>不可以</strong>==先循环<code>i</code>和<code>j</code>，把<code>k</code>放到最内层循环</p><ul><li>可以把k想象成一个阶段，即k为中转点时，枚举 i，j，通过k的变动不停地松弛i、j之间的最短路。因为i、j可以重复遍历，但k不能。如果k在内层循环，程序无法进行多次的松弛操作，也就是程序出错的原因。</li></ul></blockquote><h1 id="例题-2"><a id="liti">例题</a></h1><h2 id="简单路径">简单路径</h2><p>​自选存储结构，编写一算法判断无向图中任意给定的两个顶点间是否存在一条长度等于k的简单路径（即不含回路的路径）</p><h3 id="存储结构-4">存储结构</h3><p>采用邻接表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大的顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指的顶点的位置（即在AdjList[]中的下标）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    InfoType info;<span class="comment">//和边相关的信息,如权重</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode* firstarc;<span class="comment">//指向第一条依附该顶点的边</span></span><br><span class="line">&#125;VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">//AdjList v相当于VNode v[MVNum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义（邻接表）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">AdjList vexs;<span class="comment">//vertices是vertex的复数</span></span><br><span class="line"><span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309282018073.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>有利用<strong><font color='red'>DFS</font></strong>的思想</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"><span class="comment">//出发点为i，终点为j，长度为k </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exist_path_len</span><span class="params">(Graph G,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( k&lt;<span class="number">0</span> )<span class="comment">//路径为负显然不成立</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j &amp;&amp; k==<span class="number">0</span>)<span class="comment">//递归终止条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    visited[i]=<span class="number">1</span>;</span><br><span class="line"> <span class="comment">/*寻找i的邻接点是否存在到j的长度为k-1的路径*/</span>     </span><br><span class="line">    <span class="keyword">for</span>( ArcNode* p=G.vertices[i].firstarc; p ; p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[t])</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist_path_len</span>(G, t, j, k - p-&gt;info))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    visited[i]=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">/*如果沿某个方向不存在长度为length的路径,</span></span><br><span class="line"><span class="comment">  沿这个方向 经过的顶点 仍可能存在于沿其他方向的目标路径中,</span></span><br><span class="line"><span class="comment">  因此要恢复成未访问*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="两节点间是否存在路径">两节点间是否存在路径</h2><p>​ 试写一算法，判断以邻接表方式存储的有向图中是否存在由顶点 <spanclass="math inline">\(V_i\)</span> 到顶点 <spanclass="math inline">\(V_j\)</span> 的路径 <spanclass="math inline">\((i≠j)\)</span>。注意：算法中涉及的图的基本操作必须在存储结构上实现。</p><h3 id="存储结构-5">存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;</span><br><span class="line">    InfoType info;</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span></span><br><span class="line">&#123;</span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode * firstarc;</span><br><span class="line">&#125;VNode,*AdjList[MVNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    AdjList vexs;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;Graph;</span><br></pre></td></tr></table></figure><h3 id="算法">算法</h3><h4 id="法一">法一</h4><p>​ 在有向图中，判断顶点 <span class="math inline">\(V_i\)</span> 和顶点<span class="math inline">\(V_j\)</span>间是否有路径，可采用遍历的方法，从顶点 <spanclass="math inline">\(V_i\)</span> 出发，不论是 <spanclass="math inline">\(dfs\)</span> 还是 <spanclass="math inline">\(bfs\)</span> ，在未退出 <spanclass="math inline">\(dfs\)</span> 或 <spanclass="math inline">\(bfs\)</span> 前，若访问到 <spanclass="math inline">\(V_j\)</span>，则说明有通路，否则无通路。设一全程变量 <spanclass="math inline">\(flag\)</span>。初始化为 0，若有通路，则 <spanclass="math inline">\(flag=1\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> visited[], <span class="type">int</span> &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visited[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ArcNode *p = G.vertices[i].firstarc;</span><br><span class="line"><span class="keyword">while</span>(!flag &amp;&amp; p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="type">int</span> k = p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(!visited[k])</span><br><span class="line"><span class="built_in">DFS</span>(G, k, j, visited, flag);</span><br><span class="line">p = p-&gt;nextarc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Path</span><span class="params">(ALGraph G, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> visited[MVNum];<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">1</span>; m &lt;= G.vexnum; m++)</span><br><span class="line">visited[m] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">DFS</span>(G, i, j, visited, flag);</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二">法二</h4><p>从<strong><font color='red'>V<sub>i</sub></font></strong>开始进行DFS/BFS。</p><ul><li><p>若在此过程中访问到V<sub>j</sub>，则说明存在，返回1；</p></li><li><p>若遍历结束，则说明未找到，返回0；</p></li></ul><blockquote><p>改编DFS，将<strong><code>visit（i）</code></strong>改为判断<strong><code>if(i==j)  return 1;</code></strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MVNum];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exist_path</span><span class="params">(Graph G,<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visited[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==j)<span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ArcNode*p=G.vexs[i].firstarc; p ;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[k])</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">exist_path</span>(G,k,j))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​利用了DFS/BFS可用于求<strong><font color='red'>连通分量</font></strong>（任意两个顶点间均存在路径，均可达）的作用</p><h2 id="欧拉回路">欧拉回路</h2><p>在一个图中，存在这样一条路径，它经过每条边恰好一次，并在最后一个顶点时会到第一个顶点，这样的路径叫做<strong>欧拉回路</strong>。给无向图，编写程序输出是否存在欧拉回路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="克隆图"><a id="kelong"><ahref="https://leetcode.cn/problems/clone-graph/">克隆图</a></a></h2><p>​ 给你无向 <strong><ahref="https://baike.baidu.com/item/连通图/6460995?fr=aladdin">连通</a></strong>图中一个节点的引用，请你返回该图的 <ahref="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值<code>val</code>（<code>int</code>）和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>​ 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为1（<code>val = 1</code>），第二个节点值为2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。<strong>邻接列表</strong>是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。给定节点将始终是图中的第一个节点（值为1）。你必须将 <strong>给定节点的拷贝</strong>作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031014453.png" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031014420.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031014413.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol type="1"><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code>都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<ahref="https://baike.baidu.com/item/简单图/1680528?fr=aladdin">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em>的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是<strong>连通图</strong>，你可以从给定节点访问到所有节点。</li></ol><p><strong>分析：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403031019694.png" alt="image-20240303101924546" style="zoom:33%;" /></p><ul><li>首先<strong>拷贝顶点</strong>，使用<code>dfs</code>遍历图，并用<strong>hash表</strong> 记录原顶点与新顶点的映射关系，避免重复拷贝</li><li>然后拷贝边，我们只需要遍历一遍原始顶点，把它们的相邻顶点通过哈希表转换成拷贝顶点，并添加到当前拷贝顶点的邻居列表就可以了</li></ul><p><ahref="https://www.bilibili.com/video/BV1H34y1E7Ao/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】133. 克隆图 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; h;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        h[node] = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : node-&gt;neighbors)</span><br><span class="line">            <span class="keyword">if</span> (!h[next])</span><br><span class="line">                <span class="built_in">dfs</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* 拷贝顶点 */</span></span><br><span class="line">        <span class="built_in">dfs</span>(node);</span><br><span class="line">        <span class="comment">/* 拷贝边 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [from, to] : h)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> next : from-&gt;neighbors)</span><br><span class="line">                to-&gt;neighbors.<span class="built_in">push_back</span>(h[next]);</span><br><span class="line">        <span class="keyword">return</span> h[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同类型<ahref="D:\downloads\hexo\blog\source_posts\数据结构【线性表】.md#shenkaobei">链表的深拷贝</a></p></blockquote><h2 id="岛屿数量"><ahref="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></h2><p>给你一个由 <code>'1'</code>（陆地）和<code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 网格中上下左右四个方向[0,1],[1,0],[0,-1],[-1,0],</span></span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir_y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 或者vector&lt;pair&lt;int,int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0,1&#125;&#125;;</span></span><br><span class="line">    <span class="comment">// 或者vector&lt;vector&lt;int&gt;&gt; dd = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;grid, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;             <span class="comment">// 标记当前网格为已访问,相当于visited的作用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">// 依次检查grid[x][y]的4个临界网格是否访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; grid[tx][ty] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(grid, tx, ty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; x++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; m; y++)</span><br><span class="line">                <span class="keyword">if</span> (grid[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="腐烂的橘子"><ahref="https://leetcode.cn/problems/rotting-oranges/">腐烂的橘子</a></h2><p>​ 在给定的 <code>m x n</code> 网格 <code>grid</code>中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong>的新鲜橘子都会腐烂。返回<em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回<code>-1</code></em> 。</p><p><strong>示例 1：</strong></p><p><strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032222594.png"alt="img" /></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>​ 为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 cnt表示当前网格中的新鲜橘子数，先遍历统计新鲜数量和腐烂节点，BFS的时候如果有新鲜橘子被腐烂，则 cnt-=1 ，最后搜索结束时如果 cnt 大于 0，说明有新鲜橘子没被腐烂，返回 -1，否则返回所有新鲜橘子被腐烂的时间的最大值即可.</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m, fresh_cnt = <span class="number">0</span>, round = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir_y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    fresh_cnt++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">func</span>(grid);</span><br><span class="line">        <span class="keyword">while</span> (fresh_cnt &gt; <span class="number">0</span> &amp;&amp; !q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            round++;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tx = t.first + dir_x[i], ty = t.second + dir_y[i];</span><br><span class="line">                    <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp;</span><br><span class="line">                        grid[tx][ty] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        grid[tx][ty] = <span class="number">2</span>;</span><br><span class="line">                        fresh_cnt--;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;tx, ty&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fresh_cnt == <span class="number">0</span> ? round : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单词搜索"><ahref="https://leetcode.cn/problems/word-search/">单词搜索</a></h2><p>​ 给定一个 <code>m x n</code> 二维字符网格 <code>board</code>和一个字符串单词 <code>word</code> 。如果 <code>word</code>存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code>。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032232283.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032232317.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403032232329.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>​用DFS来做，我们可以<strong>举枚矩阵的每个位置作为单词的起点</strong>，只要能够找到对应单词，就直接返回True。具体在每次搜索中可以依次尝试相邻未访问格子的字母，只要能和单词的对应位置匹配，就继续线下搜索。<ahref="https://www.bilibili.com/video/BV16T4y1i76C/?spm_id_from=333.788&amp;vd_source=783e918d3ef4b11b94236a4cd8a51f23">【LeetCode每日一题】79. 单词搜索 | 手写图解版思路 +代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码</strong></p><p>​ 原版：空间复杂度<strong>O(nm)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dir_y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> id, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != word[id])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (id == word.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; !visited[tx][ty])</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, id + <span class="number">1</span>, tx, ty))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        visited.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改版：空间复杂度<strong>O(1)</strong></p><p>​这里有一点可以优化的地方。正常情况下，我们需要一个和矩阵一样大的数组visited来记录格子的访问状态。在这道题中指出，<strong>每个格子的字符仅由大小写英文字母组成。那么我们就可以用原始数组来记录格子的访问状态。</strong>比如每次都把选择后的格子标记为特殊符号（比如<code>!</code>）。那么在当前的搜索过程中，就不会再访问到这个格子了，这样就把空间复杂度从<strong>O(MN)</strong>优化到了<strong>O(1)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dir_y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> id, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != word[id])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (id == word.<span class="built_in">length</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span> t = board[x][y]; <span class="comment">// 记录原值，用于还原</span></span><br><span class="line">        board[x][y] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tx = x + dir_x[i], ty = y + dir_y[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; m &amp;&amp; board[tx][ty] != <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, id + <span class="number">1</span>, tx, ty))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = t; <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【栈】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%88%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%88%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一顺序栈">一：顺序栈</h1><h2 id="表示">表示</h2><ul><li><p>因为栈底位置是固定不变的，所以可以将栈底位置设置在数组的任何一个端点；</p></li><li><p>栈顶位置是随着进栈和退栈操作而变化的，故需要一个变量top来指示当前栈顶的位置，通常称top为<strong><font color='red'>栈顶指针</font></strong>。</p></li></ul><blockquote><p><strong><font color='red'>栈顶指针top</font></strong>指向<strong><font color='blue'>栈顶元素的下一个位置</font></strong></p></blockquote><span id="more"></span><h2 id="顺序栈的定义">顺序栈的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* base;<span class="comment">//栈底指针</span></span><br><span class="line">ElementType* top;<span class="comment">//栈顶指针</span></span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//可使用的最大容量</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line">Stack S;<span class="comment">//定义顺序栈</span></span><br><span class="line">S.stacksize = s;<span class="comment">//栈的大小</span></span><br><span class="line">S.base == S.top;<span class="comment">//空栈</span></span><br><span class="line">S.top - S.base == stacksize;<span class="comment">//满栈</span></span><br></pre></td></tr></table></figure><h2 id="顺序栈初始化">顺序栈初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.base = <span class="keyword">new</span> SElemType[MAXSIZE];<span class="comment">//分配空间</span></span><br><span class="line"><span class="keyword">if</span> (!S.base) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//分配失败，返回错误</span></span><br><span class="line">S.top = S.base;<span class="comment">//栈顶指针初始化为栈底指针</span></span><br><span class="line">S.stacksize = MAXSIZE;<span class="comment">//初始化栈的最大容量</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><font color='red'>exit是c++程序的退出函数</font></strong>，声明为<code>void exit(int value)</code>，其功能是退出当前的程序，并将参数value返回主调进程</li><li><strong><font color='red'>OVERFLOW为math.h的一个宏定义</font></strong>，其值为3。含义为运算过程中出现了上溢，运算结果超出了运算变量所能存储的范围。</li><li>所以，<code>exit(OVERFLOW)</code>的含义就是，退出程序，并返回OVERFLOW的值给主调进程。其标准的使用范围为，当程序运算出现上溢时，退出程序并报错给主调进程。</li></ul></blockquote><h2 id="顺序栈入栈">顺序栈入栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855471.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Stack&amp; S, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top - S.base == S.stacksize)<span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*S.top++ = e;<span class="comment">//新元素e压入栈顶，同时将栈顶指针+1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序栈出栈">顺序栈出栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855473.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><blockquote><p>算法思想 1、判断是否栈空，若空则出错 2、栈顶指针-13、获取栈顶元素e（<strong><font color='red'>引用&amp;返回</font></strong>）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack&amp; S, ElementType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//栈空报错</span></span><br><span class="line">e = *--S.top;<span class="comment">//获取栈顶元素e，同时将栈顶指针-1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取顺序栈栈顶元素">取顺序栈栈顶元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">GetTop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top != S.base)<span class="comment">//栈非空</span></span><br><span class="line"><span class="keyword">return</span> *(S.top - <span class="number">1</span>);<span class="comment">//返回栈顶元素的值</span></span><br><span class="line">                        <span class="comment">//栈顶指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出栈内容">输出栈内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut_SqS</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == S.base)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空栈！\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (ElementType* p = S.top - <span class="number">1</span> ; p &gt;= S.base ; p--)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二链栈">二：链栈</h1><blockquote><p>1、链式存储方式表示的栈称链栈 2、运算受限的单链表3、<strong><font color='red'>链表的头结点就是栈顶</font></strong>4、<strong><font color='blue'>插入与删除仅在栈顶执行</font></strong></p></blockquote><h2 id="链栈的存储结构">链栈的存储结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*Stack;</span><br><span class="line"></span><br><span class="line">Stack S;</span><br></pre></td></tr></table></figure><h2 id="链栈的初始化">链栈的初始化</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855474.png"alt="image-20221110233126960" /><figcaption aria-hidden="true">image-20221110233126960</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IniStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S=(Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!S)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的入栈">链栈的入栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855475.png"alt="image-20221110235147314" /><figcaption aria-hidden="true">image-20221110235147314</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(Stack&amp; S, ElementType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> Node;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="comment">//头插法    </span></span><br><span class="line">p-&gt;next = S-&gt;next;</span><br><span class="line">S-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链栈的出栈">链栈的出栈</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855476.png"alt="image-20221110235341367" /><figcaption aria-hidden="true">image-20221110235341367</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack&amp; S, ElementType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> ERROR;<span class="comment">//栈空</span></span><br><span class="line">    p = S-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">    </span><br><span class="line">S-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取链栈栈顶元素">取链栈栈顶元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">GetTop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = S-&gt;next;</span><br><span class="line"><span class="keyword">if</span> ( p != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出链栈的内容">输出链栈的内容</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* p = S-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空栈！&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题">例题</h1><h2 id="例一">例一</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290854572.png"alt="image-20230929085414412" /><figcaption aria-hidden="true">image-20230929085414412</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsReverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断输入的字符串中‘&amp;’前后两部分是否为逆串，是则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;s;<span class="type">char</span> c,t;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        s.<span class="built_in">push</span>(c);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t!=c)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>判断是否为逆序通常需要使用<strong><code>stack</code></strong></li><li>注意<strong>第9，第13行</strong>。</li></ol></blockquote><h2 id="例二数制转换">例二：数制转换</h2><p>基于栈设计一个算法，将一个十进制整数d转化为相应的r进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=d%r;</span><br><span class="line">        s.<span class="built_in">push</span>(t);</span><br><span class="line">        d/=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例三回文数的判断">例三：回文数的判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;    stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        t=n%<span class="number">10</span>;</span><br><span class="line">        s.<span class="built_in">push</span>(t);</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">       t=s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例四">例四</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855477.png"alt="image-20221110223733088" /><figcaption aria-hidden="true">image-20221110223733088</figcaption></figure><h3 id="分析">分析</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855478.png"alt="image-20221111125540175" /><figcaption aria-hidden="true">image-20221111125540175</figcaption></figure><h3 id="存储结构">存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementType v[m];</span><br><span class="line">    <span class="type">int</span> top[<span class="number">2</span>];<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure><h3 id="建栈">建栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(Stack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.top[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    S.top[<span class="number">1</span>]=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈">入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Stack &amp;S,ElementType x,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top[<span class="number">1</span>]-S.top[<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:S.v[++S.top[<span class="number">0</span>]]=x;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: S.v[--S.top[<span class="number">1</span>]]=x;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈">出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack &amp;S, ElementType &amp;x, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(S.top[<span class="number">0</span>]==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x=S.v[S.top[<span class="number">0</span>]--];</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(S.top[<span class="number">1</span>]==m)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            x=S.v[S.top[<span class="number">1</span>]++];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例五表达式求值">例五：表达式求值</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855479.png"alt="image-20221111000921743" /><figcaption aria-hidden="true">image-20221111000921743</figcaption></figure><h3 id="分析-1">分析</h3><hr /><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855480.png"alt="image-20221111125043545" /><figcaption aria-hidden="true">image-20221111125043545</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855481.png"alt="image-20221111125349605" /><figcaption aria-hidden="true">image-20221111125349605</figcaption></figure><h3 id="例五括号匹配">例五：括号匹配</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855482.png"alt="image-20221111110712016" /><figcaption aria-hidden="true">image-20221111110712016</figcaption></figure><h4 id="分析-2">分析</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855483.png"alt="image-20221111110734311" /><figcaption aria-hidden="true">image-20221111110734311</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855484.png"alt="image-20221111110748683" /><figcaption aria-hidden="true">image-20221111110748683</figcaption></figure><h4 id="算法">算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;stack&lt;<span class="type">char</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">getchar</span>())!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;(&#x27;</span> || ch==<span class="string">&#x27;[&#x27;</span> || ch==<span class="string">&#x27;&#123;&#x27;</span> ):</span><br><span class="line">                s.<span class="built_in">push</span>(ch);<span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;)&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(t!=<span class="string">&#x27;(&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;[&#x27;</span> ):</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(t!=<span class="string">&#x27;]&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">case</span>( ch==<span class="string">&#x27;&#123;&#x27;</span> ):</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> t=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">if</span>(t!=<span class="string">&#x27;&#125;&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例六迷宫求解">例六：迷宫求解</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290855485.png"alt="image-20221211163004047" /><figcaption aria-hidden="true">image-20221211163004047</figcaption></figure><p><ahref="D:\Document\已结课资料\数据结构\老师课件\第3章%20栈和队列22.pdf">栈和队列</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【查找】</title>
      <link href="/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91/"/>
      <url>/2023/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%9F%A5%E6%89%BE%E3%80%91/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290957892.png"alt="image-20230929095705501" /><figcaption aria-hidden="true">image-20230929095705501</figcaption></figure><span id="more"></span><h1 id="静态查找表">静态查找表</h1><p><font color='red'><strong>Static SearchTable</strong></font>：不涉及<strong><font color='blue'>插入和删除</font></strong>操作</p><h2 id="顺序查找">顺序查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素类型的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">keyType key;<span class="comment">//关键字域</span></span><br><span class="line">InfoType otherInfo;<span class="comment">//其他域</span></span><br><span class="line">&#125;ElementType;</span><br><span class="line"><span class="comment">//静态查找表的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElememtType* R;<span class="comment">//数据元素存储空间基地址，建表时按实际长度分配，0号单元留空</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//表长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line">SSTable ST;<span class="comment">//定义顺序表ST</span></span><br><span class="line"><span class="comment">//设元素从ST.R[1]开始向后顺序存放，ST.R[0]不用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, keyType key)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ST.length;i &gt;= <span class="number">1</span>;--i)</span><br><span class="line"><span class="keyword">if</span> (ST.R[i].key == key)</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//从后往前找</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>ElememtType* R;</code></strong></p><p>数据元素存储空间<strong>基地址</strong>，建表时按<strong>实际长度（length）</strong>malloc分配，<strong><font color='red'>0号单元留空</font></strong></p></blockquote><h3 id="改进">改进</h3><p>==改进==：把待查<strong>关键字key</strong>存入<strong><font color='red'>表头(0号单元)</font></strong>，充当<strong><font color='blue'>"哨兵“</font></strong>，从后向前逐个比较时，可<strong>免去</strong>查找过程中每一步都要检测是否查找完毕.<imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949384.png"alt="在这里插入图片描述" />加快速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, keyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//若成功返回其位置信息，否找返回0</span></span><br><span class="line">ST.R[<span class="number">0</span>].key = key;<span class="comment">//哨兵</span></span><br><span class="line"><span class="keyword">for</span> (i = ST.length;ST.R[i].key != key;--i)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="comment">//不用for (int i = ST.length;i &gt;= 1;--i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引查找">索引查找</h2><h3 id="存储要求">存储要求</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949385.png"alt="image-20221025123336315" /><figcaption aria-hidden="true">image-20221025123336315</figcaption></figure><h2 id="折半查找">折半查找</h2><blockquote><p><strong>折半查找</strong>又称<strong>二分查找</strong>，前提条件是<strong><font color='red'>顺序存储且数组元素有序</font></strong></p></blockquote><h3 id="算法描述">算法描述</h3><p>设表长为<code>n</code>，<code>low</code>，<code>high</code>，<code>mid</code>分别指向待查元素所在区间的上界、下界和中点，key为要查找的值。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949386.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="非递归">非递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素类型的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">keyType key;<span class="comment">//关键字域</span></span><br><span class="line">InfoType otherInfo;<span class="comment">//其他域</span></span><br><span class="line">&#125;ElementType;</span><br><span class="line"><span class="comment">//顺序表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElementType* R;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若找到，则函数值为该元素在表中的位置，否则为0</span></span><br><span class="line">low = <span class="number">1</span>;high = ST.length;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (key == ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key)</span><br><span class="line">high = mid - <span class="number">1</span>;<span class="comment">//前一子表查找</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;<span class="comment">//后一子表查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表中不存在待查元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>18行注意是==low<strong><code>&lt;=</code></strong>high==</p></blockquote><h3 id="递归">递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType* R;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin_re</span><span class="params">(SSTable ST, KeyType key,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//若找到，则函数值为该元素在表中的位置，否则为0</span></span><br><span class="line"><span class="keyword">if</span> (low &gt; high)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//表中不存在待查元素</span></span><br><span class="line"><span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (key == ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Search_Bin_re</span>(ST, key, low, mid - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Search_Bin_re</span>(ST, key, mid + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="折半查找判定树的画法">折半查找判定树的画法</h2><h3 id="思路分析">思路分析：</h3><p>​ 在计算mid值时，使用的时mid=（low+high）/2。这里由于mid为int类型，自动默认为向下取整，因此对于一个长度为n序列进行划分之后的序列为<strong><code>（0，1，2，……，mid-1）mid（mid+1，mid+2，……n-1）</code></strong>，此时出现两种情况：</p><ul><li><p>左子序列长==右子序列长 （n=2k+1 k=0，1，2，……）</p></li><li><p>左子序列长==右子序列长-1 （n=2k k=1，2，3，……）</p></li></ul><p>因此可以得知，<strong><font color='purple'>折半查找</font></strong>的二叉判定树对于所有结点，<strong><font color='red'>右子树结点个数&gt;= 左子树结点个数。</font></strong>即：</p><ul><li>若某序列总长n为奇数，左右子树结点个数相等；</li><li>若某序列总长n为偶数，左字数结点个数=右子树结点个数-1.</li></ul><blockquote><p>换句话说，对判定树中所有结点都有： （右子树结点数 - 左子树结点数 ==1）||（右子树结点数 — 左子树结点数 == 0）</p></blockquote><h3 id="步骤">步骤</h3><p><strong>由此给定某个序列，构建折半查找判定树方法如下三步：</strong></p><ol type="1"><li>按照结点总数先画出<strong><font color='blue'>最大的满二叉树</font></strong>结构，并计算剩余几个结点。</li><li>将剩余结点按照上述的规律依次填入最底层即为二叉判定树的树形。</li><li>将给定序列依次按照<strong><font color='red'>中序遍历</font></strong>顺序填入各个结点。</li></ol><blockquote><p><strong><font color='blue'>折半查找判定树</font></strong>也是<strong><font color='red'>二叉查找树</font></strong>，故<strong>中序遍历即为递增序列</strong></p></blockquote><h3 id="例一">例一</h3><p>画出（2，5，7，10，14，15，18，23，35，41，52）的折半查找判定树。</p><blockquote><p>折半查找的前提就是<strong>序列有序</strong></p></blockquote><ol type="1"><li>序列总长度为n=11&gt;2^3-1即二叉判定树为4层，前三层为满二叉树结构，剩余4个结点。</li></ol><p>​ 先画出前三层结构。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949387.png" alt="img" style="zoom:50%;" /></p><ol start="2" type="1"><li></li></ol><p>1）第一个结点。a的左右子树结点个数相等，所以新的结点应加入a的右子树；再看a的右子树，c的左右子树结点个数相等，所以新结点应加入c的右子树；再看c的右子树，g的左右子树结点个数相等，所以新结点应加入g的右子树；如图</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949388.png" alt="img" style="zoom:50%;" /></p><p>2）第二个结点。a的左子树结点数-右子树结点数=-1，所以新结点应加入a的左子树（若加入右子树，对于a来说左右子树结点之差=-2，不符合规律）；再看a的左子树，b的左右子树结点个数相等，所以新结点应加入b的右子树；再看b的右子树，e的左右子树结点个数相等，所以新结点应加入e的右子树。如图</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949389.png" alt="img" style="zoom:50%;" /></p><p>3）同理分析，第三个结点应加在如图位置。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949390.png" alt="img" style="zoom:50%;" /></p><p>4）第四个结点加在如图位置。</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949391.png" alt="img" style="zoom: 67%;" /></p><p>得到最终的树形如上图。（字母编号不唯一，但后面中序遍历结果会不同）</p><p>3.该二叉树的<strong><font color='red'>中序遍历</font></strong>顺序为dkbeiafjcgh，分别对应2，5，7，10，14，15，18，23，35，41，52。因此将序列一一对应填入树中，即</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949392.png" alt="img" style="zoom:67%;" /></p><p>该树即为此序列的二叉判定树。</p><h4 id="总结">总结</h4><p>做题过程中熟练使用此方法比通过算法模拟来推断二叉判定树的速度要快许多倍。</p><p>在平时做题过程中，涉及到需要具体画出二叉判定树的题目，往往结点个数（序列长度）不超过2^4-1=15个，即一般为高度不超过4的树，因此可以在练习时将结点个数8-14的所有树形画几遍，就可以很熟练的掌握这个方法。</p><h3 id="例二">例二</h3><p>一个递增有序表为R[0..11]，采用折半查找方法进行查找，在一次不成功查找中，以下（）是不可能的记录比较序列。</p><p>A.R[5]、R[8]、R[10]</p><p>B.R[5]、R[8]、R[6]、R[7]</p><p>C.R[5]、R[2]、R[3]</p><p>D.R[5]、R[8]、R[6]</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949393.jpg"alt="56cb394ddbe752ccadbe544a3b9f40c" /><figcaptionaria-hidden="true">56cb394ddbe752ccadbe544a3b9f40c</figcaption></figure><blockquote><p>一次失败的查找必须查找到<strong><font color='red'>叶结点/只有一个儿子节点</font></strong>处</p></blockquote><h3 id="例三">例三</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949394.png"alt="image-20221111202130826" /><figcaption aria-hidden="true">image-20221111202130826</figcaption></figure><p>答案：<strong><font color='red'>B</font></strong></p><h1 id="动态查找表">动态查找表</h1><h2 id="二叉排序树">二叉排序树</h2><blockquote><p>详细见—-数据结构【图】</p></blockquote><h3 id="例">例</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949395.png"alt="image-20221104133158218" /><figcaption aria-hidden="true">image-20221104133158218</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949396.jpg"alt="8b2b8cf18df013cb2e84b09b02b897b" /><figcaptionaria-hidden="true">8b2b8cf18df013cb2e84b09b02b897b</figcaption></figure><p><ahref="C:\Users\cuiluyi\Desktop\编程随想\数据结构%20%5BAVL树画法%5D%20.md">AVL树画法</a></p><h1 id="section"><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949397.jpg"alt="13312013948078200" /></h1><h1 id="哈希查找的asl">哈希查找的ASL</h1><h2 id="查找成功的asl">查找成功的ASL</h2><h3 id="定义">定义</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002906.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="说明">说明</h3><ol type="1"><li>题目条件通常是在<strong><font color='red'>等概率下</font>查找</strong>，所以<strong><code>ASL=（C0+C1+...+Cn）/n.</code></strong></li><li>查找成功是针对==<strong><font color='red'>关键字</font></strong>==查找的，最后除以<strong><font color='blue'>关键字的总个数</font></strong>。</li></ol><h2 id="查找失败的asl">查找失败的ASL</h2><h3 id="查找失败的原因">查找失败的原因</h3><p>如果我们要查找<strong>表中的元素</strong>，那么一定可以找到，所以讨论查找失败就没有意义。我们讨论查找失败，一定是针对<strong><font color='orange'>表中没有的元素</font></strong>在哈希表中查找，才有查找失败的意义。</p><h3 id="说明-1">说明</h3><ol type="1"><li>查找失败是针对<strong><font color='red'>表中没有的元素，是对位置的查找</font></strong></li><li>失败查找次数就是该位置<strong>向后探测到第一个没有关键字的地址位置之间的距离</strong></li></ol><h2 id="例题">例题</h2><h3 id="例一-1">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002983.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><pre><code>构建出来的哈希表有八个元素，针对这八个元素的比较次数，得出ASLsuccess=(1+1+1+2+1+2+1+2)/8=11/8.</code></pre><p>而查找失败时的平均查找长度，却是针对位置的查找。为什么呢，因为如果我们要查找表中的元素，那么一定可以找到，所以讨论查找失败就没有意义。我们讨论查找失败，一定是针对表中没有的元素在这张表中查找，才有查找失败的意义。</p><p>所以，针对上图的哈希表，我们将待查找关键字X代入哈希函数，我们设定X与这张表中的关键字都不相同：</p><ol type="1"><li><p>当H(X)=3X mod11=0时，因为散列地址为0的位置没有关键字，所以查找1次就失败了；</p></li><li><p>当H(X)=3X mod11=1时，因为散列地址为1的位置有关键字4，X与4不等，所以按照线性探测法向后探测1，散列地址为2的位置没有关键字，所以查找失败，一共查找了2次；</p></li><li><p>当H(X)=3X mod 11=2时，同0；</p></li><li><p>当H(X)=3X mod11=3时，因为散列地址为3的位置有关键字12，X与12不等，所以向后线性探测，散列地址为4的位置有关键字49，还不等，继续探测，因为X与表中的关键字都不等，所以直到散列地址为10没有关键字，才查找失败，这次一共查找了8次；…以此类推</p></li></ol><blockquote><h4id="失败查找次数就是该位置向后探测到第一个没有关键字的地址位置之间的距离">1.失败查找次数就是<strong><font color='blue'>该位置向后探测到第一个没有关键字的地址位置之间的距离</font></strong></h4><h4 id="而求平均数的除数是模的大小">2.而求平均数的除数，是<strong><font color='red'>模的大小</font></strong></h4></blockquote><p>因为失败查找次数是针对位置查找，因为模为11，所以查找的位置(哈希函数的值)为0-10(共11个),针对这11个位置进行查找，而与表的长度无关。</p><p>理清了思路，我们来看看链地址法表示的哈希表：</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002875.png" alt="img" style="zoom:80%;" /></p><pre><code>    成功时的平均查找长度很好求，针对表中的每个关键字：有五个关键字找一次：4,12,49,13,32；三个关键字找两次：38,24,21.</code></pre><p>失败时的平均查找长度针对位置来查找：</p><ol type="1"><li>等于0时，只有空指针域，查找1次；</li><li>等于1时，带一个结点，所以查找2次找到空指针； …</li><li>等于4时，带两个节点，所以查找3次找到空指针； …</li><li>综上所述，我们可以总结：</li></ol><p>==<strong>失败查找次数就是当前位置所带的结点个数+1</strong>==使用链地址法查找时无二次聚集现象(二次聚集：处理冲突过程中发生的两个第一个散列地址不同的记录争夺同一个后继散列地址的现象)</p><p>==<strong>除数也是模的大小</strong>==</p><blockquote><p><strong>查找成功时，分母为哈希表元素个数；</strong></p><p><strong>查找不成功时，分母为哈希表长度。</strong></p><p><strong>计算查找不成功的次数就直接找关键字到第一个地址上关键字为空的距离即可；</strong></p></blockquote><h3 id="例二-1">例二</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002818.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="例三-1">例三</h3><p>将关键字序列（7、8、30、11、18、9、14）散列存储到散列表中。散列表的存储空间是一个下标从0开始的一维数组。散列函数为：H(key) = (keyx3) MODT，处理冲突采用线性探测再散列法，要求装填（载）因子为0.7。 (1)请画出所构造的散列表； (2)分别计算等概率情况下查找成功和查找不成功的平均查找长度。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002054.jpeg"alt="752a42495403f7b79fb9becef3eb5c8" /><figcaptionaria-hidden="true">752a42495403f7b79fb9becef3eb5c8</figcaption></figure><h3 id="例四">例四</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002811.jpeg"alt="54636c164030154e379275639ca60fe" /><figcaptionaria-hidden="true">54636c164030154e379275639ca60fe</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002407.png"alt="image-20221025140718996" /><figcaption aria-hidden="true">image-20221025140718996</figcaption></figure><blockquote><p>d<sub>i</sub>为增量，<strong><code>i((7k)MOD10+1)</code></strong>省略了乘号，中间是k（关键字）</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291002571.jpeg"alt="13312114798622059" /><figcaption aria-hidden="true">13312114798622059</figcaption></figure><p>不成功<strong><code>30/11</code></strong></p><h1 id="例题-1">例题</h1><ul><li><h2id="实验四基于词频的文件相似度">实验四：基于词频的文件相似度</h2></li></ul><p>实现一种简单原始的文件相似度计算，即以两文件的公共词汇占总词汇的比例来定义相似度。为简化问题，这里不考虑中文（因为分词太难了），只考虑长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。</p><p><strong>输入格式:</strong></p><p>输入首先给出正整数<em>N</em>（≤100），为文件总数。随后按以下格式给出每个文件的内容：首先给出文件正文，最后在一行中只给出一个字符<code>#</code>，表示文件结束。在<em>N</em>个文件内容结束之后，给出查询总数<em>M</em>（≤104），随后<em>M</em>行，每行给出一对文件编号，其间以空格分隔。这里假设文件按给出的顺序从1到<em>N</em>编号。</p><p><strong>输出格式:</strong></p><p>针对每一条查询，在一行中输出两文件的相似度，即两文件的公共词汇量占两文件总词汇量的百分比，精确到小数点后1位。注意这里的一个“单词”只包括仅由英文字母组成的、长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。单词间以任何非英文字母隔开。另外，大小写不同的同一单词被认为是相同的单词，例如“You”和“you”是同一个单词。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">Aaa Bbb Ccc</span><br><span class="line">#</span><br><span class="line">Bbb Ccc Ddd</span><br><span class="line">#</span><br><span class="line">Aaa2 ccc Eee</span><br><span class="line">is at Ddd@Fff</span><br><span class="line">#</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50.0%</span><br><span class="line">33.3%</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949398.png"alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODk3MjYx,size_16,color_FFFFFF,t_70-1666415229140-5" /><figcaptionaria-hidden="true">watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODk3MjYx,size_16,color_FFFFFF,t_70-1666415229140-5</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290949399.png"alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODk3MjYx,size_16,color_FFFFFF,t_70-1666415220872-3" /><figcaptionaria-hidden="true">watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODk3MjYx,size_16,color_FFFFFF,t_70-1666415220872-3</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[<span class="number">11</span>],ch;</span><br><span class="line"><span class="type">int</span> com[<span class="number">101</span>][<span class="number">101</span>],num[<span class="number">101</span>],sn;</span><br><span class="line">map&lt;string,<span class="type">bool</span>&gt; mp[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) </span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span>((ch = <span class="built_in">tolower</span>(<span class="built_in">getchar</span>())) != <span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) </span><br><span class="line">&#123;</span><br><span class="line">                <span class="keyword">if</span>(sn &lt; <span class="number">10</span>) s[sn ++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">                s[sn] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sn &gt; <span class="number">2</span>) mp[i][s] = <span class="number">1</span>;</span><br><span class="line">                sn = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;string,<span class="type">bool</span>&gt;::iterator it = mp[i].<span class="built_in">begin</span>();it != mp[i].<span class="built_in">end</span>();it ++) </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j ++) </span><br><span class="line">                com[i][j] = com[j][i] += mp[j][it -&gt; first];</span><br><span class="line">        com[i][i] = num[i] = mp[i].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.1f%\n&quot;</span>,com[a][b] * <span class="number">100.0</span> / (num[a] + num[b] - com[a][b]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>17-19行的<strong><code>&#123; &#125;</code></strong>不能省略，否则下面的<strong><code>else</code></strong>配对出错</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树】</title>
      <link href="/2023/09/24/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%91%E3%80%91/"/>
      <url>/2023/09/24/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E3%80%90%E6%A0%91%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树">二叉树</h1><h2 id="存储结构">存储结构</h2><h3 id="顺序存储结构">顺序存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">typedef</span> ElementType BinTree[MAX];</span><br><span class="line">BinTree T;</span><br></pre></td></tr></table></figure><ul><li>顺序存储的二叉树是<strong>完全二叉树</strong>，完全二叉树的性质如下：</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202403072113883.jpg"alt="7476a7cbe9d1fbd33df03cf13ab37b4" /><figcaptionaria-hidden="true">7476a7cbe9d1fbd33df03cf13ab37b4</figcaption></figure><ol type="1"><li><strong><font color='red'>从1号单元开始存储树节点</font></strong>（0号单元存节点的个数）</li><li><span class="math inline">\(i\)</span> 左子树是 <spanclass="math inline">\(2i\)</span>，右子树是 <spanclass="math inline">\(2i+1\)</span>，根节点是 <spanclass="math inline">\(\lfloor i/2 \rfloor\)</span>，左兄弟是 <spanclass="math inline">\(i-1\)</span>，右兄弟 <spanclass="math inline">\(i+1\)</span></li><li>如果完全二叉树一共有 <span class="math inline">\(n\)</span>个节点，则非叶子节点为 <spanclass="math inline">\(T[0…n/2]\)</span>，叶节点为 <spanclass="math inline">\(T[n/2+1,…,n]\)</span></li></ol><span id="more"></span><h3 id="链式存储结构">链式存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol type="1"><li><p><strong><code>ElementType</code></strong>既可以是<code>int</code>，<code>char</code>，<code>double</code>，<code>float</code>等，即</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> ElementType;    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> ElementType ;      </span><br></pre></td></tr></table></figure></p><blockquote><p>注意typedef最后面的<font color='red'><strong>分号</strong></font></p></blockquote></li><li><p><strong><code>ElementType</code></strong>也可以是自定义的<strong>struct类型</strong>，eg：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">InfoType otherinfo;<span class="comment">//其他数据项</span></span><br><span class="line">&#125;ElementType;</span><br></pre></td></tr></table></figure></blockquote><h2 id="常见函数">常见函数</h2><h3 id="先序遍历">先序遍历</h3><p><strong>前序遍历(先根遍历)</strong></p><ol type="1"><li>若二叉树为空，则返回；</li><li>若不空：<ol type="1"><li>访问根结点；</li><li>前序遍历左子树；</li><li>前序遍历右子树。</li></ol></li></ol><h4 id="递归算法">递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  if(T==NULL)return;</span></span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">        <span class="built_in">preorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(T-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法">非递归算法</h4><ul><li><p>通过<strong><font color='red'>堆栈</font></strong>来实现</p></li><li><p>从当前节点开始遍历：（当入栈时访问节点内容，则为前序遍历；出栈时访问，则为中序遍历）</p><ol type="1"><li>若当前节点存在，就存入栈中，并访问左子树；</li><li>直到当前节点不存在，就<strong><font color='blue'>出栈，并通过栈顶节点访问右子树</font></strong>；</li><li>不断重复1. 2，直到当前节点不存在且栈空。</li></ol></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951583.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span>;    </span><br><span class="line">    BinTree p=T;stack&lt;BinTree&gt;s;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;val);<span class="comment">//先序，第一次遇到才输出</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">         p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>visit(p-&gt;val)</code></strong> 语句与<strong><code>s.push(p)</code></strong>语句成对出现，这表明==<strong><font color='red'>先序遍历的序列就是入栈的顺序</font></strong>==</p></blockquote><h3 id="中序遍历">中序遍历</h3><p><strong>中序遍历(中根遍历)</strong></p><ol type="1"><li>若二叉树为空，则退出；</li><li>若不空：<ol type="1"><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树</li></ol></li></ol><h4 id="递归算法-1">递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法-1">非递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    BinTree p=T;stack&lt;BinTree&gt;s;</span><br><span class="line"><span class="keyword">while</span>( p!=<span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;val);<span class="comment">//中序，第二次遇到才输出</span></span><br><span class="line">         p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>visit(p-&gt;val)</code></strong> 语句与<strong><code>s.pop()</code></strong>语句成对出现，这表明==<strong><font color='red'>中序遍历的序列就是出栈的顺序</font></strong>==</p></blockquote><h3 id="后序遍历">后序遍历</h3><p><strong>后序遍历(后根遍历)</strong></p><ol type="1"><li>若二又树为空，则退出；</li><li>若不空：<ol type="1"><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点</li></ol></li></ol><h4 id="递归算法-2">递归算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">postorder</span>(T-&gt;right);</span><br><span class="line">        <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归算法-2">非递归算法</h4><ul><li><p><strong>双栈法</strong>：用两个栈来实现后序遍历的非递归算法。</p></li><li><p>注意到<strong><font color='purple'>后序遍历</font></strong>可以看作是<font color='purple'><strong>下面遍历的逆过程</strong></font>：即<strong>先遍历<font color='red'>根结点</font>，然后遍历其<font color='red'>右子树</font>，然后遍历其<font color='red'>左子树</font></strong>。这个<strong><font color='blue'>过程逆过来就是后序遍历</font></strong>。算法步骤如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    BinTree p = T;stack&lt;BinTree&gt; s1, s2;</span><br><span class="line">    <span class="keyword">while</span> ( p!=<span class="literal">NULL</span> || !s1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(p);</span><br><span class="line">            s2.<span class="built_in">push</span>(p);<span class="comment">//visit(p)换成s2.push();</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            p = s1.<span class="built_in">top</span>();s1.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//逆序输出即为后序遍历    </span></span><br><span class="line">    <span class="keyword">while</span> (!s2.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        p = s2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="built_in">visit</span>(p-&gt;val);</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历">层序遍历</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951110.png"alt="image-20221001230537604" /><figcaption aria-hidden="true">image-20221001230537604</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="comment">/* 若是空树则直接返回 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;TreeNode *&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        BinTree t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(t-&gt;val); <span class="comment">/* 访问取出队列的结点 */</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left)</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果返回形式是下面的类型:<strong>:star2:LeetCode102</strong></p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20240220223112586.png" alt="image-20240220223112586" style="zoom:33%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; row;</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                row.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(row);</span><br><span class="line">            row.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="先序遍历建立二叉树">先序遍历建立二叉树</h3><p><strong>扩充先序序列：先序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的先序遍历序列是：ABCDEFG</strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /></p><p><strong>扩充先序序列为：ABC##DE#G##F###</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">T-&gt;val = x;<span class="comment">//生成根结点</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历建立二叉树">中序遍历建立二叉树</h3><p><strong>扩充中序序列：中序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的中序遍历序列是：CBEGDFA</strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /></p><p><strong>扩充先序序列为：#C#B#E#G#D#F#A#</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line">        T-&gt;val = x;<span class="comment">//生成根结点</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历建立二叉树">后序遍历建立二叉树</h3><p><strong>扩充后序序列：后序遍历二叉树时，如果当前要访问的结点不空，就记下这个结点值，<font color='red'>如果空，就以“#”记下来</font>，所得到的遍序序列。</strong></p><p><strong>例如：下图的后序遍历序列是：CGEFDBA</strong><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /></p><p><strong>扩充先序序列为：##C###GE##FDB#A</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951075.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BinTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">T = <span class="literal">NULL</span>;<span class="comment">//递归结束，建立空树</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="keyword">new</span> TreeNode;</span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;left);<span class="comment">//递归建立左子树</span></span><br><span class="line"><span class="built_in">CreateBiTree</span>(T-&gt;right);<span class="comment">//递归建立右子树</span></span><br><span class="line">        T-&gt;val = x;<span class="comment">//生成根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的高度深度">求二叉树的高度（深度）</h3><blockquote><p>算法基本思想：</p><p>1、若二叉树为==<strong>空树</strong>==，则高度（深度）为02、否则，二叉树的高度（深度）为左右子树的高度（深度）的最大值+1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeHeight</span><span class="params">(BinTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h1 = <span class="built_in">TreeHeight</span>(T-&gt;left);</span><br><span class="line">    <span class="type">int</span> h2 = <span class="built_in">TreeHeight</span>(T-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (h1 &gt; h2)</span><br><span class="line">        <span class="keyword">return</span> h1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> h2 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的直径">求二叉树的直径</h3><p>【LeetCode:543】</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402211129363.png"alt="image-20240221112902928" /><figcaption aria-hidden="true">image-20240221112902928</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left), r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        res = <span class="built_in">max</span>(res, l + r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="统计结点个数">统计结点个数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951318.png"alt="image-20221002083141111" /><figcaption aria-hidden="true">image-20221002083141111</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nodesum</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodesum</span>(T-&gt;left)+<span class="built_in">nodes</span>(T-&gt;right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计叶结点个数">统计叶结点个数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951178.png"alt="image-20221002085013531" /><figcaption aria-hidden="true">image-20221002085013531</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">leafnodes</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;left == <span class="literal">NULL</span> &amp;&amp; T-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leafnodes</span>(T-&gt;left) + <span class="built_in">leafnodes</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计度数为2的结点个数">统计度数为2的结点个数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">nodes_two</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;left &amp;&amp; T-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodes_two</span>(T-&gt;left) + <span class="built_in">nodes_two</span>(T-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nodes_two</span>(T-&gt;left) + <span class="built_in">nodes_two</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否为对称二叉树">判断是否为对称二叉树</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402202108310.png"alt="image-20240220210836661" /><figcaption aria-hidden="true">image-20240220210836661</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(TreeNode *a, TreeNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">nullptr</span> &amp;&amp; b != <span class="literal">nullptr</span> &amp;&amp; a-&gt;val == b-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(a-&gt;left, b-&gt;right) &amp;&amp; <span class="built_in">func</span>(a-&gt;right, b-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断两个二叉树是否相同">判断两个二叉树是否相同</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBinTree</span><span class="params">(BinTree T1, BinTree T2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((T1 == <span class="literal">NULL</span> &amp;&amp; T2 != <span class="literal">NULL</span>) || (T1 != <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T1-&gt;val != T2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isBinTree</span>(T1-&gt;left) &amp;&amp; <span class="built_in">isBinTree</span>(T1-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出叶结点">输出叶结点</h3><p>本题要求按照<strong>先序遍历</strong>的顺序输出二叉树的叶结点。</p><blockquote><p>思路：==<strong>先序遍历</strong>==输出根节点时<strong><font color='red'>加上判断</font></strong>其是否为叶结点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderPrintLeaves</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>&amp;&amp;T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">visit</span>(T-&gt;val);</span><br><span class="line">        <span class="built_in">PreorderPrintLeaves</span>(T-&gt;left);</span><br><span class="line">        <span class="built_in">PreorderPrintLeaves</span>(T-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除二叉树">删除二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyTree</span><span class="params">(BinTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">Destroy</span>(T-&gt;left);</span><br><span class="line">    <span class="built_in">Destrot</span>(T-&gt;right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：必须<strong><code>Destroy(T-&gt;left);     Destrot(T-&gt;right);</code><font color='red'>之后</font>才能<code>free(T);</code></strong></p></blockquote><h3 id="复制二叉树">复制二叉树</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951514.png"alt="image-20221002113115794" /><figcaption aria-hidden="true">image-20221002113115794</figcaption></figure><h4 id="法一">法一：</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951555.png"alt="image-20221002113137163" /><figcaption aria-hidden="true">image-20221002113137163</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinTree &amp;b, BinTree &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        t == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = b-&gt;val;</span><br><span class="line">    <span class="built_in">CopyTree</span>(b-&gt;left, t-&gt;left);</span><br><span class="line">    <span class="built_in">CopyTree</span>(b-&gt;right, b-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二">法二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">CopyTree</span><span class="params">(BinTree b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = b-&gt;val;</span><br><span class="line">    t-&gt;left = <span class="built_in">CopyTree</span>(b-&gt;left);</span><br><span class="line">    t-&gt;right = <span class="built_in">CopyTree</span>(b-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换二叉树的左右子树">交换二叉树的左右子树</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951582.png"alt="image-20221002120102502" /><figcaption aria-hidden="true">image-20221002120102502</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402202059497.png"alt="image-20240220205942861" /><figcaption aria-hidden="true">image-20240220205942861</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">invertTree</span><span class="params">(BinTree b, BinTree t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = b-&gt;val;</span><br><span class="line">    <span class="built_in">invertTree</span>(b-&gt;left, t-&gt;right);</span><br><span class="line">    <span class="built_in">invertTree</span>(b-&gt;right, t-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以破坏原来的二叉树,则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值为x的结点所在的层数">返回值为x的结点所在的层数</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951796.jpeg"alt="38251992cd4cab160ebe3b423b0e74a" /><figcaptionaria-hidden="true">38251992cd4cab160ebe3b423b0e74a</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodeLevel</span> <span class="params">(BinTree T,ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树的层号为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;val==X)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//规定根节点的层号为1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t1=<span class="built_in">NodeLevel</span>(T-&gt;left,X);</span><br><span class="line">        <span class="type">int</span> t2=<span class="built_in">NodeLevel</span>(T-&gt;right,X);</span><br><span class="line">        <span class="keyword">if</span>(t1 &gt; <span class="number">0</span>)<span class="keyword">return</span> t1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t2 &gt; <span class="number">0</span>)<span class="keyword">return</span> t2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若树中不存在值为X的结点，返回0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>若函数返回0，说明树中不存在值为X的结点</strong></p></blockquote><h3 id="前序中序建树">前序中序建树</h3><h4 id="法一-1">法一：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> preorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【前序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BinTree <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = (BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    t-&gt;val = preorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != preorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    t-&gt;left = <span class="built_in">BuildTree</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">    t-&gt;right = <span class="built_in">BuildTree</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T = <span class="built_in">BuildTree</span>(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="法二-1">法二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【前序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, BinTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    T-&gt;val = preorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != preorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>, T-&gt;left);</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right, T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, T);</span><br></pre></td></tr></table></figure><h3 id="后序中序建树">后序中序建树</h3><h4 id="法一-2">法一：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【后序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BinTree <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinTree t = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    t-&gt;val = postorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != postorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    t-&gt;left = <span class="built_in">BuildTree</span>(root - right + i - <span class="number">1</span>, left, i - <span class="number">1</span>);</span><br><span class="line">    t-&gt;right = <span class="built_in">BuildTree</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T = <span class="built_in">BuildTree</span>(n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="法二-2">法二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br><span class="line"><span class="type">char</span> postorder[<span class="number">50</span>], inorder[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- root: 当前根节点在【后序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, BinTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    T = <span class="keyword">new</span> TreeNode;</span><br><span class="line">    T-&gt;val = postorder[root];</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != postorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>, T-&gt;left);</span><br><span class="line">    <span class="built_in">BuildTree</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right, T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinTree T;</span><br><span class="line"><span class="built_in">BuildTree</span>(n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, T);</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li><p>注意第10行</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left&gt;right)</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><p>而<strong>不能直接</strong>==<del><code>return;</code></del>==</p></li><li><p>```c++ void BuildTree(int root, int left, int right, BinTree&amp;T) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    注意**T**是引用类型，加了一个==**&amp;**==</span><br><span class="line"></span><br><span class="line">3. 递归模型</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    left&gt;rightT==NULL;</span><br><span class="line">    BuildTree(root+1, left, i-1, T-&gt;left);</span><br><span class="line">    BuildTree(root+i-left+1, i+1, right, T-&gt;right);</span><br></pre></td></tr></table></figure></p></li></ol></blockquote><h3 id="前序中序转后序">前序中序转后序</h3><p>已知前序与中序,请输出后序。 前序：1, 2, 3, 4, 5, 6（根左右） 中序：3,2, 4, 1, 6, 5（左根右）</p><blockquote><p>分析：因为前序的第一个总是根结点，令i在中序中找到该根结点，则i把中序分为两部分，左边是左子树，右边是右子树。因为是输出后序（左右根）所以先打印出当前左子树，然后右子树，再打印根结点。</p></blockquote><p><strong>:smile:算法</strong></p><ol type="1"><li>root为当前子树的根结点在<strong>前序</strong><code>preorder</code>中的下标。<strong>left和right</strong>为当前子树的最左边和最右边的结点在<strong>中序</strong><code>inorder</code>中的下标。</li><li>用<code>i</code>找到当前子树的<strong>根结点</strong>root在<strong>中序</strong>中的下标，然后左边和右边就分别为当前根结点root的左子树和右子树。递归实现～</li><li>左子树在<strong>前序</strong>中的根结点为当前根结点的后一个结点<code>root + 1</code>；左子树在<strong>中序</strong>中的起始点left为<code>left</code>，末尾点right为<code>i – 1</code>.</li><li>右子树的根结点在<strong>前序</strong>中为<code>root + (i -left + 1)</code>，即为当前根结点+(左子树的个数+1)。右子树在中序中的起始点left为<code>i+1</code>，末尾right点为<code>right</code>。</li></ol><p>输出的后序应为：3 4 2 6 5 1（左右根）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用数组，且数组必须是是全局变量</span></span><br><span class="line"><span class="type">int</span> preorder[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 前序</span></span><br><span class="line"><span class="type">int</span> inorder[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;  <span class="comment">// 中序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- root: 当前根节点在【前序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = left; <span class="comment">// i从当前树的起点开始寻找 ，直到end</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != preorder[root])</span><br><span class="line">        i++;</span><br><span class="line">    <span class="built_in">postorder</span>(root + <span class="number">1</span>, left, i - <span class="number">1</span>);             <span class="comment">// 左子树</span></span><br><span class="line">    <span class="built_in">postorder</span>(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, preorder[root]);                <span class="comment">// 或printf(&quot;%d &quot;, in[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">postorder</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 初始根节点在preorder和最左最右结点在inorder中下标已知</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序中序转前序">后序中序转前序</h3><p>已知后序与中序,请输出前序（先序）： 后序：3, 4, 2, 6, 5, 1（左右根）中序：3, 2, 4, 1, 6, 5（左根右）</p><blockquote><p>分析：因为后序的最后一个总是根结点，令<code>i</code>在中序中找到该根结点，然后<code>i</code>把中序分为两部分，左边是左子树，右边是右子树。因为是输出先序（根左右），所以先打印出当前根结点，然后打印左子树，再打印右子树。</p></blockquote><p><strong>:smile:算法</strong></p><ol type="1"><li><p>root为当前子树的根结点在<strong>后序</strong><code>postorder</code>中的下标。<strong>left和right</strong>为当前子树的最左边和最右边的结点在<strong>中序</strong><code>inorder</code>中的下标。</p></li><li><p>用<code>i</code>找到当前子树的<strong>根结点</strong>root在<strong>中序</strong>中的下标，然后左边和右边就分别为当前根结点root的左子树和右子树。递归实现～</p></li><li><p>左子树的根结点在<strong>后序</strong>中为<code>root – (end – i + 1)</code>，即为当前根结点-(右子树的个数+1)；左子树在中序中的起始点left为<code>left</code>，末尾点right为<code>i – 1</code>.</p></li><li><p>右子树的根结点在后序中为当前根结点的前一个结点root – 1；右子树在中序中的起始点left为<code>i+1</code>，末尾right点为<code>right</code>。</p></li></ol><p>输出的前序应该为：1, 2, 3, 4, 5, 6（根左右）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> postorder[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>&#125;; <span class="comment">// 后序</span></span><br><span class="line"><span class="type">int</span> inorder[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;   <span class="comment">// 中序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">- root: 当前根节点在【后序】数组的下标</span></span><br><span class="line"><span class="comment">- left, right: 当前根节点root所在子树在【中序】数组的左右下标边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = left; <span class="comment">// i从当前树的起点开始寻找 ，直到end</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; right &amp;&amp; inorder[i] != postorder[root])</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, postorder[root]);              <span class="comment">// 或printf(&quot;%d &quot;, inorder[i]);</span></span><br><span class="line">    <span class="built_in">preorder</span>(root - <span class="number">1</span> - right + i, left, i - <span class="number">1</span>); <span class="comment">// 左子树</span></span><br><span class="line">    <span class="built_in">preorder</span>(root - <span class="number">1</span>, i + <span class="number">1</span>, right);            <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">preorder</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 初始根节点在postorder和最左最右结点在inorder中下标已知</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的右视图"><ahref="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a></h3><p>​ 给定一个二叉树的 <strong>根节点</strong><code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402251724343.jpeg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p>按照<strong>层序遍历</strong>的⽅式，把每一层的<strong>最后⼀个结点</strong>的值存⼊vector中，最后返回vector～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            TreeNode *t;</span><br><span class="line">            <span class="keyword">while</span> (size--)</span><br><span class="line">            &#123;</span><br><span class="line">                t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和-i"><ahref="https://leetcode.cn/problems/path-sum/">路径总和 I</a></h3><p>​ 给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数<code>targetSum</code> 。判断该树中是否存在<strong>根节点到叶子节点</strong>的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code>。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code>。<strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val == targetSum;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) ||</span><br><span class="line">               <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和-ii"><ahref="https://leetcode.cn/problems/path-sum-ii/">路径总和 II</a></h3><p>​ 给你二叉树的根节点 <code>root</code> 和一个整数目标和<code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong>路径总和等于给定目标和的路径。<strong>叶子节点</strong>是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>​pathsum函数中只需dfs一下然后返回result数组即可，dfs函数中从root开始寻找到底端sum==root-&gt;val的结点，如果满足就将root-&gt;val压入path数组中，path数组压入result数组中，然后将当前结点弹出，return。不满足是最后一个结点的则不断深度优先左结点、右结点，同时处理好path数组的压入和弹出~~</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">            root-&gt;val == sum) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();<span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="section"></h3><h2 id="例题">例题</h2><blockquote><blockquote><p>先序序列a,b,c,d的不同二又树个数是() A.13 B.14 C.15 D.16</p></blockquote></blockquote><ul><li><p>因为先序序列和中序序列可以唯一地确定一棵二叉树，并且题目已经给出了先序序列，所以我们只需要知道由该先序序列可以确定多少个中序序列，即可确定确定多少棵二叉树！</p></li><li><p>那么，问题来了，由一个先序序列如何确定有多少个中序序列呢？这就有两个“公式”需要大家去牢记了！</p></li></ul><blockquote><p>1、先序序列和中序序列的关系为：==<strong><font color='blue'>以先序序列入栈，则出栈序列必为中序序列</font></strong>==2、一个入栈顺序可以确定的出栈顺序有 f(n)种（卡特兰数）：<spanclass="math display">\[f\left( n \right)=C_{2n}^{n}-C_{2n}^{n-1}=\frac{1}{n+1}C_{2n}^{n}\]</span>，n为结点个数</p></blockquote><ul><li>所以答案就清楚了，如果以abcd的顺序入栈，将有14种出栈顺序，也就是可以确定14个中序序列，即可以确定14个不同的二叉树。</li></ul><blockquote><blockquote><p>假定只有四个结点A、B、C、D的二叉树，其前序遍历序列为ABCD，则下面哪个序列是不可能的中序遍历序列?</p><p>A：ABCD B：ACDB C：DCBA D：DABC</p></blockquote></blockquote><blockquote><p>答案：D 二叉树的前序遍历和中序遍历分别对应入栈和出栈顺序</p></blockquote><h1 id="二叉搜索树bst">二叉搜索树(BST)</h1><h2 id="介绍">介绍</h2><p>==<strong><font color='blue'>二叉搜索树</font></strong> ==<strong><font color='blue'>二叉查找树</font></strong> （Binary SearchTree） == <strong><font color='blue'>二叉排序树</font></strong> （BinarySort Tree）==</p><ul><li>若它的左子树不空，则<strong>左子树</strong>上<strong>所有</strong>结点的值均<font color='red'><strong>小于</strong></font>根结点的值;</li><li>若它的右子树不空，则<strong>右子树</strong>上<strong>所有</strong>结点的值均<font color='red'><strong>大于</strong></font>根结点的值;</li><li>它的左、右子树也都分别是<strong>二又搜索树</strong></li></ul><blockquote><blockquote><ol type="1"><li><strong>二叉排序树</strong>的<strong><font color='red'>中序遍历</font></strong>是<strong><font color='gree'>递增</font></strong>序列</li><li>在构造二叉排序树时，若关键字序列有序，则二叉排序树的高度最大</li></ol></blockquote></blockquote><h2 id="存储结构-1">存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125; *BinTree;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>struct TreeNode* left, *right;</code></strong>中<strong><code>*</code></strong>是跟着变量名的</p></blockquote><h2 id="操作集">操作集</h2><h3 id="查找">查找</h3><ul><li>函数<code>Find</code>在二叉搜索树<code>T</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li></ul><h4 id="法一递归">法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Find</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Find</span>(T-&gt;right,X);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Find</span>(T-&gt;left,X);</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二循环">法二：循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Find</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">            T=T-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">            T=T-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最小值">找最小值</h3><ul><li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li></ul><h4 id="法一递归-1">法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">FindMin</span>(T-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二循环-1">法二:循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">while</span>(T-&gt;left)</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找最大值">找最大值</h3><ul><li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li></ul><h4 id="法一递归-2">法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">if</span>(T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> T;</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">FindMin</span>(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二循环-2">法二：循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">FindMin</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">while</span>(T-&gt;right)</span><br><span class="line">            T=T-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入">插入</h3><ul><li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li></ul><h4 id="法一-3">法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;val=X;</span><br><span class="line">        T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X&lt;T-&gt;Data)    </span><br><span class="line">            T-&gt;left=<span class="built_in">Insert</span>(T-&gt;left,X);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;val)</span><br><span class="line">            T-&gt;right=<span class="built_in">Insert</span>(T-&gt;right,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二-3">法二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">( BinTree &amp;T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=(BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">        T-&gt;val=X;T-&gt;left=T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">            <span class="built_in">Insert</span>( T-&gt;right, ElementType X );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">            <span class="built_in">Insert</span>( T-&gt;left, ElementType X );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>二叉树排序树中<strong><font color='red'>不存在</font></strong>相同的结点，故</p><p><strong><code>if( X==T-&gt;val )    return;         //无需插入</code></strong></p></li><li><p>注意函数参数T是<font color='blue'><strong>引用&amp;类型</strong></font></p></li></ul></blockquote><h3 id="删除">删除</h3><ul><li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li></ul><h4 id="算法描述">算法描述</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951998.png" alt="image-20221019104744543" style="zoom:80%;" /></p><p><strong>（1）p为叶结点</strong></p><p>删除方法：释放结点p，修改p父节点指针f的相应指针</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951995.png" alt="image-20221019105019917" style="zoom:80%;" /></p><p><strong>（2）p只有左子树</strong></p><p>删除方法：释放结点p，p的左子树顶替p结点的位置</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952089.png"alt="image-20221019105212235" /><figcaption aria-hidden="true">image-20221019105212235</figcaption></figure><p><strong>（3）p只有右子树</strong></p><p>删除方法：释放结点p，p的右子树顶替p结点的位置</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952098.png"alt="image-20221019105327790" /><figcaption aria-hidden="true">image-20221019105327790</figcaption></figure><p><strong>(4）p既有左子树，也有右子树</strong></p><p>删除方法：寻找p<strong><font color='red'>左子树中最大的结点</font></strong>或 p<strong><font color='red'>右子树中最小的结点</font></strong>来替代结点p</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952259.png" alt="image-20221019191743343" style="zoom:67%;" /></p><h4 id="法一-4">法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">        T-&gt;left=<span class="built_in">Delete</span>(T-&gt;left,X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">        T-&gt;right=<span class="built_in">Delete</span>(T-&gt;right,X);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;left &amp;&amp; T-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            BinTree t=<span class="built_in">FindMin</span>(T-&gt;right);</span><br><span class="line">            T-&gt;val=t-&gt;val;</span><br><span class="line">            T-&gt;right=<span class="built_in">Delete</span>(T-&gt;right,T-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            BinTree t=T;</span><br><span class="line">            <span class="keyword">if</span>(!T-&gt;left)</span><br><span class="line">                T=T-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!T-&gt;right)</span><br><span class="line">                T=T-&gt;left;  </span><br><span class="line">            <span class="built_in">free</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="法二-4">法二</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952414.jpeg"alt="微信图片_20221019200024" /><figcaption aria-hidden="true">微信图片_20221019200024</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">( BinTree &amp;T, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; T-&gt;val)</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;left,X);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; T-&gt;val)</span><br><span class="line">        <span class="built_in">Delete</span>(T-&gt;right,X);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( T-&gt;left == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;BinTree t=T;T = T-&gt;left;<span class="built_in">free</span>(t);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( T-&gt;right == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;BinTree t=T;T = T-&gt;right;<span class="built_in">free</span>(t);&#125;          </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;<span class="comment">//在左子树中寻找最大的（最右边的）</span></span><br><span class="line">            BinTree p=T;BinTree t=T-&gt;left;</span><br><span class="line">            <span class="comment">//初始化：p为t的父节点,t为左子树的根节点</span></span><br><span class="line">            <span class="keyword">while</span>( t-&gt;right )</span><br><span class="line">            &#123;p = t;t=t-&gt;right;&#125;<span class="comment">//p为被删除结点t的前驱</span></span><br><span class="line">            T-&gt;val=t-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(p!=T )p-&gt;right=t-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;left=t-&gt;left；</span><br><span class="line">            <span class="built_in">free</span>(t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见函数-1">常见函数</h2><h3 id="判断二叉树">判断二叉树</h3><p>​ 给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p>:sunny:<strong>分析</strong>：既然是⼆叉搜索树，那么按照左根右遍历后的结果一定是增序～所以只需要中序遍历一遍，判断遍历结果的数组是不是后⾯面数⼀定⼤于前面数就可以了～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">            v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (v[i] &gt;= v[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树中第k小的元素"><ahref="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a></h3><p>​ 给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数<code>k</code> ，请你设计一个算法查找其中第 <code>k</code>个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250211734.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402250211749.jpeg" alt="img" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">inOrder</span>(root-&gt;left, k);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k)</span><br><span class="line">            &#123;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">inOrder</span>(root-&gt;right, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode *root, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树avl">平衡二叉树（AVL）</h1><h2 id="介绍-1">介绍</h2><h3 id="定义">定义</h3><p>​ 平衡二叉树 全称叫做 <code>平衡二叉搜索（排序）树</code>，简称AVL树。英文：Balanced Binary Tree （BBT），注：二叉查找树(BST)</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221451357.jpg" alt="960faf26fc684ecc6dad1e5ba01e3ba" style="zoom: 33%;" /></p><h3 id="avl-什么意思">AVL 什么意思 ？</h3><p>​ AVL 是大学教授 G.M. Adelson-Velsky 和 E.M. Landis名称的缩写，他们提出的平衡二叉树的概念，为了纪念他们，将平衡二叉树称为AVL树。</p><h3 id="为什么使用avl树">为什么使用AVL树</h3><p>​ 二叉搜索树能提高查找的效率 O(log n)，但是当你插入<code>&#123;1,2,3,4,5,6&#125;</code> 这种数据的时候，二叉树的效率变为 O(n)</p><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952506.png" alt="image-20210110143451761" style="zoom: 33%;" /></p><p>:sunny:判断「平衡二叉树」的 2 个条件：</p><ol type="1"><li><p><strong>是「二叉排序树」</strong></p></li><li><p><strong>任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于1）</strong></p></li></ol><h3 id="平衡因子">平衡因子</h3><p>平衡因子（Balance Factor，简写为bf）=<font color='red'><strong>左子树的==高度== - 右子树的==高度==</strong> </font>。</p><blockquote><blockquote><p><strong>在 AVL树中，所有节点的平衡因子都必须满足：-1&lt;=bf&lt;=1;</strong></p></blockquote></blockquote><h2 id="有序数组构建avl">有序数组构建AVL</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按<strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong>二叉搜索树。</p><p><strong>高度平衡</strong>二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1」的二叉树。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202402221527581.png"alt="image-20240222152702374" /><figcaption aria-hidden="true">image-20240222152702374</figcaption></figure><p>​ 思路：设⽴立left和right，mid = (left + right) /2，每次将数组的中点mid的值为根结点的值，中点左边为根结点的左⼦子树，右边为根结点的右⼦子树～递归求解～</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据有序数组构建平衡二叉树AVL */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">func</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">func</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="构造方法">构造方法</h2><p>详细请看 <ahref="https://zhuanlan.zhihu.com/p/165939383">【数据结构】AVL树（平衡二叉树）画法速成教学 - 知乎 (zhihu.com)</a></p><h3 id="ll型右旋">LL型—右旋</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240951033.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Rotate</span><span class="params">(BinTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree t=p-&gt;left;</span><br><span class="line">    p-&gt;left=t-&gt;right;</span><br><span class="line">    t-&gt;right=p;</span><br><span class="line">    p=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rr型左旋">RR型—左旋</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952586.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">L_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree t=p-&gt;right;</span><br><span class="line">    p-&gt;right=t-&gt;left;</span><br><span class="line">    t-&gt;left=p;</span><br><span class="line">    p=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lr型左右旋">LR型—左右旋</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952663.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952646.png" alt="在这里插入图片描述" style="zoom:80%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LR_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">L_Rotate</span>(p-&gt;left);</span><br><span class="line">    <span class="built_in">R_Rotate</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rl型右左旋">RL型—右左旋</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952836.png" alt="在这里插入图片描述" style="zoom:95%;" /></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952963.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RL_Rotate</span><span class="params">(BinTree &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">R_Rotate</span>(p-&gt;right);</span><br><span class="line">    <span class="built_in">L_Rotate</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avl最小节点数">AVL最小节点数</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952095.png"alt="image-20221025134419965" /><figcaption aria-hidden="true">image-20221025134419965</figcaption></figure><p><strong>N<sub>5</sub> =12</strong></p><blockquote><blockquote><p>==规律：<strong><font color='red'>N<sub>h</sub> = N<sub>h-1</sub> +N<sub>h-2</sub> + 1</font></strong>==</p></blockquote></blockquote><p>【单选】若一AVL树的结点数是21，则该树的高度至多是多少?（注:只有一个根节点的树高度为0 ）</p><blockquote><p>答案：B <strong><code>1 2 4 7 12 20 33</code></strong></p><p>21个结点达到了5层所需的最小结点数，但没有达到6层所需的最小结点数</p></blockquote><h2 id="例题-1">例题</h2><p><strong>1123 Is It a Complete AVL Tree</strong></p><p>An AVL tree is a self-balancing binary search tree. In an AVL tree,the heights of the two child subtrees of any node differ by at most one;if at any time they differ by more than one, rebalancing is done torestore this property. Figures 1-4 illustrate the rotation rules.</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952090.jpeg"alt="F1.jpg" /></th><th><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952183.jpeg"alt="F2.jpg" /></th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952280.jpeg"alt="F3.jpg" /></td><td><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952482.jpeg"alt="F4.jpg" /></td></tr></tbody></table><p>Now given a sequence of insertions, you are supposed to output thelevel-order traversal sequence of the resulting AVL tree, and to tell ifit is a complete binary tree.</p><ul><li><strong>Input Specification:</strong></li></ul><p>Each input file contains one test case. For each case, the first linecontains a positive integer N (≤ 20). Then N distinct integer keys aregiven in the next line. All the numbers in a line are separated by aspace.</p><ul><li><strong>Output Specification:</strong></li></ul><p>For each test case, insert the keys one by one into an initiallyempty AVL tree. Then first print in a line the level-order traversalsequence of the resulting AVL tree. All the numbers in a line must beseparated by a space, and there must be no extra space at the end of theline. Then in the next line, print <code>YES</code> if the tree iscomplete, or <code>NO</code> if not.</p><ul><li><strong>Sample Input 1:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 63 65</span><br></pre></td></tr></table></figure><ul><li><strong>Sample Output 1:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">70 63 88 61 65</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><ul><li><strong>Sample Input 2:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">88 70 61 96 120 90 65 68</span><br></pre></td></tr></table></figure><ul><li><strong>Sample Output 2:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88 65 96 61 70 90 120 68</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><ul><li><strong>代码</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    TreeNode *temp = tree-&gt;right;</span><br><span class="line">    tree-&gt;right = temp-&gt;left;</span><br><span class="line">    temp-&gt;left = tree;</span><br><span class="line">    tree = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    TreeNode *temp = tree-&gt;left;</span><br><span class="line">    tree-&gt;left = temp-&gt;right;</span><br><span class="line">    temp-&gt;right = tree;</span><br><span class="line">    tree = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftRightRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">leftRotate</span>(tree-&gt;left);</span><br><span class="line">    <span class="built_in">rightRotate</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rightLeftRotate</span><span class="params">(TreeNode *&amp;tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rightRotate</span>(tree-&gt;right);</span><br><span class="line">    <span class="built_in">leftRotate</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left);</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode *tree, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        tree-&gt;val = val;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tree-&gt;val &gt; val) &#123;</span><br><span class="line">        tree-&gt;left = <span class="built_in">insert</span>(tree-&gt;left, val);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left), r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (l - r &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; tree-&gt;left-&gt;val)</span><br><span class="line">                <span class="built_in">rightRotate</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">leftRightRotate</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tree-&gt;right = <span class="built_in">insert</span>(tree-&gt;right, val);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">getHeight</span>(tree-&gt;left), r = <span class="built_in">getHeight</span>(tree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; tree-&gt;right-&gt;val)</span><br><span class="line">                <span class="built_in">leftRotate</span>(tree);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">rightLeftRotate</span>(tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> isComplete = <span class="number">1</span>, after = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode *tree)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    queue&lt;TreeNode *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(tree);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *temp = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (after) isComplete = <span class="number">0</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            after = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    TreeNode *tree = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        tree = <span class="built_in">insert</span>(tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">levelOrder</span>(tree);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s&quot;</span>, isComplete ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的深度高度层数">树的深度/高度/层数</h1><h2 id="介绍-2">介绍</h2><p><strong>深度定义是从上往下的，高度定义是从下往上的。</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952536.jpeg"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="总结">总结</h2><p>==<strong>高度=深度=层数</strong>==</p><blockquote><p>其中<strong>根结点</strong>的<strong>高度/层数/深度</strong>均为1</p></blockquote><h2 id="举例">举例</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952587.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><table><thead><tr class="header"><th>图</th><th></th></tr></thead><tbody><tr class="odd"><td>层数</td><td>第1层开始</td></tr><tr class="even"><td>最大层数</td><td>5</td></tr><tr class="odd"><td>深度</td><td>5</td></tr><tr class="even"><td>高度</td><td>5</td></tr></tbody></table><h1 id="树和森林">树和森林</h1><h2 id="树二叉树森林的关系">树、二叉树、森林的关系</h2><blockquote><p><strong><font color='blue'>树&lt; == &gt;二叉树&lt; ==&gt;森林</font></strong>（三者<strong><font color='red'>一一对应</font></strong>）</p><ul><li>树可以唯一地确定 二叉树 和 森林</li><li>二叉树（不含左子树）可以唯一地确定 树 和 森林</li><li>森林可以唯一地确定 树和二叉树</li></ul></blockquote><h2 id="树">树</h2><p>树(Tree)是n(n≥0)个结点的有限集合。在任意一棵非空树中，有以下两个性质：</p><ol type="1"><li>有且<strong>仅有一个特定的结点</strong>，称为根(Root)。</li><li>当n＞1时，其余的结点可分为m个互不相交的集合T1，T2，…，Tm，其中每一个集合都是一棵树，并且称为根的<strong>子树</strong>(Subtree)。</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952600.png"alt="树型结构实例" /><figcaption aria-hidden="true">树型结构实例</figcaption></figure><h2 id="森林">森林</h2><p>森林(Forest)是m(m≥0)棵互不相交的==<strong>树的集合</strong>==。对树中每个结点而言，其子树的集合即为森林</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952720.png"alt="image-20230924094551480" /><figcaption aria-hidden="true">image-20230924094551480</figcaption></figure><h2 id="树转化为二叉树">树转化为二叉树</h2><h3 id="方法">方法</h3><p>树中每个结点最多只有一个==<strong><font color='red'>最左边的孩子(长子)</font></strong>==和一个==<strong><font color='blue'>右邻的兄弟</font></strong>==。按照这种关系很</p><p>自然地就能将树转换成相应的二叉树：</p><ol type="1"><li>在所有兄弟结点之间<strong>加一连线</strong></li><li>对每个结点，除了保留与其<strong>长子</strong>的连线外，去掉该结点与其它孩子的连线。</li></ol><blockquote><p>注</p><ul><li>二叉树的<strong><font color='cyan'>左结点为儿子节点</font></strong>，<strong><font color='purple'>右结点为兄弟节点</font></strong></li><li>任何一棵和==<strong><font color='red'>树</font></strong>==对应的<strong><font color='red'>二叉树</font></strong>，其==<strong><font color='blue'>右子树必定为空</font></strong>==</li></ul></blockquote><h3 id="树的遍历">树的遍历</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952797.png"alt="image-20221108225001648" /><figcaption aria-hidden="true">image-20221108225001648</figcaption></figure><blockquote><p>◆由于一个结点可以有两棵以上的子树，因此一般<strong><font color='red'>不讨论中根遍历</font></strong>。</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952916.png"alt="image-20221108225308793" /><figcaption aria-hidden="true">image-20221108225308793</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952127.png"alt="image-20221108225333415" /><figcaption aria-hidden="true">image-20221108225333415</figcaption></figure><blockquote><blockquote><ol type="1"><li><p>树的==<strong><font color='red'>先序遍历</font></strong>==与转化为二叉树的==<strong><font color='red'>先序遍历</font></strong>==相同</p></li><li><p>树的==<strong><font color='red'>后序遍历</font></strong>==与转化为二叉树的==<strong><font color='red'>中序遍历</font></strong>==相同</p></li></ol></blockquote></blockquote><h3 id="例一">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952060.jpeg"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="例二">例二</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952136.png"alt="image-20221030194329120" /><figcaption aria-hidden="true">image-20221030194329120</figcaption></figure><h2 id="森林转化二叉树">森林转化二叉树</h2><h3 id="方法-1">方法</h3><ol type="1"><li>将森林中的每一棵<strong>树</strong>转化为<strong>二叉树</strong></li><li>将各二叉树的根节点视为兄弟结点连在一起</li><li>再将其转化为二叉树</li></ol><blockquote><p>注：</p><ol type="1"><li>任何一个==<strong>树或森林</strong>==可以唯一地对应到一棵<strong>二叉树</strong></li><li>任何一个==<strong>二叉树</strong>==可以唯一地对应到一棵<strong>树或森林</strong></li></ol></blockquote><h3 id="例一-1">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952176.png"alt="image-20221030194059329" /><figcaption aria-hidden="true">image-20221030194059329</figcaption></figure><h4 id="第一步">第一步</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952254.png"alt="image-20230924094405918" /><figcaption aria-hidden="true">image-20230924094405918</figcaption></figure><h4 id="第二步">第二步</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952755.png"alt="image-20230924094423337" /><figcaption aria-hidden="true">image-20230924094423337</figcaption></figure><blockquote><p>将==<strong>右边的一棵树</strong>==依次作为==<strong>左边那棵树</strong>==的<strong>右子树</strong>，最后得到的那<strong>1棵树</strong>即为森林对应的二叉树</p></blockquote><h4 id="第三步">第三步</h4><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952695.png" alt="image-20230924094513604" style="zoom:33%;" /></p><h3 id="例二-1">例二</h3><p>​ 设森林 F中有三棵树，第一、第二、第三棵树的结点个数分别为M1、M2和M3。与森林 F对应的二叉树根结点的左子树上的节点个数为（），根结点的右子树上的结点个数是（)</p><p>A .M1 B .M1+M2 C . M3 D .M2+M3</p><p>E .M1-1 F: M2-1 G .M2 H .M3-1</p><blockquote><p>答案：==<strong>E D</strong>==</p></blockquote><blockquote><p>二叉树根节点<strong>右子树</strong>由森林<font color='red'><strong>除第一棵以外的</strong></font>==其他所有树==组成</p></blockquote><h3 id="例三">例三</h3><p>​ 设森林F对应的二叉树为 B ，它有 m 个结点，B的根为 p，p的右子树结点个数为 n，森林 F 中第一棵树的结点个数是（A） A.m-n B.m-n-1C:n+1 D.条件不足，无法确定</p><h1 id="二叉树的线索化">二叉树的线索化</h1><h2 id="方法-2">方法</h2><h3 id="头结点的设定">头结点的设定</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952955.png"alt="image-20220928190044829" /><figcaption aria-hidden="true">image-20220928190044829</figcaption></figure><h3 id="结点的设定">结点的设定</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952816.png"alt="image-20220928190232383" /><figcaption aria-hidden="true">image-20220928190232383</figcaption></figure><h2 id="例题-2">例题</h2><p>​已知二叉树的先序、中序和后序序列如下（其中有一些看不清的字母用*表示）：</p><p>前序序列：<code>*BC***G*</code> 中序序列：<code>CB*EAGH*</code>后序序列:<code>*EDB**FA</code></p><p>(1)请先补充<code>*</code>处的字母 (2)再构造一棵符合条件的二叉树(3)最后画出带头结点的中序线索链表。</p><h3 id="答案">答案</h3><p>前序：ABCDEFGH</p><p>后序：CBDEAGHF</p><p>后序：CEDBHGFA</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952200.png"alt="image-20220928191441993" /><figcaption aria-hidden="true">image-20220928191441993</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309240952307.png"alt="image-20220928191522050" /><figcaption aria-hidden="true">image-20220928191522050</figcaption></figure><blockquote><p>注：</p><ol type="1"><li>每个结点用<strong>5个域</strong>来表示</li><li>注意根节点<code>ltag=0;lright=1;</code></li><li><code>tag=1;</code>的指针指向前驱后继，用==<strong>带箭头的虚线</strong>==表示；</li><li><code>tag=0;</code>的指针指向左右孩子，用==<strong>不带箭头的实线</strong>==表示；</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ALV树画法</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E7%94%BB%E6%B3%95/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/AVL%E6%A0%91%E7%94%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="avl树画法">AVL树画法</h1><h2 id="基本理论"><strong>基本理论：</strong></h2><h3 id="一avl树的前身">一：AVL树的前身</h3><p>平衡二叉树（AVL树）的前身是<strong>二叉排序树（二叉查找树）</strong>。</p><blockquote><p>二叉排序树的一个重要性质：左子树上的所有结点都小于根结点，右子树上的所有结点都大于根节点。<strong>简而言之，左小右大。</strong></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916761.jpeg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图1</p><span id="more"></span><p>如图1。10左边的数都比它小，右边的数都比它大。对于9和15来说也是一样。<strong>所以如果要插入一个数字14，那么该如何做呢？</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916545.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图2</p><p>如图2。14比10大，所以在10的右边。比15小，所以在15的左边。比12大，所以在12的右边。</p><h3 id="二何来平衡">二、何来“平衡”？</h3><p>引入概念，<strong>平衡因子。即左子树与右子树的高度（深度）差。</strong>请为上图，标上平衡因子。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916731.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图3</p><p>如图3所示。<strong>平衡二叉树要求平衡因子的绝对值不大于1</strong>，所以该图就是一个标准的平衡二叉树。</p><hr /><h3 id="三不平衡与旋转">三：<strong>不平衡与旋转：</strong></h3><p><strong>不平衡即出现了绝对值大于1的平衡因子。</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916119.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图4（LL旋转）</p><p>插入3之后，9的平衡因子变为2。<strong>二叉树失去平衡，需要通过旋转来重新平衡。</strong></p><h3 id="四旋转类型的判定">四：<strong>旋转类型的判定：</strong></h3><p><font color='red'><strong>离插入点最近的</strong></font>，平衡因子的绝对值大于1的点称为<strong>失衡点</strong>。</p><p>==<font color='blue'><strong>从失衡点开始，沿树“寻找”插入点。且只记录“寻找”的前两步的路径方向。由此判定旋转类型。</strong></font>==</p><p>以图4为例。插入点为3，失衡点为9。从9开始，“寻找”3。<strong>发现3在9的左子树的左子树上。</strong>将路径简记为“左左”。所以需要<strong>LL旋转</strong>。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916606.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图5（LR旋转）</p><p>如图5。从失衡点5开始，“寻找”插入点4。将路径简记为“左右”。所以需要<strong>LR旋转</strong>。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916620.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图6（RR旋转）</p><p>如图6。“寻找”路径简记为“右右”。所以需要<strong>RR旋转</strong>。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916869.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>​ 图7（RL旋转）</p><p>如图7。“寻找”路径简记为“右左”。所以需要<strong>RL旋转</strong>。</p><hr /><h2 id="旋转方法"><strong>旋转方法：</strong></h2><p>方法与旋转类型无关。且一种方法就可应对四种旋转类型。</p><p><strong><font color='red'>从失衡点开始，经过两步“寻找”，则必然遇到两个结点。加上失衡点，总共三个结点。</font>假设为A、B、C，并规定A&lt;B&lt;C。将这三个结点单独拿出来。把其中的“中位数”B作为根结点，A作为B的左子树，C作为B的右子树，构建一个新的平衡二叉树。并将该新树的根B放到原来的失衡点上。其中，A和C的子树不动。【当B原来的左子树根≠A时，把它接到A的右边。当B原来的右子树根≠C时，把它接到C的左边。】</strong>（框内步骤不一定会用到，需要具体问题具体分析。）</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916234.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>旋转方法图解</p><p>问：那A原来的右子树和C原来的左子树怎么办？</p><p>答：它们不存在，或者A原来的右子树根=B or C，C原来的左子树根=A orB。</p><p>问：B的右子树恰好是C</p><p>答：这个时候就<strong>不用将</strong>B的右子树“顺理成章”的放在新树C的左边了</p><h3 id="具体示例"><strong>具体示例：</strong></h3><p><strong>1.将图4重新平衡</strong></p><p>失衡点为9。<strong>“寻找”路径上的三个点为9、4、3。取“中位数”4为树根，</strong>生成新的平衡二叉树。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916846.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>把树根4替换到失衡点上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916902.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>二叉树重新获得平衡。</p><p>*<strong>2.画出以序列{25,27,30,12,11,18,14,20,15,22}构造的一棵平衡二叉树*</strong></p><p>首先，<strong>按照左小右大的原则，画二叉树。依次插入25,27,30。</strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916188.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入30后，二叉树失衡。显然，需要进行<strong>RR旋转。</strong>取“中位数”27作树根，25作左子树，30作右子树，生成新的平衡二叉树。并替换到失衡点25上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916309.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>继续插入12，11。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916724.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入11后，二叉树又失衡了。显然，需要进行<strong>LL旋转。</strong>取“中位数”12作树根，11作左子树，25作右子树，生成新的平衡二叉树。并替换到失衡点25上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916723.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>继续插入18。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290916161.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入18后，二叉树双失衡了。插入点为18，失衡点为27。“寻找”路径记为“左右”，因此需要<strong>LR旋转</strong>。<strong>在27,12,25中</strong>，取“中位数”25作树根，12作左子树，27作右子树，生成新的平衡二叉树。<strong>且25的左子树根18“顺理成章”地放在12的右侧。</strong>（不懂请看旋转方法图解）并替换到失衡点27上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915364.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>继续插入14，20，15。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915337.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入15后，二叉树叒失衡了。插入点为15，失衡点为12。“寻找”路径记为“右左”，因此需要<strong>RL旋转</strong>。<strong>在12,18,14中</strong>，取“中位数”14作树根，12作左子树，18作右子树，生成新的平衡二叉树。<strong>且14的右子树根15“顺利成章”地放在18的左侧。</strong>（不懂请看旋转方法图解）并替换到失衡点12上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915412.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>最后插入22。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915594.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>插入22后，二叉树叕失衡了。插入点为22，失衡点为25。“寻找”路径记为“左右”，因此需要<strong>LR旋转</strong>。<strong>在25,14,18中</strong>，取“中位数”18作树根，14作左子树，25作右子树，生成新的平衡二叉树。<strong>且18的左子树根15“顺理成章”地放在14的右侧，18的右子树根20“顺利成章”地放在25的左侧。</strong>（不懂请看旋转方法图解）并替换到失衡点25上。</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915415.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>最终的平衡二叉树，如图。</p><h1 id="例题">例题</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915234.png"alt="image-20221111200549327" /><figcaption aria-hidden="true">image-20221111200549327</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290915235.jpg"alt="59b2f7b53f3380a64c814219d3e04bb" /><figcaptionaria-hidden="true">59b2f7b53f3380a64c814219d3e04bb</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="时间空间复杂度">时间空间复杂度</h1><h2 id="例一">例一</h2><p>设 <em>n</em>是描述问题规模的非负整数，下列程序段的时间复杂度是：<strong><font color='red'>C</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( n &gt;= (x+<span class="number">1</span>)*(x+<span class="number">1</span>) )</span><br><span class="line">    x = x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>A. <em>O</em>(<em>n</em>2)</p><p>B. <em>O</em>(<em>n</em>)</p><p>C. <em>O</em>(n<sup>1/2</sup>)</p><p>D. <em>O</em>(logn) <imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914207.png"alt="image-20221019111453276" /></p><span id="more"></span><h2 id="例二">例二</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914217.png" alt="image-20221019111930977" style="zoom:80%;" /></p><h2 id="例三">例三</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914238.png"alt="image-20221019111828861" /><figcaption aria-hidden="true">image-20221019111828861</figcaption></figure><h2 id="例四">例四</h2><p>设n nn是描述问题规模的非负整数，下面程序片段的时间复杂度是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">2</span>；</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">x=<span class="number">2</span>*x;</span><br></pre></td></tr></table></figure><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914208.png" alt="image-20221104182829170" style="zoom: 50%;" /></p><h2 id="例五">例五</h2><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914201.png" alt="image-20221104182958557" style="zoom:150%;" /></p><h2 id="例六">例六</h2><p>下列函数的时间复杂度是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span> <span class="params">( <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sum&lt; n) sum += ++ i;</span><br><span class="line"><span class="keyword">return</span> i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914190.png"alt="image-20221104183451111" /><figcaption aria-hidden="true">image-20221104183451111</figcaption></figure><p><strong><code>B</code></strong></p><h1 id="存储密度">存储密度</h1><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914686.png" alt="image-20221016175203394" style="zoom:150%;" /></p><h2 id="解析">解析</h2><h3 id="数据逻辑结构">数据逻辑结构</h3><p>1.<strong>集合结构</strong>:数据元素之间没有任何关系.</p><p>2.<strong>线性结构</strong>:数据元素之间定义了线性关系.1对1</p><p>3.<strong>树形结构</strong>:数据元素之间定义了层次关系 1对多.</p><p>4.<strong>图状结构</strong>:数据元素之间定义了网状关系 多对多.</p><h3 id="数据存储结构">数据存储结构</h3><ol type="1"><li><p><strong>顺序存储结构</strong>:借助数据元素之间的相对位置来表示元素之间的逻辑结构.（vector动态数组、deque双端队列、stack栈容器、queue队列容器）</p></li><li><p><strong>链式存储结构</strong>:借助数据元素之间的元素的指针表示数组元素的逻辑结构.</p></li><li><p><strong>散列存储结构</strong>:顺序存储+算列.</p></li><li><p><strong>索引存储结构</strong>:顺序存储+索引.</p></li></ol><blockquote><p><strong>数据逻辑结构在计算机存储器中的表示称为数据的<ahref="https://so.csdn.net/so/search?q=存储结构&amp;spm=1001.2101.3001.7020">存储结构</a></strong>（或存储表示），也称为<strong>物理结构</strong>。</p></blockquote><h3 id="存储密度-1">存储密度</h3><h4 id="定义">定义：</h4><pre><code>存储密度 = &lt;u&gt;结点&lt;/u&gt;**数据**本身所占存储量 / &lt;u&gt;结点&lt;/u&gt;**结构**所占的存储量</code></pre><ul><li>结构数据本身所占存储量 = 数据域所占存储量</li><li>结点结构所占的存储总量 = （数据域+结点域）所占存储量</li><li>注：指针存储量与机器位数有关，如32位机指针大小为32bit，4Byte</li></ul><h4 id="注意">注意：</h4><ol type="1"><li><p>==<strong>顺序表</strong>==的存储密度等于1</p></li><li><p>假设单链表的结点的<strong>数据域</strong>占的存储量为N，结点的<strong>指针域</strong>所占的存储量为M，则存储密度= N / (N+M)，所以<strong>单链表的密度是小于1</strong>的。</p></li></ol><h4 id="举例">举例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">chainList</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chainList</span> *next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>该链表的</p><ul><li><p>结构数据本身所占存储量 = sizeof(int) = 2</p></li><li><p>结点结构所占的存储总量 = 8(64位机)+2</p></li><li><p>存储密度 = 20%</p></li></ul><h1 id="最小生成树">最小生成树</h1><p>对某个带权连通图构造最小生成树，以下说法中正确的是（ ）。</p><p>Ⅰ.该图的所有最小生成树的总代价一定是唯一的</p><p>Ⅱ.其<strong><font color='red'>所有</font></strong>权值<strong><font color='red'>最小的</font></strong>边一定会出现在所有的最小生成树中</p><p>Ⅲ.用普里姆（Prim）算法从不同顶点开始构造的所有最小生成树<strong><font color='red'>一定相同</font></strong></p><p>Ⅳ.使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树<font color='red'><strong>总不相同</strong></font></p><ol type="A"><li>仅Ⅰ、Ⅲ</li></ol><p>==<strong>B. 仅Ⅰ</strong>==</p><ol start="3" type="A"><li><p>仅Ⅱ</p></li><li><p>仅Ⅱ、Ⅳ</p></li></ol><blockquote><p>A：由一个<strong>带权连通图</strong>构造的最小生成树可能有多棵，但其代价一定是唯一的；</p><p>B：<strong><font color='red'>权值最小的边可能不止一条</font></strong>，这些不唯一的最小权值边<strong><font color='blue'>不一定都会</font></strong>出现在所有的最小生成树中，但至少会有一条权值最小的边出现在MBT中（根据Kruskal算法至少会有一条，多条可能导致<strong>内部联通</strong>）</p><p>C：当存在<strong><font color='blue'>多条权值相同的边</font></strong>时，用普里姆（Prim）算法从不同顶点开始得到的最小生成树不一定相同（不唯一）；</p><p>D：使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树不一定总不相同</p><ul><li>若图中<strong><font color='red'>最小生成树唯一时</font>，==无论用哪种算法==，得到的最小生成树都是相同的</strong>。</li><li>若图中<strong><font color='red'>最小生成树不唯一时</font>，prim和Kruskal算法得到的最小生成树并不总是相同</strong>。</li></ul></blockquote><h1 id="数据基本概念">数据基本概念</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914908.png"alt="image-20221104184520267" /><figcaption aria-hidden="true">image-20221104184520267</figcaption></figure><blockquote><p>数据元素是数据的==<strong><font color='red'>基本（最小）单位</font></strong>==</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914913.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914895.png"alt="image-20221109214634474" /><figcaption aria-hidden="true">image-20221109214634474</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914037.png"alt="image-20221109214836979" /><figcaption aria-hidden="true">image-20221109214836979</figcaption></figure><blockquote><p>DFS/BFS：邻接矩阵O（n<sup>2</sup>） 邻接表O（n+e）</p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290914968.png"alt="image-20221110140604533" /><figcaption aria-hidden="true">image-20221110140604533</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀、中缀、后缀表达式</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%8D%E7%BC%80%EF%BC%8C%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%8D%E7%BC%80%EF%BC%8C%E4%B8%AD%E7%BC%80%EF%BC%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概念">概念</h2><p>前缀表达式（波兰式），中缀表达式，后缀表达式（逆波兰式）</p><ul><li>区别在于<strong>运算符</strong>相对与<strong>操作数</strong>的位置不同：<ul><li>前缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之前</strong>；</li><li>中缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之间</strong>；</li><li>后缀表达式的<strong>运算符</strong>位于与其相关的操作数<strong>之后</strong>；</li></ul></li><li>举例： (3 + 4) × 5 - 6 就是中缀表达式 - × + 3 4 5 6 前缀表达式 3 4 +5 × 6 - 后缀表达式</li></ul><span id="more"></span><h2 id="中缀表达式转后缀表达式">1、中缀表达式转后缀表达式：</h2><p>假定有中缀表达式A：1 + (( 2 + 3)* 4 ) –5，请将它转化为后缀表达式。</p><h3 id="方法一直接转换法">方法一：直接转换法</h3><p>（1）首先确定表达式表达式A的运算顺序，然后加括号：（（1 + (( 2 + 3)*4 )） – 5 ）</p><p>（2）从最里面的一层括号开始运算，转换成后缀表达式的方法为：（忽略括号）数字在前，符号在后。</p><p>​ 1）( 2 + 3) =&gt; 23+</p><p>​ 2) (( 2 + 3)* 4 ) =&gt; 23+4*</p><p>​ 3) （1 + (( 2 + 3)* 4 )）=&gt; 123+4*+[按照运算次序，从左到右排列]</p><p>​ 4）（（1 + (( 2 + 3)* 4 )） – 5 ）=&gt; 123+4*+ 5-</p><p>​ 后缀表达式为：12 3 + 4 * + 5 –</p><h3 id="方法二利用表达式树">方法二：利用表达式树</h3><p>​首先将中缀表达式转换为表达式树，然后<strong>后序遍历</strong>表达式树，所得结果就是后缀表达式。详细过程见<ahref="C:\Users\cuiluyi\Desktop\编程随想\DAG和二叉树描述表达式.md">DAG和二叉树描述表达式</a>如上述表达式的表达式树为：</p><blockquote><p><ahref="路径....................................">自定义名称</a>跳转文件，详细见<ahref="%5B(69条消息)%20Typora使用技巧%20%7C%20各种跳转%20【必备】_想要腹肌的熊的博客-CSDN博客_typora链接跳转到其他文件%5D(https://blog.csdn.net/qq_41907769/article/details/121722716)">Typora使用技巧| 各种跳转</a></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290925432.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="法三">法三</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290941178.png"alt="image-20230929094150044" /><figcaption aria-hidden="true">image-20230929094150044</figcaption></figure><blockquote><p>任意时刻<strong>栈顶的优先级</strong>都要<strong>大于</strong>其<strong><font color='red'>下面一个</font></strong>的优先级</p></blockquote><h4 id="例一">例一</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290942146.png"alt="image-20230929094204000" /><figcaption aria-hidden="true">image-20230929094204000</figcaption></figure><h4 id="例二">例二</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290942448.png"alt="image-20221103161920147" /><figcaption aria-hidden="true">image-20221103161920147</figcaption></figure><blockquote><p><strong><font color='red'>B</font></strong></p></blockquote><h2 id="中缀表达式转为前缀表达式">2、中缀表达式转为前缀表达式</h2><p>假定有中缀表达式1 + (( 2 + 3)* 4 ) – 5，请将它转化为前缀表达式。</p><p>### 方法一：直接转换法</p><p>（1）首先确定表达式表达式A的运算顺序，然后加括号：（（1 + (( 2 + 3)*4 )） – 5 ）</p><p>（2）从最里面的一层括号开始运算，转换成前缀表达式的方法为：（忽略括号）符号在前，数字在后。</p><p>​ 1）( 2 + 3) =&gt; +23</p><p>​ \2) (( 2 + 3)* 4 ) =&gt; *+234</p><p>​ \3) （1 + (( 2 + 3)* 4 )）=&gt; +1*+234</p><p>​ 4）（（1 + (( 2 + 3)* 4 )） – 5 ）=&gt; -+1*+2345</p><p>​ 前缀表达式为：-+1*+2345</p><h3 id="方法二利用表达式树-1">方法二：利用表达式树</h3><p>首先将中缀表达式转换为表达式树，然后先序遍历表达式树，所得结果就是前缀表达式。</p><p>将中缀表达式转化为表达式树的方法：表达式树的树叶是操作数，而其他节点为操作符，根结点为优先级最低且靠右的操作符（如上述表达式优先级最低是-和+，但-最靠右，所以根为-），圆括号不包括。</p><p>经过前序遍历所得前缀表达式为：- + 1 * + 2 3 4 5</p><h2 id="后缀表达式-转-中缀表达式">3、后缀表达式 转 中缀表达式</h2><p>假定有后缀表达式1 2 3 + 4 * +5 – ，请将它转化为前缀表达式。</p><p>### 方法一：利用表达式树：</p><p>​从左到右扫面后缀表达式，一次一个符号读入表达式。如果符号是操作数，那么就建立一个单节点树并将它推入栈中。如果符号是操作符，那么就从栈中弹出两个树T1和T2（T1先弹出）并形成一颗新的树，该树的根就是操作符，它的左、右儿子分别是T2和T1。然后将指向这棵新树的指针压入栈中。</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943091.png"alt="img" /> 扫描123后</p><p>前三个符号是操作数，因此创建三颗单节点树并将指向它们的指针压入栈中。</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943201.png"alt="img" /> 扫描+后</p><p>“+”被读入，因此指向最后两颗树的指针被弹出，形成一颗新树，并将指向新树的指针压入栈中。以下的流程图以相同原理执行。</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943954.png"alt="img" /> 扫描4和*后</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943074.png"alt="img" /> 扫描+和5后</p><p><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290943478.png"alt="img" /> 扫描-后</p><p>最后再中序遍历所得的表达式树即得到我们所需的中缀表达式：1+（（2+3）*4）-5</p><h2 id="例题">例题</h2><h3 id="表达式转换">表达式转换</h3><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。</p><h3 id="输入格式">输入格式:</h3><p>输入在一行中给出不含空格的中缀表达式，可包含<code>+</code>、<code>-</code>、<code>*</code>、<code>\</code>以及左右括号<code>()</code>，表达式不超过20个字符。</p><h3 id="输出格式">输出格式:</h3><p>在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。</p><h3 id="输入样例">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2+3*(7-4)+8/4</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 7 4 - * + 8 4 / +</span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string c;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;p;</span><br><span class="line">p[<span class="string">&quot;+&quot;</span>]=<span class="number">1</span>;p[<span class="string">&quot;-&quot;</span>]=<span class="number">1</span>;p[<span class="string">&quot;*&quot;</span>]=<span class="number">2</span>;p[<span class="string">&quot;/&quot;</span>]=<span class="number">2</span>;p[<span class="string">&quot;(&quot;</span>]=<span class="number">3</span>;p[<span class="string">&quot;)&quot;</span>]=<span class="number">3</span>;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    vector&lt;string&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;c.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(c[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c[i]&lt;=<span class="string">&#x27;9&#x27;</span>||i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;(c[j]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c[j]&lt;=<span class="string">&#x27;9&#x27;</span>||c[j]==<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">j++;</span><br><span class="line">            l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i,j-i));    </span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;c[i+<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;c[j]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">j++;</span><br><span class="line">    l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i+<span class="number">2</span>,j-i<span class="number">-2</span>));</span><br><span class="line">    i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;c[i+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=i+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;c.<span class="built_in">size</span>()&amp;&amp;c[j]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">j++;</span><br><span class="line">    l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i+<span class="number">1</span>,j-i<span class="number">-1</span>));</span><br><span class="line">    i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l.<span class="built_in">push_back</span>(c.<span class="built_in">substr</span>(i,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">stack&lt;string&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l[i]==<span class="string">&quot;+&quot;</span>||l[i]==<span class="string">&quot;-&quot;</span>||l[i]==<span class="string">&quot;*&quot;</span>||l[i]==<span class="string">&quot;/&quot;</span>||l[i]==<span class="string">&quot;(&quot;</span>||l[i]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||(p[l[i]]&gt;p[s.<span class="built_in">top</span>()]&amp;&amp;l[i]!=<span class="string">&quot;)&quot;</span>)||s.<span class="built_in">top</span>()==<span class="string">&quot;(&quot;</span>)</span><br><span class="line">s.<span class="built_in">push</span>(l[i]);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l[i]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">top</span>()!=<span class="string">&quot;(&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;p[l[i]]&lt;=p[s.<span class="built_in">top</span>()]&amp;&amp;s.<span class="built_in">top</span>()!=<span class="string">&quot;(&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">push</span>(l[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;cout&lt;&lt;(flag==<span class="number">0</span>?<span class="string">&quot;&quot;</span>:<span class="string">&quot; &quot;</span>)&lt;&lt;l[i];flag=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树结点的计算问题</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="树结点的计算问题">树结点的计算问题</h1><h2 id="树的种数">树的种数</h2><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291052715.png"alt="image-20230929105248559" /><figcaption aria-hidden="true">image-20230929105248559</figcaption></figure><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309291053249.png"alt="image-20230929105310153" /><figcaption aria-hidden="true">image-20230929105310153</figcaption></figure><h1 id="一完全二叉树中结点问题">一：完全二叉树中结点问题</h1><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919576.png"alt="image-20221105154910530" /><figcaption aria-hidden="true">image-20221105154910530</figcaption></figure><blockquote><h1id="完全二叉树n10或1"><font color='red'>完全二叉树，n<sub>1</sub>=0或1</font></h1></blockquote><h3 id="分析">分析：</h3><p>设叶子节点个数为n0,度为1的节点个数为n1,度为2的节点个数为n2</p><p>则</p><p>n0+n1+n2=n (1)</p><p>n0=n2+1 (2)</p><p>由(1)(2) ==&gt; ==<strong>n0=(n+1-n1)/2</strong>==</p><h3 id="总结">总结:</h3><p>由<strong><u>完全二叉树的性质可知：n1=0 或 1</u></strong></p><ol type="1"><li><p>当<strong>n1=0</strong>或<strong>n为奇数</strong>时，n0=(n+1)/2;</p></li><li><p>当<strong>n1=1</strong>或<strong>n为偶数</strong>时，n0=n/2;</p></li></ol><blockquote><p>综合1，2可得：</p><p>一个具有n个节点的<strong>完全二叉树</strong>，其<strong>叶子节点的个数n0</strong>为：==<strong>n/2 向上取整，或者(n+1)/2 向下取整</strong>==</p></blockquote><hr /><h3 id="例题">例题</h3><h4 id="例1">例1：</h4><p>设一棵完全二叉树共有699个节点，则在该二叉树中的叶节点数为？</p><p>——350</p><hr /><h4 id="例2">例2</h4><p>一棵完全二叉树<u>第六层有</u>8个叶结点（根为第一层），则结点个数<u>最多有</u>（）个。</p><h5 id="分析-1">分析</h5><ol type="1"><li><p><strong>二叉树第k层最多有 2^(k-1) 个节点</strong></p><p>第一层最多有1个节点</p></li></ol><p>​ 第二层最多有2个节点</p><p>​ 第三层最多有4个节点</p><p>​ 第四层最多有8个节点</p><p>​ 第五层最多有16个节点</p><p>​ 第六层最多有32个节点</p><ol start="2" type="1"><li><p><strong>完全二叉树的叶节点只可能出现在后两层</strong>，<strong>除最后一层可能不满，其余层均满</strong></p><p>第六层有8（&lt;2<sup>6-1</sup>=32）个结点，说明<strong>第六层</strong>是完全二叉树的<strong>最后两层</strong>之一</p></li></ol><ul><li><p>==<strong>如果完全二叉树有6层</strong>==，则前5层是满二叉树，总节点数n=（2<sup>5</sup>-1）+8=39</p></li><li><p>如果完全二叉树有7层，则</p><ul><li><p>前6层是满二叉树，前六层总节点数目为2<sup>6</sup>-1=63</p></li><li><p>第六层有8个叶子节点，则有32-8=24个非叶子节点</p></li><li><p><span class="math display">\[  第七层最多有24*2=48个叶子节点  \]</span></p></li></ul><p>故总节点数目为63+24*2=111</p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919577.jpg"alt="10579c757472bc18bd16578d42dcb1d" /><figcaptionaria-hidden="true">10579c757472bc18bd16578d42dcb1d</figcaption></figure></li></ul><h1 id="二树的结点问题">二：树的结点问题</h1><h2 id="例1-1">例1</h2><p>已知在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶子结点的个数为？</p><h3 id="分析-2">分析</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919578.jpg"alt="daf0765aa213be23c7bff6d820e6c92" /><figcaptionaria-hidden="true">daf0765aa213be23c7bff6d820e6c92</figcaption></figure><blockquote><p>注：==<strong>若树的节点数为n，则边数为n-1</strong>==</p></blockquote><h2 id="例2-1">例2</h2><p>一棵度为3的树中，有3度的结点100个，有2度的结点200个，有叶子结点多少个？</p><h3 id="分析-3">分析</h3><p><img src="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290921109.png" alt="image-20221002222557971" style="zoom: 18%;" /></p><h3 id="例三">例三</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919580.jpg"alt="6eb138545a60b02c6aace0b7aa36ab2" /><figcaptionaria-hidden="true">6eb138545a60b02c6aace0b7aa36ab2</figcaption></figure><h4 id="解析">解析</h4><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919581.jpg"alt="a07999b6a7af0f1122d73a179281c15" /><figcaptionaria-hidden="true">a07999b6a7af0f1122d73a179281c15</figcaption></figure><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309290919582.jpg"alt="3f1a63bfca3d22b868487ba223510bc" /><figcaptionaria-hidden="true">3f1a63bfca3d22b868487ba223510bc</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DAG、BT描述表达式</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DAG%E3%80%81BT%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/DAG%E3%80%81BT%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式二叉树">表达式二叉树</h1><h2 id="介绍">介绍</h2><p>用二叉树来表示一个简单算术表达式，树的每一个结点包括一个运算符或运算数。</p><h2 id="步骤">步骤</h2><p><strong><font color='red'>把操作数作为叶结点，操作符作为非叶节点</font></strong></p><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847728.png"alt="image-20221101205736696" /><figcaption aria-hidden="true">image-20221101205736696</figcaption></figure><blockquote><p>表达式二叉树</p><ul><li>==<strong><font color='orange'>叶结点的个数</font></strong>即为<strong><font color='red'>操作数的个数<font color='cyan'>（可以重复）</font></strong>==</li><li><strong><font color='red'>操作符均位于非叶子节点</font></strong></li><li><strong><font color='green'>结点个数 = 操作数的个数 +操作符的个数</font></strong></li></ul></blockquote><span id="more"></span><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847729.png"alt="image-20221101210106099" /><figcaption aria-hidden="true">image-20221101210106099</figcaption></figure><blockquote><ol type="1"><li>表达式二叉树的<strong><font color='red'>前序遍历</font></strong>序列和<strong><font color='red'>后序遍历</font></strong>序列即为相应的<strong><font color='blue'>前缀表达式</font></strong>和<strong><font color='blue'>后缀表达式</font></strong></li><li>表达式二叉树的<strong><font color='red'>中序遍历</font></strong>序列与中缀表达式有可能不符合</li></ol></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847730.jpg"alt="821ba35825723c1d45f5ee6ca406d33" /><figcaptionaria-hidden="true">821ba35825723c1d45f5ee6ca406d33</figcaption></figure><ul><li><h2 id="解答-b">解答 <font color='red'>B</font></h2></li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847732.jpg"alt="13312021776171515" /><figcaption aria-hidden="true">13312021776171515</figcaption></figure><h1id="有向无环图描述表达式"><font color='purple'>有向</font>无环图描述表达式</h1><h2 id="步骤-1">步骤</h2><ol type="1"><li>把各个<strong>操作数<font color='red'>不重复地</font></strong>排成一排</li><li>标出各个运算符的<strong><font color='blue'>生效顺序</font></strong>（先算左边括号或者先算右边括号均可以）</li><li>==<strong>按运算先后顺序加入运算符</strong>==，不同的运算级别层次不同，过程中如果已经存在某部分，则直接用</li><li>最后生成的图就是有向无环图</li></ol><blockquote><ol type="1"><li><strong>用有向无环图表示表达式的目的就是<font color='red'>去掉相同的部分</font>，压缩存储，节省空间</strong></li><li>DAG中==<strong>顶点的个数</strong>即为<strong><font color='gree'>运算符号个数（无重复）</font></strong>和<strong><font color='cyan'>运算数个数（无重复）</font></strong>之和==</li></ol></blockquote><h2 id="例题8">例题8</h2><h3 id="例一">例一</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847733.png"alt="image-20221101203825317" /><figcaption aria-hidden="true">image-20221101203825317</figcaption></figure><blockquote><p>注意：<strong><code>( x + y )( ( x + y ) / x )</code><font color='red'>省略了一个<code>*</code></font></strong></p></blockquote><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160848334.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="例二">例二</h3><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160847734.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map应用</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/map%E5%BA%94%E7%94%A8/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/map%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="单身狗"><strong>1065 单身狗</strong></h1><h2 id="题目">题目</h2><p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p><h3 id="输入格式">输入格式：</h3><p>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10000），为参加派对的总人数；随后一行给出这 M 位客人的ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p><h3 id="输出格式">输出格式：</h3><p>首先第一行输出落单客人的总人数；随后第二行按 ID递增顺序列出落单的客人。ID 间用 1个空格分隔，行的首尾不得有多余空格。</p><span id="more"></span><h3 id="输入样例">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">11111 22222</span><br><span class="line">33333 44444</span><br><span class="line">55555 66666</span><br><span class="line">7</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333</span><br></pre></td></tr></table></figure><h3 id="输出样例">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10000 23333 44444 55555 88888</span><br></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//find函数 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,t1,t2;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">p[t1]=t2;p[t2]=t1;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans,<span class="built_in">t</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">cin&gt;&gt;t[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">find</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>(),p[t[i]]);</span><br><span class="line"><span class="keyword">if</span>(it==t.<span class="built_in">end</span>())</span><br><span class="line">ans.<span class="built_in">push_back</span>(t[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%05d&quot;</span>,i==<span class="number">0</span>?<span class="string">&quot;&quot;</span>:<span class="string">&quot; &quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第22-23行代码不能写成<del><code>if(find(t.begin(),t.end(),p[t[i]]==t.end())</code></del></p></blockquote><h1 id="危险品装箱"><strong>1090 危险品装箱</strong></h1><h2 id="题目-1">题目</h2><p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。</p><p>本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。</p><h3 id="输入格式-1">输入格式：</h3><p>输入第一行给出两个正整数：<em>N</em> (≤104)是成对的不相容物品的对数；<em>M</em> (≤100) 是集装箱货品清单的单数。</p><p>随后数据分两大块给出。第一块有 <em>N</em>行，每行给出一对不相容的物品。第二块有 <em>M</em>行，每行给出一箱货物的清单，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K G[1] G[2] ... G[K]</span><br></pre></td></tr></table></figure><p>其中 <code>K</code> (≤1000) 是物品件数，<code>G[i]</code>是物品的编号。简单起见，每件物品用一个 5位数的编号代表。两个数字之间用空格分隔。</p><h3 id="输出格式-1">输出格式：</h3><p>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出<code>Yes</code>，否则输出 <code>No</code>。</p><h3 id="输入样例-1">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">20001 20002</span><br><span class="line">20003 20004</span><br><span class="line">20005 20006</span><br><span class="line">20003 20001</span><br><span class="line">20005 20004</span><br><span class="line">20004 20006</span><br><span class="line">4 00001 20004 00002 20003</span><br><span class="line">5 98823 20002 20003 20006 10010</span><br><span class="line">3 12345 67890 23333</span><br></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;map&gt;</span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// int main() &#123;</span></span><br><span class="line"><span class="comment">//     int n, k, t1, t2;</span></span><br><span class="line"><span class="comment">//     map&lt;int,vector&lt;int&gt;&gt; m;</span></span><br><span class="line"><span class="comment">//     scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; n; i++) </span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         scanf(&quot;%d%d&quot;, &amp;t1, &amp;t2);</span></span><br><span class="line"><span class="comment">//         m[t1].push_back(t2);//m[t]是vector&lt;int&gt;(动态数组),表示与编号为t的所有不相容货物的编号 </span></span><br><span class="line"><span class="comment">//         m[t2].push_back(t1);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     while (k--) </span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//         int cnt, flag = 0, a[100000] = &#123;0&#125;;//a[]用于记录相关编号是否出现 </span></span><br><span class="line"><span class="comment">//         scanf(&quot;%d&quot;, &amp;cnt);//cnt表示每箱的物品件数； </span></span><br><span class="line"><span class="comment">//         vector&lt;int&gt; v(cnt);//初始化动态数组v，长度为cnt，自动初始化全为0；用于记录一箱内所有物品编号（因为要成对比较） </span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; cnt; i++) </span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//             scanf(&quot;%d&quot;, &amp;v[i]);</span></span><br><span class="line"><span class="comment">//             a[v[i]] = 1;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; v.size(); i++)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//    for (int j = 0; j &lt; m[v[i]].size(); j++)//两个集合之间是否存在交集，存在flag=1；否则flag=0； </span></span><br><span class="line"><span class="comment">//             if (a[m[v[i]][j]] == 1) flag = 1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//         printf(&quot;%s\n&quot;,flag ? &quot;No&quot; :&quot;Yes&quot;);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法二：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span><span class="comment">//find函数 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,t1,t2;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;p;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;        <span class="comment">//m[t]是vector&lt;int&gt;(动态数组),表示与编号为t的所有不相容货物的编号 </span></span><br><span class="line">p[t1].<span class="built_in">push_back</span>(t2);p[t1].<span class="built_in">push_back</span>(t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(t1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t1;j++)</span><br><span class="line">cin&gt;&gt;a[j];</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t1;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;p[a[j]].<span class="built_in">size</span>();k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it=<span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),p[a[j]][k]);</span><br><span class="line"><span class="keyword">if</span>(it!=a.<span class="built_in">end</span>())</span><br><span class="line">&#123;flag=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法与MST</title>
      <link href="/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2022/09/28/%5Bobject%20Object%5D/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Dijkstra%E7%AE%97%E6%B3%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><spanclass="math display">\[Dijkstra\]</span>最短路径算法构造的生成树是否一定为最小生成树？问题描述：一连通无向图,边为非负权值，问用<spanclass="math display">\[Dijkstra\]</span>最短路径算法能否给出一棵生成树，这树是否一定为最小生成树？说明理由。</p><span id="more"></span><blockquote><p>​ 解答:<spanclass="math display">\[Dijkstra\]</span>最短路径算法能够给出一棵生成树,但该树不一定为最小生成树。虽然<spanclass="math display">\[Dijkstra\]</span>算法和<spanclass="math display">\[Prim\]</span>算法的思路与步骤较为相似，但两者的更新算法不一致，而其余部分完全一致。</p></blockquote><ol type="1"><li><span class="math display">\[Dijkstra\]</span>算法对应的<spanclass="math display">\[Min\]</span>更新算法为:</li></ol><p><span class="math display">\[if(Min[j] &gt; Min[k] + G[k][j])\\Min[j] = Min[k] + G[k][j];\]</span></p><ol start="2" type="1"><li>而<span class="math display">\[Prim\]</span>算法对应的<spanclass="math display">\[Min\]</span>更新算法为:</li></ol><p><span class="math display">\[if(Min[j] &gt; G[k][j])\\Min[j] = G[k][j]\]</span></p><ol start="3" type="1"><li>为此，可考虑以下的反例：对于以下的带权连通无向图</li></ol><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849744.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ul><li>用<spanclass="math display">\[Prim\]</span>算法构造的一棵最小生成树为:</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849802.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ul><li>而用<spanclass="math display">\[Dijkstra\]</span>算法构造的一棵生成树为:</li></ul><figure><imgsrc="https://tianchou.oss-cn-beijing.aliyuncs.com/img/202309160849648.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>​ 其中，<spanclass="math display">\[Dijkstra\]</span>算法的执行过程中，从<spanclass="math display">\[v1\]</span>到<spanclass="math display">\[v3\]</span>的最短路径选择的是<spanclass="math display">\[v1-&gt;v3\]</span>，而不是<spanclass="math display">\[v1-&gt;v4-&gt;v3\]</span>，原因是<spanclass="math display">\[Min[3]=Min[4]+G[4][3]\]</span>，即<spanclass="math display">\[v1\]</span>到<spanclass="math display">\[v3\]</span>的初始最短距离与<spanclass="math display">\[v1\]</span>到<spanclass="math display">\[v4\]</span>的最短路径加上<spanclass="math display">\[v4\]</span>到<spanclass="math display">\[v3\]</span>的距离相等，因此在更新过程中保留<spanclass="math display">\[v1-&gt;v3\]</span>的最短路径为<spanclass="math display">\[v1-&gt;v3\]</span>而非<spanclass="math display">\[v1-&gt;v4-&gt;v3\]</span>，所以最后，构造的生成树的边权值之和为<spanclass="math display">\[1+4+6=11\]</span>，远大于用<spanclass="math display">\[Prim\]</span>算法构造的最小生成树边权值之和<spanclass="math display">\[1+2+4=7\]</span>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
